# 0 "duktape.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "duktape.c"
# 1 "duk_replacements.c"
# 1 "duk_internal.h"
# 26 "duk_internal.h"
# 1 "duktape.h" 1
# 202 "duktape.h"
# 1 "duk_config.h" 1
# 736 "duk_config.h"
# 1 "/usr/include/x86_64-linux-gnu/sys/types.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 392 "/usr/include/features.h" 3 4
# 1 "/usr/include/features-time64.h" 1 3 4
# 20 "/usr/include/features-time64.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 21 "/usr/include/features-time64.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 22 "/usr/include/features-time64.h" 2 3 4
# 393 "/usr/include/features.h" 2 3 4
# 486 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 1 3 4
# 559 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 560 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 561 "/usr/include/x86_64-linux-gnu/sys/cdefs.h" 2 3 4
# 487 "/usr/include/features.h" 2 3 4
# 510 "/usr/include/features.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/gnu/stubs.h" 2 3 4
# 511 "/usr/include/features.h" 2 3 4
# 26 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 1 3 4
# 19 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/timesize.h" 2 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4



# 31 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/x86_64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/x86_64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 30 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;





typedef __off_t off_t;






typedef __off64_t off64_t;




typedef __pid_t pid_t;





typedef __id_t id_t;




typedef __ssize_t ssize_t;





typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/x86_64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/time_t.h" 3 4
typedef __time_t time_t;
# 130 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 209 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 145 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;




# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 156 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 24 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/endian.h" 2 3 4
# 25 "/usr/include/endian.h" 2 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/x86_64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/x86_64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/select.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{




  __time_t tv_sec;
  __suseconds_t tv_usec;

};
# 38 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 11 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{



  __time_t tv_sec;




  __syscall_slong_t tv_nsec;
# 31 "/usr/include/x86_64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/x86_64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 102 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 127 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 153 "/usr/include/x86_64-linux-gnu/sys/select.h" 3 4

# 180 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/x86_64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 21 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes-arch.h" 2 3 4
# 45 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/atomic_wide_counter.h" 3 4
typedef union
{
  __extension__ unsigned long long int __value64;
  struct
  {
    unsigned int __low;
    unsigned int __high;
  } __value32;
} __atomic_wide_counter;
# 47 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 76 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;



  int __kind;

  short __spins;
  short __elision;
  __pthread_list_t __list;
# 53 "/usr/include/x86_64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 77 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 89 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;

  int __cur_writer;
  int __shared;
  signed char __rwelision;




  unsigned char __pad1[7];


  unsigned long int __pad2;


  unsigned int __flags;
# 55 "/usr/include/x86_64-linux-gnu/bits/struct_rwlock.h" 3 4
};
# 90 "/usr/include/x86_64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __atomic_wide_counter __wseq;
  __atomic_wide_counter __g1_start;
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};

typedef unsigned int __tss_t;
typedef unsigned long int __thrd_t;

typedef struct
{
  int __data ;
} __once_flag;
# 24 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/x86_64-linux-gnu/sys/types.h" 2 3 4



# 737 "duk_config.h" 2




# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 87 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 101 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stdint.h" 2 3 4
# 742 "duk_config.h" 2

# 1 "/usr/include/x86_64-linux-gnu/sys/param.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/sys/param.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-linux-gnu/11/include/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/limits.h" 1 3 4
# 203 "/usr/lib/gcc/x86_64-linux-gnu/11/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 195 "/usr/include/limits.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 161 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 81 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/pthread_stack_min-dynamic.h" 3 4

extern long int __sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));

# 82 "/usr/include/x86_64-linux-gnu/bits/local_lim.h" 2 3 4
# 162 "/usr/include/x86_64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 196 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 200 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 64 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/uio_lim.h" 1 3 4
# 65 "/usr/include/x86_64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 204 "/usr/include/limits.h" 2 3 4
# 204 "/usr/lib/gcc/x86_64-linux-gnu/11/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-linux-gnu/11/include/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-linux-gnu/11/include/limits.h" 2 3 4
# 27 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4

# 1 "/usr/include/signal.h" 1 3 4
# 27 "/usr/include/signal.h" 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/signum-generic.h" 1 3 4
# 76 "/usr/include/x86_64-linux-gnu/bits/signum-generic.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/signum-arch.h" 1 3 4
# 77 "/usr/include/x86_64-linux-gnu/bits/signum-generic.h" 2 3 4
# 31 "/usr/include/signal.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/sig_atomic_t.h" 1 3 4







typedef __sig_atomic_t sig_atomic_t;
# 33 "/usr/include/signal.h" 2 3 4
# 57 "/usr/include/signal.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 5 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/__sigval_t.h" 3 4
union sigval
{
  int sival_int;
  void *sival_ptr;
};

typedef union sigval __sigval_t;
# 7 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 2 3 4
# 16 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo-arch.h" 1 3 4
# 17 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 2 3 4
# 36 "/usr/include/x86_64-linux-gnu/bits/types/siginfo_t.h" 3 4
typedef struct
  {
    int si_signo;

    int si_errno;

    int si_code;





    int __pad0;


    union
      {
 int _pad[((128 / sizeof (int)) - 4)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     __sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     __sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __clock_t si_utime;
     __clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
    
     short int si_addr_lsb;
     union
       {

  struct
    {
      void *_lower;
      void *_upper;
    } _addr_bnd;

  __uint32_t _pkey;
       } _bounds;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;



 struct
   {
     void *_call_addr;
     int _syscall;
     unsigned int _arch;
   } _sigsys;

      } _sifields;
  } siginfo_t ;
# 58 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 3 4
enum
{
  SI_ASYNCNL = -60,
  SI_DETHREAD = -7,

  SI_TKILL,
  SI_SIGIO,

  SI_ASYNCIO,
  SI_MESGQ,
  SI_TIMER,





  SI_QUEUE,
  SI_USER,
  SI_KERNEL = 0x80
# 66 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 3 4
};




enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK,

  ILL_BADIADDR

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB,

  FPE_FLTUNK = 14,

  FPE_CONDTRAP

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR,

  SEGV_BNDERR,

  SEGV_PKUERR,

  SEGV_ACCADI,

  SEGV_ADIDERR,

  SEGV_ADIPERR,

  SEGV_MTEAERR,

  SEGV_MTESERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR,

  BUS_MCEERR_AR,

  BUS_MCEERR_AO

};




enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE,

  TRAP_BRANCH,

  TRAP_HWBKPT,

  TRAP_UNK

};




enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};





# 1 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts-arch.h" 1 3 4
# 214 "/usr/include/x86_64-linux-gnu/bits/siginfo-consts.h" 2 3 4
# 59 "/usr/include/signal.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigval_t.h" 1 3 4
# 16 "/usr/include/x86_64-linux-gnu/bits/types/sigval_t.h" 3 4
typedef __sigval_t sigval_t;
# 63 "/usr/include/signal.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 1 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 5 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 2 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/sigevent_t.h" 3 4
typedef struct sigevent
  {
    __sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 4)];



 __pid_t _tid;

 struct
   {
     void (*_function) (__sigval_t);
     pthread_attr_t *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;
# 67 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/sigevent-consts.h" 3 4
enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4


};
# 68 "/usr/include/signal.h" 2 3 4




typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));

extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));






extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
# 112 "/usr/include/signal.h" 3 4
extern int kill (__pid_t __pid, int __sig) __attribute__ ((__nothrow__ , __leaf__));






extern int killpg (__pid_t __pgrp, int __sig) __attribute__ ((__nothrow__ , __leaf__));



extern int raise (int __sig) __attribute__ ((__nothrow__ , __leaf__));



extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
extern int gsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));




extern void psignal (int __sig, const char *__s);


extern void psiginfo (const siginfo_t *__pinfo, const char *__s);
# 151 "/usr/include/signal.h" 3 4
extern int sigpause (int __sig) __asm__ ("__xpg_sigpause")
  __attribute__ ((__deprecated__ ("Use the sigsuspend function instead")));
# 173 "/usr/include/signal.h" 3 4
extern int sigblock (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


extern int siggetmask (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
# 188 "/usr/include/signal.h" 3 4
typedef __sighandler_t sighandler_t;




typedef __sighandler_t sig_t;





extern int sigemptyset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigismember (const sigset_t *__set, int __signo)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int sigisemptyset (const sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigandset (sigset_t *__set, const sigset_t *__left,
        const sigset_t *__right) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern int sigorset (sigset_t *__set, const sigset_t *__left,
       const sigset_t *__right) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));




# 1 "/usr/include/x86_64-linux-gnu/bits/sigaction.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 230 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) __attribute__ ((__nothrow__ , __leaf__));






extern int sigsuspend (const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) __attribute__ ((__nothrow__ , __leaf__));


extern int sigpending (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int sigwait (const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));







extern int sigwaitinfo (const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));







extern int sigtimedwait (const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));
# 292 "/usr/include/signal.h" 3 4
extern int sigqueue (__pid_t __pid, int __sig, const union sigval __val)
     __attribute__ ((__nothrow__ , __leaf__));







# 1 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 3 4
struct _fpx_sw_bytes
{
  __uint32_t magic1;
  __uint32_t extended_size;
  __uint64_t xstate_bv;
  __uint32_t xstate_size;
  __uint32_t __glibc_reserved1[7];
};

struct _fpreg
{
  unsigned short significand[4];
  unsigned short exponent;
};

struct _fpxreg
{
  unsigned short significand[4];
  unsigned short exponent;
  unsigned short __glibc_reserved1[3];
};

struct _xmmreg
{
  __uint32_t element[4];
};
# 123 "/usr/include/x86_64-linux-gnu/bits/sigcontext.h" 3 4
struct _fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _fpxreg _st[8];
  struct _xmmreg _xmm[16];
  __uint32_t __glibc_reserved1[24];
};

struct sigcontext
{
  __uint64_t r8;
  __uint64_t r9;
  __uint64_t r10;
  __uint64_t r11;
  __uint64_t r12;
  __uint64_t r13;
  __uint64_t r14;
  __uint64_t r15;
  __uint64_t rdi;
  __uint64_t rsi;
  __uint64_t rbp;
  __uint64_t rbx;
  __uint64_t rdx;
  __uint64_t rax;
  __uint64_t rcx;
  __uint64_t rsp;
  __uint64_t rip;
  __uint64_t eflags;
  unsigned short cs;
  unsigned short gs;
  unsigned short fs;
  unsigned short __pad0;
  __uint64_t err;
  __uint64_t trapno;
  __uint64_t oldmask;
  __uint64_t cr2;
  __extension__ union
    {
      struct _fpstate * fpstate;
      __uint64_t __fpstate_word;
    };
  __uint64_t __reserved1 [8];
};



struct _xsave_hdr
{
  __uint64_t xstate_bv;
  __uint64_t __glibc_reserved1[2];
  __uint64_t __glibc_reserved2[5];
};

struct _ymmh_state
{
  __uint32_t ymmh_space[64];
};

struct _xstate
{
  struct _fpstate fpstate;
  struct _xsave_hdr xstate_hdr;
  struct _ymmh_state ymmh;
};
# 302 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) __attribute__ ((__nothrow__ , __leaf__));






# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 312 "/usr/include/signal.h" 2 3 4

# 1 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/types/stack_t.h" 2 3 4


typedef struct
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 314 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 1 3 4
# 37 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
__extension__ typedef long long int greg_t;
# 46 "/usr/include/x86_64-linux-gnu/sys/ucontext.h" 3 4
typedef greg_t gregset_t[23];



enum
{
  REG_R8 = 0,

  REG_R9,

  REG_R10,

  REG_R11,

  REG_R12,

  REG_R13,

  REG_R14,

  REG_R15,

  REG_RDI,

  REG_RSI,

  REG_RBP,

  REG_RBX,

  REG_RDX,

  REG_RAX,

  REG_RCX,

  REG_RSP,

  REG_RIP,

  REG_EFL,

  REG_CSGSFS,

  REG_ERR,

  REG_TRAPNO,

  REG_OLDMASK,

  REG_CR2

};


struct _libc_fpxreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
  unsigned short int __glibc_reserved1[3];
};

struct _libc_xmmreg
{
  __uint32_t element[4];
};

struct _libc_fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _libc_fpxreg _st[8];
  struct _libc_xmmreg _xmm[16];
  __uint32_t __glibc_reserved1[24];
};


typedef struct _libc_fpstate *fpregset_t;


typedef struct
  {
    gregset_t gregs;

    fpregset_t fpregs;
    __extension__ unsigned long long __reserved1 [8];
} mcontext_t;


typedef struct ucontext_t
  {
    unsigned long int uc_flags;
    struct ucontext_t *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
    __extension__ unsigned long long int __ssp[4];
  } ucontext_t;
# 317 "/usr/include/signal.h" 2 3 4







extern int siginterrupt (int __sig, int __interrupt) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__deprecated__ ("Use sigaction with SA_RESTART instead")));

# 1 "/usr/include/x86_64-linux-gnu/bits/sigstack.h" 1 3 4
# 328 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/sigstksz.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/sigstksz.h" 3 4
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4

# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 274 "/usr/include/unistd.h" 3 4
typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int execveat (int __fd, const char *__path, char *const __argv[],
                     char *const __envp[], int __flags)
    __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;
# 339 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ , __leaf__));
# 350 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     __attribute__ ((__nothrow__ , __leaf__));






extern int close (int __fd);




extern void closefrom (int __lowfd) __attribute__ ((__nothrow__ , __leaf__));







extern ssize_t read (int __fd, void *__buf, size_t __nbytes)
    __attribute__ ((__access__ (__write_only__, 2, 3)));





extern ssize_t write (int __fd, const void *__buf, size_t __n)
    __attribute__ ((__access__ (__read_only__, 2, 3)));
# 389 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset)
    __attribute__ ((__access__ (__write_only__, 2, 3)));






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset)
    __attribute__ ((__access__ (__read_only__, 2, 3)));
# 422 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset)
    __attribute__ ((__access__ (__write_only__, 2, 3)));


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset)
    __attribute__ ((__access__ (__read_only__, 2, 3)));







extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int pipe2 (int __pipedes[2], int __flags) __attribute__ ((__nothrow__ , __leaf__)) ;
# 452 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ , __leaf__));
# 464 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ , __leaf__));






extern int usleep (__useconds_t __useconds);
# 489 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;
# 531 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) ;





extern char *get_current_dir_name (void) __attribute__ ((__nothrow__ , __leaf__));







extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__))
    __attribute__ ((__access__ (__write_only__, 1)));




extern int dup (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ , __leaf__));




extern int dup3 (int __fd, int __fd2, int __flags) __attribute__ ((__nothrow__ , __leaf__));



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/x86_64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT,


    _SC_MINSIGSTKSZ,


    _SC_SIGSTKSZ

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 631 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ , __leaf__));


extern long int sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__))
    __attribute__ ((__access__ (__write_only__, 2, 3)));




extern __pid_t getpid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getppid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ , __leaf__));
# 682 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__ , __leaf__));






extern __pid_t setsid (void) __attribute__ ((__nothrow__ , __leaf__));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));



extern __uid_t getuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getgid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getegid (void) __attribute__ ((__nothrow__ , __leaf__));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ , __leaf__))
    __attribute__ ((__access__ (__write_only__, 2, 1)));


extern int group_member (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__));






extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     __attribute__ ((__nothrow__ , __leaf__)) ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     __attribute__ ((__nothrow__ , __leaf__)) ;






extern __pid_t fork (void) __attribute__ ((__nothrow__));







extern __pid_t vfork (void) __attribute__ ((__nothrow__ , __leaf__));






extern __pid_t _Fork (void) __attribute__ ((__nothrow__ , __leaf__));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)))
     __attribute__ ((__access__ (__write_only__, 2, 3)));



extern int isatty (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern int ttyslot (void) __attribute__ ((__nothrow__ , __leaf__));




extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)))
     __attribute__ ((__access__ (__write_only__, 2, 3)));





extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)))
     __attribute__ ((__access__ (__write_only__, 3, 4)));



extern int unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ , __leaf__));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ , __leaf__));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));




extern int setlogin (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4








extern char *optarg;
# 50 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 91 "/usr/include/x86_64-linux-gnu/bits/getopt_core.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));


# 28 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 2 3 4


# 49 "/usr/include/x86_64-linux-gnu/bits/getopt_posix.h" 3 4

# 904 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));






extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__access__ (__read_only__, 1, 2)));



extern int sethostid (long int __id) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)))
     __attribute__ ((__access__ (__write_only__, 1, 2)));
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__access__ (__read_only__, 1, 2)));




extern int vhangup (void) __attribute__ ((__nothrow__ , __leaf__));


extern int revoke (const char *__file) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) __attribute__ ((__nothrow__ , __leaf__));



extern char *getusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void endusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void setusershell (void) __attribute__ ((__nothrow__ , __leaf__));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int chroot (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) __attribute__ ((__nothrow__ , __leaf__));






extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__ , __leaf__));





extern int getpagesize (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__ , __leaf__));
# 1026 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1038 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1049 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1059 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1070 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ , __leaf__));
# 1091 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ , __leaf__));
# 1114 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1124 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) ;
# 1142 "/usr/include/unistd.h" 3 4
ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
    int __outfd, __off64_t *__poutoff,
    size_t __length, unsigned int __flags);





extern int fdatasync (int __fildes);
# 1159 "/usr/include/unistd.h" 3 4
extern char *crypt (const char *__key, const char *__salt)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));







extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)))
    __attribute__ ((__access__ (__read_only__, 1, 3)))
    __attribute__ ((__access__ (__write_only__, 2, 3)));
# 1198 "/usr/include/unistd.h" 3 4
int getentropy (void *__buffer, size_t __length)
    __attribute__ ((__access__ (__write_only__, 1, 2)));
# 1208 "/usr/include/unistd.h" 3 4
extern int close_range (unsigned int __fd, unsigned int __max_fd,
   int __flags) __attribute__ ((__nothrow__ , __leaf__));
# 1218 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 3 4
extern __pid_t gettid (void) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/linux/close_range.h" 1 3 4
# 39 "/usr/include/x86_64-linux-gnu/bits/unistd_ext.h" 2 3 4
# 1219 "/usr/include/unistd.h" 2 3 4


# 25 "/usr/include/x86_64-linux-gnu/bits/sigstksz.h" 2 3 4
# 329 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/ss_flags.h" 3 4
enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 330 "/usr/include/signal.h" 2 3 4



extern int sigaltstack (const stack_t *__restrict __ss,
   stack_t *__restrict __oss) __attribute__ ((__nothrow__ , __leaf__));




# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/types/struct_sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };
# 340 "/usr/include/signal.h" 2 3 4







extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));






extern int sighold (int __sig) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__deprecated__ ("Use the sigprocmask function instead")));


extern int sigrelse (int __sig) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__deprecated__ ("Use the sigprocmask function instead")));


extern int sigignore (int __sig) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__deprecated__ ("Use the signal function instead")));


extern __sighandler_t sigset (int __sig, __sighandler_t __disp) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__deprecated__ ("Use the signal and sigprocmask functions instead")))
                                                        ;






# 1 "/usr/include/x86_64-linux-gnu/bits/sigthread.h" 1 3 4
# 31 "/usr/include/x86_64-linux-gnu/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)__attribute__ ((__nothrow__ , __leaf__));


extern int pthread_kill (pthread_t __threadid, int __signo) __attribute__ ((__nothrow__ , __leaf__));



extern int pthread_sigqueue (pthread_t __threadid, int __signo,
        const union sigval __value) __attribute__ ((__nothrow__ , __leaf__));
# 377 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) __attribute__ ((__nothrow__ , __leaf__));

extern int __libc_current_sigrtmax (void) __attribute__ ((__nothrow__ , __leaf__));





# 1 "/usr/include/x86_64-linux-gnu/bits/signal_ext.h" 1 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/signal_ext.h" 3 4
extern int tgkill (__pid_t __tgid, __pid_t __tid, int __signal);
# 392 "/usr/include/signal.h" 2 3 4


# 29 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/param.h" 1 3 4
# 28 "/usr/include/x86_64-linux-gnu/bits/param.h" 3 4
# 1 "/usr/include/linux/param.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/asm/param.h" 1 3 4
# 1 "/usr/include/asm-generic/param.h" 1 3 4
# 2 "/usr/include/x86_64-linux-gnu/asm/param.h" 2 3 4
# 6 "/usr/include/linux/param.h" 2 3 4
# 29 "/usr/include/x86_64-linux-gnu/bits/param.h" 2 3 4
# 32 "/usr/include/x86_64-linux-gnu/sys/param.h" 2 3 4
# 744 "duk_config.h" 2
# 1 "/usr/include/x86_64-linux-gnu/sys/time.h" 1 3 4
# 34 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4

# 52 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };
# 67 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    void *__restrict __tz) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 86 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int settimeofday (const struct timeval *__tv,
    const struct timezone *__tz)
     __attribute__ ((__nothrow__ , __leaf__));





extern int adjtime (const struct timeval *__delta,
      struct timeval *__olddelta) __attribute__ ((__nothrow__ , __leaf__));
# 114 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };




typedef enum __itimer_which __itimer_which_t;







extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) __attribute__ ((__nothrow__ , __leaf__));




extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) __attribute__ ((__nothrow__ , __leaf__));




extern int utimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 189 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int lutimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, const struct timeval __tvp[2]) __attribute__ ((__nothrow__ , __leaf__));
# 214 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4
extern int futimesat (int __fd, const char *__file,
        const struct timeval __tvp[2]) __attribute__ ((__nothrow__ , __leaf__));
# 258 "/usr/include/x86_64-linux-gnu/sys/time.h" 3 4

# 745 "duk_config.h" 2
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/x86_64-linux-gnu/bits/time.h" 1 3 4
# 73 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/timex.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
struct timex
{
# 58 "/usr/include/x86_64-linux-gnu/bits/timex.h" 3 4
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;

};
# 74 "/usr/include/x86_64-linux-gnu/bits/time.h" 2 3 4




extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) __attribute__ ((__nothrow__ , __leaf__));
# 90 "/usr/include/x86_64-linux-gnu/bits/time.h" 3 4

# 34 "/usr/include/time.h" 2 3 4





# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4
# 48 "/usr/include/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 60 "/usr/include/time.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/x86_64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 61 "/usr/include/time.h" 2 3 4











extern clock_t clock (void) __attribute__ ((__nothrow__ , __leaf__));



extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));
# 100 "/usr/include/time.h" 3 4
extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));






extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));
# 154 "/usr/include/time.h" 3 4
extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));
# 179 "/usr/include/time.h" 3 4
extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));



extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));
# 197 "/usr/include/time.h" 3 4
extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));
# 217 "/usr/include/time.h" 3 4
extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__ , __leaf__));



extern int daylight;
extern long int timezone;
# 249 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));

extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));
# 262 "/usr/include/time.h" 3 4
extern int dysize (int __year) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 272 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);


extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     __attribute__ ((__nothrow__ , __leaf__));
# 311 "/usr/include/time.h" 3 4
extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);
# 326 "/usr/include/time.h" 3 4
extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__ , __leaf__));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));



extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__ , __leaf__));
# 364 "/usr/include/time.h" 3 4
extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));






extern int timespec_get (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 387 "/usr/include/time.h" 3 4
extern int timespec_getres (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ , __leaf__));
# 413 "/usr/include/time.h" 3 4
extern int getdate_err;
# 422 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 436 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);



# 746 "duk_config.h" 2
# 871 "duk_config.h"
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 37 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 47 "/usr/include/stdio.h" 2 3 4





typedef __gnuc_va_list va_list;
# 84 "/usr/include/stdio.h" 3 4
typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4
# 143 "/usr/include/stdio.h" 3 4
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));
# 170 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) __attribute__ ((__nothrow__ , __leaf__));






extern int fclose (FILE *__stream);
# 188 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;
# 200 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void)
   __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;



extern char *tmpnam (char[20]) __attribute__ ((__nothrow__ , __leaf__)) ;




extern char *tmpnam_r (char __s[20]) __attribute__ ((__nothrow__ , __leaf__)) ;
# 222 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
   __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (__builtin_free, 1)));






extern int fflush (FILE *__stream);
# 239 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 249 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 258 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 283 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) ;
# 328 "/usr/include/stdio.h" 3 4
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));





# 1 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 1 3 4
# 119 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/floatn-common.h" 2 3 4
# 120 "/usr/include/x86_64-linux-gnu/bits/floatn.h" 2 3 4
# 431 "/usr/include/stdio.h" 2 3 4



extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 459 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));





extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 513 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 538 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 549 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 565 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__access__ (__write_only__, 1, 2)));
# 615 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream)
    __attribute__ ((__access__ (__write_only__, 1, 2)));
# 632 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) ;







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 691 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 702 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);
# 736 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 760 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 779 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;



extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;







extern void perror (const char *__s);




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 823 "/usr/include/stdio.h" 3 4
extern int pclose (FILE *__stream);





extern FILE *popen (const char *__command, const char *__modes)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (pclose, 1))) ;






extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__access__ (__write_only__, 1)));





extern char *cuserid (char *__s)
  __attribute__ ((__access__ (__write_only__, 1)));




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 885 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);
# 902 "/usr/include/stdio.h" 3 4

# 872 "duk_config.h" 2
# 1 "/usr/include/stdlib.h" 1 3 4
# 26 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 321 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 3 4
typedef int wchar_t;
# 33 "/usr/include/stdlib.h" 2 3 4







# 1 "/usr/include/x86_64-linux-gnu/bits/waitflags.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h" 1 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 59 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 98 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;



extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 141 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float64 strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float128 strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float32x strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern _Float64x strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 177 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 233 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         _Float32 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         _Float64 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   _Float128 __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   _Float32x __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   _Float64x __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 275 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 317 "/usr/include/stdlib.h" 3 4
extern _Float32 strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64 strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float128 strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float32x strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern _Float64x strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 386 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;
# 402 "/usr/include/stdlib.h" 3 4
extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));



extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) ;






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));


extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)))
    __attribute__ ((__malloc__ (__builtin_free, 1)));


extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__ (reallocarray, 1)));



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 575 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_align__ (1)))
     __attribute__ ((__alloc_size__ (2))) ;



extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;




extern char *secure_getenv (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 682 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 695 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 705 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 717 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 727 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
# 738 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 749 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 759 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
# 769 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 781 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;
# 791 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) ;





extern char *canonicalize_file_name (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__malloc__))
     __attribute__ ((__malloc__ (__builtin_free, 1))) ;
# 808 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;







extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;






extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
# 880 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__))
    __attribute__ ((__access__ (__read_only__, 2)));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__access__ (__write_only__, 1, 3)))
  __attribute__ ((__access__ (__read_only__, 2)));






extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 967 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1023 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 1024 "/usr/include/stdlib.h" 2 3 4
# 1035 "/usr/include/stdlib.h" 3 4

# 873 "duk_config.h" 2
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4






# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
    __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__write_only__, 1, 4)));




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 80 "/usr/include/string.h" 3 4
extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 107 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 120 "/usr/include/string.h" 3 4
extern void *rawmemchr (const void *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 133 "/usr/include/string.h" 3 4
extern void *memrchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
      __attribute__ ((__access__ (__read_only__, 1, 3)));





extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
    __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 1, 3)));






extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)))
     __attribute__ ((__access__ (__write_only__, 1, 3)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 246 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 273 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 286 "/usr/include/string.h" 3 4
extern char *strchrnul (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 323 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 350 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 380 "/usr/include/string.h" 3 4
extern char *strcasestr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)))
    __attribute__ ((__access__ (__read_only__, 1, 2)))
    __attribute__ ((__access__ (__read_only__, 3, 4)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));
# 444 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));




extern const char *strerrordesc_np (int __err) __attribute__ ((__nothrow__ , __leaf__));

extern const char *strerrorname_np (int __err) __attribute__ ((__nothrow__ , __leaf__));





extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4










extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));



# 463 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));



extern const char *sigabbrev_np (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern const char *sigdescr_np (int __sig) __attribute__ ((__nothrow__ , __leaf__));



extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__read_write__, 1, 2)));
# 527 "/usr/include/string.h" 3 4
extern char *basename (const char *__filename) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 539 "/usr/include/string.h" 3 4

# 874 "duk_config.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stdarg.h" 1 3 4
# 875 "duk_config.h" 2
# 1 "/usr/include/setjmp.h" 1 3 4
# 27 "/usr/include/setjmp.h" 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/wordsize.h" 1 3 4
# 27 "/usr/include/x86_64-linux-gnu/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 30 "/usr/include/setjmp.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/types/struct___jmp_buf_tag.h" 3 4
struct __jmp_buf_tag
  {




    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
  };
# 31 "/usr/include/setjmp.h" 2 3 4

typedef struct __jmp_buf_tag jmp_buf[1];



extern int setjmp (jmp_buf __env) __attribute__ ((__nothrow__));




extern int __sigsetjmp (struct __jmp_buf_tag __env[1], int __savemask) __attribute__ ((__nothrow__));



extern int _setjmp (struct __jmp_buf_tag __env[1]) __attribute__ ((__nothrow__));
# 54 "/usr/include/setjmp.h" 3 4
extern void longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));





extern void _longjmp (struct __jmp_buf_tag __env[1], int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));







typedef struct __jmp_buf_tag sigjmp_buf[1];
# 80 "/usr/include/setjmp.h" 3 4
extern void siglongjmp (sigjmp_buf __env, int __val)
     __attribute__ ((__nothrow__)) __attribute__ ((__noreturn__));
# 90 "/usr/include/setjmp.h" 3 4

# 876 "duk_config.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 1 3 4
# 143 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 415 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/usr/lib/gcc/x86_64-linux-gnu/11/include/stddef.h" 3 4
} max_align_t;
# 877 "duk_config.h" 2
# 1 "/usr/include/math.h" 1 3 4
# 27 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 28 "/usr/include/math.h" 2 3 4












# 1 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 1 3 4
# 25 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/libm-simd-decl-stubs.h" 1 3 4
# 26 "/usr/include/x86_64-linux-gnu/bits/math-vector.h" 2 3 4
# 41 "/usr/include/math.h" 2 3 4
# 152 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/flt-eval-method.h" 1 3 4
# 153 "/usr/include/math.h" 2 3 4
# 163 "/usr/include/math.h" 3 4
typedef float float_t;
typedef double double_t;
# 204 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-logb.h" 1 3 4
# 205 "/usr/include/math.h" 2 3 4
# 247 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/fp-fast.h" 1 3 4
# 248 "/usr/include/math.h" 2 3 4



enum
  {
    FP_INT_UPWARD =

      0,
    FP_INT_DOWNWARD =

      1,
    FP_INT_TOWARDZERO =

      2,
    FP_INT_TONEARESTFROMZERO =

      3,
    FP_INT_TONEAREST =

      4,
  };
# 312 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassify (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbit (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern int __isinf (double __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern int __finite (double __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern int __isnan (double __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern int __iseqsig (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern int __issignaling (double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));
# 313 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern double acos (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __acos (double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern double asin (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __asin (double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern double atan (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atan (double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern double atan2 (double __y, double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atan2 (double __y, double __x) __attribute__ ((__nothrow__ , __leaf__));


 extern double cos (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cos (double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern double sin (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sin (double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern double tan (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __tan (double __x) __attribute__ ((__nothrow__ , __leaf__));




 extern double cosh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cosh (double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern double sinh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sinh (double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern double tanh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __tanh (double __x) __attribute__ ((__nothrow__ , __leaf__));



 extern void sincos (double __x, double *__sinx, double *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincos (double __x, double *__sinx, double *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




 extern double acosh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __acosh (double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern double asinh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __asinh (double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern double atanh (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __atanh (double __x) __attribute__ ((__nothrow__ , __leaf__));





 extern double exp (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern double __frexp (double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern double ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern double __ldexp (double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern double log (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log (double __x) __attribute__ ((__nothrow__ , __leaf__));


 extern double log10 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log10 (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double modf (double __x, double *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern double __modf (double __x, double *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



 extern double exp10 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp10 (double __x) __attribute__ ((__nothrow__ , __leaf__));




 extern double expm1 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __expm1 (double __x) __attribute__ ((__nothrow__ , __leaf__));


 extern double log1p (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log1p (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double logb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __logb (double __x) __attribute__ ((__nothrow__ , __leaf__));




 extern double exp2 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __exp2 (double __x) __attribute__ ((__nothrow__ , __leaf__));


 extern double log2 (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __log2 (double __x) __attribute__ ((__nothrow__ , __leaf__));






 extern double pow (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __pow (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double sqrt (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __sqrt (double __x) __attribute__ ((__nothrow__ , __leaf__));



 extern double hypot (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __hypot (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));




 extern double cbrt (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __cbrt (double __x) __attribute__ ((__nothrow__ , __leaf__));






extern double ceil (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __ceil (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fabs (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fabs (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double floor (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __floor (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fmod (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __fmod (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinf (double __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));




extern int finite (double __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern double drem (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __drem (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));



extern double significand (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __significand (double __x) __attribute__ ((__nothrow__ , __leaf__));






extern double copysign (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __copysign (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern double nan (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)); extern double __nan (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__));
# 213 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnan (double __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));





extern double j0 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __j0 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double j1 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __j1 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double jn (int, double) __attribute__ ((__nothrow__ , __leaf__)); extern double __jn (int, double) __attribute__ ((__nothrow__ , __leaf__));
extern double y0 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __y0 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double y1 (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __y1 (double) __attribute__ ((__nothrow__ , __leaf__));
extern double yn (int, double) __attribute__ ((__nothrow__ , __leaf__)); extern double __yn (int, double) __attribute__ ((__nothrow__ , __leaf__));





 extern double erf (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __erf (double) __attribute__ ((__nothrow__ , __leaf__));
 extern double erfc (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __erfc (double) __attribute__ ((__nothrow__ , __leaf__));
extern double lgamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __lgamma (double) __attribute__ ((__nothrow__ , __leaf__));




extern double tgamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __tgamma (double) __attribute__ ((__nothrow__ , __leaf__));





extern double gamma (double) __attribute__ ((__nothrow__ , __leaf__)); extern double __gamma (double) __attribute__ ((__nothrow__ , __leaf__));







extern double lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern double __lgamma_r (double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern double rint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __rint (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double nextafter (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __nextafter (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));

extern double nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __nexttoward (double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));




extern double nextdown (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __nextdown (double __x) __attribute__ ((__nothrow__ , __leaf__));

extern double nextup (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __nextup (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern double remainder (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __remainder (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));



extern double scalbn (double __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalbn (double __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogb (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long int llogb (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __llogb (double __x) __attribute__ ((__nothrow__ , __leaf__));




extern double scalbln (double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalbln (double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern double nearbyint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern double __nearbyint (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern double round (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __round (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern double trunc (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __trunc (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern double __remquo (double __x, double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrint (double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrint (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrint (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lround (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lround (double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llround (double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llround (double __x) __attribute__ ((__nothrow__ , __leaf__));



extern double fdim (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)); extern double __fdim (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));



extern double fmax (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmax (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fmin (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmin (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ , __leaf__)); extern double __fma (double __x, double __y, double __z) __attribute__ ((__nothrow__ , __leaf__));




extern double roundeven (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __roundeven (double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern __intmax_t fromfp (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfp (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                            ;



extern __uintmax_t ufromfp (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfp (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                              ;




extern __intmax_t fromfpx (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpx (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                             ;




extern __uintmax_t ufromfpx (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpx (double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                               ;


extern int canonicalize (double *__cx, const double *__x) __attribute__ ((__nothrow__ , __leaf__));






extern double fmaxmag (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmaxmag (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fminmag (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fminmag (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern double fmaximum (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmaximum (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fminimum (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fminimum (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fmaximum_num (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmaximum_num (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fminimum_num (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fminimum_num (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fmaximum_mag (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmaximum_mag (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fminimum_mag (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fminimum_mag (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fmaximum_mag_num (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fmaximum_mag_num (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern double fminimum_mag_num (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern double __fminimum_mag_num (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int totalorder (const double *__x, const double *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern int totalordermag (const double *__x, const double *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern double getpayload (const double *__x) __attribute__ ((__nothrow__ , __leaf__)); extern double __getpayload (const double *__x) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayload (double *__x, double __payload) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadsig (double *__x, double __payload) __attribute__ ((__nothrow__ , __leaf__));







extern double scalb (double __x, double __n) __attribute__ ((__nothrow__ , __leaf__)); extern double __scalb (double __x, double __n) __attribute__ ((__nothrow__ , __leaf__));
# 314 "/usr/include/math.h" 2 3 4
# 329 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbitf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern int __isinff (float __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern int __finitef (float __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern int __isnanf (float __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern int __iseqsigf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


extern int __issignalingf (float __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));
# 330 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern float acosf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __acosf (float __x) __attribute__ ((__nothrow__ , __leaf__));

 extern float asinf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __asinf (float __x) __attribute__ ((__nothrow__ , __leaf__));

 extern float atanf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atanf (float __x) __attribute__ ((__nothrow__ , __leaf__));

 extern float atan2f (float __y, float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atan2f (float __y, float __x) __attribute__ ((__nothrow__ , __leaf__));


 extern float cosf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __cosf (float __x) __attribute__ ((__nothrow__ , __leaf__));

 extern float sinf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sinf (float __x) __attribute__ ((__nothrow__ , __leaf__));

 extern float tanf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __tanf (float __x) __attribute__ ((__nothrow__ , __leaf__));




 extern float coshf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __coshf (float __x) __attribute__ ((__nothrow__ , __leaf__));

 extern float sinhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sinhf (float __x) __attribute__ ((__nothrow__ , __leaf__));

 extern float tanhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __tanhf (float __x) __attribute__ ((__nothrow__ , __leaf__));



 extern void sincosf (float __x, float *__sinx, float *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosf (float __x, float *__sinx, float *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




 extern float acoshf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __acoshf (float __x) __attribute__ ((__nothrow__ , __leaf__));

 extern float asinhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __asinhf (float __x) __attribute__ ((__nothrow__ , __leaf__));

 extern float atanhf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __atanhf (float __x) __attribute__ ((__nothrow__ , __leaf__));





 extern float expf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __expf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern float __frexpf (float __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern float ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern float __ldexpf (float __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern float logf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __logf (float __x) __attribute__ ((__nothrow__ , __leaf__));


 extern float log10f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log10f (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float modff (float __x, float *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern float __modff (float __x, float *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



 extern float exp10f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __exp10f (float __x) __attribute__ ((__nothrow__ , __leaf__));




 extern float expm1f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __expm1f (float __x) __attribute__ ((__nothrow__ , __leaf__));


 extern float log1pf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log1pf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float logbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __logbf (float __x) __attribute__ ((__nothrow__ , __leaf__));




 extern float exp2f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __exp2f (float __x) __attribute__ ((__nothrow__ , __leaf__));


 extern float log2f (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __log2f (float __x) __attribute__ ((__nothrow__ , __leaf__));






 extern float powf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __powf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));


extern float sqrtf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __sqrtf (float __x) __attribute__ ((__nothrow__ , __leaf__));



 extern float hypotf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __hypotf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));




 extern float cbrtf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __cbrtf (float __x) __attribute__ ((__nothrow__ , __leaf__));






extern float ceilf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __ceilf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fabsf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fabsf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float floorf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __floorf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fmodf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __fmodf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinff (float __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));




extern int finitef (float __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern float dremf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __dremf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));



extern float significandf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __significandf (float __x) __attribute__ ((__nothrow__ , __leaf__));






extern float copysignf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern float nanf (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)); extern float __nanf (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__));
# 213 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanf (float __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));





extern float j0f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __j0f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float j1f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __j1f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float jnf (int, float) __attribute__ ((__nothrow__ , __leaf__)); extern float __jnf (int, float) __attribute__ ((__nothrow__ , __leaf__));
extern float y0f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __y0f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float y1f (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __y1f (float) __attribute__ ((__nothrow__ , __leaf__));
extern float ynf (int, float) __attribute__ ((__nothrow__ , __leaf__)); extern float __ynf (int, float) __attribute__ ((__nothrow__ , __leaf__));





 extern float erff (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __erff (float) __attribute__ ((__nothrow__ , __leaf__));
 extern float erfcf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __erfcf (float) __attribute__ ((__nothrow__ , __leaf__));
extern float lgammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __lgammaf (float) __attribute__ ((__nothrow__ , __leaf__));




extern float tgammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __tgammaf (float) __attribute__ ((__nothrow__ , __leaf__));





extern float gammaf (float) __attribute__ ((__nothrow__ , __leaf__)); extern float __gammaf (float) __attribute__ ((__nothrow__ , __leaf__));







extern float lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern float __lgammaf_r (float, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern float rintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __rintf (float __x) __attribute__ ((__nothrow__ , __leaf__));


extern float nextafterf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __nextafterf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));

extern float nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __nexttowardf (float __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));




extern float nextdownf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __nextdownf (float __x) __attribute__ ((__nothrow__ , __leaf__));

extern float nextupf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __nextupf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern float remainderf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __remainderf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));



extern float scalbnf (float __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalbnf (float __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern long int llogbf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __llogbf (float __x) __attribute__ ((__nothrow__ , __leaf__));




extern float scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalblnf (float __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern float nearbyintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern float __nearbyintf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern float roundf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __roundf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern float truncf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __truncf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern float __remquof (float __x, float __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf (float __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf (float __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundf (float __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf (float __x) __attribute__ ((__nothrow__ , __leaf__));



extern float fdimf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)); extern float __fdimf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__));



extern float fmaxf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fminf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fminf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ , __leaf__)); extern float __fmaf (float __x, float __y, float __z) __attribute__ ((__nothrow__ , __leaf__));




extern float roundevenf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __roundevenf (float __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern __intmax_t fromfpf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                            ;



extern __uintmax_t ufromfpf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                              ;




extern __intmax_t fromfpxf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpxf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                             ;




extern __uintmax_t ufromfpxf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpxf (float __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                               ;


extern int canonicalizef (float *__cx, const float *__x) __attribute__ ((__nothrow__ , __leaf__));






extern float fmaxmagf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fmaxmagf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fminmagf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fminmagf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern float fmaximumf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fmaximumf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fminimumf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fminimumf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fmaximum_numf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fmaximum_numf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fminimum_numf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fminimum_numf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fmaximum_magf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fmaximum_magf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fminimum_magf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fminimum_magf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fmaximum_mag_numf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fmaximum_mag_numf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern float fminimum_mag_numf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern float __fminimum_mag_numf (float __x, float __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int totalorderf (const float *__x, const float *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern int totalordermagf (const float *__x, const float *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern float getpayloadf (const float *__x) __attribute__ ((__nothrow__ , __leaf__)); extern float __getpayloadf (const float *__x) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadf (float *__x, float __payload) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadsigf (float *__x, float __payload) __attribute__ ((__nothrow__ , __leaf__));







extern float scalbf (float __x, float __n) __attribute__ ((__nothrow__ , __leaf__)); extern float __scalbf (float __x, float __n) __attribute__ ((__nothrow__ , __leaf__));
# 331 "/usr/include/math.h" 2 3 4
# 398 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbitl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern int __isinfl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern int __finitel (long double __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern int __isnanl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern int __iseqsigl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern int __issignalingl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));
# 399 "/usr/include/math.h" 2 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern long double acosl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __acosl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern long double asinl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __asinl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern long double atanl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atanl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern long double atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atan2l (long double __y, long double __x) __attribute__ ((__nothrow__ , __leaf__));


 extern long double cosl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cosl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern long double sinl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sinl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern long double tanl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tanl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




 extern long double coshl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __coshl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern long double sinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern long double tanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



 extern void sincosl (long double __x, long double *__sinx, long double *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




 extern long double acoshl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __acoshl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern long double asinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __asinhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

 extern long double atanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __atanhl (long double __x) __attribute__ ((__nothrow__ , __leaf__));





 extern long double expl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __expl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern long double __frexpl (long double __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern long double ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern long double __ldexpl (long double __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern long double logl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __logl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


 extern long double log10l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log10l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern long double __modfl (long double __x, long double *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



 extern long double exp10l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __exp10l (long double __x) __attribute__ ((__nothrow__ , __leaf__));




 extern long double expm1l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __expm1l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


 extern long double log1pl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log1pl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double logbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __logbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




 extern long double exp2l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __exp2l (long double __x) __attribute__ ((__nothrow__ , __leaf__));


 extern long double log2l (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __log2l (long double __x) __attribute__ ((__nothrow__ , __leaf__));






 extern long double powl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __powl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern long double sqrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __sqrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



 extern long double hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __hypotl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));




 extern long double cbrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __cbrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__));






extern long double ceill (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __ceill (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fabsl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fabsl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double floorl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __floorl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fmodl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));
# 177 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isinfl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));




extern int finitel (long double __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __dreml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));



extern long double significandl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __significandl (long double __x) __attribute__ ((__nothrow__ , __leaf__));






extern long double copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern long double nanl (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nanl (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__));
# 213 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern int isnanl (long double __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));





extern long double j0l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __j0l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double j1l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __j1l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double jnl (int, long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __jnl (int, long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double y0l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __y0l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double y1l (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __y1l (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double ynl (int, long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __ynl (int, long double) __attribute__ ((__nothrow__ , __leaf__));





 extern long double erfl (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __erfl (long double) __attribute__ ((__nothrow__ , __leaf__));
 extern long double erfcl (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __erfcl (long double) __attribute__ ((__nothrow__ , __leaf__));
extern long double lgammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __lgammal (long double) __attribute__ ((__nothrow__ , __leaf__));




extern long double tgammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __tgammal (long double) __attribute__ ((__nothrow__ , __leaf__));





extern long double gammal (long double) __attribute__ ((__nothrow__ , __leaf__)); extern long double __gammal (long double) __attribute__ ((__nothrow__ , __leaf__));







extern long double lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern long double __lgammal_r (long double, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern long double rintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __rintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern long double nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nextafterl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));

extern long double nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nexttowardl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));




extern long double nextdownl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nextdownl (long double __x) __attribute__ ((__nothrow__ , __leaf__));

extern long double nextupl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nextupl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long double remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __remainderl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));



extern long double scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalbnl (long double __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long int llogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __llogbl (long double __x) __attribute__ ((__nothrow__ , __leaf__));




extern long double scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalblnl (long double __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern long double nearbyintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __nearbyintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long double roundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __roundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern long double truncl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __truncl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern long double __remquol (long double __x, long double __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundl (long double __x) __attribute__ ((__nothrow__ , __leaf__));



extern long double fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fdiml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));



extern long double fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ , __leaf__)); extern long double __fmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ , __leaf__));




extern long double roundevenl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __roundevenl (long double __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern __intmax_t fromfpl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                            ;



extern __uintmax_t ufromfpl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                              ;




extern __intmax_t fromfpxl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpxl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                             ;




extern __uintmax_t ufromfpxl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpxl (long double __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                               ;


extern int canonicalizel (long double *__cx, const long double *__x) __attribute__ ((__nothrow__ , __leaf__));






extern long double fmaxmagl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fmaxmagl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fminmagl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fminmagl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern long double fmaximuml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fmaximuml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fminimuml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fminimuml (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fmaximum_numl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fmaximum_numl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fminimum_numl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fminimum_numl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fmaximum_magl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fmaximum_magl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fminimum_magl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fminimum_magl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fmaximum_mag_numl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fmaximum_mag_numl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern long double fminimum_mag_numl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern long double __fminimum_mag_numl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int totalorderl (const long double *__x, const long double *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern int totalordermagl (const long double *__x, const long double *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern long double getpayloadl (const long double *__x) __attribute__ ((__nothrow__ , __leaf__)); extern long double __getpayloadl (const long double *__x) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadl (long double *__x, long double __payload) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadsigl (long double *__x, long double __payload) __attribute__ ((__nothrow__ , __leaf__));







extern long double scalbl (long double __x, long double __n) __attribute__ ((__nothrow__ , __leaf__)); extern long double __scalbl (long double __x, long double __n) __attribute__ ((__nothrow__ , __leaf__));
# 400 "/usr/include/math.h" 2 3 4
# 450 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float32 acosf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __acosf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float32 asinf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __asinf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float32 atanf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __atanf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float32 atan2f32 (_Float32 __y, _Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __atan2f32 (_Float32 __y, _Float32 __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float32 cosf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __cosf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float32 sinf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __sinf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float32 tanf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __tanf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));




 extern _Float32 coshf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __coshf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float32 sinhf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __sinhf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float32 tanhf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __tanhf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));



 extern void sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosf32 (_Float32 __x, _Float32 *__sinx, _Float32 *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




 extern _Float32 acoshf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __acoshf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float32 asinhf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __asinhf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float32 atanhf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __atanhf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));





 extern _Float32 expf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __expf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 frexpf32 (_Float32 __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __frexpf32 (_Float32 __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 ldexpf32 (_Float32 __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __ldexpf32 (_Float32 __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float32 logf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __logf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float32 log10f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __log10f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 modff32 (_Float32 __x, _Float32 *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __modff32 (_Float32 __x, _Float32 *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



 extern _Float32 exp10f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __exp10f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));




 extern _Float32 expm1f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __expm1f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float32 log1pf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __log1pf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 logbf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __logbf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));




 extern _Float32 exp2f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __exp2f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float32 log2f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __log2f32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));






 extern _Float32 powf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __powf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 sqrtf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __sqrtf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));



 extern _Float32 hypotf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __hypotf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__));




 extern _Float32 cbrtf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __cbrtf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));






extern _Float32 ceilf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __ceilf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32 fabsf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __fabsf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32 floorf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __floorf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32 fmodf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __fmodf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__));
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 copysignf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __copysignf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float32 nanf32 (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __nanf32 (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__));
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 j0f32 (_Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __j0f32 (_Float32) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32 j1f32 (_Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __j1f32 (_Float32) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32 jnf32 (int, _Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __jnf32 (int, _Float32) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32 y0f32 (_Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __y0f32 (_Float32) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32 y1f32 (_Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __y1f32 (_Float32) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32 ynf32 (int, _Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __ynf32 (int, _Float32) __attribute__ ((__nothrow__ , __leaf__));





 extern _Float32 erff32 (_Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __erff32 (_Float32) __attribute__ ((__nothrow__ , __leaf__));
 extern _Float32 erfcf32 (_Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __erfcf32 (_Float32) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32 lgammaf32 (_Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __lgammaf32 (_Float32) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32 tgammaf32 (_Float32) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __tgammaf32 (_Float32) __attribute__ ((__nothrow__ , __leaf__));
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32 lgammaf32_r (_Float32, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __lgammaf32_r (_Float32, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern _Float32 rintf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __rintf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 nextafterf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __nextafterf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__));






extern _Float32 nextdownf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __nextdownf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32 nextupf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __nextupf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32 remainderf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __remainderf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32 scalbnf32 (_Float32 __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __scalbnf32 (_Float32 __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));




extern long int llogbf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __llogbf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32 scalblnf32 (_Float32 __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __scalblnf32 (_Float32 __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32 nearbyintf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __nearbyintf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32 roundf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __roundf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern _Float32 truncf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __truncf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float32 remquof32 (_Float32 __x, _Float32 __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __remquof32 (_Float32 __x, _Float32 __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32 fdimf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __fdimf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32 fmaxf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __fmaxf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32 fminf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __fminf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern _Float32 fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __fmaf32 (_Float32 __x, _Float32 __y, _Float32 __z) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32 roundevenf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __roundevenf32 (_Float32 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern __intmax_t fromfpf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                            ;



extern __uintmax_t ufromfpf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                              ;




extern __intmax_t fromfpxf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpxf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                             ;




extern __uintmax_t ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpxf32 (_Float32 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                               ;


extern int canonicalizef32 (_Float32 *__cx, const _Float32 *__x) __attribute__ ((__nothrow__ , __leaf__));






extern _Float32 fmaxmagf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __fmaxmagf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32 fminmagf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __fminmagf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float32 fmaximumf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __fmaximumf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32 fminimumf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __fminimumf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32 fmaximum_numf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __fmaximum_numf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32 fminimum_numf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __fminimum_numf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32 fmaximum_magf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __fmaximum_magf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32 fminimum_magf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __fminimum_magf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32 fmaximum_mag_numf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __fmaximum_mag_numf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32 fminimum_mag_numf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32 __fminimum_mag_numf32 (_Float32 __x, _Float32 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int totalorderf32 (const _Float32 *__x, const _Float32 *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern int totalordermagf32 (const _Float32 *__x, const _Float32 *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern _Float32 getpayloadf32 (const _Float32 *__x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32 __getpayloadf32 (const _Float32 *__x) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadf32 (_Float32 *__x, _Float32 __payload) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadsigf32 (_Float32 *__x, _Float32 __payload) __attribute__ ((__nothrow__ , __leaf__));
# 451 "/usr/include/math.h" 2 3 4
# 467 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float64 acosf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __acosf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float64 asinf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __asinf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float64 atanf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __atanf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float64 atan2f64 (_Float64 __y, _Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __atan2f64 (_Float64 __y, _Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float64 cosf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __cosf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float64 sinf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __sinf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float64 tanf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __tanf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));




 extern _Float64 coshf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __coshf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float64 sinhf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __sinhf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float64 tanhf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __tanhf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));



 extern void sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosf64 (_Float64 __x, _Float64 *__sinx, _Float64 *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




 extern _Float64 acoshf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __acoshf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float64 asinhf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __asinhf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float64 atanhf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __atanhf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));





 extern _Float64 expf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __expf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 frexpf64 (_Float64 __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __frexpf64 (_Float64 __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 ldexpf64 (_Float64 __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __ldexpf64 (_Float64 __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float64 logf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __logf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float64 log10f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __log10f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 modff64 (_Float64 __x, _Float64 *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __modff64 (_Float64 __x, _Float64 *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



 extern _Float64 exp10f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __exp10f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));




 extern _Float64 expm1f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __expm1f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float64 log1pf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __log1pf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 logbf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __logbf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));




 extern _Float64 exp2f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __exp2f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float64 log2f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __log2f64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));






 extern _Float64 powf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __powf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 sqrtf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __sqrtf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));



 extern _Float64 hypotf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __hypotf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));




 extern _Float64 cbrtf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __cbrtf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));






extern _Float64 ceilf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __ceilf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64 fabsf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __fabsf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64 floorf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __floorf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64 fmodf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __fmodf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 copysignf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __copysignf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float64 nanf64 (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __nanf64 (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__));
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 j0f64 (_Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __j0f64 (_Float64) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64 j1f64 (_Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __j1f64 (_Float64) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64 jnf64 (int, _Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __jnf64 (int, _Float64) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64 y0f64 (_Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __y0f64 (_Float64) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64 y1f64 (_Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __y1f64 (_Float64) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64 ynf64 (int, _Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __ynf64 (int, _Float64) __attribute__ ((__nothrow__ , __leaf__));





 extern _Float64 erff64 (_Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __erff64 (_Float64) __attribute__ ((__nothrow__ , __leaf__));
 extern _Float64 erfcf64 (_Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __erfcf64 (_Float64) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64 lgammaf64 (_Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __lgammaf64 (_Float64) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64 tgammaf64 (_Float64) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __tgammaf64 (_Float64) __attribute__ ((__nothrow__ , __leaf__));
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64 lgammaf64_r (_Float64, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __lgammaf64_r (_Float64, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern _Float64 rintf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __rintf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 nextafterf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __nextafterf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));






extern _Float64 nextdownf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __nextdownf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64 nextupf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __nextupf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64 remainderf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __remainderf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64 scalbnf64 (_Float64 __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __scalbnf64 (_Float64 __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));




extern long int llogbf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __llogbf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64 scalblnf64 (_Float64 __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __scalblnf64 (_Float64 __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64 nearbyintf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __nearbyintf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64 roundf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __roundf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern _Float64 truncf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __truncf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float64 remquof64 (_Float64 __x, _Float64 __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __remquof64 (_Float64 __x, _Float64 __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64 fdimf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __fdimf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64 fmaxf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __fmaxf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64 fminf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __fminf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern _Float64 fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64 roundevenf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __roundevenf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern __intmax_t fromfpf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                            ;



extern __uintmax_t ufromfpf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                              ;




extern __intmax_t fromfpxf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpxf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                             ;




extern __uintmax_t ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpxf64 (_Float64 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                               ;


extern int canonicalizef64 (_Float64 *__cx, const _Float64 *__x) __attribute__ ((__nothrow__ , __leaf__));






extern _Float64 fmaxmagf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __fmaxmagf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64 fminmagf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __fminmagf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float64 fmaximumf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __fmaximumf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64 fminimumf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __fminimumf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64 fmaximum_numf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __fmaximum_numf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64 fminimum_numf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __fminimum_numf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64 fmaximum_magf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __fmaximum_magf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64 fminimum_magf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __fminimum_magf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64 fmaximum_mag_numf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __fmaximum_mag_numf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64 fminimum_mag_numf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64 __fminimum_mag_numf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int totalorderf64 (const _Float64 *__x, const _Float64 *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern int totalordermagf64 (const _Float64 *__x, const _Float64 *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern _Float64 getpayloadf64 (const _Float64 *__x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64 __getpayloadf64 (const _Float64 *__x) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadf64 (_Float64 *__x, _Float64 __payload) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadsigf64 (_Float64 *__x, _Float64 __payload) __attribute__ ((__nothrow__ , __leaf__));
# 468 "/usr/include/math.h" 2 3 4
# 481 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 1 3 4
# 20 "/usr/include/x86_64-linux-gnu/bits/mathcalls-helper-functions.h" 3 4
extern int __fpclassifyf128 (_Float128 __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));


extern int __signbitf128 (_Float128 __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));



extern int __isinff128 (_Float128 __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern int __finitef128 (_Float128 __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern int __isnanf128 (_Float128 __value) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__const__));


extern int __iseqsigf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern int __issignalingf128 (_Float128 __value) __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__const__));
# 482 "/usr/include/math.h" 2 3 4


# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float128 acosf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __acosf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float128 asinf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __asinf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float128 atanf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __atanf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float128 atan2f128 (_Float128 __y, _Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __atan2f128 (_Float128 __y, _Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float128 cosf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __cosf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float128 sinf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __sinf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float128 tanf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __tanf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));




 extern _Float128 coshf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __coshf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float128 sinhf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __sinhf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float128 tanhf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __tanhf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));



 extern void sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosf128 (_Float128 __x, _Float128 *__sinx, _Float128 *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




 extern _Float128 acoshf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __acoshf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float128 asinhf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __asinhf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float128 atanhf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __atanhf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));





 extern _Float128 expf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __expf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 frexpf128 (_Float128 __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __frexpf128 (_Float128 __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 ldexpf128 (_Float128 __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __ldexpf128 (_Float128 __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float128 logf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __logf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float128 log10f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __log10f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 modff128 (_Float128 __x, _Float128 *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __modff128 (_Float128 __x, _Float128 *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



 extern _Float128 exp10f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __exp10f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));




 extern _Float128 expm1f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __expm1f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float128 log1pf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __log1pf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 logbf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __logbf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));




 extern _Float128 exp2f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __exp2f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float128 log2f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __log2f128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));






 extern _Float128 powf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __powf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 sqrtf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __sqrtf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));



 extern _Float128 hypotf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __hypotf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));




 extern _Float128 cbrtf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __cbrtf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));






extern _Float128 ceilf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __ceilf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float128 fabsf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __fabsf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float128 floorf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __floorf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float128 fmodf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __fmodf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 copysignf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __copysignf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float128 nanf128 (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __nanf128 (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__));
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 j0f128 (_Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __j0f128 (_Float128) __attribute__ ((__nothrow__ , __leaf__));
extern _Float128 j1f128 (_Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __j1f128 (_Float128) __attribute__ ((__nothrow__ , __leaf__));
extern _Float128 jnf128 (int, _Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __jnf128 (int, _Float128) __attribute__ ((__nothrow__ , __leaf__));
extern _Float128 y0f128 (_Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __y0f128 (_Float128) __attribute__ ((__nothrow__ , __leaf__));
extern _Float128 y1f128 (_Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __y1f128 (_Float128) __attribute__ ((__nothrow__ , __leaf__));
extern _Float128 ynf128 (int, _Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __ynf128 (int, _Float128) __attribute__ ((__nothrow__ , __leaf__));





 extern _Float128 erff128 (_Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __erff128 (_Float128) __attribute__ ((__nothrow__ , __leaf__));
 extern _Float128 erfcf128 (_Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __erfcf128 (_Float128) __attribute__ ((__nothrow__ , __leaf__));
extern _Float128 lgammaf128 (_Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __lgammaf128 (_Float128) __attribute__ ((__nothrow__ , __leaf__));




extern _Float128 tgammaf128 (_Float128) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __tgammaf128 (_Float128) __attribute__ ((__nothrow__ , __leaf__));
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float128 lgammaf128_r (_Float128, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __lgammaf128_r (_Float128, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern _Float128 rintf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __rintf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float128 nextafterf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __nextafterf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));






extern _Float128 nextdownf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __nextdownf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float128 nextupf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __nextupf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float128 remainderf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __remainderf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));



extern _Float128 scalbnf128 (_Float128 __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __scalbnf128 (_Float128 __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));




extern long int llogbf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __llogbf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float128 scalblnf128 (_Float128 __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __scalblnf128 (_Float128 __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern _Float128 nearbyintf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __nearbyintf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float128 roundf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __roundf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern _Float128 truncf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __truncf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float128 remquof128 (_Float128 __x, _Float128 __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __remquof128 (_Float128 __x, _Float128 __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float128 fdimf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __fdimf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));



extern _Float128 fmaxf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __fmaxf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float128 fminf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __fminf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern _Float128 fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) __attribute__ ((__nothrow__ , __leaf__));




extern _Float128 roundevenf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __roundevenf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern __intmax_t fromfpf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                            ;



extern __uintmax_t ufromfpf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                              ;




extern __intmax_t fromfpxf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpxf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                             ;




extern __uintmax_t ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpxf128 (_Float128 __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                               ;


extern int canonicalizef128 (_Float128 *__cx, const _Float128 *__x) __attribute__ ((__nothrow__ , __leaf__));






extern _Float128 fmaxmagf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __fmaxmagf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float128 fminmagf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __fminmagf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float128 fmaximumf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __fmaximumf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float128 fminimumf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __fminimumf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float128 fmaximum_numf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __fmaximum_numf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float128 fminimum_numf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __fminimum_numf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float128 fmaximum_magf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __fmaximum_magf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float128 fminimum_magf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __fminimum_magf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float128 fmaximum_mag_numf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __fmaximum_mag_numf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float128 fminimum_mag_numf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float128 __fminimum_mag_numf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int totalorderf128 (const _Float128 *__x, const _Float128 *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern int totalordermagf128 (const _Float128 *__x, const _Float128 *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern _Float128 getpayloadf128 (const _Float128 *__x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float128 __getpayloadf128 (const _Float128 *__x) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadf128 (_Float128 *__x, _Float128 __payload) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadsigf128 (_Float128 *__x, _Float128 __payload) __attribute__ ((__nothrow__ , __leaf__));
# 485 "/usr/include/math.h" 2 3 4
# 501 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float32x acosf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __acosf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float32x asinf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __asinf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float32x atanf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __atanf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float32x atan2f32x (_Float32x __y, _Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __atan2f32x (_Float32x __y, _Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float32x cosf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __cosf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float32x sinf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __sinf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float32x tanf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __tanf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));




 extern _Float32x coshf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __coshf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float32x sinhf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __sinhf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float32x tanhf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __tanhf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));



 extern void sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosf32x (_Float32x __x, _Float32x *__sinx, _Float32x *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




 extern _Float32x acoshf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __acoshf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float32x asinhf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __asinhf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float32x atanhf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __atanhf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));





 extern _Float32x expf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __expf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x frexpf32x (_Float32x __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __frexpf32x (_Float32x __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x ldexpf32x (_Float32x __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __ldexpf32x (_Float32x __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float32x logf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __logf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float32x log10f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __log10f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x modff32x (_Float32x __x, _Float32x *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __modff32x (_Float32x __x, _Float32x *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



 extern _Float32x exp10f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __exp10f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));




 extern _Float32x expm1f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __expm1f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float32x log1pf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __log1pf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x logbf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __logbf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));




 extern _Float32x exp2f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __exp2f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float32x log2f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __log2f32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));






 extern _Float32x powf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __powf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x sqrtf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __sqrtf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));



 extern _Float32x hypotf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __hypotf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));




 extern _Float32x cbrtf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __cbrtf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));






extern _Float32x ceilf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __ceilf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32x fabsf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __fabsf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32x floorf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __floorf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32x fmodf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __fmodf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x copysignf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __copysignf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float32x nanf32x (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __nanf32x (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__));
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x j0f32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __j0f32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32x j1f32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __j1f32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32x jnf32x (int, _Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __jnf32x (int, _Float32x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32x y0f32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __y0f32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32x y1f32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __y1f32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32x ynf32x (int, _Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __ynf32x (int, _Float32x) __attribute__ ((__nothrow__ , __leaf__));





 extern _Float32x erff32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __erff32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__));
 extern _Float32x erfcf32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __erfcf32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float32x lgammaf32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __lgammaf32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32x tgammaf32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __tgammaf32x (_Float32x) __attribute__ ((__nothrow__ , __leaf__));
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float32x lgammaf32x_r (_Float32x, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __lgammaf32x_r (_Float32x, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern _Float32x rintf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __rintf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x nextafterf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __nextafterf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));






extern _Float32x nextdownf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __nextdownf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float32x nextupf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __nextupf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32x remainderf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __remainderf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32x scalbnf32x (_Float32x __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __scalbnf32x (_Float32x __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));




extern long int llogbf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __llogbf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32x scalblnf32x (_Float32x __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __scalblnf32x (_Float32x __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32x nearbyintf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __nearbyintf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32x roundf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __roundf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern _Float32x truncf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __truncf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float32x remquof32x (_Float32x __x, _Float32x __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __remquof32x (_Float32x __x, _Float32x __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32x fdimf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __fdimf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));



extern _Float32x fmaxf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __fmaxf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32x fminf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __fminf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern _Float32x fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) __attribute__ ((__nothrow__ , __leaf__));




extern _Float32x roundevenf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __roundevenf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern __intmax_t fromfpf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                            ;



extern __uintmax_t ufromfpf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                              ;




extern __intmax_t fromfpxf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpxf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                             ;




extern __uintmax_t ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpxf32x (_Float32x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                               ;


extern int canonicalizef32x (_Float32x *__cx, const _Float32x *__x) __attribute__ ((__nothrow__ , __leaf__));






extern _Float32x fmaxmagf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __fmaxmagf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32x fminmagf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __fminmagf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float32x fmaximumf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __fmaximumf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32x fminimumf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __fminimumf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32x fmaximum_numf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __fmaximum_numf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32x fminimum_numf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __fminimum_numf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32x fmaximum_magf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __fmaximum_magf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32x fminimum_magf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __fminimum_magf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32x fmaximum_mag_numf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __fmaximum_mag_numf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float32x fminimum_mag_numf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float32x __fminimum_mag_numf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int totalorderf32x (const _Float32x *__x, const _Float32x *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern int totalordermagf32x (const _Float32x *__x, const _Float32x *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern _Float32x getpayloadf32x (const _Float32x *__x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float32x __getpayloadf32x (const _Float32x *__x) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadf32x (_Float32x *__x, _Float32x __payload) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadsigf32x (_Float32x *__x, _Float32x __payload) __attribute__ ((__nothrow__ , __leaf__));
# 502 "/usr/include/math.h" 2 3 4
# 518 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 1 3 4
# 53 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
 extern _Float64x acosf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __acosf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float64x asinf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __asinf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float64x atanf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __atanf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float64x atan2f64x (_Float64x __y, _Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __atan2f64x (_Float64x __y, _Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float64x cosf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __cosf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float64x sinf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __sinf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float64x tanf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __tanf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));




 extern _Float64x coshf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __coshf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float64x sinhf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __sinhf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float64x tanhf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __tanhf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));



 extern void sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) __attribute__ ((__nothrow__ , __leaf__)); extern void __sincosf64x (_Float64x __x, _Float64x *__sinx, _Float64x *__cosx) __attribute__ ((__nothrow__ , __leaf__))
                                                        ;




 extern _Float64x acoshf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __acoshf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float64x asinhf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __asinhf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

 extern _Float64x atanhf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __atanhf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));





 extern _Float64x expf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __expf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x frexpf64x (_Float64x __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __frexpf64x (_Float64x __x, int *__exponent) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x ldexpf64x (_Float64x __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __ldexpf64x (_Float64x __x, int __exponent) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float64x logf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __logf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float64x log10f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __log10f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x modff64x (_Float64x __x, _Float64x *__iptr) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __modff64x (_Float64x __x, _Float64x *__iptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



 extern _Float64x exp10f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __exp10f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));




 extern _Float64x expm1f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __expm1f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float64x log1pf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __log1pf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x logbf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __logbf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));




 extern _Float64x exp2f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __exp2f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


 extern _Float64x log2f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __log2f64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));






 extern _Float64x powf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __powf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x sqrtf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __sqrtf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));



 extern _Float64x hypotf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __hypotf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));




 extern _Float64x cbrtf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __cbrtf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));






extern _Float64x ceilf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __ceilf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64x fabsf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __fabsf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64x floorf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __floorf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64x fmodf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __fmodf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));
# 198 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x copysignf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __copysignf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float64x nanf64x (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __nanf64x (const char *__tagb) __attribute__ ((__nothrow__ , __leaf__));
# 220 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x j0f64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __j0f64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64x j1f64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __j1f64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64x jnf64x (int, _Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __jnf64x (int, _Float64x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64x y0f64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __y0f64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64x y1f64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __y1f64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64x ynf64x (int, _Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __ynf64x (int, _Float64x) __attribute__ ((__nothrow__ , __leaf__));





 extern _Float64x erff64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __erff64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__));
 extern _Float64x erfcf64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __erfcf64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__));
extern _Float64x lgammaf64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __lgammaf64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64x tgammaf64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __tgammaf64x (_Float64x) __attribute__ ((__nothrow__ , __leaf__));
# 252 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h" 3 4
extern _Float64x lgammaf64x_r (_Float64x, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __lgammaf64x_r (_Float64x, int *__signgamp) __attribute__ ((__nothrow__ , __leaf__));






extern _Float64x rintf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __rintf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x nextafterf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __nextafterf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));






extern _Float64x nextdownf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __nextdownf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));

extern _Float64x nextupf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __nextupf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64x remainderf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __remainderf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64x scalbnf64x (_Float64x __x, int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __scalbnf64x (_Float64x __x, int __n) __attribute__ ((__nothrow__ , __leaf__));



extern int ilogbf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern int __ilogbf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));




extern long int llogbf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __llogbf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64x scalblnf64x (_Float64x __x, long int __n) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __scalblnf64x (_Float64x __x, long int __n) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64x nearbyintf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __nearbyintf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64x roundf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __roundf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern _Float64x truncf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __truncf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float64x remquof64x (_Float64x __x, _Float64x __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __remquof64x (_Float64x __x, _Float64x __y, int *__quo) __attribute__ ((__nothrow__ , __leaf__));






extern long int lrintf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lrintf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llrintf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llrintf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));



extern long int lroundf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long int __lroundf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));
__extension__
extern long long int llroundf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)); extern long long int __llroundf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64x fdimf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __fdimf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));



extern _Float64x fmaxf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __fmaxf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64x fminf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __fminf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern _Float64x fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) __attribute__ ((__nothrow__ , __leaf__));




extern _Float64x roundevenf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __roundevenf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern __intmax_t fromfpf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                            ;



extern __uintmax_t ufromfpf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                              ;




extern __intmax_t fromfpxf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __intmax_t __fromfpxf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                             ;




extern __uintmax_t ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__)); extern __uintmax_t __ufromfpxf64x (_Float64x __x, int __round, unsigned int __width) __attribute__ ((__nothrow__ , __leaf__))
                               ;


extern int canonicalizef64x (_Float64x *__cx, const _Float64x *__x) __attribute__ ((__nothrow__ , __leaf__));






extern _Float64x fmaxmagf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __fmaxmagf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64x fminmagf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __fminmagf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern _Float64x fmaximumf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __fmaximumf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64x fminimumf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __fminimumf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64x fmaximum_numf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __fmaximum_numf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64x fminimum_numf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __fminimum_numf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64x fmaximum_magf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __fmaximum_magf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64x fminimum_magf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __fminimum_magf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64x fmaximum_mag_numf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __fmaximum_mag_numf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern _Float64x fminimum_mag_numf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)); extern _Float64x __fminimum_mag_numf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int totalorderf64x (const _Float64x *__x, const _Float64x *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern int totalordermagf64x (const _Float64x *__x, const _Float64x *__y) __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__pure__));


extern _Float64x getpayloadf64x (const _Float64x *__x) __attribute__ ((__nothrow__ , __leaf__)); extern _Float64x __getpayloadf64x (const _Float64x *__x) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadf64x (_Float64x *__x, _Float64x __payload) __attribute__ ((__nothrow__ , __leaf__));


extern int setpayloadsigf64x (_Float64x *__x, _Float64x __payload) __attribute__ ((__nothrow__ , __leaf__));
# 519 "/usr/include/math.h" 2 3 4
# 566 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern float fadd (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern float fdiv (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern float ffma (double __x, double __y, double __z) __attribute__ ((__nothrow__ , __leaf__));


extern float fmul (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));


extern float fsqrt (double __x) __attribute__ ((__nothrow__ , __leaf__));


extern float fsub (double __x, double __y) __attribute__ ((__nothrow__ , __leaf__));
# 567 "/usr/include/math.h" 2 3 4
# 587 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern float faddl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern float fdivl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern float ffmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ , __leaf__));


extern float fmull (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern float fsqrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern float fsubl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));
# 588 "/usr/include/math.h" 2 3 4
# 616 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern double daddl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double ddivl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double dfmal (long double __x, long double __y, long double __z) __attribute__ ((__nothrow__ , __leaf__));


extern double dmull (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));


extern double dsqrtl (long double __x) __attribute__ ((__nothrow__ , __leaf__));


extern double dsubl (long double __x, long double __y) __attribute__ ((__nothrow__ , __leaf__));
# 617 "/usr/include/math.h" 2 3 4
# 697 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32divf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32fmaf32x (_Float32x __x, _Float32x __y, _Float32x __z) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32mulf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32sqrtf32x (_Float32x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32subf32x (_Float32x __x, _Float32x __y) __attribute__ ((__nothrow__ , __leaf__));
# 698 "/usr/include/math.h" 2 3 4
# 707 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32divf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32fmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32mulf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32sqrtf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32subf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));
# 708 "/usr/include/math.h" 2 3 4
# 717 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32divf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32mulf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32sqrtf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32subf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));
# 718 "/usr/include/math.h" 2 3 4
# 727 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32 f32addf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32divf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32mulf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32sqrtf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32 f32subf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));
# 728 "/usr/include/math.h" 2 3 4
# 747 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xdivf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xfmaf64 (_Float64 __x, _Float64 __y, _Float64 __z) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xmulf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xsqrtf64 (_Float64 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xsubf64 (_Float64 __x, _Float64 __y) __attribute__ ((__nothrow__ , __leaf__));
# 748 "/usr/include/math.h" 2 3 4
# 757 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xdivf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xfmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xmulf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xsqrtf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xsubf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));
# 758 "/usr/include/math.h" 2 3 4
# 767 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float32x f32xaddf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xdivf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xfmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xmulf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xsqrtf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float32x f32xsubf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));
# 768 "/usr/include/math.h" 2 3 4
# 787 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 f64divf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 f64fmaf64x (_Float64x __x, _Float64x __y, _Float64x __z) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 f64mulf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 f64sqrtf64x (_Float64x __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 f64subf64x (_Float64x __x, _Float64x __y) __attribute__ ((__nothrow__ , __leaf__));
# 788 "/usr/include/math.h" 2 3 4
# 797 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64 f64addf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 f64divf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 f64fmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 f64mulf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 f64sqrtf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64 f64subf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));
# 798 "/usr/include/math.h" 2 3 4
# 817 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 1 3 4
# 24 "/usr/include/x86_64-linux-gnu/bits/mathcalls-narrow.h" 3 4
extern _Float64x f64xaddf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x f64xdivf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x f64xfmaf128 (_Float128 __x, _Float128 __y, _Float128 __z) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x f64xmulf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x f64xsqrtf128 (_Float128 __x) __attribute__ ((__nothrow__ , __leaf__));


extern _Float64x f64xsubf128 (_Float128 __x, _Float128 __y) __attribute__ ((__nothrow__ , __leaf__));
# 818 "/usr/include/math.h" 2 3 4
# 854 "/usr/include/math.h" 3 4
extern int signgam;
# 934 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
# 1054 "/usr/include/math.h" 3 4
# 1 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 1 3 4
# 23 "/usr/include/x86_64-linux-gnu/bits/iscanonical.h" 3 4
extern int __iscanonicall (long double __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 1055 "/usr/include/math.h" 2 3 4
# 1423 "/usr/include/math.h" 3 4

# 878 "duk_config.h" 2
# 1 "/usr/lib/gcc/x86_64-linux-gnu/11/include/limits.h" 1 3 4
# 879 "duk_config.h" 2
# 1654 "duk_config.h"
# 1 "/usr/include/inttypes.h" 1 3 4
# 34 "/usr/include/inttypes.h" 3 4
typedef int __gwchar_t;
# 266 "/usr/include/inttypes.h" 3 4





typedef struct
  {
    long int quot;
    long int rem;
  } imaxdiv_t;
# 290 "/usr/include/inttypes.h" 3 4
extern intmax_t imaxabs (intmax_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern intmax_t strtoimax (const char *__restrict __nptr,
      char **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));


extern uintmax_t strtoumax (const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));


extern intmax_t wcstoimax (const __gwchar_t *__restrict __nptr,
      __gwchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));


extern uintmax_t wcstoumax (const __gwchar_t *__restrict __nptr,
       __gwchar_t ** __restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));


# 1655 "duk_config.h" 2


# 1656 "duk_config.h"
typedef uint8_t duk_uint8_t;
typedef int8_t duk_int8_t;
typedef uint16_t duk_uint16_t;
typedef int16_t duk_int16_t;
typedef uint32_t duk_uint32_t;
typedef int32_t duk_int32_t;
typedef uint64_t duk_uint64_t;
typedef int64_t duk_int64_t;
typedef uint_least8_t duk_uint_least8_t;
typedef int_least8_t duk_int_least8_t;
typedef uint_least16_t duk_uint_least16_t;
typedef int_least16_t duk_int_least16_t;
typedef uint_least32_t duk_uint_least32_t;
typedef int_least32_t duk_int_least32_t;
typedef uint_least64_t duk_uint_least64_t;
typedef int_least64_t duk_int_least64_t;
typedef uint_fast8_t duk_uint_fast8_t;
typedef int_fast8_t duk_int_fast8_t;
typedef uint_fast16_t duk_uint_fast16_t;
typedef int_fast16_t duk_int_fast16_t;
typedef uint_fast32_t duk_uint_fast32_t;
typedef int_fast32_t duk_int_fast32_t;
typedef uint_fast64_t duk_uint_fast64_t;
typedef int_fast64_t duk_int_fast64_t;
typedef uintptr_t duk_uintptr_t;
typedef intptr_t duk_intptr_t;
typedef uintmax_t duk_uintmax_t;
typedef intmax_t duk_intmax_t;
# 1996 "duk_config.h"
typedef size_t duk_size_t;
typedef ptrdiff_t duk_ptrdiff_t;






typedef int duk_int_t;
typedef unsigned int duk_uint_t;
# 2023 "duk_config.h"
typedef duk_int_fast32_t duk_int_fast_t;
typedef duk_uint_fast32_t duk_uint_fast_t;
# 2033 "duk_config.h"
typedef int duk_small_int_t;
typedef unsigned int duk_small_uint_t;
# 2043 "duk_config.h"
typedef duk_int_fast16_t duk_small_int_fast_t;
typedef duk_uint_fast16_t duk_small_uint_fast_t;






typedef duk_small_uint_t duk_bool_t;




typedef duk_int_t duk_idx_t;




typedef duk_uint_t duk_uidx_t;






typedef duk_uint_t duk_uarridx_t;







typedef duk_small_int_t duk_ret_t;






typedef duk_int_t duk_errcode_t;
# 2094 "duk_config.h"
typedef duk_int_t duk_codepoint_t;
typedef duk_uint_t duk_ucodepoint_t;






typedef float duk_float_t;
typedef double duk_double_t;
# 2126 "duk_config.h"
typedef struct duk_hthread duk_context;
# 203 "duktape.h" 2
# 231 "duktape.h"
struct duk_thread_state;
struct duk_memory_functions;
struct duk_function_list_entry;
struct duk_number_list_entry;
struct duk_time_components;




typedef struct duk_thread_state duk_thread_state;
typedef struct duk_memory_functions duk_memory_functions;
typedef struct duk_function_list_entry duk_function_list_entry;
typedef struct duk_number_list_entry duk_number_list_entry;
typedef struct duk_time_components duk_time_components;

typedef duk_ret_t (*duk_c_function)(duk_context *ctx);
typedef void *(*duk_alloc_function) (void *udata, duk_size_t size);
typedef void *(*duk_realloc_function) (void *udata, void *ptr, duk_size_t size);
typedef void (*duk_free_function) (void *udata, void *ptr);
typedef void (*duk_fatal_function) (void *udata, const char *msg);
typedef void (*duk_decode_char_function) (void *udata, duk_codepoint_t codepoint);
typedef duk_codepoint_t (*duk_map_char_function) (void *udata, duk_codepoint_t codepoint);
typedef duk_ret_t (*duk_safe_call_function) (duk_context *ctx, void *udata);
typedef duk_size_t (*duk_debug_read_function) (void *udata, char *buffer, duk_size_t length);
typedef duk_size_t (*duk_debug_write_function) (void *udata, const char *buffer, duk_size_t length);
typedef duk_size_t (*duk_debug_peek_function) (void *udata);
typedef void (*duk_debug_read_flush_function) (void *udata);
typedef void (*duk_debug_write_flush_function) (void *udata);
typedef duk_idx_t (*duk_debug_request_function) (duk_context *ctx, void *udata, duk_idx_t nvalues);
typedef void (*duk_debug_detached_function) (duk_context *ctx, void *udata);

struct duk_thread_state {




 char data[128];
};

struct duk_memory_functions {
 duk_alloc_function alloc_func;
 duk_realloc_function realloc_func;
 duk_free_function free_func;
 void *udata;
};

struct duk_function_list_entry {
 const char *key;
 duk_c_function value;
 duk_idx_t nargs;
};

struct duk_number_list_entry {
 const char *key;
 duk_double_t value;
};

struct duk_time_components {
 duk_double_t year;
 duk_double_t month;
 duk_double_t day;
 duk_double_t hours;
 duk_double_t minutes;
 duk_double_t seconds;
 duk_double_t milliseconds;
 duk_double_t weekday;
};
# 506 "duktape.h"
__attribute__ ((visibility("default"))) extern
duk_context *duk_create_heap(duk_alloc_function alloc_func,
                             duk_realloc_function realloc_func,
                             duk_free_function free_func,
                             void *heap_udata,
                             duk_fatal_function fatal_handler);
__attribute__ ((visibility("default"))) extern void duk_destroy_heap(duk_context *ctx);

__attribute__ ((visibility("default"))) extern void duk_suspend(duk_context *ctx, duk_thread_state *state);
__attribute__ ((visibility("default"))) extern void duk_resume(duk_context *ctx, const duk_thread_state *state);
# 526 "duktape.h"
__attribute__ ((visibility("default"))) extern void *duk_alloc_raw(duk_context *ctx, duk_size_t size);
__attribute__ ((visibility("default"))) extern void duk_free_raw(duk_context *ctx, void *ptr);
__attribute__ ((visibility("default"))) extern void *duk_realloc_raw(duk_context *ctx, void *ptr, duk_size_t size);
__attribute__ ((visibility("default"))) extern void *duk_alloc(duk_context *ctx, duk_size_t size);
__attribute__ ((visibility("default"))) extern void duk_free(duk_context *ctx, void *ptr);
__attribute__ ((visibility("default"))) extern void *duk_realloc(duk_context *ctx, void *ptr, duk_size_t size);
__attribute__ ((visibility("default"))) extern void duk_get_memory_functions(duk_context *ctx, duk_memory_functions *out_funcs);
__attribute__ ((visibility("default"))) extern void duk_gc(duk_context *ctx, duk_uint_t flags);





__attribute__ ((visibility("default"))) extern void duk_throw_raw(duk_context *ctx);


__attribute__ ((visibility("default"))) extern void duk_fatal_raw(duk_context *ctx, const char *err_msg);


__attribute__ ((visibility("default"))) extern void duk_error_raw(duk_context *ctx, duk_errcode_t err_code, const char *filename, duk_int_t line, const char *fmt, ...);
# 615 "duktape.h"
__attribute__ ((visibility("default"))) extern void duk_error_va_raw(duk_context *ctx, duk_errcode_t err_code, const char *filename, duk_int_t line, const char *fmt, va_list ap);
# 638 "duktape.h"
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_strict_call(duk_context *ctx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_constructor_call(duk_context *ctx);





__attribute__ ((visibility("default"))) extern duk_idx_t duk_normalize_index(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_idx_t duk_require_normalize_index(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_valid_index(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_require_valid_index(duk_context *ctx, duk_idx_t idx);

__attribute__ ((visibility("default"))) extern duk_idx_t duk_get_top(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_set_top(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_idx_t duk_get_top_index(duk_context *ctx);
__attribute__ ((visibility("default"))) extern duk_idx_t duk_require_top_index(duk_context *ctx);
# 662 "duktape.h"
__attribute__ ((visibility("default"))) extern duk_bool_t duk_check_stack(duk_context *ctx, duk_idx_t extra);
__attribute__ ((visibility("default"))) extern void duk_require_stack(duk_context *ctx, duk_idx_t extra);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_check_stack_top(duk_context *ctx, duk_idx_t top);
__attribute__ ((visibility("default"))) extern void duk_require_stack_top(duk_context *ctx, duk_idx_t top);





__attribute__ ((visibility("default"))) extern void duk_swap(duk_context *ctx, duk_idx_t idx1, duk_idx_t idx2);
__attribute__ ((visibility("default"))) extern void duk_swap_top(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_dup(duk_context *ctx, duk_idx_t from_idx);
__attribute__ ((visibility("default"))) extern void duk_dup_top(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_insert(duk_context *ctx, duk_idx_t to_idx);
__attribute__ ((visibility("default"))) extern void duk_pull(duk_context *ctx, duk_idx_t from_idx);
__attribute__ ((visibility("default"))) extern void duk_replace(duk_context *ctx, duk_idx_t to_idx);
__attribute__ ((visibility("default"))) extern void duk_copy(duk_context *ctx, duk_idx_t from_idx, duk_idx_t to_idx);
__attribute__ ((visibility("default"))) extern void duk_remove(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_xcopymove_raw(duk_context *to_ctx, duk_context *from_ctx, duk_idx_t count, duk_bool_t is_copy);
# 696 "duktape.h"
__attribute__ ((visibility("default"))) extern void duk_push_undefined(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_push_null(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_push_boolean(duk_context *ctx, duk_bool_t val);
__attribute__ ((visibility("default"))) extern void duk_push_true(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_push_false(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_push_number(duk_context *ctx, duk_double_t val);
__attribute__ ((visibility("default"))) extern void duk_push_nan(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_push_int(duk_context *ctx, duk_int_t val);
__attribute__ ((visibility("default"))) extern void duk_push_uint(duk_context *ctx, duk_uint_t val);
__attribute__ ((visibility("default"))) extern const char *duk_push_string(duk_context *ctx, const char *str);
__attribute__ ((visibility("default"))) extern const char *duk_push_lstring(duk_context *ctx, const char *str, duk_size_t len);
__attribute__ ((visibility("default"))) extern void duk_push_pointer(duk_context *ctx, void *p);
__attribute__ ((visibility("default"))) extern const char *duk_push_sprintf(duk_context *ctx, const char *fmt, ...);
__attribute__ ((visibility("default"))) extern const char *duk_push_vsprintf(duk_context *ctx, const char *fmt, va_list ap);
# 720 "duktape.h"
__attribute__ ((visibility("default"))) extern const char *duk_push_literal_raw(duk_context *ctx, const char *str, duk_size_t len);



__attribute__ ((visibility("default"))) extern void duk_push_this(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_push_new_target(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_push_current_function(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_push_current_thread(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_push_global_object(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_push_heap_stash(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_push_global_stash(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_push_thread_stash(duk_context *ctx, duk_context *target_ctx);

__attribute__ ((visibility("default"))) extern duk_idx_t duk_push_object(duk_context *ctx);
__attribute__ ((visibility("default"))) extern duk_idx_t duk_push_bare_object(duk_context *ctx);
__attribute__ ((visibility("default"))) extern duk_idx_t duk_push_array(duk_context *ctx);
__attribute__ ((visibility("default"))) extern duk_idx_t duk_push_bare_array(duk_context *ctx);
__attribute__ ((visibility("default"))) extern duk_idx_t duk_push_c_function(duk_context *ctx, duk_c_function func, duk_idx_t nargs);
__attribute__ ((visibility("default"))) extern duk_idx_t duk_push_c_lightfunc(duk_context *ctx, duk_c_function func, duk_idx_t nargs, duk_idx_t length, duk_int_t magic);
__attribute__ ((visibility("default"))) extern duk_idx_t duk_push_thread_raw(duk_context *ctx, duk_uint_t flags);
__attribute__ ((visibility("default"))) extern duk_idx_t duk_push_proxy(duk_context *ctx, duk_uint_t proxy_flags);







__attribute__ ((visibility("default"))) extern duk_idx_t duk_push_error_object_raw(duk_context *ctx, duk_errcode_t err_code, const char *filename, duk_int_t line, const char *fmt, ...);
# 762 "duktape.h"
__attribute__ ((visibility("default"))) extern duk_idx_t duk_push_error_object_va_raw(duk_context *ctx, duk_errcode_t err_code, const char *filename, duk_int_t line, const char *fmt, va_list ap);







__attribute__ ((visibility("default"))) extern void *duk_push_buffer_raw(duk_context *ctx, duk_size_t size, duk_small_uint_t flags);
# 794 "duktape.h"
__attribute__ ((visibility("default"))) extern void duk_push_buffer_object(duk_context *ctx, duk_idx_t idx_buffer, duk_size_t byte_offset, duk_size_t byte_length, duk_uint_t flags);

__attribute__ ((visibility("default"))) extern duk_idx_t duk_push_heapptr(duk_context *ctx, void *ptr);





__attribute__ ((visibility("default"))) extern void duk_pop(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_pop_n(duk_context *ctx, duk_idx_t count);
__attribute__ ((visibility("default"))) extern void duk_pop_2(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_pop_3(duk_context *ctx);
# 814 "duktape.h"
__attribute__ ((visibility("default"))) extern duk_int_t duk_get_type(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_check_type(duk_context *ctx, duk_idx_t idx, duk_int_t type);
__attribute__ ((visibility("default"))) extern duk_uint_t duk_get_type_mask(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_check_type_mask(duk_context *ctx, duk_idx_t idx, duk_uint_t mask);

__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_undefined(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_null(duk_context *ctx, duk_idx_t idx);



__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_boolean(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_number(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_nan(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_string(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_object(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_buffer(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_buffer_data(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_pointer(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_lightfunc(duk_context *ctx, duk_idx_t idx);

__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_symbol(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_array(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_function(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_c_function(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_ecmascript_function(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_bound_function(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_thread(duk_context *ctx, duk_idx_t idx);



__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_constructable(duk_context *ctx, duk_idx_t idx);

__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_dynamic_buffer(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_fixed_buffer(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_is_external_buffer(duk_context *ctx, duk_idx_t idx);
# 872 "duktape.h"
__attribute__ ((visibility("default"))) extern duk_errcode_t duk_get_error_code(duk_context *ctx, duk_idx_t idx);
# 896 "duktape.h"
__attribute__ ((visibility("default"))) extern duk_bool_t duk_get_boolean(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_double_t duk_get_number(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_int_t duk_get_int(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_uint_t duk_get_uint(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern const char *duk_get_string(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern const char *duk_get_lstring(duk_context *ctx, duk_idx_t idx, duk_size_t *out_len);
__attribute__ ((visibility("default"))) extern void *duk_get_buffer(duk_context *ctx, duk_idx_t idx, duk_size_t *out_size);
__attribute__ ((visibility("default"))) extern void *duk_get_buffer_data(duk_context *ctx, duk_idx_t idx, duk_size_t *out_size);
__attribute__ ((visibility("default"))) extern void *duk_get_pointer(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_c_function duk_get_c_function(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_context *duk_get_context(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void *duk_get_heapptr(duk_context *ctx, duk_idx_t idx);






__attribute__ ((visibility("default"))) extern duk_bool_t duk_get_boolean_default(duk_context *ctx, duk_idx_t idx, duk_bool_t def_value);
__attribute__ ((visibility("default"))) extern duk_double_t duk_get_number_default(duk_context *ctx, duk_idx_t idx, duk_double_t def_value);
__attribute__ ((visibility("default"))) extern duk_int_t duk_get_int_default(duk_context *ctx, duk_idx_t idx, duk_int_t def_value);
__attribute__ ((visibility("default"))) extern duk_uint_t duk_get_uint_default(duk_context *ctx, duk_idx_t idx, duk_uint_t def_value);
__attribute__ ((visibility("default"))) extern const char *duk_get_string_default(duk_context *ctx, duk_idx_t idx, const char *def_value);
__attribute__ ((visibility("default"))) extern const char *duk_get_lstring_default(duk_context *ctx, duk_idx_t idx, duk_size_t *out_len, const char *def_ptr, duk_size_t def_len);
__attribute__ ((visibility("default"))) extern void *duk_get_buffer_default(duk_context *ctx, duk_idx_t idx, duk_size_t *out_size, void *def_ptr, duk_size_t def_len);
__attribute__ ((visibility("default"))) extern void *duk_get_buffer_data_default(duk_context *ctx, duk_idx_t idx, duk_size_t *out_size, void *def_ptr, duk_size_t def_len);
__attribute__ ((visibility("default"))) extern void *duk_get_pointer_default(duk_context *ctx, duk_idx_t idx, void *def_value);
__attribute__ ((visibility("default"))) extern duk_c_function duk_get_c_function_default(duk_context *ctx, duk_idx_t idx, duk_c_function def_value);
__attribute__ ((visibility("default"))) extern duk_context *duk_get_context_default(duk_context *ctx, duk_idx_t idx, duk_context *def_value);
__attribute__ ((visibility("default"))) extern void *duk_get_heapptr_default(duk_context *ctx, duk_idx_t idx, void *def_value);







__attribute__ ((visibility("default"))) extern duk_bool_t duk_opt_boolean(duk_context *ctx, duk_idx_t idx, duk_bool_t def_value);
__attribute__ ((visibility("default"))) extern duk_double_t duk_opt_number(duk_context *ctx, duk_idx_t idx, duk_double_t def_value);
__attribute__ ((visibility("default"))) extern duk_int_t duk_opt_int(duk_context *ctx, duk_idx_t idx, duk_int_t def_value);
__attribute__ ((visibility("default"))) extern duk_uint_t duk_opt_uint(duk_context *ctx, duk_idx_t idx, duk_uint_t def_value);
__attribute__ ((visibility("default"))) extern const char *duk_opt_string(duk_context *ctx, duk_idx_t idx, const char *def_ptr);
__attribute__ ((visibility("default"))) extern const char *duk_opt_lstring(duk_context *ctx, duk_idx_t idx, duk_size_t *out_len, const char *def_ptr, duk_size_t def_len);
__attribute__ ((visibility("default"))) extern void *duk_opt_buffer(duk_context *ctx, duk_idx_t idx, duk_size_t *out_size, void *def_ptr, duk_size_t def_size);
__attribute__ ((visibility("default"))) extern void *duk_opt_buffer_data(duk_context *ctx, duk_idx_t idx, duk_size_t *out_size, void *def_ptr, duk_size_t def_size);
__attribute__ ((visibility("default"))) extern void *duk_opt_pointer(duk_context *ctx, duk_idx_t idx, void *def_value);
__attribute__ ((visibility("default"))) extern duk_c_function duk_opt_c_function(duk_context *ctx, duk_idx_t idx, duk_c_function def_value);
__attribute__ ((visibility("default"))) extern duk_context *duk_opt_context(duk_context *ctx, duk_idx_t idx, duk_context *def_value);
__attribute__ ((visibility("default"))) extern void *duk_opt_heapptr(duk_context *ctx, duk_idx_t idx, void *def_value);
# 954 "duktape.h"
__attribute__ ((visibility("default"))) extern void duk_require_undefined(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_require_null(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_require_boolean(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_double_t duk_require_number(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_int_t duk_require_int(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_uint_t duk_require_uint(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern const char *duk_require_string(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern const char *duk_require_lstring(duk_context *ctx, duk_idx_t idx, duk_size_t *out_len);
__attribute__ ((visibility("default"))) extern void duk_require_object(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void *duk_require_buffer(duk_context *ctx, duk_idx_t idx, duk_size_t *out_size);
__attribute__ ((visibility("default"))) extern void *duk_require_buffer_data(duk_context *ctx, duk_idx_t idx, duk_size_t *out_size);
__attribute__ ((visibility("default"))) extern void *duk_require_pointer(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_c_function duk_require_c_function(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_context *duk_require_context(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_require_function(duk_context *ctx, duk_idx_t idx);


__attribute__ ((visibility("default"))) extern void duk_require_constructor_call(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_require_constructable(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void *duk_require_heapptr(duk_context *ctx, duk_idx_t idx);
# 993 "duktape.h"
__attribute__ ((visibility("default"))) extern void duk_to_undefined(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_to_null(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_to_boolean(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_double_t duk_to_number(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_int_t duk_to_int(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_uint_t duk_to_uint(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_int32_t duk_to_int32(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_uint32_t duk_to_uint32(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_uint16_t duk_to_uint16(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern const char *duk_to_string(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern const char *duk_to_lstring(duk_context *ctx, duk_idx_t idx, duk_size_t *out_len);
__attribute__ ((visibility("default"))) extern void *duk_to_buffer_raw(duk_context *ctx, duk_idx_t idx, duk_size_t *out_size, duk_uint_t flags);
__attribute__ ((visibility("default"))) extern void *duk_to_pointer(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_to_object(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_to_primitive(duk_context *ctx, duk_idx_t idx, duk_int_t hint);
# 1021 "duktape.h"
__attribute__ ((visibility("default"))) extern const char *duk_safe_to_lstring(duk_context *ctx, duk_idx_t idx, duk_size_t *out_len);
__attribute__ ((visibility("default"))) extern const char *duk_to_stacktrace(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern const char *duk_safe_to_stacktrace(duk_context *ctx, duk_idx_t idx);







__attribute__ ((visibility("default"))) extern duk_size_t duk_get_length(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_set_length(duk_context *ctx, duk_idx_t idx, duk_size_t len);
# 1042 "duktape.h"
__attribute__ ((visibility("default"))) extern const char *duk_base64_encode(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_base64_decode(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern const char *duk_hex_encode(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_hex_decode(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern const char *duk_json_encode(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_json_decode(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_cbor_encode(duk_context *ctx, duk_idx_t idx, duk_uint_t encode_flags);
__attribute__ ((visibility("default"))) extern void duk_cbor_decode(duk_context *ctx, duk_idx_t idx, duk_uint_t decode_flags);

__attribute__ ((visibility("default"))) extern const char *duk_buffer_to_string(duk_context *ctx, duk_idx_t idx);





__attribute__ ((visibility("default"))) extern void *duk_resize_buffer(duk_context *ctx, duk_idx_t idx, duk_size_t new_size);
__attribute__ ((visibility("default"))) extern void *duk_steal_buffer(duk_context *ctx, duk_idx_t idx, duk_size_t *out_size);
__attribute__ ((visibility("default"))) extern void duk_config_buffer(duk_context *ctx, duk_idx_t idx, void *ptr, duk_size_t len);
# 1071 "duktape.h"
__attribute__ ((visibility("default"))) extern duk_bool_t duk_get_prop(duk_context *ctx, duk_idx_t obj_idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_get_prop_string(duk_context *ctx, duk_idx_t obj_idx, const char *key);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_get_prop_lstring(duk_context *ctx, duk_idx_t obj_idx, const char *key, duk_size_t key_len);



__attribute__ ((visibility("default"))) extern duk_bool_t duk_get_prop_literal_raw(duk_context *ctx, duk_idx_t obj_idx, const char *key, duk_size_t key_len);


__attribute__ ((visibility("default"))) extern duk_bool_t duk_get_prop_index(duk_context *ctx, duk_idx_t obj_idx, duk_uarridx_t arr_idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_get_prop_heapptr(duk_context *ctx, duk_idx_t obj_idx, void *ptr);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_put_prop(duk_context *ctx, duk_idx_t obj_idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_put_prop_string(duk_context *ctx, duk_idx_t obj_idx, const char *key);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_put_prop_lstring(duk_context *ctx, duk_idx_t obj_idx, const char *key, duk_size_t key_len);



__attribute__ ((visibility("default"))) extern duk_bool_t duk_put_prop_literal_raw(duk_context *ctx, duk_idx_t obj_idx, const char *key, duk_size_t key_len);


__attribute__ ((visibility("default"))) extern duk_bool_t duk_put_prop_index(duk_context *ctx, duk_idx_t obj_idx, duk_uarridx_t arr_idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_put_prop_heapptr(duk_context *ctx, duk_idx_t obj_idx, void *ptr);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_del_prop(duk_context *ctx, duk_idx_t obj_idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_del_prop_string(duk_context *ctx, duk_idx_t obj_idx, const char *key);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_del_prop_lstring(duk_context *ctx, duk_idx_t obj_idx, const char *key, duk_size_t key_len);



__attribute__ ((visibility("default"))) extern duk_bool_t duk_del_prop_literal_raw(duk_context *ctx, duk_idx_t obj_idx, const char *key, duk_size_t key_len);


__attribute__ ((visibility("default"))) extern duk_bool_t duk_del_prop_index(duk_context *ctx, duk_idx_t obj_idx, duk_uarridx_t arr_idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_del_prop_heapptr(duk_context *ctx, duk_idx_t obj_idx, void *ptr);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_has_prop(duk_context *ctx, duk_idx_t obj_idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_has_prop_string(duk_context *ctx, duk_idx_t obj_idx, const char *key);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_has_prop_lstring(duk_context *ctx, duk_idx_t obj_idx, const char *key, duk_size_t key_len);



__attribute__ ((visibility("default"))) extern duk_bool_t duk_has_prop_literal_raw(duk_context *ctx, duk_idx_t obj_idx, const char *key, duk_size_t key_len);


__attribute__ ((visibility("default"))) extern duk_bool_t duk_has_prop_index(duk_context *ctx, duk_idx_t obj_idx, duk_uarridx_t arr_idx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_has_prop_heapptr(duk_context *ctx, duk_idx_t obj_idx, void *ptr);

__attribute__ ((visibility("default"))) extern void duk_get_prop_desc(duk_context *ctx, duk_idx_t obj_idx, duk_uint_t flags);
__attribute__ ((visibility("default"))) extern void duk_def_prop(duk_context *ctx, duk_idx_t obj_idx, duk_uint_t flags);

__attribute__ ((visibility("default"))) extern duk_bool_t duk_get_global_string(duk_context *ctx, const char *key);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_get_global_lstring(duk_context *ctx, const char *key, duk_size_t key_len);



__attribute__ ((visibility("default"))) extern duk_bool_t duk_get_global_literal_raw(duk_context *ctx, const char *key, duk_size_t key_len);


__attribute__ ((visibility("default"))) extern duk_bool_t duk_get_global_heapptr(duk_context *ctx, void *ptr);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_put_global_string(duk_context *ctx, const char *key);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_put_global_lstring(duk_context *ctx, const char *key, duk_size_t key_len);



__attribute__ ((visibility("default"))) extern duk_bool_t duk_put_global_literal_raw(duk_context *ctx, const char *key, duk_size_t key_len);


__attribute__ ((visibility("default"))) extern duk_bool_t duk_put_global_heapptr(duk_context *ctx, void *ptr);





__attribute__ ((visibility("default"))) extern void duk_inspect_value(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_inspect_callstack_entry(duk_context *ctx, duk_int_t level);





__attribute__ ((visibility("default"))) extern void duk_get_prototype(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_set_prototype(duk_context *ctx, duk_idx_t idx);





__attribute__ ((visibility("default"))) extern void duk_get_finalizer(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_set_finalizer(duk_context *ctx, duk_idx_t idx);





__attribute__ ((visibility("default"))) extern void duk_set_global_object(duk_context *ctx);





__attribute__ ((visibility("default"))) extern duk_int_t duk_get_magic(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern void duk_set_magic(duk_context *ctx, duk_idx_t idx, duk_int_t magic);
__attribute__ ((visibility("default"))) extern duk_int_t duk_get_current_magic(duk_context *ctx);





__attribute__ ((visibility("default"))) extern void duk_put_function_list(duk_context *ctx, duk_idx_t obj_idx, const duk_function_list_entry *funcs);
__attribute__ ((visibility("default"))) extern void duk_put_number_list(duk_context *ctx, duk_idx_t obj_idx, const duk_number_list_entry *numbers);





__attribute__ ((visibility("default"))) extern void duk_compact(duk_context *ctx, duk_idx_t obj_idx);
__attribute__ ((visibility("default"))) extern void duk_enum(duk_context *ctx, duk_idx_t obj_idx, duk_uint_t enum_flags);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_next(duk_context *ctx, duk_idx_t enum_idx, duk_bool_t get_value);
__attribute__ ((visibility("default"))) extern void duk_seal(duk_context *ctx, duk_idx_t obj_idx);
__attribute__ ((visibility("default"))) extern void duk_freeze(duk_context *ctx, duk_idx_t obj_idx);





__attribute__ ((visibility("default"))) extern void duk_concat(duk_context *ctx, duk_idx_t count);
__attribute__ ((visibility("default"))) extern void duk_join(duk_context *ctx, duk_idx_t count);
__attribute__ ((visibility("default"))) extern void duk_decode_string(duk_context *ctx, duk_idx_t idx, duk_decode_char_function callback, void *udata);
__attribute__ ((visibility("default"))) extern void duk_map_string(duk_context *ctx, duk_idx_t idx, duk_map_char_function callback, void *udata);
__attribute__ ((visibility("default"))) extern void duk_substring(duk_context *ctx, duk_idx_t idx, duk_size_t start_char_offset, duk_size_t end_char_offset);
__attribute__ ((visibility("default"))) extern void duk_trim(duk_context *ctx, duk_idx_t idx);
__attribute__ ((visibility("default"))) extern duk_codepoint_t duk_char_code_at(duk_context *ctx, duk_idx_t idx, duk_size_t char_offset);





__attribute__ ((visibility("default"))) extern duk_bool_t duk_equals(duk_context *ctx, duk_idx_t idx1, duk_idx_t idx2);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_strict_equals(duk_context *ctx, duk_idx_t idx1, duk_idx_t idx2);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_samevalue(duk_context *ctx, duk_idx_t idx1, duk_idx_t idx2);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_instanceof(duk_context *ctx, duk_idx_t idx1, duk_idx_t idx2);





__attribute__ ((visibility("default"))) extern duk_double_t duk_random(duk_context *ctx);





__attribute__ ((visibility("default"))) extern void duk_call(duk_context *ctx, duk_idx_t nargs);
__attribute__ ((visibility("default"))) extern void duk_call_method(duk_context *ctx, duk_idx_t nargs);
__attribute__ ((visibility("default"))) extern void duk_call_prop(duk_context *ctx, duk_idx_t obj_idx, duk_idx_t nargs);
__attribute__ ((visibility("default"))) extern duk_int_t duk_pcall(duk_context *ctx, duk_idx_t nargs);
__attribute__ ((visibility("default"))) extern duk_int_t duk_pcall_method(duk_context *ctx, duk_idx_t nargs);
__attribute__ ((visibility("default"))) extern duk_int_t duk_pcall_prop(duk_context *ctx, duk_idx_t obj_idx, duk_idx_t nargs);
__attribute__ ((visibility("default"))) extern void duk_new(duk_context *ctx, duk_idx_t nargs);
__attribute__ ((visibility("default"))) extern duk_int_t duk_pnew(duk_context *ctx, duk_idx_t nargs);
__attribute__ ((visibility("default"))) extern duk_int_t duk_safe_call(duk_context *ctx, duk_safe_call_function func, void *udata, duk_idx_t nargs, duk_idx_t nrets);
# 1243 "duktape.h"
__attribute__ ((visibility("default"))) extern duk_int_t duk_eval_raw(duk_context *ctx, const char *src_buffer, duk_size_t src_length, duk_uint_t flags);
__attribute__ ((visibility("default"))) extern duk_int_t duk_compile_raw(duk_context *ctx, const char *src_buffer, duk_size_t src_length, duk_uint_t flags);
# 1319 "duktape.h"
__attribute__ ((visibility("default"))) extern void duk_dump_function(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_load_function(duk_context *ctx);





__attribute__ ((visibility("default"))) extern void duk_push_context_dump(duk_context *ctx);





__attribute__ ((visibility("default"))) extern void duk_debugger_attach(duk_context *ctx,
                                           duk_debug_read_function read_cb,
                                           duk_debug_write_function write_cb,
                                           duk_debug_peek_function peek_cb,
                                           duk_debug_read_flush_function read_flush_cb,
                                           duk_debug_write_flush_function write_flush_cb,
                                           duk_debug_request_function request_cb,
                                           duk_debug_detached_function detached_cb,
                                           void *udata);
__attribute__ ((visibility("default"))) extern void duk_debugger_detach(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_debugger_cooperate(duk_context *ctx);
__attribute__ ((visibility("default"))) extern duk_bool_t duk_debugger_notify(duk_context *ctx, duk_idx_t nvalues);
__attribute__ ((visibility("default"))) extern void duk_debugger_pause(duk_context *ctx);





__attribute__ ((visibility("default"))) extern duk_double_t duk_get_now(duk_context *ctx);
__attribute__ ((visibility("default"))) extern void duk_time_to_components(duk_context *ctx, duk_double_t timeval, duk_time_components *comp);
__attribute__ ((visibility("default"))) extern duk_double_t duk_components_to_time(duk_context *ctx, duk_time_components *comp);
# 27 "duk_internal.h" 2
# 1 "duk_dblunion.h"
# 59 "duk_dblunion.h"
union duk_double_union {
 double d;
 float f[2];

 duk_uint64_t ull[1];

 duk_uint32_t ui[2];
 duk_uint16_t us[4];
 duk_uint8_t uc[8];



};

typedef union duk_double_union duk_double_union;
# 1 "duk_fltunion.h"
# 10 "duk_fltunion.h"
union duk_float_union {
 float f;
 duk_uint32_t ui[1];
 duk_uint16_t us[2];
 duk_uint8_t uc[4];
};

typedef union duk_float_union duk_float_union;
# 1 "duk_replacements.h"
# 1 "duk_jmpbuf.h"
# 19 "duk_jmpbuf.h"
struct duk_jmpbuf {
 jmp_buf jb;
};
# 1 "duk_exception.h"
# 1 "duk_forwdecl.h"
# 15 "duk_forwdecl.h"
struct duk_jmpbuf;



struct duk_heaphdr;
struct duk_heaphdr_string;
struct duk_harray;
struct duk_hstring;
struct duk_hstring_external;
struct duk_hobject;
struct duk_hcompfunc;
struct duk_hnatfunc;
struct duk_hboundfunc;
struct duk_hthread;
struct duk_hbufobj;
struct duk_hdecenv;
struct duk_hobjenv;
struct duk_hproxy;
struct duk_hbuffer;
struct duk_hbuffer_fixed;
struct duk_hbuffer_dynamic;
struct duk_hbuffer_external;

struct duk_propaccessor;
union duk_propvalue;
struct duk_propdesc;

struct duk_heap;
struct duk_breakpoint;

struct duk_activation;
struct duk_catcher;
struct duk_ljstate;
struct duk_strcache_entry;
struct duk_litcache_entry;
struct duk_strtab_entry;





struct duk_bitdecoder_ctx;
struct duk_bitencoder_ctx;
struct duk_bufwriter_ctx;

struct duk_token;
struct duk_re_token;
struct duk_lexer_point;
struct duk_lexer_ctx;
struct duk_lexer_codepoint;

struct duk_compiler_instr;
struct duk_compiler_func;
struct duk_compiler_ctx;

struct duk_re_matcher_ctx;
struct duk_re_compiler_ctx;




typedef struct duk_jmpbuf duk_jmpbuf;



typedef struct duk_heaphdr duk_heaphdr;
typedef struct duk_heaphdr_string duk_heaphdr_string;
typedef struct duk_harray duk_harray;
typedef struct duk_hstring duk_hstring;
typedef struct duk_hstring_external duk_hstring_external;
typedef struct duk_hobject duk_hobject;
typedef struct duk_hcompfunc duk_hcompfunc;
typedef struct duk_hnatfunc duk_hnatfunc;
typedef struct duk_hboundfunc duk_hboundfunc;
typedef struct duk_hthread duk_hthread;
typedef struct duk_hbufobj duk_hbufobj;
typedef struct duk_hdecenv duk_hdecenv;
typedef struct duk_hobjenv duk_hobjenv;
typedef struct duk_hproxy duk_hproxy;
typedef struct duk_hbuffer duk_hbuffer;
typedef struct duk_hbuffer_fixed duk_hbuffer_fixed;
typedef struct duk_hbuffer_dynamic duk_hbuffer_dynamic;
typedef struct duk_hbuffer_external duk_hbuffer_external;

typedef struct duk_propaccessor duk_propaccessor;
typedef union duk_propvalue duk_propvalue;
typedef struct duk_propdesc duk_propdesc;

typedef struct duk_heap duk_heap;
typedef struct duk_breakpoint duk_breakpoint;

typedef struct duk_activation duk_activation;
typedef struct duk_catcher duk_catcher;
typedef struct duk_ljstate duk_ljstate;
typedef struct duk_strcache_entry duk_strcache_entry;
typedef struct duk_litcache_entry duk_litcache_entry;
typedef struct duk_strtab_entry duk_strtab_entry;





typedef struct duk_bitdecoder_ctx duk_bitdecoder_ctx;
typedef struct duk_bitencoder_ctx duk_bitencoder_ctx;
typedef struct duk_bufwriter_ctx duk_bufwriter_ctx;

typedef struct duk_token duk_token;
typedef struct duk_re_token duk_re_token;
typedef struct duk_lexer_point duk_lexer_point;
typedef struct duk_lexer_ctx duk_lexer_ctx;
typedef struct duk_lexer_codepoint duk_lexer_codepoint;

typedef struct duk_compiler_instr duk_compiler_instr;
typedef struct duk_compiler_func duk_compiler_func;
typedef struct duk_compiler_ctx duk_compiler_ctx;

typedef struct duk_re_matcher_ctx duk_re_matcher_ctx;
typedef struct duk_re_compiler_ctx duk_re_compiler_ctx;
# 1 "duk_tval.h"
# 329 "duk_tval.h"
typedef struct duk_tval_struct duk_tval;

struct duk_tval_struct {
 duk_small_uint_t t;
 duk_small_uint_t v_extra;
 union {
  duk_double_t d;
  duk_small_int_t i;



  void *voidptr;
  duk_hstring *hstring;
  duk_hobject *hobject;
  duk_hcompfunc *hcompfunc;
  duk_hnatfunc *hnatfunc;
  duk_hthread *hthread;
  duk_hbuffer *hbuffer;
  duk_heaphdr *heaphdr;
  duk_c_function lightfunc;
 } v;
};

typedef struct {
 duk_small_uint_t t;
 duk_small_uint_t v_extra;





 duk_double_t d;
} duk_tval_unused;
# 1 "duk_builtins.h"
# 531 "duk_builtins.h"
static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_function_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_function_prototype(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_boolean_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_number_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_date_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_regexp_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_error_constructor_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_type_error_thrower(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_parse_int(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_parse_float(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_thread_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_pointer_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_proxy_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_symbol_constructor_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_arraybuffer_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_dataview_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_typedarray_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_textencoder_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_textdecoder_constructor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_eval(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_is_nan(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_is_finite(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_decode_uri(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_decode_uri_component(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_encode_uri(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_encode_uri_component(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_escape(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_unescape(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_getprototype_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_setprototype_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_get_own_property_descriptor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_keys_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_assign(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_create(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_define_property(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_define_properties(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_seal_freeze_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_prevent_extensions(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_is_sealed_frozen_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_is_extensible(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_is(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_to_string(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_to_locale_string(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_value_of(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_has_own_property(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_is_prototype_of(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_property_is_enumerable(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_defineaccessor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_lookupaccessor(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_function_prototype_to_string(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_function_prototype_apply(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_function_prototype_call(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_function_prototype_bind(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_function_prototype_hasinstance(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_native_function_length(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_native_function_name(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_constructor_is_array(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_to_string(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_join_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_concat(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_pop(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_push(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_reverse(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_shift(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_slice(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_sort(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_splice(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_unshift(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_indexof_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_iter_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_reduce_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_constructor_from_char_code(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_constructor_from_code_point(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_to_string(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_char_at(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_char_code_at(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_concat(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_indexof_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_locale_compare(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_match(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_replace(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_search(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_slice(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_split(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_substring(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_caseconv_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_trim(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_repeat(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_startswith_endswith(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_includes(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_substr(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_boolean_prototype_tostring_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_number_check_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_number_prototype_to_string(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_number_prototype_to_locale_string(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_number_prototype_value_of(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_number_prototype_to_fixed(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_number_prototype_to_exponential(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_number_prototype_to_precision(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_date_constructor_parse(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_date_constructor_utc(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_date_constructor_now(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_tostring_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_to_json(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_value_of(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_get_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_get_timezone_offset(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_set_time(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_set_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_toprimitive(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_regexp_prototype_exec(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_regexp_prototype_test(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_regexp_prototype_tostring(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_regexp_prototype_flags(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_regexp_prototype_shared_getter(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_stack_getter(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_stack_setter(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_filename_getter(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_filename_setter(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_linenumber_getter(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_linenumber_setter(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_to_string(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_onearg_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_twoarg_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_clz32(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_hypot(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_imul(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_max(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_min(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_random(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_sign(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_json_object_parse(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_json_object_stringify(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_info(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_act(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_gc(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_fin(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_enc(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_dec(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_compact(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_thread_yield(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_thread_resume(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_thread_current(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_pointer_prototype_tostring_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_reflect_apply(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_reflect_construct(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_reflect_object_delete_property(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_reflect_object_get(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_reflect_object_has(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_reflect_object_set(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_symbol_key_for(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_symbol_tostring_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_symbol_toprimitive(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_arraybuffer_isview(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_typedarray_bytelength_getter(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_buffer_slice_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_typedarray_byteoffset_getter(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_typedarray_buffer_getter(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_buffer_readfield(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_buffer_writefield(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_typedarray_set(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_uint8array_allocplain(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_uint8array_plainof(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_concat(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_is_encoding(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_is_buffer(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_byte_length(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_buffer_compare_shared(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_tostring(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_tojson(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_fill(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_copy(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_write(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_cbor_encode(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_cbor_decode(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_textencoder_prototype_encoding_getter(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_textencoder_prototype_encode(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_textdecoder_prototype_shared_getter(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_textdecoder_prototype_decode(duk_context *ctx);
static __attribute__ ((unused)) duk_ret_t duk_bi_performance_now(duk_context *ctx);
# 45 "duk_internal.h"
# 1 "duk_util.h"
# 39 "duk_util.h"
struct duk_bitdecoder_ctx {
 const duk_uint8_t *data;
 duk_size_t offset;
 duk_size_t length;
 duk_uint32_t currval;
 duk_small_int_t currbits;
};







struct duk_bitencoder_ctx {
 duk_uint8_t *data;
 duk_size_t offset;
 duk_size_t length;
 duk_uint32_t currval;
 duk_small_int_t currbits;
 duk_small_int_t truncated;
};
# 103 "duk_util.h"
static __attribute__ ((unused)) void duk_dblunion_host_to_little(duk_double_union *u);
static __attribute__ ((unused)) void duk_dblunion_little_to_host(duk_double_union *u);
static __attribute__ ((unused)) void duk_dblunion_host_to_big(duk_double_union *u);
static __attribute__ ((unused)) void duk_dblunion_big_to_host(duk_double_union *u);
static __attribute__ ((unused)) void duk_fltunion_host_to_big(duk_float_union *u);
static __attribute__ ((unused)) void duk_fltunion_big_to_host(duk_float_union *u);
# 135 "duk_util.h"
struct duk_bufwriter_ctx {
 duk_uint8_t *p;
 duk_uint8_t *p_base;
 duk_uint8_t *p_limit;
 duk_hbuffer_dynamic *buf;
};
# 546 "duk_util.h"
static __attribute__ ((unused)) duk_uint32_t duk_bd_decode(duk_bitdecoder_ctx *ctx, duk_small_int_t bits);
static __attribute__ ((unused)) duk_small_uint_t duk_bd_decode_flag(duk_bitdecoder_ctx *ctx);
static __attribute__ ((unused)) duk_uint32_t duk_bd_decode_flagged(duk_bitdecoder_ctx *ctx, duk_small_int_t bits, duk_uint32_t def_value);
static __attribute__ ((unused)) duk_int32_t duk_bd_decode_flagged_signed(duk_bitdecoder_ctx *ctx, duk_small_int_t bits, duk_int32_t def_value);
static __attribute__ ((unused)) duk_uint32_t duk_bd_decode_varuint(duk_bitdecoder_ctx *ctx);
static __attribute__ ((unused)) duk_small_uint_t duk_bd_decode_bitpacked_string(duk_bitdecoder_ctx *bd, duk_uint8_t *out);

static __attribute__ ((unused)) void duk_be_encode(duk_bitencoder_ctx *ctx, duk_uint32_t data, duk_small_int_t bits);
static __attribute__ ((unused)) void duk_be_finish(duk_bitencoder_ctx *ctx);


static __attribute__ ((unused)) duk_double_t duk_util_tinyrandom_get_double(duk_hthread *thr);
static __attribute__ ((unused)) void duk_util_tinyrandom_prepare_seed(duk_hthread *thr);


static __attribute__ ((unused)) void duk_bw_init(duk_hthread *thr, duk_bufwriter_ctx *bw_ctx, duk_hbuffer_dynamic *h_buf);
static __attribute__ ((unused)) void duk_bw_init_pushbuf(duk_hthread *thr, duk_bufwriter_ctx *bw_ctx, duk_size_t buf_size);
static __attribute__ ((unused)) duk_uint8_t *duk_bw_resize(duk_hthread *thr, duk_bufwriter_ctx *bw_ctx, duk_size_t sz);
static __attribute__ ((unused)) void duk_bw_compact(duk_hthread *thr, duk_bufwriter_ctx *bw_ctx);
static __attribute__ ((unused)) void duk_bw_write_raw_slice(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t src_off, duk_size_t len);
static __attribute__ ((unused)) void duk_bw_write_ensure_slice(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t src_off, duk_size_t len);
static __attribute__ ((unused)) void duk_bw_insert_raw_bytes(duk_hthread *thr,
                                               duk_bufwriter_ctx *bw,
                                               duk_size_t dst_off,
                                               const duk_uint8_t *buf,
                                               duk_size_t len);
static __attribute__ ((unused)) void duk_bw_insert_ensure_bytes(duk_hthread *thr,
                                                  duk_bufwriter_ctx *bw,
                                                  duk_size_t dst_off,
                                                  const duk_uint8_t *buf,
                                                  duk_size_t len);
static __attribute__ ((unused)) void duk_bw_insert_raw_slice(duk_hthread *thr,
                                               duk_bufwriter_ctx *bw,
                                               duk_size_t dst_off,
                                               duk_size_t src_off,
                                               duk_size_t len);
static __attribute__ ((unused)) void duk_bw_insert_ensure_slice(duk_hthread *thr,
                                                  duk_bufwriter_ctx *bw,
                                                  duk_size_t dst_off,
                                                  duk_size_t src_off,
                                                  duk_size_t len);
static __attribute__ ((unused)) duk_uint8_t *duk_bw_insert_raw_area(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t off, duk_size_t len);
static __attribute__ ((unused)) duk_uint8_t *duk_bw_insert_ensure_area(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t off, duk_size_t len);
static __attribute__ ((unused)) void duk_bw_remove_raw_slice(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t off, duk_size_t len);


static __attribute__ ((unused)) duk_uint16_t duk_raw_read_u16_be(const duk_uint8_t *p);
static __attribute__ ((unused)) duk_uint32_t duk_raw_read_u32_be(const duk_uint8_t *p);
static __attribute__ ((unused)) duk_float_t duk_raw_read_float_be(const duk_uint8_t *p);
static __attribute__ ((unused)) duk_double_t duk_raw_read_double_be(const duk_uint8_t *p);
static __attribute__ ((unused)) duk_uint16_t duk_raw_readinc_u16_be(const duk_uint8_t **p);
static __attribute__ ((unused)) duk_uint32_t duk_raw_readinc_u32_be(const duk_uint8_t **p);
static __attribute__ ((unused)) duk_float_t duk_raw_readinc_float_be(const duk_uint8_t **p);
static __attribute__ ((unused)) duk_double_t duk_raw_readinc_double_be(const duk_uint8_t **p);
static __attribute__ ((unused)) void duk_raw_write_u16_be(duk_uint8_t *p, duk_uint16_t val);
static __attribute__ ((unused)) void duk_raw_write_u32_be(duk_uint8_t *p, duk_uint32_t val);
static __attribute__ ((unused)) void duk_raw_write_float_be(duk_uint8_t *p, duk_float_t val);
static __attribute__ ((unused)) void duk_raw_write_double_be(duk_uint8_t *p, duk_double_t val);
static __attribute__ ((unused)) duk_small_int_t duk_raw_write_xutf8(duk_uint8_t *p, duk_ucodepoint_t val);
static __attribute__ ((unused)) duk_small_int_t duk_raw_write_cesu8(duk_uint8_t *p, duk_ucodepoint_t val);
static __attribute__ ((unused)) void duk_raw_writeinc_u16_be(duk_uint8_t **p, duk_uint16_t val);
static __attribute__ ((unused)) void duk_raw_writeinc_u32_be(duk_uint8_t **p, duk_uint32_t val);
static __attribute__ ((unused)) void duk_raw_writeinc_float_be(duk_uint8_t **p, duk_float_t val);
static __attribute__ ((unused)) void duk_raw_writeinc_double_be(duk_uint8_t **p, duk_double_t val);
static __attribute__ ((unused)) void duk_raw_writeinc_xutf8(duk_uint8_t **p, duk_ucodepoint_t val);
static __attribute__ ((unused)) void duk_raw_writeinc_cesu8(duk_uint8_t **p, duk_ucodepoint_t val);





static __attribute__ ((unused)) duk_double_t duk_util_get_random_double(duk_hthread *thr);
# 749 "duk_util.h"
static __attribute__ ((unused)) duk_small_int_t duk_memcmp(const void *s1, const void *s2, duk_size_t len);
static __attribute__ ((unused)) duk_small_int_t duk_memcmp_unsafe(const void *s1, const void *s2, duk_size_t len);

static __attribute__ ((unused)) duk_bool_t duk_is_whole_get_int32_nonegzero(duk_double_t x, duk_int32_t *ival);
static __attribute__ ((unused)) duk_bool_t duk_is_whole_get_int32(duk_double_t x, duk_int32_t *ival);
static __attribute__ ((unused)) duk_bool_t duk_double_is_anyinf(duk_double_t x);
static __attribute__ ((unused)) duk_bool_t duk_double_is_posinf(duk_double_t x);
static __attribute__ ((unused)) duk_bool_t duk_double_is_neginf(duk_double_t x);
static __attribute__ ((unused)) duk_bool_t duk_double_is_nan(duk_double_t x);
static __attribute__ ((unused)) duk_bool_t duk_double_is_nan_or_zero(duk_double_t x);
static __attribute__ ((unused)) duk_bool_t duk_double_is_nan_or_inf(duk_double_t x);
static __attribute__ ((unused)) duk_bool_t duk_double_is_nan_zero_inf(duk_double_t x);
static __attribute__ ((unused)) duk_small_uint_t duk_double_signbit(duk_double_t x);
static __attribute__ ((unused)) duk_double_t duk_double_trunc_towards_zero(duk_double_t x);
static __attribute__ ((unused)) duk_bool_t duk_double_same_sign(duk_double_t x, duk_double_t y);
static __attribute__ ((unused)) duk_double_t duk_double_fmin(duk_double_t x, duk_double_t y);
static __attribute__ ((unused)) duk_double_t duk_double_fmax(duk_double_t x, duk_double_t y);
static __attribute__ ((unused)) duk_bool_t duk_double_is_finite(duk_double_t x);
static __attribute__ ((unused)) duk_bool_t duk_double_is_integer(duk_double_t x);
static __attribute__ ((unused)) duk_bool_t duk_double_is_safe_integer(duk_double_t x);

static __attribute__ ((unused)) duk_double_t duk_double_div(duk_double_t x, duk_double_t y);
static __attribute__ ((unused)) duk_int_t duk_double_to_int_t(duk_double_t x);
static __attribute__ ((unused)) duk_uint_t duk_double_to_uint_t(duk_double_t x);
static __attribute__ ((unused)) duk_int32_t duk_double_to_int32_t(duk_double_t x);
static __attribute__ ((unused)) duk_uint32_t duk_double_to_uint32_t(duk_double_t x);
static __attribute__ ((unused)) duk_float_t duk_double_to_float_t(duk_double_t x);
static __attribute__ ((unused)) duk_bool_t duk_double_equals(duk_double_t x, duk_double_t y);
static __attribute__ ((unused)) duk_bool_t duk_float_equals(duk_float_t x, duk_float_t y);
# 1 "duk_strings.h"
# 1 "duk_js_bytecode.h"
# 84 "duk_js_bytecode.h"
typedef duk_uint32_t duk_instr_t;
# 1 "duk_lexer.h"







typedef void (*duk_re_range_callback)(void *user, duk_codepoint_t r1, duk_codepoint_t r2, duk_bool_t direct);
# 354 "duk_lexer.h"
struct duk_token {
 duk_small_uint_t t;
 duk_small_uint_t t_nores;
 duk_double_t num;
 duk_hstring *str1;
 duk_hstring *str2;
 duk_size_t start_offset;
 duk_int_t start_line;
 duk_int_t num_escapes;
 duk_bool_t lineterm;
 duk_bool_t allow_auto_semi;
};




struct duk_re_token {
 duk_small_uint_t t;
 duk_small_uint_t greedy;
 duk_uint32_t num;
 duk_uint32_t qmin;
 duk_uint32_t qmax;
};


struct duk_lexer_point {
 duk_size_t offset;
 duk_int_t line;
};


struct duk_lexer_codepoint {
 duk_codepoint_t codepoint;
 duk_size_t offset;
 duk_int_t line;
};


struct duk_lexer_ctx {

 duk_lexer_codepoint *window;
 duk_lexer_codepoint buffer[64];




 duk_hthread *thr;

 const duk_uint8_t *input;
 duk_size_t input_length;
 duk_size_t input_offset;
 duk_int_t input_line;

 duk_idx_t slot1_idx;
 duk_idx_t slot2_idx;
 duk_idx_t buf_idx;
 duk_hbuffer_dynamic *buf;
 duk_bufwriter_ctx bw;

 duk_int_t token_count;
 duk_int_t token_limit;

 duk_small_uint_t flags;
};





static __attribute__ ((unused)) void duk_lexer_initctx(duk_lexer_ctx *lex_ctx);

static __attribute__ ((unused)) void duk_lexer_getpoint(duk_lexer_ctx *lex_ctx, duk_lexer_point *pt);
static __attribute__ ((unused)) void duk_lexer_setpoint(duk_lexer_ctx *lex_ctx, duk_lexer_point *pt);

static __attribute__ ((unused))
void duk_lexer_parse_js_input_element(duk_lexer_ctx *lex_ctx, duk_token *out_token, duk_bool_t strict_mode, duk_bool_t regexp_mode);

static __attribute__ ((unused)) void duk_lexer_parse_re_token(duk_lexer_ctx *lex_ctx, duk_re_token *out_token);
static __attribute__ ((unused)) void duk_lexer_parse_re_ranges(duk_lexer_ctx *lex_ctx, duk_re_range_callback gen_range, void *userdata);
# 1 "duk_js_compiler.h"
# 44 "duk_js_compiler.h"
typedef duk_int32_t duk_regconst_t;

typedef struct {
 duk_small_uint_t t;
 duk_regconst_t regconst;
 duk_idx_t valstack_idx;
} duk_ispec;

typedef struct {
# 61 "duk_js_compiler.h"
 duk_small_uint_t t;
 duk_small_uint_t op;
 duk_ispec x1;
 duk_ispec x2;
} duk_ivalue;







struct duk_compiler_instr {
 duk_instr_t ins;

 duk_uint32_t line;

};
# 91 "duk_js_compiler.h"
typedef struct {
 duk_small_uint_t flags;
 duk_int_t label_id;
 duk_hstring *h_label;
 duk_int_t catch_depth;
 duk_int_t pc_label;
# 106 "duk_js_compiler.h"
} duk_labelinfo;


struct duk_compiler_func {





 duk_bufwriter_ctx bw_code;

 duk_hstring *h_name;

 duk_hobject *h_consts;
 duk_hobject *h_funcs;


 duk_hobject *h_decls;



 duk_hobject *h_labelnames;
 duk_hbuffer_dynamic *h_labelinfos;
 duk_hobject *h_argnames;
 duk_hobject *h_varmap;



 duk_idx_t consts_idx;
 duk_idx_t funcs_idx;
 duk_idx_t decls_idx;
 duk_idx_t labelnames_idx;
 duk_idx_t labelinfos_idx;
 duk_idx_t argnames_idx;
 duk_idx_t varmap_idx;


 duk_regconst_t temp_first;
 duk_regconst_t temp_next;
 duk_regconst_t temp_max;


 duk_regconst_t shuffle1;
 duk_regconst_t shuffle2;
 duk_regconst_t shuffle3;


 duk_int_t nud_count;
 duk_int_t led_count;
 duk_int_t paren_level;
 duk_bool_t expr_lhs;
 duk_bool_t allow_in;


 duk_int_t stmt_next;
 duk_int_t label_next;
 duk_int_t catch_depth;
 duk_int_t with_depth;
 duk_int_t fnum_next;
 duk_int_t num_formals;
 duk_regconst_t
     reg_stmt_value;






 duk_uint8_t is_function;
 duk_uint8_t is_eval;
 duk_uint8_t is_global;
 duk_uint8_t is_namebinding;
 duk_uint8_t is_constructable;
 duk_uint8_t is_setget;
 duk_uint8_t is_strict;
 duk_uint8_t is_notail;
 duk_uint8_t in_directive_prologue;
 duk_uint8_t in_scanning;
 duk_uint8_t may_direct_eval;
 duk_uint8_t id_access_arguments;
 duk_uint8_t id_access_slow;
 duk_uint8_t id_access_slow_own;
 duk_uint8_t is_arguments_shadowed;
 duk_uint8_t needs_shuffle;
 duk_uint8_t
     reject_regexp_in_adv;
 duk_uint8_t allow_regexp_in_adv;
};

struct duk_compiler_ctx {
 duk_hthread *thr;


 duk_hstring *h_filename;


 duk_lexer_ctx lex;


 duk_token prev_token;
 duk_token curr_token;
 duk_idx_t tok11_idx;
 duk_idx_t tok12_idx;
 duk_idx_t tok21_idx;
 duk_idx_t tok22_idx;


 duk_int_t recursion_depth;
 duk_int_t recursion_limit;


 duk_int_t emit_jumpslot_pc;


 duk_compiler_func curr_func;
};





static __attribute__ ((unused)) void duk_js_compile(duk_hthread *thr,
                                      const duk_uint8_t *src_buffer,
                                      duk_size_t src_length,
                                      duk_small_uint_t flags);
# 1 "duk_regexp.h"
# 43 "duk_regexp.h"
struct duk_re_matcher_ctx {
 duk_hthread *thr;

 duk_uint32_t re_flags;
 const duk_uint8_t *input;
 const duk_uint8_t *input_end;
 const duk_uint8_t *bytecode;
 const duk_uint8_t *bytecode_end;
 const duk_uint8_t **saved;
 duk_uint32_t nsaved;
 duk_uint32_t recursion_depth;
 duk_uint32_t recursion_limit;
 duk_uint32_t steps_count;
 duk_uint32_t steps_limit;
};

struct duk_re_compiler_ctx {
 duk_hthread *thr;

 duk_uint32_t re_flags;
 duk_lexer_ctx lex;
 duk_re_token curr_token;
 duk_bufwriter_ctx bw;
 duk_uint32_t captures;
 duk_uint32_t highest_backref;
 duk_uint32_t recursion_depth;
 duk_uint32_t recursion_limit;
 duk_uint32_t nranges;
};






static __attribute__ ((unused)) void duk_regexp_compile(duk_hthread *thr);
static __attribute__ ((unused)) void duk_regexp_create_instance(duk_hthread *thr);
static __attribute__ ((unused)) void duk_regexp_match(duk_hthread *thr);
static __attribute__ ((unused)) void duk_regexp_match_force_global(duk_hthread *thr);
# 1 "duk_heaphdr.h"
# 35 "duk_heaphdr.h"
struct duk_heaphdr {
 duk_uint32_t h_flags;
# 48 "duk_heaphdr.h"
 duk_uint32_t h_refcount;
# 57 "duk_heaphdr.h"
 duk_heaphdr *h_next;







 duk_heaphdr *h_prev;
# 80 "duk_heaphdr.h"
};

struct duk_heaphdr_string {






 duk_uint32_t h_flags;
# 102 "duk_heaphdr.h"
 duk_uint32_t h_refcount;







 duk_hstring *h_next;

};
# 1 "duk_refcount.h"
# 984 "duk_refcount.h"
static __attribute__ ((unused)) void duk_refzero_check_slow(duk_hthread *thr);
static __attribute__ ((unused)) void duk_refzero_check_fast(duk_hthread *thr);

static __attribute__ ((unused)) void duk_heaphdr_refcount_finalize_norz(duk_heap *heap, duk_heaphdr *hdr);
static __attribute__ ((unused)) void duk_hobject_refcount_finalize_norz(duk_heap *heap, duk_hobject *h);
# 997 "duk_refcount.h"
static __attribute__ ((unused)) void duk_heaphdr_refzero(duk_hthread *thr, duk_heaphdr *h);
static __attribute__ ((unused)) void duk_heaphdr_refzero_norz(duk_hthread *thr, duk_heaphdr *h);

static __attribute__ ((unused)) void duk_hstring_refzero(duk_hthread *thr, duk_hstring *h);
static __attribute__ ((unused)) void duk_hbuffer_refzero(duk_hthread *thr, duk_hbuffer *h);
static __attribute__ ((unused)) void duk_hobject_refzero(duk_hthread *thr, duk_hobject *h);
static __attribute__ ((unused)) void duk_hobject_refzero_norz(duk_hthread *thr, duk_hobject *h);
# 1 "duk_api_internal.h"
# 43 "duk_api_internal.h"
static __attribute__ ((unused)) void duk_valstack_grow_check_throw(duk_hthread *thr, duk_size_t min_bytes);
static __attribute__ ((unused)) duk_bool_t duk_valstack_grow_check_nothrow(duk_hthread *thr, duk_size_t min_bytes);
static __attribute__ ((unused)) void duk_valstack_shrink_check_nothrow(duk_hthread *thr, duk_bool_t snug);

static __attribute__ ((unused)) void duk_copy_tvals_incref(duk_hthread *thr, duk_tval *tv_dst, duk_tval *tv_src, duk_size_t count);

static __attribute__ ((unused)) duk_tval *duk_reserve_gap(duk_hthread *thr, duk_idx_t idx_base, duk_idx_t count);

static __attribute__ ((unused)) void duk_set_top_unsafe(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) void duk_set_top_and_wipe(duk_hthread *thr, duk_idx_t top, duk_idx_t idx_wipe_start);

static __attribute__ ((unused)) void duk_dup_0(duk_hthread *thr);
static __attribute__ ((unused)) void duk_dup_1(duk_hthread *thr);
static __attribute__ ((unused)) void duk_dup_2(duk_hthread *thr);

static __attribute__ ((unused)) void duk_dup_m2(duk_hthread *thr);
static __attribute__ ((unused)) void duk_dup_m3(duk_hthread *thr);
static __attribute__ ((unused)) void duk_dup_m4(duk_hthread *thr);

static __attribute__ ((unused)) void duk_remove_unsafe(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) void duk_remove_m2(duk_hthread *thr);
static __attribute__ ((unused)) void duk_remove_n(duk_hthread *thr, duk_idx_t idx, duk_idx_t count);
static __attribute__ ((unused)) void duk_remove_n_unsafe(duk_hthread *thr, duk_idx_t idx, duk_idx_t count);

static __attribute__ ((unused)) duk_int_t duk_get_type_tval(duk_tval *tv);
static __attribute__ ((unused)) duk_uint_t duk_get_type_mask_tval(duk_tval *tv);




static __attribute__ ((unused)) duk_small_uint_t duk_get_class_number(duk_hthread *thr, duk_idx_t idx);

static __attribute__ ((unused)) duk_tval *duk_get_tval(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_tval *duk_get_tval_or_unused(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_tval *duk_require_tval(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) void duk_push_tval(duk_hthread *thr, duk_tval *tv);




static __attribute__ ((unused)) void duk_push_this_check_object_coercible(duk_hthread *thr);


static __attribute__ ((unused)) duk_hobject *duk_push_this_coercible_to_object(duk_hthread *thr);


static __attribute__ ((unused)) duk_hstring *duk_push_this_coercible_to_string(duk_hthread *thr);

static __attribute__ ((unused)) duk_hstring *duk_push_uint_to_hstring(duk_hthread *thr, duk_uint_t i);





static __attribute__ ((unused)) duk_tval *duk_get_borrowed_this_tval(duk_hthread *thr);
# 112 "duk_api_internal.h"
static __attribute__ ((unused)) duk_bool_t duk_is_string_notsymbol(duk_hthread *thr, duk_idx_t idx);

static __attribute__ ((unused)) duk_bool_t duk_is_callable_tval(duk_hthread *thr, duk_tval *tv);

static __attribute__ ((unused)) duk_bool_t duk_is_bare_object(duk_hthread *thr, duk_idx_t idx);

static __attribute__ ((unused)) duk_hstring *duk_get_hstring(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hstring *duk_get_hstring_notsymbol(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) const char *duk_get_string_notsymbol(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hobject *duk_get_hobject(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hbuffer *duk_get_hbuffer(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hthread *duk_get_hthread(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hcompfunc *duk_get_hcompfunc(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hnatfunc *duk_get_hnatfunc(duk_hthread *thr, duk_idx_t idx);

static __attribute__ ((unused)) void *duk_get_buffer_data_raw(duk_hthread *thr,
                                                duk_idx_t idx,
                                                duk_size_t *out_size,
                                                void *def_ptr,
                                                duk_size_t def_len,
                                                duk_bool_t throw_flag,
                                                duk_bool_t *out_isbuffer);

static __attribute__ ((unused)) duk_hobject *duk_get_hobject_with_class(duk_hthread *thr, duk_idx_t idx, duk_small_uint_t classnum);

static __attribute__ ((unused)) duk_hobject *duk_get_hobject_promote_mask(duk_hthread *thr, duk_idx_t idx, duk_uint_t type_mask);
static __attribute__ ((unused)) duk_hobject *duk_require_hobject_promote_mask(duk_hthread *thr, duk_idx_t idx, duk_uint_t type_mask);
static __attribute__ ((unused)) duk_hobject *duk_require_hobject_accept_mask(duk_hthread *thr, duk_idx_t idx, duk_uint_t type_mask);







static __attribute__ ((unused)) duk_hstring *duk_known_hstring(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hobject *duk_known_hobject(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hbuffer *duk_known_hbuffer(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hcompfunc *duk_known_hcompfunc(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hnatfunc *duk_known_hnatfunc(duk_hthread *thr, duk_idx_t idx);

static __attribute__ ((unused)) duk_double_t duk_to_number_tval(duk_hthread *thr, duk_tval *tv);

static __attribute__ ((unused)) duk_hstring *duk_to_hstring(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hstring *duk_to_hstring_m1(duk_hthread *thr);
static __attribute__ ((unused)) duk_hstring *duk_to_hstring_acceptsymbol(duk_hthread *thr, duk_idx_t idx);

static __attribute__ ((unused)) duk_hobject *duk_to_hobject(duk_hthread *thr, duk_idx_t idx);

static __attribute__ ((unused)) duk_double_t duk_to_number_m1(duk_hthread *thr);
static __attribute__ ((unused)) duk_double_t duk_to_number_m2(duk_hthread *thr);

static __attribute__ ((unused)) duk_bool_t duk_to_boolean_top_pop(duk_hthread *thr);




static __attribute__ ((unused)) void duk_push_class_string_tval(duk_hthread *thr, duk_tval *tv, duk_bool_t avoid_side_effects);

static __attribute__ ((unused)) duk_int_t duk_to_int_clamped_raw(duk_hthread *thr,
                                                   duk_idx_t idx,
                                                   duk_int_t minval,
                                                   duk_int_t maxval,
                                                   duk_bool_t *out_clamped);
static __attribute__ ((unused)) duk_int_t duk_to_int_clamped(duk_hthread *thr, duk_idx_t idx, duk_int_t minval, duk_int_t maxval);
static __attribute__ ((unused)) duk_int_t duk_to_int_check_range(duk_hthread *thr, duk_idx_t idx, duk_int_t minval, duk_int_t maxval);

static __attribute__ ((unused)) duk_uint8_t duk_to_uint8clamped(duk_hthread *thr, duk_idx_t idx);

static __attribute__ ((unused)) duk_hstring *duk_to_property_key_hstring(duk_hthread *thr, duk_idx_t idx);

static __attribute__ ((unused)) duk_hstring *duk_require_hstring(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hstring *duk_require_hstring_notsymbol(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) const char *duk_require_lstring_notsymbol(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_len);
static __attribute__ ((unused)) const char *duk_require_string_notsymbol(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hobject *duk_require_hobject(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hbuffer *duk_require_hbuffer(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hthread *duk_require_hthread(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hcompfunc *duk_require_hcompfunc(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) duk_hnatfunc *duk_require_hnatfunc(duk_hthread *thr, duk_idx_t idx);

static __attribute__ ((unused)) duk_hobject *duk_require_hobject_with_class(duk_hthread *thr, duk_idx_t idx, duk_small_uint_t classnum);

static __attribute__ ((unused)) void duk_push_hstring(duk_hthread *thr, duk_hstring *h);
static __attribute__ ((unused)) void duk_push_hstring_stridx(duk_hthread *thr, duk_small_uint_t stridx);
static __attribute__ ((unused)) void duk_push_hstring_empty(duk_hthread *thr);
static __attribute__ ((unused)) void duk_push_hobject(duk_hthread *thr, duk_hobject *h);
static __attribute__ ((unused)) void duk_push_hbuffer(duk_hthread *thr, duk_hbuffer *h);


static __attribute__ ((unused)) void duk_push_hobject_bidx(duk_hthread *thr, duk_small_int_t builtin_idx);
static __attribute__ ((unused)) duk_hobject *duk_push_object_helper(duk_hthread *thr,
                                                      duk_uint_t hobject_flags_and_class,
                                                      duk_small_int_t prototype_bidx);
static __attribute__ ((unused)) duk_hobject *duk_push_object_helper_proto(duk_hthread *thr,
                                                            duk_uint_t hobject_flags_and_class,
                                                            duk_hobject *proto);
static __attribute__ ((unused)) duk_hcompfunc *duk_push_hcompfunc(duk_hthread *thr);
static __attribute__ ((unused)) duk_hboundfunc *duk_push_hboundfunc(duk_hthread *thr);
static __attribute__ ((unused)) void duk_push_c_function_builtin(duk_hthread *thr, duk_c_function func, duk_int_t nargs);
static __attribute__ ((unused)) void duk_push_c_function_builtin_noconstruct(duk_hthread *thr, duk_c_function func, duk_int_t nargs);




static __attribute__ ((unused)) duk_harray *duk_push_harray(duk_hthread *thr);
static __attribute__ ((unused)) duk_harray *duk_push_harray_with_size(duk_hthread *thr, duk_uint32_t size);
static __attribute__ ((unused)) duk_tval *duk_push_harray_with_size_outptr(duk_hthread *thr, duk_uint32_t size);

static __attribute__ ((unused)) void duk_push_string_funcptr(duk_hthread *thr, duk_uint8_t *ptr, duk_size_t sz);
static __attribute__ ((unused)) void duk_push_lightfunc_name_raw(duk_hthread *thr, duk_c_function func, duk_small_uint_t lf_flags);
static __attribute__ ((unused)) void duk_push_lightfunc_name(duk_hthread *thr, duk_tval *tv);
static __attribute__ ((unused)) void duk_push_lightfunc_tostring(duk_hthread *thr, duk_tval *tv);




static __attribute__ ((unused)) duk_hbufobj *duk_push_bufobj_raw(duk_hthread *thr,
                                                   duk_uint_t hobject_flags_and_class,
                                                   duk_small_int_t prototype_bidx);


static __attribute__ ((unused)) void *duk_push_fixed_buffer_nozero(duk_hthread *thr, duk_size_t len);
static __attribute__ ((unused)) void *duk_push_fixed_buffer_zero(duk_hthread *thr, duk_size_t len);

static __attribute__ ((unused)) const char *duk_push_string_readable(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) const char *duk_push_string_tval_readable(duk_hthread *thr, duk_tval *tv);
static __attribute__ ((unused)) const char *duk_push_string_tval_readable_error(duk_hthread *thr, duk_tval *tv);
# 248 "duk_api_internal.h"
static __attribute__ ((unused)) duk_bool_t duk_get_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx);
static __attribute__ ((unused)) duk_bool_t duk_get_prop_stridx_short_raw(duk_hthread *thr, duk_uint_t packed_args);




static __attribute__ ((unused)) duk_bool_t duk_get_prop_stridx_boolean(duk_hthread *thr,
                                                         duk_idx_t obj_idx,
                                                         duk_small_uint_t stridx,
                                                         duk_bool_t *out_has_prop);

static __attribute__ ((unused)) duk_bool_t duk_xget_owndataprop(duk_hthread *thr, duk_idx_t obj_idx);
static __attribute__ ((unused)) duk_bool_t duk_xget_owndataprop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx);
static __attribute__ ((unused)) duk_bool_t duk_xget_owndataprop_stridx_short_raw(duk_hthread *thr, duk_uint_t packed_args);





static __attribute__ ((unused)) duk_bool_t duk_put_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx);
static __attribute__ ((unused)) duk_bool_t duk_put_prop_stridx_short_raw(duk_hthread *thr, duk_uint_t packed_args);





static __attribute__ ((unused)) duk_bool_t duk_del_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx);
# 284 "duk_api_internal.h"
static __attribute__ ((unused)) duk_bool_t duk_has_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx);
# 294 "duk_api_internal.h"
static __attribute__ ((unused)) void duk_xdef_prop(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t desc_flags);

static __attribute__ ((unused)) void duk_xdef_prop_index(duk_hthread *thr,
                                           duk_idx_t obj_idx,
                                           duk_uarridx_t arr_idx,
                                           duk_small_uint_t desc_flags);




static __attribute__ ((unused)) void duk_xdef_prop_stridx(duk_hthread *thr,
                                            duk_idx_t obj_idx,
                                            duk_small_uint_t stridx,
                                            duk_small_uint_t desc_flags);
static __attribute__ ((unused)) void duk_xdef_prop_stridx_short_raw(duk_hthread *thr, duk_uint_t packed_args);
# 327 "duk_api_internal.h"
static __attribute__ ((unused)) void duk_xdef_prop_stridx_thrower(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx);

static __attribute__ ((unused)) duk_bool_t duk_get_method_stridx(duk_hthread *thr, duk_idx_t idx, duk_small_uint_t stridx);

static __attribute__ ((unused)) void duk_pack(duk_hthread *thr, duk_idx_t count);
static __attribute__ ((unused)) duk_idx_t duk_unpack_array_like(duk_hthread *thr, duk_idx_t idx);




static __attribute__ ((unused)) void duk_push_symbol_descriptive_string(duk_hthread *thr, duk_hstring *h);

static __attribute__ ((unused)) void duk_resolve_nonbound_function(duk_hthread *thr);

static __attribute__ ((unused)) duk_idx_t duk_get_top_require_min(duk_hthread *thr, duk_idx_t min_top);
static __attribute__ ((unused)) duk_idx_t duk_get_top_index_unsafe(duk_hthread *thr);

static __attribute__ ((unused)) void duk_pop_n_unsafe(duk_hthread *thr, duk_idx_t count);
static __attribute__ ((unused)) void duk_pop_unsafe(duk_hthread *thr);
static __attribute__ ((unused)) void duk_pop_2_unsafe(duk_hthread *thr);
static __attribute__ ((unused)) void duk_pop_3_unsafe(duk_hthread *thr);
static __attribute__ ((unused)) void duk_pop_n_nodecref_unsafe(duk_hthread *thr, duk_idx_t count);
static __attribute__ ((unused)) void duk_pop_nodecref_unsafe(duk_hthread *thr);
static __attribute__ ((unused)) void duk_pop_2_nodecref_unsafe(duk_hthread *thr);
static __attribute__ ((unused)) void duk_pop_3_nodecref_unsafe(duk_hthread *thr);
static __attribute__ ((unused)) void duk_pop_undefined(duk_hthread *thr);

static __attribute__ ((unused)) void duk_compact_m1(duk_hthread *thr);

static __attribute__ ((unused)) void duk_seal_freeze_raw(duk_hthread *thr, duk_idx_t obj_idx, duk_bool_t is_freeze);

static __attribute__ ((unused)) void duk_insert_undefined(duk_hthread *thr, duk_idx_t idx);
static __attribute__ ((unused)) void duk_insert_undefined_n(duk_hthread *thr, duk_idx_t idx, duk_idx_t count);

static __attribute__ ((unused)) void duk_concat_2(duk_hthread *thr);

static __attribute__ ((unused)) duk_int_t duk_pcall_method_flags(duk_hthread *thr, duk_idx_t nargs, duk_small_uint_t call_flags);


static __attribute__ ((unused)) void duk_to_primitive_ordinary(duk_hthread *thr, duk_idx_t idx, duk_int_t hint);


static __attribute__ ((unused)) void duk_clear_prototype(duk_hthread *thr, duk_idx_t idx);
# 389 "duk_api_internal.h"
static __attribute__ ((unused)) duk_double_t duk_time_get_ecmascript_time(duk_hthread *thr);
static __attribute__ ((unused)) duk_double_t duk_time_get_ecmascript_time_nofrac(duk_hthread *thr);
static __attribute__ ((unused)) duk_double_t duk_time_get_monotonic_time(duk_hthread *thr);
# 1 "duk_hstring.h"
# 192 "duk_hstring.h"
struct duk_hstring {





 duk_heaphdr_string hdr;





 duk_uint32_t hash;




 duk_uarridx_t arridx;






 duk_uint32_t blen;
# 227 "duk_hstring.h"
 duk_uint32_t clen;
# 236 "duk_hstring.h"
};


struct duk_hstring_external {
 duk_hstring str;







 const duk_uint8_t *extdata;
};





static __attribute__ ((unused)) duk_ucodepoint_t duk_hstring_char_code_at_raw(duk_hthread *thr,
                                                                duk_hstring *h,
                                                                duk_uint_t pos,
                                                                duk_bool_t surrogate_aware);
static __attribute__ ((unused)) duk_bool_t duk_hstring_equals_ascii_cstring(duk_hstring *h, const char *cstr);
static __attribute__ ((unused)) duk_size_t duk_hstring_get_charlen(duk_hstring *h);
# 1 "duk_hobject.h"
# 715 "duk_hobject.h"
struct duk_propaccessor {
 duk_hobject *get;
 duk_hobject *set;
};

union duk_propvalue {




 duk_tval v;
 duk_propaccessor a;
};

struct duk_propdesc {

 duk_small_uint_t flags;
 duk_hobject *get;
 duk_hobject *set;


 duk_int_t e_idx;
 duk_int_t h_idx;
 duk_int_t a_idx;
};

struct duk_hobject {
 duk_heaphdr hdr;
# 815 "duk_hobject.h"
 duk_uint8_t *props;






 duk_hobject *prototype;
# 833 "duk_hobject.h"
 duk_uint32_t e_size;
 duk_uint32_t e_next;
 duk_uint32_t a_size;

 duk_uint32_t h_size;


};
# 855 "duk_hobject.h"
static __attribute__ ((unused)) duk_hobject *duk_hobject_alloc_unchecked(duk_heap *heap, duk_uint_t hobject_flags);
static __attribute__ ((unused)) duk_hobject *duk_hobject_alloc(duk_hthread *thr, duk_uint_t hobject_flags);
static __attribute__ ((unused)) duk_harray *duk_harray_alloc(duk_hthread *thr, duk_uint_t hobject_flags);
static __attribute__ ((unused)) duk_hcompfunc *duk_hcompfunc_alloc(duk_hthread *thr, duk_uint_t hobject_flags);
static __attribute__ ((unused)) duk_hnatfunc *duk_hnatfunc_alloc(duk_hthread *thr, duk_uint_t hobject_flags);
static __attribute__ ((unused)) duk_hboundfunc *duk_hboundfunc_alloc(duk_heap *heap, duk_uint_t hobject_flags);

static __attribute__ ((unused)) duk_hbufobj *duk_hbufobj_alloc(duk_hthread *thr, duk_uint_t hobject_flags);

static __attribute__ ((unused)) duk_hthread *duk_hthread_alloc_unchecked(duk_heap *heap, duk_uint_t hobject_flags);
static __attribute__ ((unused)) duk_hthread *duk_hthread_alloc(duk_hthread *thr, duk_uint_t hobject_flags);
static __attribute__ ((unused)) duk_hdecenv *duk_hdecenv_alloc(duk_hthread *thr, duk_uint_t hobject_flags);
static __attribute__ ((unused)) duk_hobjenv *duk_hobjenv_alloc(duk_hthread *thr, duk_uint_t hobject_flags);
static __attribute__ ((unused)) duk_hproxy *duk_hproxy_alloc(duk_hthread *thr, duk_uint_t hobject_flags);


static __attribute__ ((unused)) void duk_hobject_realloc_props(duk_hthread *thr,
                                                 duk_hobject *obj,
                                                 duk_uint32_t new_e_size,
                                                 duk_uint32_t new_a_size,
                                                 duk_uint32_t new_h_size,
                                                 duk_bool_t abandon_array);
static __attribute__ ((unused)) void duk_hobject_resize_entrypart(duk_hthread *thr, duk_hobject *obj, duk_uint32_t new_e_size);







static __attribute__ ((unused)) duk_bool_t
duk_hobject_find_entry(duk_heap *heap, duk_hobject *obj, duk_hstring *key, duk_int_t *e_idx, duk_int_t *h_idx);
static __attribute__ ((unused)) duk_tval *duk_hobject_find_entry_tval_ptr(duk_heap *heap, duk_hobject *obj, duk_hstring *key);
static __attribute__ ((unused)) duk_tval *duk_hobject_find_entry_tval_ptr_stridx(duk_heap *heap, duk_hobject *obj, duk_small_uint_t stridx);
static __attribute__ ((unused)) duk_tval *duk_hobject_find_entry_tval_ptr_and_attrs(duk_heap *heap,
                                                                      duk_hobject *obj,
                                                                      duk_hstring *key,
                                                                      duk_uint_t *out_attrs);
static __attribute__ ((unused)) duk_tval *duk_hobject_find_array_entry_tval_ptr(duk_heap *heap, duk_hobject *obj, duk_uarridx_t i);
static __attribute__ ((unused)) duk_bool_t
duk_hobject_get_own_propdesc(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *out_desc, duk_small_uint_t flags);


static __attribute__ ((unused)) duk_bool_t duk_hobject_getprop(duk_hthread *thr, duk_tval *tv_obj, duk_tval *tv_key);
static __attribute__ ((unused)) duk_bool_t
duk_hobject_putprop(duk_hthread *thr, duk_tval *tv_obj, duk_tval *tv_key, duk_tval *tv_val, duk_bool_t throw_flag);
static __attribute__ ((unused)) duk_bool_t duk_hobject_delprop(duk_hthread *thr, duk_tval *tv_obj, duk_tval *tv_key, duk_bool_t throw_flag);
static __attribute__ ((unused)) duk_bool_t duk_hobject_hasprop(duk_hthread *thr, duk_tval *tv_obj, duk_tval *tv_key);




static __attribute__ ((unused)) duk_bool_t duk_hobject_delprop_raw(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_small_uint_t flags);
static __attribute__ ((unused)) duk_bool_t duk_hobject_hasprop_raw(duk_hthread *thr, duk_hobject *obj, duk_hstring *key);
static __attribute__ ((unused)) void duk_hobject_define_property_internal(duk_hthread *thr,
                                                            duk_hobject *obj,
                                                            duk_hstring *key,
                                                            duk_small_uint_t flags);
static __attribute__ ((unused)) void duk_hobject_define_property_internal_arridx(duk_hthread *thr,
                                                                   duk_hobject *obj,
                                                                   duk_uarridx_t arr_idx,
                                                                   duk_small_uint_t flags);
static __attribute__ ((unused)) duk_size_t duk_hobject_get_length(duk_hthread *thr, duk_hobject *obj);



static __attribute__ ((unused)) duk_bool_t duk_hobject_has_finalizer_fast_raw(duk_hobject *obj);



static __attribute__ ((unused)) void duk_hobject_prepare_property_descriptor(duk_hthread *thr,
                                                               duk_idx_t idx_in,
                                                               duk_uint_t *out_defprop_flags,
                                                               duk_idx_t *out_idx_value,
                                                               duk_hobject **out_getter,
                                                               duk_hobject **out_setter);
static __attribute__ ((unused)) duk_bool_t duk_hobject_define_property_helper(duk_hthread *thr,
                                                                duk_uint_t defprop_flags,
                                                                duk_hobject *obj,
                                                                duk_hstring *key,
                                                                duk_idx_t idx_value,
                                                                duk_hobject *get,
                                                                duk_hobject *set,
                                                                duk_bool_t throw_flag);


static __attribute__ ((unused)) void duk_hobject_object_get_own_property_descriptor(duk_hthread *thr, duk_idx_t obj_idx);
static __attribute__ ((unused)) void duk_hobject_object_seal_freeze_helper(duk_hthread *thr, duk_hobject *obj, duk_bool_t is_freeze);
static __attribute__ ((unused)) duk_bool_t duk_hobject_object_is_sealed_frozen_helper(duk_hthread *thr, duk_hobject *obj, duk_bool_t is_frozen);
static __attribute__ ((unused)) duk_bool_t duk_hobject_object_ownprop_helper(duk_hthread *thr, duk_small_uint_t required_desc_flags);


static __attribute__ ((unused)) duk_tval *duk_hobject_get_internal_value_tval_ptr(duk_heap *heap, duk_hobject *obj);
static __attribute__ ((unused)) duk_hstring *duk_hobject_get_internal_value_string(duk_heap *heap, duk_hobject *obj);
static __attribute__ ((unused)) duk_harray *duk_hobject_get_formals(duk_hthread *thr, duk_hobject *obj);
static __attribute__ ((unused)) duk_hobject *duk_hobject_get_varmap(duk_hthread *thr, duk_hobject *obj);


static __attribute__ ((unused)) void duk_hobject_compact_props(duk_hthread *thr, duk_hobject *obj);



static __attribute__ ((unused)) duk_bool_t duk_hobject_proxy_check(duk_hobject *obj, duk_hobject **out_target, duk_hobject **out_handler);
static __attribute__ ((unused)) duk_hobject *duk_hobject_resolve_proxy_target(duk_hobject *obj);



static __attribute__ ((unused)) void duk_hobject_enumerator_create(duk_hthread *thr, duk_small_uint_t enum_flags);
static __attribute__ ((unused)) duk_ret_t duk_hobject_get_enumerated_keys(duk_hthread *thr, duk_small_uint_t enum_flags);
static __attribute__ ((unused)) duk_bool_t duk_hobject_enumerator_next(duk_hthread *thr, duk_bool_t get_value);


static __attribute__ ((unused)) void duk_hobject_set_prototype_updref(duk_hthread *thr, duk_hobject *h, duk_hobject *p);



static __attribute__ ((unused)) void duk_hobject_pc2line_pack(duk_hthread *thr, duk_compiler_instr *instrs, duk_uint_fast32_t length);
static __attribute__ ((unused)) duk_uint_fast32_t duk_hobject_pc2line_query(duk_hthread *thr, duk_idx_t idx_func, duk_uint_fast32_t pc);



static __attribute__ ((unused)) duk_bool_t duk_hobject_prototype_chain_contains(duk_hthread *thr,
                                                                  duk_hobject *h,
                                                                  duk_hobject *p,
                                                                  duk_bool_t ignore_loop);
# 1 "duk_hcompfunc.h"
# 131 "duk_hcompfunc.h"
struct duk_hcompfunc {

 duk_hobject obj;
# 160 "duk_hcompfunc.h"
 duk_hbuffer *data;
# 174 "duk_hcompfunc.h"
 duk_hobject **funcs;
 duk_instr_t *bytecode;
# 185 "duk_hcompfunc.h"
 duk_hobject *lex_env;
 duk_hobject *var_env;
# 211 "duk_hcompfunc.h"
 duk_uint16_t nregs;
 duk_uint16_t nargs;
# 257 "duk_hcompfunc.h"
};
# 1 "duk_hnatfunc.h"
# 23 "duk_hnatfunc.h"
struct duk_hnatfunc {

 duk_hobject obj;

 duk_c_function func;
 duk_int16_t nargs;
 duk_int16_t magic;
# 42 "duk_hnatfunc.h"
};
# 1 "duk_hboundfunc.h"
# 25 "duk_hboundfunc.h"
struct duk_hboundfunc {

 duk_hobject obj;




 duk_tval target;


 duk_tval this_binding;


 duk_tval *args;
 duk_idx_t nargs;
};
# 1 "duk_hbufobj.h"
# 85 "duk_hbufobj.h"
struct duk_hbufobj {

 duk_hobject obj;


 duk_hbuffer *buf;


 duk_hobject *buf_prop;
# 108 "duk_hbufobj.h"
 duk_uint_t offset;
 duk_uint_t length;
 duk_uint8_t shift;





 duk_uint8_t elem_type;
 duk_uint8_t is_typedarray;
};

static __attribute__ ((unused)) duk_uint_t duk_hbufobj_clamp_bytelength(duk_hbufobj *h_bufobj, duk_uint_t len);
static __attribute__ ((unused)) void duk_hbufobj_push_uint8array_from_plain(duk_hthread *thr, duk_hbuffer *h_buf);
static __attribute__ ((unused)) void duk_hbufobj_push_validated_read(duk_hthread *thr,
                                                       duk_hbufobj *h_bufobj,
                                                       duk_uint8_t *p,
                                                       duk_small_uint_t elem_size);
static __attribute__ ((unused)) void duk_hbufobj_validated_write(duk_hthread *thr,
                                                   duk_hbufobj *h_bufobj,
                                                   duk_uint8_t *p,
                                                   duk_small_uint_t elem_size);
static __attribute__ ((unused)) void duk_hbufobj_promote_plain(duk_hthread *thr, duk_idx_t idx);
# 1 "duk_hthread.h"
# 206 "duk_hthread.h"
struct duk_activation {
 duk_tval tv_func;
 duk_hobject *func;

 duk_activation *parent;
 duk_hobject *var_env;
 duk_hobject *lex_env;
 duk_catcher *cat;
# 222 "duk_hthread.h"
 duk_instr_t *curr_pc;
# 235 "duk_hthread.h"
 duk_size_t bottom_byteoff;
# 247 "duk_hthread.h"
 duk_size_t retval_byteoff;
# 259 "duk_hthread.h"
 duk_size_t reserve_byteoff;





 duk_small_uint_t flags;
};

struct duk_catcher {
 duk_catcher *parent;
 duk_hstring *h_varname;

 duk_instr_t *pc_base;
 duk_size_t idx_base;
 duk_uint32_t flags;



};

struct duk_hthread {

 duk_hobject obj;






 duk_instr_t **ptr_curr_pc;


 duk_heap *heap;


 duk_uint8_t strict;


 duk_uint8_t state;
 duk_uint8_t unused1;
 duk_uint8_t unused2;
# 332 "duk_hthread.h"
 duk_tval *valstack;
 duk_tval *valstack_end;
 duk_tval *valstack_alloc_end;
 duk_tval *valstack_bottom;
 duk_tval *valstack_top;




 duk_activation *callstack_curr;
 duk_size_t callstack_top;
 duk_size_t callstack_preventcount;


 duk_hthread *resumer;


 duk_compiler_ctx *compile_ctx;
# 374 "duk_hthread.h"
 duk_hobject *builtins[51];
# 383 "duk_hthread.h"
 duk_hstring **strs;


};





static __attribute__ ((unused)) void duk_hthread_copy_builtin_objects(duk_hthread *thr_from, duk_hthread *thr_to);
static __attribute__ ((unused)) void duk_hthread_create_builtin_objects(duk_hthread *thr);
static __attribute__ ((unused)) duk_bool_t duk_hthread_init_stacks(duk_heap *heap, duk_hthread *thr);
static __attribute__ ((unused)) void duk_hthread_terminate(duk_hthread *thr);

static __attribute__ ((unused)) duk_activation *duk_hthread_activation_alloc(duk_hthread *thr);
static __attribute__ ((unused)) void duk_hthread_activation_free(duk_hthread *thr, duk_activation *act);
static __attribute__ ((unused)) void duk_hthread_activation_unwind_norz(duk_hthread *thr);
static __attribute__ ((unused)) void duk_hthread_activation_unwind_reuse_norz(duk_hthread *thr);
static __attribute__ ((unused)) duk_activation *duk_hthread_get_activation_for_level(duk_hthread *thr, duk_int_t level);

static __attribute__ ((unused)) duk_catcher *duk_hthread_catcher_alloc(duk_hthread *thr);
static __attribute__ ((unused)) void duk_hthread_catcher_free(duk_hthread *thr, duk_catcher *cat);
static __attribute__ ((unused)) void duk_hthread_catcher_unwind_norz(duk_hthread *thr, duk_activation *act);
static __attribute__ ((unused)) void duk_hthread_catcher_unwind_nolexenv_norz(duk_hthread *thr, duk_activation *act);





static __attribute__ ((unused)) void *duk_hthread_get_valstack_ptr(duk_heap *heap, void *ud);




static __attribute__ ((unused)) duk_uint_fast32_t duk_hthread_get_act_prev_pc(duk_hthread *thr, duk_activation *act);
static __attribute__ ((unused)) void duk_hthread_sync_currpc(duk_hthread *thr);
static __attribute__ ((unused)) void duk_hthread_sync_and_null_currpc(duk_hthread *thr);
# 1 "duk_harray.h"
# 35 "duk_harray.h"
struct duk_harray {

 duk_hobject obj;







 duk_uint32_t length;
# 56 "duk_harray.h"
 duk_bool_t length_nonwritable;
};
# 1 "duk_henv.h"
# 28 "duk_henv.h"
struct duk_hdecenv {

 duk_hobject obj;





 duk_hthread *thread;
 duk_hobject *varmap;
 duk_size_t regbase_byteoff;
};

struct duk_hobjenv {

 duk_hobject obj;


 duk_hobject *target;





 duk_bool_t has_this;
};
# 1 "duk_hbuffer.h"
# 189 "duk_hbuffer.h"
struct duk_hbuffer {
 duk_heaphdr hdr;
# 200 "duk_hbuffer.h"
 duk_size_t size;
# 227 "duk_hbuffer.h"
};







struct duk_hbuffer_fixed {






 union {
  struct {
   duk_heaphdr hdr;



   duk_size_t size;

  } s;



  duk_double_t dummy_for_align8_1;

  duk_uint64_t dummy_for_align8_2;






 } u;
# 277 "duk_hbuffer.h"
}

__attribute__((aligned(8)))



;
# 292 "duk_hbuffer.h"
struct duk_hbuffer_dynamic {
 duk_heaphdr hdr;




 duk_size_t size;





 void *curr_alloc;
# 315 "duk_hbuffer.h"
};





struct duk_hbuffer_external {
 duk_heaphdr hdr;




 duk_size_t size;





 void *curr_alloc;
};





static __attribute__ ((unused)) duk_hbuffer *duk_hbuffer_alloc(duk_heap *heap, duk_size_t size, duk_small_uint_t flags, void **out_bufdata);
static __attribute__ ((unused)) void *duk_hbuffer_get_dynalloc_ptr(duk_heap *heap, void *ud);


static __attribute__ ((unused)) void duk_hbuffer_resize(duk_hthread *thr, duk_hbuffer_dynamic *buf, duk_size_t new_size);
static __attribute__ ((unused)) void duk_hbuffer_reset(duk_hthread *thr, duk_hbuffer_dynamic *buf);
# 1 "duk_hproxy.h"
# 20 "duk_hproxy.h"
struct duk_hproxy {

 duk_hobject obj;


 duk_hobject *target;


 duk_hobject *handler;
};
# 1 "duk_heap.h"
# 225 "duk_heap.h"
typedef void *(*duk_mem_getptr)(duk_heap *heap, void *ud);
# 289 "duk_heap.h"
struct duk_breakpoint {
 duk_hstring *filename;
 duk_uint32_t line;
};
# 303 "duk_heap.h"
struct duk_strcache_entry {
 duk_hstring *h;
 duk_uint32_t bidx;
 duk_uint32_t cidx;
};






struct duk_ljstate {
 duk_jmpbuf *jmpbuf_ptr;
 duk_small_uint_t type;
 duk_bool_t iserror;
 duk_tval value1;
 duk_tval value2;
};
# 340 "duk_heap.h"
struct duk_litcache_entry {
 const duk_uint8_t *addr;
 duk_hstring *h;
};
# 361 "duk_heap.h"
struct duk_heap {
 duk_small_uint_t flags;


 duk_alloc_function alloc_func;
 duk_realloc_function realloc_func;
 duk_free_function free_func;




 void *heap_udata;






 duk_fatal_function fatal_func;





 duk_heaphdr *heap_allocated;
# 394 "duk_heap.h"
 duk_heaphdr *refzero_list;




 duk_heaphdr *finalize_list;
# 408 "duk_heap.h"
 duk_activation *activation_free;


 duk_catcher *catcher_free;







 duk_int_t ms_trigger_counter;





 duk_uint_t ms_recursion_depth;


 duk_small_uint_t ms_base_flags;
# 438 "duk_heap.h"
 duk_uint_t ms_running;







 duk_uint_t ms_prevent_count;






 duk_uint_t pf_prevent_count;






 duk_uint_t pf_skip_finalizers;
# 480 "duk_heap.h"
 duk_bool_t creating_error;






 duk_bool_t augmenting_error;



 duk_ljstate lj;


 duk_hthread *heap_thread;


 duk_hthread *curr_thread;


 duk_hobject *heap_object;


 duk_int_t call_recursion_depth;
 duk_int_t call_recursion_limit;


 duk_uint32_t hash_seed;






 duk_uint64_t rnd_state[2];
# 523 "duk_heap.h"
 duk_uint32_t sym_counter[2];
# 579 "duk_heap.h"
 duk_hstring **strtable;

 duk_uint32_t st_mask;
 duk_uint32_t st_size;

 duk_uint32_t st_count;

 duk_bool_t st_resizing;




 duk_strcache_entry strcache[4];






 duk_litcache_entry litcache[256];
# 608 "duk_heap.h"
 duk_hstring *strs[167];
# 664 "duk_heap.h"
};





static __attribute__ ((unused))
duk_heap *duk_heap_alloc(duk_alloc_function alloc_func,
                         duk_realloc_function realloc_func,
                         duk_free_function free_func,
                         void *heap_udata,
                         duk_fatal_function fatal_func);
static __attribute__ ((unused)) void duk_heap_free(duk_heap *heap);
static __attribute__ ((unused)) void duk_free_hobject(duk_heap *heap, duk_hobject *h);
static __attribute__ ((unused)) void duk_free_hbuffer(duk_heap *heap, duk_hbuffer *h);
static __attribute__ ((unused)) void duk_free_hstring(duk_heap *heap, duk_hstring *h);
static __attribute__ ((unused)) void duk_heap_free_heaphdr_raw(duk_heap *heap, duk_heaphdr *hdr);

static __attribute__ ((unused)) void duk_heap_insert_into_heap_allocated(duk_heap *heap, duk_heaphdr *hdr);

static __attribute__ ((unused)) void duk_heap_remove_from_heap_allocated(duk_heap *heap, duk_heaphdr *hdr);


static __attribute__ ((unused)) void duk_heap_insert_into_finalize_list(duk_heap *heap, duk_heaphdr *hdr);
static __attribute__ ((unused)) void duk_heap_remove_from_finalize_list(duk_heap *heap, duk_heaphdr *hdr);
# 697 "duk_heap.h"
static __attribute__ ((unused)) duk_hstring *duk_heap_strtable_intern(duk_heap *heap, const duk_uint8_t *str, duk_uint32_t blen);
static __attribute__ ((unused)) duk_hstring *duk_heap_strtable_intern_checked(duk_hthread *thr, const duk_uint8_t *str, duk_uint32_t len);

static __attribute__ ((unused)) duk_hstring *duk_heap_strtable_intern_literal_checked(duk_hthread *thr,
                                                                        const duk_uint8_t *str,
                                                                        duk_uint32_t blen);

static __attribute__ ((unused)) duk_hstring *duk_heap_strtable_intern_u32(duk_heap *heap, duk_uint32_t val);
static __attribute__ ((unused)) duk_hstring *duk_heap_strtable_intern_u32_checked(duk_hthread *thr, duk_uint32_t val);

static __attribute__ ((unused)) void duk_heap_strtable_unlink(duk_heap *heap, duk_hstring *h);

static __attribute__ ((unused)) void duk_heap_strtable_unlink_prev(duk_heap *heap, duk_hstring *h, duk_hstring *prev);
static __attribute__ ((unused)) void duk_heap_strtable_force_resize(duk_heap *heap);
static __attribute__ ((unused)) void duk_heap_strtable_free(duk_heap *heap);




static __attribute__ ((unused)) void duk_heap_strcache_string_remove(duk_heap *heap, duk_hstring *h);
static __attribute__ ((unused)) duk_uint_fast32_t duk_heap_strcache_offset_char2byte(duk_hthread *thr,
                                                                       duk_hstring *h,
                                                                       duk_uint_fast32_t char_offset);


static __attribute__ ((unused)) void *duk_default_alloc_function(void *udata, duk_size_t size);
static __attribute__ ((unused)) void *duk_default_realloc_function(void *udata, void *ptr, duk_size_t newsize);
static __attribute__ ((unused)) void duk_default_free_function(void *udata, void *ptr);


static __attribute__ ((unused)) void *duk_heap_mem_alloc(duk_heap *heap, duk_size_t size);
static __attribute__ ((unused)) void *duk_heap_mem_alloc_zeroed(duk_heap *heap, duk_size_t size);
static __attribute__ ((unused)) void *duk_heap_mem_alloc_checked(duk_hthread *thr, duk_size_t size);
static __attribute__ ((unused)) void *duk_heap_mem_alloc_checked_zeroed(duk_hthread *thr, duk_size_t size);
static __attribute__ ((unused)) void *duk_heap_mem_realloc(duk_heap *heap, void *ptr, duk_size_t newsize);
static __attribute__ ((unused)) void *duk_heap_mem_realloc_indirect(duk_heap *heap, duk_mem_getptr cb, void *ud, duk_size_t newsize);
static __attribute__ ((unused)) void duk_heap_mem_free(duk_heap *heap, void *ptr);

static __attribute__ ((unused)) void duk_heap_free_freelists(duk_heap *heap);


static __attribute__ ((unused)) void duk_heap_run_finalizer(duk_heap *heap, duk_hobject *obj);
static __attribute__ ((unused)) void duk_heap_process_finalize_list(duk_heap *heap);


static __attribute__ ((unused)) void duk_heap_mark_and_sweep(duk_heap *heap, duk_small_uint_t flags);

static __attribute__ ((unused)) duk_uint32_t duk_heap_hashstring(duk_heap *heap, const duk_uint8_t *str, duk_size_t len);
# 1 "duk_debugger.h"
# 1 "duk_debug.h"
# 1 "duk_error.h"
# 608 "duk_error.h"
static __attribute__ ((unused)) void duk_err_handle_error(duk_hthread *thr, const char *filename, duk_uint_t line_and_code, const char *msg)
                                                                                                                                   ;
static __attribute__ ((unused)) void duk_err_handle_error_fmt(duk_hthread *thr, const char *filename, duk_uint_t line_and_code, const char *fmt, ...)
                                                                                                                                  ;





static __attribute__ ((unused)) void duk_err_create_and_throw(duk_hthread *thr, duk_errcode_t code, const char *msg, const char *filename, duk_int_t line)



                                                                             ;




static __attribute__ ((unused)) void duk_error_throw_from_negative_rc(duk_hthread *thr, duk_ret_t rc);





static __attribute__ ((unused)) void duk_err_augment_error_create(duk_hthread *thr,
                                                    duk_hthread *thr_callstack,
                                                    const char *filename,
                                                    duk_int_t line,
                                                    duk_small_uint_t flags);


static __attribute__ ((unused)) void duk_err_augment_error_throw(duk_hthread *thr);
# 650 "duk_error.h"
static __attribute__ ((unused)) void duk_err_require_type_index(duk_hthread *thr, const char *filename, duk_int_t linenumber, duk_idx_t idx, const char *expect_name)



                                                                                        ;

static __attribute__ ((unused)) void duk_err_error_internal(duk_hthread *thr, const char *filename, duk_int_t linenumber);
static __attribute__ ((unused)) void duk_err_error_alloc_failed(duk_hthread *thr, const char *filename, duk_int_t linenumber);
static __attribute__ ((unused)) void duk_err_error(duk_hthread *thr, const char *filename, duk_int_t linenumber, const char *message)
                                                                                                                            ;
static __attribute__ ((unused)) void duk_err_range_index(duk_hthread *thr, const char *filename, duk_int_t linenumber, duk_idx_t idx)
                                                                                                                            ;
static __attribute__ ((unused)) void duk_err_range_push_beyond(duk_hthread *thr, const char *filename, duk_int_t linenumber);
static __attribute__ ((unused)) void duk_err_range(duk_hthread *thr, const char *filename, duk_int_t linenumber, const char *message)
                                                                                                                            ;
static __attribute__ ((unused)) void duk_err_type_invalid_args(duk_hthread *thr, const char *filename, duk_int_t linenumber);
static __attribute__ ((unused)) void duk_err_type_invalid_state(duk_hthread *thr, const char *filename, duk_int_t linenumber);
static __attribute__ ((unused)) void duk_err_type_invalid_trap_result(duk_hthread *thr, const char *filename, duk_int_t linenumber);
# 678 "duk_error.h"
static __attribute__ ((unused)) void duk_err_longjmp(duk_hthread *thr);

static __attribute__ ((unused)) void duk_default_fatal_handler(void *udata, const char *msg);

static __attribute__ ((unused)) void duk_err_setup_ljstate1(duk_hthread *thr, duk_small_uint_t lj_type, duk_tval *tv_val);




static __attribute__ ((unused)) duk_hobject *duk_error_prototype_from_code(duk_hthread *thr, duk_errcode_t err_code);
# 1 "duk_unicode.h"
# 188 "duk_unicode.h"
extern const duk_uint8_t duk_unicode_ids_noa[1116];
# 202 "duk_unicode.h"
extern const duk_uint8_t duk_unicode_ids_m_let_noa[42];
# 216 "duk_unicode.h"
extern const duk_uint8_t duk_unicode_idp_m_ids_noa[576];
# 229 "duk_unicode.h"
extern const duk_uint8_t duk_unicode_caseconv_uc[1411];
extern const duk_uint8_t duk_unicode_caseconv_lc[706];
# 248 "duk_unicode.h"
extern const duk_uint8_t duk_unicode_re_canon_bitmap[256];
# 271 "duk_unicode.h"
static __attribute__ ((unused)) duk_small_int_t duk_unicode_get_xutf8_length(duk_ucodepoint_t cp);



static __attribute__ ((unused)) duk_small_int_t duk_unicode_encode_xutf8(duk_ucodepoint_t cp, duk_uint8_t *out);
static __attribute__ ((unused)) duk_small_int_t duk_unicode_encode_cesu8(duk_ucodepoint_t cp, duk_uint8_t *out);
static __attribute__ ((unused)) duk_small_int_t duk_unicode_decode_xutf8(duk_hthread *thr,
                                                           const duk_uint8_t **ptr,
                                                           const duk_uint8_t *ptr_start,
                                                           const duk_uint8_t *ptr_end,
                                                           duk_ucodepoint_t *out_cp);
static __attribute__ ((unused)) duk_ucodepoint_t duk_unicode_decode_xutf8_checked(duk_hthread *thr,
                                                                    const duk_uint8_t **ptr,
                                                                    const duk_uint8_t *ptr_start,
                                                                    const duk_uint8_t *ptr_end);
static __attribute__ ((unused)) duk_size_t duk_unicode_unvalidated_utf8_length(const duk_uint8_t *data, duk_size_t blen);
static __attribute__ ((unused)) duk_bool_t duk_unicode_is_utf8_compatible(const duk_uint8_t *buf, duk_size_t len);
static __attribute__ ((unused)) duk_small_int_t duk_unicode_is_whitespace(duk_codepoint_t cp);
static __attribute__ ((unused)) duk_small_int_t duk_unicode_is_line_terminator(duk_codepoint_t cp);
static __attribute__ ((unused)) duk_small_int_t duk_unicode_is_identifier_start(duk_codepoint_t cp);
static __attribute__ ((unused)) duk_small_int_t duk_unicode_is_identifier_part(duk_codepoint_t cp);
static __attribute__ ((unused)) duk_small_int_t duk_unicode_is_letter(duk_codepoint_t cp);
static __attribute__ ((unused)) void duk_unicode_case_convert_string(duk_hthread *thr, duk_bool_t uppercase);

static __attribute__ ((unused)) duk_codepoint_t duk_unicode_re_canonicalize_char(duk_hthread *thr, duk_codepoint_t cp);
static __attribute__ ((unused)) duk_small_int_t duk_unicode_re_is_wordchar(duk_codepoint_t cp);
# 1 "duk_json.h"
# 24 "duk_json.h"
typedef struct {
 duk_hthread *thr;
 duk_bufwriter_ctx bw;
 duk_hobject *h_replacer;
 duk_hstring *h_gap;
 duk_idx_t idx_proplist;
 duk_idx_t idx_loop;
 duk_small_uint_t flags;
 duk_small_uint_t flag_ascii_only;
 duk_small_uint_t flag_avoid_key_quotes;

 duk_small_uint_t flag_ext_custom;
 duk_small_uint_t flag_ext_compatible;
 duk_small_uint_t flag_ext_custom_or_compatible;

 duk_uint_t recursion_depth;
 duk_uint_t recursion_limit;
 duk_uint_t mask_for_undefined;

 duk_small_uint_t stridx_custom_undefined;
 duk_small_uint_t stridx_custom_nan;
 duk_small_uint_t stridx_custom_neginf;
 duk_small_uint_t stridx_custom_posinf;
 duk_small_uint_t stridx_custom_function;

 duk_hobject *visiting[64];
} duk_json_enc_ctx;

typedef struct {
 duk_hthread *thr;
 const duk_uint8_t *p;
 const duk_uint8_t *p_start;
 const duk_uint8_t *p_end;
 duk_idx_t idx_reviver;
 duk_small_uint_t flags;

 duk_small_uint_t flag_ext_custom;
 duk_small_uint_t flag_ext_compatible;
 duk_small_uint_t flag_ext_custom_or_compatible;

 duk_int_t recursion_depth;
 duk_int_t recursion_limit;
} duk_json_dec_ctx;
# 1 "duk_js.h"
# 27 "duk_js.h"
static __attribute__ ((unused)) duk_bool_t duk_js_toboolean(duk_tval *tv);
static __attribute__ ((unused)) duk_double_t duk_js_tonumber(duk_hthread *thr, duk_tval *tv);
static __attribute__ ((unused)) duk_double_t duk_js_tointeger_number(duk_double_t x);
static __attribute__ ((unused)) duk_double_t duk_js_tointeger(duk_hthread *thr, duk_tval *tv);
static __attribute__ ((unused)) duk_uint32_t duk_js_touint32(duk_hthread *thr, duk_tval *tv);
static __attribute__ ((unused)) duk_int32_t duk_js_toint32(duk_hthread *thr, duk_tval *tv);
static __attribute__ ((unused)) duk_uint16_t duk_js_touint16(duk_hthread *thr, duk_tval *tv);
static __attribute__ ((unused)) duk_uarridx_t duk_js_to_arrayindex_string(const duk_uint8_t *str, duk_uint32_t blen);




static __attribute__ ((unused)) duk_bool_t duk_js_equals_helper(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y, duk_small_uint_t flags);
static __attribute__ ((unused)) duk_small_int_t duk_js_data_compare(const duk_uint8_t *buf1,
                                                      const duk_uint8_t *buf2,
                                                      duk_size_t len1,
                                                      duk_size_t len2);
static __attribute__ ((unused)) duk_small_int_t duk_js_string_compare(duk_hstring *h1, duk_hstring *h2);



static __attribute__ ((unused)) duk_bool_t duk_js_compare_helper(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y, duk_small_uint_t flags);
static __attribute__ ((unused)) duk_bool_t duk_js_instanceof(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y);

static __attribute__ ((unused)) duk_bool_t duk_js_instanceof_ordinary(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y);

static __attribute__ ((unused)) duk_bool_t duk_js_in(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y);
static __attribute__ ((unused)) duk_small_uint_t duk_js_typeof_stridx(duk_tval *tv_x);
static __attribute__ ((unused)) duk_bool_t duk_js_isarray_hobject(duk_hobject *h);
static __attribute__ ((unused)) duk_bool_t duk_js_isarray(duk_tval *tv);


static __attribute__ ((unused)) double duk_js_arith_pow(double x, double y);
static __attribute__ ((unused)) double duk_js_arith_mod(double x, double y);
# 83 "duk_js.h"
static __attribute__ ((unused)) duk_bool_t duk_js_getvar_envrec(duk_hthread *thr, duk_hobject *env, duk_hstring *name, duk_bool_t throw_flag);
static __attribute__ ((unused)) duk_bool_t duk_js_getvar_activation(duk_hthread *thr,
                                                      duk_activation *act,
                                                      duk_hstring *name,
                                                      duk_bool_t throw_flag);
static __attribute__ ((unused)) void duk_js_putvar_envrec(duk_hthread *thr,
                                            duk_hobject *env,
                                            duk_hstring *name,
                                            duk_tval *val,
                                            duk_bool_t strict);
static __attribute__ ((unused)) void duk_js_putvar_activation(duk_hthread *thr,
                                                duk_activation *act,
                                                duk_hstring *name,
                                                duk_tval *val,
                                                duk_bool_t strict);



static __attribute__ ((unused)) duk_bool_t duk_js_delvar_activation(duk_hthread *thr, duk_activation *act, duk_hstring *name);
static __attribute__ ((unused)) duk_bool_t duk_js_declvar_activation(duk_hthread *thr,
                                                       duk_activation *act,
                                                       duk_hstring *name,
                                                       duk_tval *val,
                                                       duk_small_uint_t prop_flags,
                                                       duk_bool_t is_func_decl);
static __attribute__ ((unused)) void duk_js_init_activation_environment_records_delayed(duk_hthread *thr, duk_activation *act);
static __attribute__ ((unused)) void duk_js_close_environment_record(duk_hthread *thr, duk_hobject *env);
static __attribute__ ((unused)) duk_hobject *duk_create_activation_environment_record(duk_hthread *thr,
                                                                        duk_hobject *func,
                                                                        duk_size_t bottom_byteoff);
static __attribute__ ((unused)) void duk_js_push_closure(duk_hthread *thr,
                                           duk_hcompfunc *fun_temp,
                                           duk_hobject *outer_var_env,
                                           duk_hobject *outer_lex_env,
                                           duk_bool_t add_auto_proto);


static __attribute__ ((unused)) void duk_native_stack_check(duk_hthread *thr);
static __attribute__ ((unused)) duk_int_t duk_handle_call_unprotected(duk_hthread *thr, duk_idx_t idx_func, duk_small_uint_t call_flags);
static __attribute__ ((unused)) duk_int_t duk_handle_call_unprotected_nargs(duk_hthread *thr, duk_idx_t nargs, duk_small_uint_t call_flags);
static __attribute__ ((unused)) duk_int_t
duk_handle_safe_call(duk_hthread *thr, duk_safe_call_function func, void *udata, duk_idx_t num_stack_args, duk_idx_t num_stack_res);
static __attribute__ ((unused)) void duk_call_construct_postprocess(duk_hthread *thr, duk_small_uint_t proxy_invariant);

static __attribute__ ((unused)) void duk_call_setup_propcall_error(duk_hthread *thr, duk_tval *tv_base, duk_tval *tv_key);



static __attribute__ ((unused)) void duk_js_execute_bytecode(duk_hthread *exec_thr);
# 1 "duk_numconv.h"
# 101 "duk_numconv.h"
static __attribute__ ((unused)) void duk_numconv_stringify(duk_hthread *thr,
                                             duk_small_int_t radix,
                                             duk_small_int_t digits,
                                             duk_small_uint_t flags);
static __attribute__ ((unused)) void duk_numconv_parse(duk_hthread *thr, duk_small_int_t radix, duk_small_uint_t flags);
# 1 "duk_bi_protos.h"
# 18 "duk_bi_protos.h"
static __attribute__ ((unused)) void duk_bi_date_timeval_to_parts(duk_double_t d, duk_int_t *parts, duk_double_t *dparts, duk_small_uint_t flags);
static __attribute__ ((unused)) duk_double_t duk_bi_date_get_timeval_from_dparts(duk_double_t *dparts, duk_small_uint_t flags);
static __attribute__ ((unused)) duk_bool_t duk_bi_date_is_leap_year(duk_int_t year);
static __attribute__ ((unused)) duk_bool_t duk_bi_date_timeval_in_valid_range(duk_double_t x);
static __attribute__ ((unused)) duk_bool_t duk_bi_date_year_in_valid_range(duk_double_t year);
static __attribute__ ((unused)) duk_bool_t duk_bi_date_timeval_in_leeway_range(duk_double_t x);


static __attribute__ ((unused)) duk_double_t duk_bi_date_get_now_gettimeofday(void);
# 38 "duk_bi_protos.h"
static __attribute__ ((unused)) duk_int_t duk_bi_date_get_local_tzoffset_gmtime(duk_double_t d);
# 47 "duk_bi_protos.h"
static __attribute__ ((unused)) duk_bool_t duk_bi_date_parse_string_strptime(duk_hthread *thr, const char *str);





static __attribute__ ((unused)) duk_bool_t duk_bi_date_format_parts_strftime(duk_hthread *thr,
                                                               duk_int_t *parts,
                                                               duk_int_t tzoffset,
                                                               duk_small_uint_t flags);
# 66 "duk_bi_protos.h"
static __attribute__ ((unused))
void duk_bi_json_parse_helper(duk_hthread *thr, duk_idx_t idx_value, duk_idx_t idx_reviver, duk_small_uint_t flags);
static __attribute__ ((unused))
void duk_bi_json_stringify_helper(duk_hthread *thr,
                                  duk_idx_t idx_value,
                                  duk_idx_t idx_replacer,
                                  duk_idx_t idx_space,
                                  duk_small_uint_t flags);

static __attribute__ ((unused)) duk_ret_t duk_textdecoder_decode_utf8_nodejs(duk_hthread *thr);


static __attribute__ ((unused)) void duk_proxy_ownkeys_postprocess(duk_hthread *thr, duk_hobject *h_proxy_target, duk_uint_t flags);
# 1 "duk_selftest.h"
# 76 "duk_internal.h"
# 10 "duk_replacements.c"
# 1 "duk_debug_macros.c"
# 1 "duk_builtins.c"
# 16 "duk_builtins.c"
static __attribute__ ((unused)) const duk_uint8_t duk_strings_data[972] = {
79,40,209,144,168,105,6,78,54,139,89,185,44,48,46,90,120,8,154,140,35,103,
35,113,193,73,5,52,112,180,104,166,135,52,188,4,98,12,27,146,156,80,211,31,
129,115,150,64,52,220,109,24,18,68,156,24,38,67,114,36,55,9,119,151,132,
140,93,18,113,128,153,201,212,201,205,2,248,8,196,24,224,104,82,146,40,224,
193,48,114,168,37,147,196,54,123,28,4,98,12,43,148,67,103,177,192,70,32,
196,121,68,54,123,28,18,192,199,144,124,4,98,12,43,136,108,244,117,184,8,
196,24,95,40,134,207,71,91,128,140,65,133,113,13,158,158,151,1,24,131,11,
229,16,217,233,233,112,17,136,48,206,21,110,4,244,244,184,8,196,24,103,10,
183,2,122,218,156,4,98,12,24,203,112,64,179,113,193,79,8,218,155,131,32,
184,70,212,220,13,10,82,68,252,123,144,217,146,38,228,207,18,0,100,37,64,
178,212,11,161,17,104,162,96,10,200,193,57,165,65,169,16,5,100,81,27,70,18,
32,10,200,68,185,13,116,221,197,184,64,89,57,41,197,13,49,234,5,208,156,
113,87,55,118,147,20,187,56,161,166,92,221,212,73,210,236,226,134,153,115,
119,76,201,203,179,138,26,99,73,212,136,136,164,25,174,137,56,32,72,137,
101,23,52,45,13,34,86,9,79,136,104,201,114,149,96,52,138,134,140,151,75,
226,233,186,120,121,22,39,54,83,141,5,55,68,236,36,164,3,16,225,115,150,64,
52,205,163,2,72,154,83,138,26,99,75,12,11,150,103,5,36,20,211,70,140,133,
67,72,49,241,160,227,81,196,52,168,106,39,132,252,183,136,105,80,212,79,2,
249,110,128,126,88,95,133,109,237,237,237,151,235,127,46,249,119,203,190,
186,206,33,181,2,208,61,190,12,19,34,65,19,81,132,108,228,97,1,107,33,12,
32,45,100,137,64,247,175,9,19,155,41,198,130,155,134,69,146,100,227,226,
231,146,51,192,204,73,140,224,145,221,102,241,68,196,169,248,30,75,12,11,
151,242,233,187,143,138,24,137,162,164,255,253,63,3,201,97,129,114,254,92,
112,75,136,108,166,6,136,159,255,167,224,121,44,48,46,95,203,166,238,74,
113,67,77,201,128,223,255,223,224,121,44,48,46,95,203,145,46,9,205,16,39,
201,62,36,0,192,21,147,255,238,145,39,199,197,211,116,240,242,113,197,78,
214,211,226,233,187,107,105,19,119,37,56,161,166,52,221,212,201,205,36,240,
242,16,96,152,12,26,20,164,137,150,70,154,103,28,137,50,202,96,18,132,241,
41,104,105,56,218,48,36,138,183,57,56,128,68,24,38,2,52,12,34,10,133,147,
141,3,8,119,185,13,153,34,125,206,76,17,49,38,93,206,52,151,154,119,56,28,
76,130,112,200,141,206,21,209,96,23,35,238,114,160,139,0,243,238,114,78,
164,68,68,110,113,226,210,90,26,66,110,113,128,121,247,57,80,68,141,170,
183,56,84,52,11,70,73,19,110,114,160,93,8,113,57,143,66,200,84,53,244,154,
73,24,240,81,32,38,68,18,49,228,207,23,88,100,109,70,114,92,193,4,137,173,
168,36,220,73,19,247,247,182,168,209,144,187,223,58,156,104,79,190,183,127,
123,105,160,110,247,206,167,26,19,239,173,223,222,218,67,75,189,243,169,
198,132,251,235,183,247,182,154,134,151,123,231,83,141,9,247,215,111,239,
109,22,141,22,247,206,167,26,19,239,172,223,218,45,26,47,157,78,52,39,223,
74,24,144,10,32,129,34,20,64,152,142,129,57,179,67,104,68,12,129,161,140,
72,156,100,40,40,185,152,100,89,38,65,13,196,34,228,67,149,13,2,215,129,
149,209,65,104,209,77,14,104,144,81,33,170,67,101,48,52,68,113,70,210,88,
209,36,233,22,154,86,68,196,114,76,232,145,102,120,186,195,156,112,105,225,
228,113,71,80,68,162,115,101,50,85,200,25,108,116,44,132,178,38,114,137,96,
148,136,70,209,134,37,222,232,204,228,188,200,209,200,200,99,221,25,150,84,
121,34,70,209,107,36,227,66,20,160,92,136,164,49,235,35,8,217,201,40,108,
201,18,128,68,26,201,51,188,2,80,12,67,190,40,168,38,68,190,46,153,5,50,12,
207,160,86,129,26,83,4,208,34,225,4,88,192,
};






static __attribute__ ((unused)) const duk_c_function duk_bi_native_functions[185] = {
 
# 72 "duk_builtins.c" 3 4
((void *)0)
# 72 "duk_builtins.c"
    ,
 duk_bi_array_constructor,
 duk_bi_array_constructor_is_array,
 duk_bi_array_prototype_concat,
 duk_bi_array_prototype_indexof_shared,
 duk_bi_array_prototype_iter_shared,
 duk_bi_array_prototype_join_shared,
 duk_bi_array_prototype_pop,
 duk_bi_array_prototype_push,
 duk_bi_array_prototype_reduce_shared,
 duk_bi_array_prototype_reverse,
 duk_bi_array_prototype_shift,
 duk_bi_array_prototype_slice,
 duk_bi_array_prototype_sort,
 duk_bi_array_prototype_splice,
 duk_bi_array_prototype_to_string,
 duk_bi_array_prototype_unshift,
 duk_bi_arraybuffer_constructor,
 duk_bi_arraybuffer_isview,
 duk_bi_boolean_constructor,
 duk_bi_boolean_prototype_tostring_shared,
 duk_bi_buffer_compare_shared,
 duk_bi_buffer_readfield,
 duk_bi_buffer_slice_shared,
 duk_bi_buffer_writefield,
 duk_bi_cbor_decode,
 duk_bi_cbor_encode,
 duk_bi_dataview_constructor,
 duk_bi_date_constructor,
 duk_bi_date_constructor_now,
 duk_bi_date_constructor_parse,
 duk_bi_date_constructor_utc,
 duk_bi_date_prototype_get_shared,
 duk_bi_date_prototype_get_timezone_offset,
 duk_bi_date_prototype_set_shared,
 duk_bi_date_prototype_set_time,
 duk_bi_date_prototype_to_json,
 duk_bi_date_prototype_toprimitive,
 duk_bi_date_prototype_tostring_shared,
 duk_bi_date_prototype_value_of,
 duk_bi_duktape_object_act,
 duk_bi_duktape_object_compact,
 duk_bi_duktape_object_dec,
 duk_bi_duktape_object_enc,
 duk_bi_duktape_object_fin,
 duk_bi_duktape_object_gc,
 duk_bi_duktape_object_info,
 duk_bi_error_constructor_shared,
 duk_bi_error_prototype_filename_getter,
 duk_bi_error_prototype_filename_setter,
 duk_bi_error_prototype_linenumber_getter,
 duk_bi_error_prototype_linenumber_setter,
 duk_bi_error_prototype_stack_getter,
 duk_bi_error_prototype_stack_setter,
 duk_bi_error_prototype_to_string,
 duk_bi_function_constructor,
 duk_bi_function_prototype,
 duk_bi_function_prototype_apply,
 duk_bi_function_prototype_bind,
 duk_bi_function_prototype_call,
 duk_bi_function_prototype_hasinstance,
 duk_bi_function_prototype_to_string,
 duk_bi_global_object_decode_uri,
 duk_bi_global_object_decode_uri_component,
 duk_bi_global_object_encode_uri,
 duk_bi_global_object_encode_uri_component,
 duk_bi_global_object_escape,
 duk_bi_global_object_eval,
 duk_bi_global_object_is_finite,
 duk_bi_global_object_is_nan,
 duk_bi_global_object_parse_float,
 duk_bi_global_object_parse_int,
 duk_bi_global_object_unescape,
 duk_bi_json_object_parse,
 duk_bi_json_object_stringify,
 duk_bi_math_object_clz32,
 duk_bi_math_object_hypot,
 duk_bi_math_object_imul,
 duk_bi_math_object_max,
 duk_bi_math_object_min,
 duk_bi_math_object_onearg_shared,
 duk_bi_math_object_random,
 duk_bi_math_object_sign,
 duk_bi_math_object_twoarg_shared,
 duk_bi_native_function_length,
 duk_bi_native_function_name,
 duk_bi_nodejs_buffer_byte_length,
 duk_bi_nodejs_buffer_concat,
 duk_bi_nodejs_buffer_constructor,
 duk_bi_nodejs_buffer_copy,
 duk_bi_nodejs_buffer_fill,
 duk_bi_nodejs_buffer_is_buffer,
 duk_bi_nodejs_buffer_is_encoding,
 duk_bi_nodejs_buffer_tojson,
 duk_bi_nodejs_buffer_tostring,
 duk_bi_nodejs_buffer_write,
 duk_bi_number_check_shared,
 duk_bi_number_constructor,
 duk_bi_number_prototype_to_exponential,
 duk_bi_number_prototype_to_fixed,
 duk_bi_number_prototype_to_locale_string,
 duk_bi_number_prototype_to_precision,
 duk_bi_number_prototype_to_string,
 duk_bi_number_prototype_value_of,
 duk_bi_object_constructor,
 duk_bi_object_constructor_assign,
 duk_bi_object_constructor_create,
 duk_bi_object_constructor_define_properties,
 duk_bi_object_constructor_define_property,
 duk_bi_object_constructor_get_own_property_descriptor,
 duk_bi_object_constructor_is,
 duk_bi_object_constructor_is_extensible,
 duk_bi_object_constructor_is_sealed_frozen_shared,
 duk_bi_object_constructor_keys_shared,
 duk_bi_object_constructor_prevent_extensions,
 duk_bi_object_constructor_seal_freeze_shared,
 duk_bi_object_getprototype_shared,
 duk_bi_object_prototype_defineaccessor,
 duk_bi_object_prototype_has_own_property,
 duk_bi_object_prototype_is_prototype_of,
 duk_bi_object_prototype_lookupaccessor,
 duk_bi_object_prototype_property_is_enumerable,
 duk_bi_object_prototype_to_locale_string,
 duk_bi_object_prototype_to_string,
 duk_bi_object_prototype_value_of,
 duk_bi_object_setprototype_shared,
 duk_bi_performance_now,
 duk_bi_pointer_constructor,
 duk_bi_pointer_prototype_tostring_shared,
 duk_bi_proxy_constructor,
 duk_bi_reflect_apply,
 duk_bi_reflect_construct,
 duk_bi_reflect_object_delete_property,
 duk_bi_reflect_object_get,
 duk_bi_reflect_object_has,
 duk_bi_reflect_object_set,
 duk_bi_regexp_constructor,
 duk_bi_regexp_prototype_exec,
 duk_bi_regexp_prototype_flags,
 duk_bi_regexp_prototype_shared_getter,
 duk_bi_regexp_prototype_test,
 duk_bi_regexp_prototype_tostring,
 duk_bi_string_constructor,
 duk_bi_string_constructor_from_char_code,
 duk_bi_string_constructor_from_code_point,
 duk_bi_string_prototype_caseconv_shared,
 duk_bi_string_prototype_char_at,
 duk_bi_string_prototype_char_code_at,
 duk_bi_string_prototype_concat,
 duk_bi_string_prototype_includes,
 duk_bi_string_prototype_indexof_shared,
 duk_bi_string_prototype_locale_compare,
 duk_bi_string_prototype_match,
 duk_bi_string_prototype_repeat,
 duk_bi_string_prototype_replace,
 duk_bi_string_prototype_search,
 duk_bi_string_prototype_slice,
 duk_bi_string_prototype_split,
 duk_bi_string_prototype_startswith_endswith,
 duk_bi_string_prototype_substr,
 duk_bi_string_prototype_substring,
 duk_bi_string_prototype_to_string,
 duk_bi_string_prototype_trim,
 duk_bi_symbol_constructor_shared,
 duk_bi_symbol_key_for,
 duk_bi_symbol_toprimitive,
 duk_bi_symbol_tostring_shared,
 duk_bi_textdecoder_constructor,
 duk_bi_textdecoder_prototype_decode,
 duk_bi_textdecoder_prototype_shared_getter,
 duk_bi_textencoder_constructor,
 duk_bi_textencoder_prototype_encode,
 duk_bi_textencoder_prototype_encoding_getter,
 duk_bi_thread_constructor,
 duk_bi_thread_current,
 duk_bi_thread_resume,
 duk_bi_thread_yield,
 duk_bi_type_error_thrower,
 duk_bi_typedarray_buffer_getter,
 duk_bi_typedarray_bytelength_getter,
 duk_bi_typedarray_byteoffset_getter,
 duk_bi_typedarray_constructor,
 duk_bi_typedarray_set,
 duk_bi_uint8array_allocplain,
 duk_bi_uint8array_plainof,
};

static __attribute__ ((unused)) const duk_uint8_t duk_builtins_data[4281] = {
144,148,105,226,32,68,52,228,254,12,104,202,37,132,52,167,194,138,105,245,
124,57,28,211,57,18,64,52,239,126,44,138,111,175,241,164,19,87,145,30,33,
167,22,145,159,8,211,139,9,225,42,5,240,145,139,163,163,8,211,139,10,228,
64,211,19,132,140,93,29,56,70,156,88,119,34,66,146,36,104,137,194,70,46,
142,172,35,78,44,47,146,195,102,11,240,145,139,163,175,8,211,139,9,228,240,
242,112,145,139,163,179,8,211,139,8,237,34,130,118,49,116,118,225,26,48,0,
1,98,29,201,158,46,183,39,135,147,132,140,93,16,132,76,66,33,8,66,16,132,
33,8,66,26,180,105,97,167,68,150,34,33,154,112,0,1,91,247,35,79,111,237,
198,174,232,47,31,23,95,17,13,31,249,96,211,49,50,53,214,77,141,24,0,0,181,
10,228,240,242,15,128,140,65,128,134,188,0,0,90,167,97,181,224,0,2,213,62,
53,224,0,2,213,66,237,120,0,0,181,81,204,107,192,0,5,170,150,67,94,0,0,45,
84,245,90,240,0,1,106,169,162,215,128,0,11,85,93,150,188,0,0,90,171,111,53,
109,22,162,26,48,0,1,84,23,201,146,243,225,26,39,12,145,136,104,192,0,5,61,
11,228,201,121,240,100,19,134,72,196,33,195,14,40,203,112,64,190,76,232,
145,153,136,0,0,0,0,0,0,31,15,249,152,0,0,0,0,0,0,30,15,249,120,144,13,96,
155,194,56,80,206,36,67,141,20,228,70,57,81,206,100,131,156,39,132,168,23,
194,70,46,137,208,21,200,129,166,39,9,24,186,39,72,119,34,66,146,36,104,
137,194,70,46,137,212,23,201,97,179,5,248,72,197,209,58,194,121,60,60,156,
36,98,232,157,129,29,164,80,78,198,46,137,218,146,121,25,71,146,9,209,5,
209,61,48,126,14,138,152,30,67,186,23,143,139,175,131,202,135,228,72,85,
144,83,60,179,30,94,209,233,102,30,98,105,230,103,30,114,121,231,104,30,
122,137,231,233,30,130,153,232,106,30,138,169,232,235,30,144,67,193,25,19,
136,108,207,30,41,224,140,137,194,173,192,153,228,5,242,100,188,248,70,137,
195,36,79,78,47,147,37,231,193,144,78,25,34,122,145,111,36,74,232,176,13,
17,61,234,226,93,207,148,160,84,75,141,7,27,161,32,33,18,225,80,212,76,154,
2,2,70,65,56,100,237,34,140,209,2,67,32,156,50,118,145,64,186,230,61,205,
35,103,155,32,36,141,19,134,78,210,40,206,16,36,70,137,195,39,105,20,11,
174,99,220,210,54,121,210,1,137,33,1,228,207,16,17,70,146,66,3,201,164,32,
0,65,112,152,56,196,159,31,23,77,211,195,201,199,23,160,72,214,246,81,6,12,
73,241,214,111,31,23,60,145,158,56,50,72,81,67,230,232,242,80,19,49,39,199,
89,188,124,92,242,70,120,227,64,194,75,154,72,12,9,73,6,111,21,120,12,40,
144,19,39,25,0,225,144,168,105,56,248,185,228,140,241,200,96,64,100,42,26,
78,62,46,121,35,52,18,92,116,1,36,64,47,158,64,49,98,66,100,156,242,65,23,
196,149,35,103,194,94,100,108,144,230,203,156,64,66,37,201,16,11,32,249,
132,4,34,92,44,93,146,55,152,72,24,137,112,151,153,27,36,5,100,229,144,8,
162,98,92,210,5,76,73,241,214,111,31,23,60,145,158,57,44,48,46,92,185,164,
160,72,151,41,0,50,107,179,244,59,36,93,127,92,6,19,172,3,11,216,0,56,224,
151,29,102,241,241,115,201,25,227,164,64,106,37,199,197,211,116,240,242,
113,197,233,144,40,248,185,228,140,241,196,75,132,109,24,72,128,43,39,84,
129,13,173,161,144,168,105,56,98,78,100,142,214,215,69,1,13,173,161,144,
168,105,57,34,78,100,142,214,215,69,16,67,107,105,110,114,168,254,24,147,
153,35,181,181,212,32,67,107,105,110,114,168,254,72,147,153,35,181,181,212,
36,65,130,3,144,8,26,252,200,13,30,85,16,16,64,90,242,231,192,64,161,163,
203,31,26,172,193,17,4,23,105,159,96,27,172,251,16,32,196,4,14,137,112,17,
136,48,164,28,134,80,215,202,1,132,130,8,12,39,52,64,155,31,24,56,36,1,189,
207,132,0,35,233,35,195,62,3,196,149,36,100,72,160,2,200,232,44,227,0,11,
37,160,68,142,128,36,157,25,200,32,26,79,90,4,73,43,192,122,54,71,65,103,
44,248,14,134,140,151,227,138,231,208,45,96,148,248,134,140,151,227,138,
231,240,1,255,254,10,74,146,56,128,104,4,147,152,72,6,144,28,174,143,8,1,
30,1,165,3,96,31,0,211,3,21,11,153,35,0,211,131,68,131,160,137,16,250,5,
196,131,160,137,200,160,199,156,67,248,0,255,255,65,140,10,48,177,115,56,
35,130,60,19,134,79,89,240,52,177,115,56,39,12,156,123,144,217,251,15,135,
34,167,30,20,170,154,255,232,12,47,244,0,97,28,17,224,39,238,32,40,71,4,
120,39,12,156,4,253,228,5,137,195,39,30,228,54,124,4,253,228,128,194,115,
68,9,252,15,128,232,104,201,126,56,191,35,64,90,193,41,241,13,25,47,199,23,
228,105,3,86,225,1,100,224,156,199,130,36,249,144,10,192,76,71,250,16,15,
18,61,96,17,62,200,3,72,128,136,143,247,32,22,75,64,137,248,64,22,79,90,39,
249,64,38,84,12,167,20,52,223,196,2,230,238,45,214,36,120,32,72,158,208,4,
102,238,45,194,2,201,197,186,196,143,4,9,19,218,0,92,221,202,61,228,143,4,
9,19,218,8,35,55,113,110,16,22,78,81,239,36,120,32,72,158,208,64,73,197,12,
255,0,13,18,60,128,159,212,128,169,76,17,156,185,100,76,255,163,64,65,26,
57,114,200,153,255,70,144,33,13,18,232,50,75,226,104,6,149,3,41,199,246,
130,12,128,28,142,156,120,203,175,158,8,194,207,1,6,81,20,79,88,11,237,84,
11,161,32,127,255,255,255,255,255,247,191,137,235,16,221,170,129,116,36,0,
16,0,0,0,0,0,0,12,196,0,0,0,0,0,0,15,135,242,61,123,164,137,162,164,218,67,
74,134,162,120,128,0,0,0,0,0,1,224,254,71,173,33,129,52,84,155,72,105,80,
212,79,16,0,0,0,0,0,0,60,63,195,244,143,146,22,230,192,0,0,0,0,0,0,176,60,
33,214,2,251,82,1,73,180,134,204,134,36,96,127,255,255,255,255,255,159,161,
144,235,16,221,169,0,164,218,67,102,67,18,48,63,255,255,255,255,255,207,
240,196,60,17,145,56,134,204,241,226,158,8,200,156,42,220,9,158,65,196,34,
92,42,26,137,147,120,64,74,37,196,54,100,49,35,188,36,5,68,184,208,113,187,
194,80,212,75,146,1,73,196,54,100,49,35,188,38,57,37,56,240,0,0,0,0,0,0,0,
0,32,235,248,68,48,156,2,24,94,24,0,243,119,10,139,144,123,242,3,102,238,
18,239,115,72,217,160,11,223,16,23,55,113,241,32,145,36,57,188,18,16,102,3,
5,120,35,34,89,32,15,180,152,173,127,0,218,235,88,0,228,180,227,200,0,0,0,
0,0,0,248,127,197,107,240,64,6,77,220,24,38,78,74,113,67,77,130,4,12,155,
185,52,48,156,148,226,134,155,4,10,194,96,129,132,166,238,45,194,2,201,193,
130,100,228,167,20,52,216,32,113,41,187,139,112,128,178,114,104,97,57,41,
197,13,54,8,32,48,216,32,130,195,224,130,19,97,124,134,23,6,0,57,137,62,77,
12,38,12,0,179,18,124,45,22,190,96,128,141,176,134,28,98,79,180,152,139,
218,45,124,193,1,27,97,16,32,196,159,24,230,204,246,194,40,89,137,62,210,
98,103,92,217,158,216,70,7,49,39,193,130,100,182,17,194,140,73,246,147,16,
250,9,146,216,72,6,49,39,193,131,22,194,72,73,137,62,210,98,31,65,139,97,
40,32,196,159,14,234,70,86,194,88,89,137,62,210,98,63,93,72,202,216,76,10,
49,39,198,33,180,153,37,108,38,134,152,147,237,38,38,117,13,164,201,43,97,
56,40,196,159,36,65,57,163,149,176,158,26,98,79,180,152,165,210,9,205,28,
173,133,0,243,18,124,98,22,180,72,130,115,71,43,97,68,72,196,159,105,49,51,
168,90,209,34,9,205,28,173,133,33,19,18,124,154,24,76,185,164,227,138,89,
18,119,0,7,145,39,201,161,132,188,64,124,137,62,49,11,90,36,65,57,163,149,
210,166,37,34,79,180,152,153,212,45,104,145,4,230,142,87,74,160,84,137,62,
72,130,115,71,43,171,234,134,200,147,237,38,41,116,130,115,71,43,171,235,5,
72,147,227,16,218,76,146,186,254,184,108,137,62,210,98,103,80,218,76,146,
186,254,192,68,137,62,29,212,140,174,207,178,23,34,79,180,152,143,215,82,
50,187,62,208,60,137,62,12,19,37,210,182,21,34,79,180,152,135,208,76,151,
74,224,68,137,62,49,205,153,238,175,186,23,34,79,180,152,153,215,54,103,
186,190,240,92,137,62,22,139,95,48,64,70,235,251,225,210,36,251,73,136,189,
162,215,204,16,17,186,255,2,14,98,79,152,32,35,108,48,64,242,36,249,130,2,
55,75,6,212,224,72,200,51,128,114,108,28,100,128,0,0,0,0,0,0,0,12,110,127,
48,98,115,249,201,117,243,249,195,21,159,206,38,47,63,156,86,8,75,144,94,
82,1,38,73,79,208,67,95,233,1,6,128,14,79,129,186,40,249,18,149,182,207,
144,200,155,188,248,204,105,184,207,142,199,137,175,201,0,159,72,10,5,21,
221,10,120,74,129,124,36,98,232,228,74,81,62,160,20,10,107,186,21,114,32,
105,137,194,70,46,142,68,165,19,235,1,64,170,187,161,119,34,66,146,36,104,
137,194,70,46,142,68,165,19,236,1,64,174,187,161,95,37,134,204,23,225,35,
23,71,34,82,137,246,128,160,89,93,208,167,147,195,201,194,70,46,142,68,165,
19,238,1,64,182,187,161,71,105,20,19,177,139,163,145,41,68,16,7,6,15,82,70,
72,115,96,0,0,0,0,0,27,234,32,91,60,165,195,201,194,8,134,149,216,162,0,
192,41,225,8,2,48,177,36,1,149,13,196,15,0,200,209,97,199,128,99,32,176,
195,192,113,57,143,0,167,133,32,230,80,28,202,139,175,238,2,48,189,192,20,
1,119,80,87,193,186,129,89,56,72,197,209,200,193,185,35,23,71,109,13,219,
36,98,232,237,156,13,26,208,211,14,102,19,87,137,91,95,128,0,10,96,24,92,0,
0,83,2,53,56,0,0,165,3,28,204,160,160,226,100,226,200,211,76,241,240,0,1,
102,8,22,75,64,137,73,20,230,105,133,7,19,39,22,70,154,103,143,128,0,11,48,
20,28,76,156,113,75,34,78,62,0,0,45,3,103,31,0,0,22,65,44,57,137,62,33,179,
216,162,152,192,131,18,124,162,27,61,138,41,108,32,196,159,16,217,232,235,
81,76,104,73,137,62,81,13,158,142,181,20,184,16,98,79,136,108,244,244,168,
166,56,36,196,159,40,134,207,79,74,138,93,10,49,39,194,173,192,158,158,149,
20,188,20,98,79,133,91,129,61,109,74,41,124,30,68,159,16,217,236,83,108,96,
68,137,62,81,13,158,197,54,182,17,34,79,136,108,244,117,169,182,52,38,68,
159,40,134,207,71,90,155,92,8,145,39,196,54,122,122,84,219,28,19,34,79,148,
67,103,167,165,77,174,133,72,147,225,86,224,79,79,74,155,94,10,145,39,194,
173,192,158,182,165,54,190,206,25,212,35,208,226,100,150,211,201,29,162,44,
140,35,103,0,0,0,0,0,0,3,192,252,206,25,228,35,208,226,100,150,211,201,29,
162,44,140,35,103,0,0,0,0,0,0,3,192,252,206,25,244,35,208,226,100,150,211,
201,29,162,44,140,35,103,0,0,0,0,0,0,3,192,252,206,26,4,35,208,226,100,150,
211,201,29,162,44,140,35,103,0,0,0,0,0,0,0,1,0,206,26,20,35,208,226,100,
150,211,201,29,162,44,140,35,103,0,0,0,0,0,0,0,1,0,206,26,36,35,208,226,
100,150,211,201,29,162,44,140,35,103,0,0,0,0,0,0,0,65,0,206,26,52,35,208,
226,100,150,211,201,29,162,44,140,35,103,0,0,0,0,0,0,0,65,0,206,26,68,35,
208,226,100,150,211,201,29,162,44,140,35,103,0,0,0,0,0,0,0,65,0,206,26,84,
35,208,226,100,150,211,201,29,162,44,140,35,103,0,0,0,0,0,0,0,129,0,195,
154,99,16,38,36,0,251,68,117,179,216,162,128,68,72,1,241,13,158,197,20,150,
25,18,0,125,162,58,217,232,235,117,100,162,136,25,18,0,125,162,58,217,232,
235,116,36,162,145,2,226,64,15,136,108,244,117,186,178,81,73,129,113,32,7,
196,54,122,58,221,9,40,165,64,200,144,3,237,17,214,207,79,75,171,37,20,80,
200,144,3,237,17,214,207,79,75,161,37,20,138,23,18,0,124,67,103,167,165,
213,146,138,77,11,137,0,62,33,179,211,210,232,73,69,42,133,196,128,31,10,
183,2,125,89,40,163,5,196,128,31,10,183,2,125,9,40,164,96,200,144,3,224,
221,64,172,157,89,40,163,134,68,128,31,6,234,5,100,232,73,69,35,133,68,128,
31,104,142,182,125,89,40,180,0,168,144,3,237,17,214,207,161,37,22,144,19,
18,0,124,67,103,213,146,139,80,9,137,0,62,33,179,232,73,69,172,5,90,40,153,
59,68,117,179,216,166,192,77,162,137,147,136,108,246,41,180,176,219,69,19,
39,104,142,182,122,58,221,89,41,178,6,218,40,153,59,68,117,179,209,214,232,
73,77,162,6,90,40,153,56,134,207,71,91,171,37,54,152,25,104,162,100,226,27,
61,29,110,132,148,218,160,109,162,137,147,180,71,91,61,61,46,172,148,217,
67,109,20,76,157,162,58,217,233,233,116,36,166,209,67,45,20,76,156,67,103,
167,165,213,146,155,77,12,180,81,50,113,13,158,158,151,66,74,109,84,50,209,
68,201,194,173,192,159,86,74,108,193,150,138,38,78,21,110,4,250,18,83,104,
193,182,138,38,78,13,212,10,201,213,146,155,56,109,162,137,147,131,117,2,
178,116,36,166,209,194,237,20,76,157,162,58,217,245,100,167,16,2,237,20,76,
157,162,58,217,244,36,167,18,2,173,20,76,156,67,103,213,146,156,80,10,180,
81,50,113,13,159,66,74,113,97,175,221,48,216,110,64,4,42,22,189,179,0,196,
133,0,185,80,32,28,78,99,193,18,80,36,4,19,159,141,172,0,178,90,4,74,73,0,
22,209,68,201,187,129,4,2,8,3,132,64,60,36,6,149,113,72,176,171,240,84,0,
157,91,116,116,32,11,42,218,221,216,181,129,32,3,234,219,165,3,188,231,235,
249,8,187,152,252,47,86,227,105,18,7,244,17,91,42,56,175,185,248,110,173,
198,209,208,36,0,238,82,97,87,188,189,179,240,93,122,32,12,22,162,42,125,
144,132,160,7,236,161,25,232,237,105,64,205,59,127,102,158,160,230,63,11,
217,66,51,210,129,154,118,254,205,61,65,236,127,171,197,34,168,48,6,90,194,
1,0,39,75,88,72,8,9,33,186,194,80,64,76,13,214,19,2,130,96,110,150,189,0,
65,6,51,214,20,128,65,17,11,214,19,130,137,121,211,210,211,144,6,39,75,88,
80,0,201,119,235,10,8,41,86,231,71,88,80,129,79,135,186,122,133,224,34,25,
69,234,80,3,91,141,172,40,96,139,113,180,181,133,36,21,110,54,142,134,176,
165,1,176,23,213,47,0,216,134,234,215,128,111,117,181,232,128,209,3,70,230,
107,64,5,139,168,209,235,10,32,36,144,102,235,136,3,146,27,172,40,160,146,
132,103,172,40,192,115,3,117,133,28,22,113,163,69,172,41,103,1,66,188,17,
145,52,168,4,202,113,67,76,130,227,76,194,13,240,108,0,0,83,224,0,2,193,0,
104,146,84,97,48,0,1,94,192,56,169,24,145,179,192,0,5,112,8,56,16,32,128,
56,18,52,125,230,86,147,190,140,28,50,21,13,39,31,23,60,145,158,57,12,141,
47,129,6,155,194,188,24,49,39,199,89,188,124,92,242,70,120,224,201,33,69,
15,155,163,201,68,14,49,39,199,197,211,116,240,242,113,197,232,18,180,254,
36,3,17,46,18,243,35,100,128,172,156,178,70,163,154,76,34,248,146,164,108,
248,75,204,141,146,28,217,115,137,27,95,27,241,173,236,162,160,224,200,2,
206,9,113,13,148,192,209,18,22,164,146,37,193,57,162,4,249,39,196,128,24,2,
178,66,213,136,68,201,16,77,209,131,31,192,242,88,96,92,191,151,34,100,136,
38,232,255,252,92,221,199,197,12,68,209,82,66,212,11,155,185,41,197,13,55,
38,3,66,213,47,135,254,72,12,162,99,133,116,112,0,1,72,66,14,16,16,50,37,
202,160,150,154,66,14,20,8,57,192,28,24,80,113,50,113,100,105,166,120,248,
0,0,179,1,65,196,201,199,20,178,36,227,224,0,2,208,54,113,240,0,1,100,11,
181,192,0,5,178,1,18,160,65,24,131,20,145,25,188,48,132,122,28,76,146,218,
121,35,180,69,145,132,108,224,0,0,0,0,0,0,120,31,153,188,56,132,122,28,76,
146,218,121,35,180,69,145,132,108,224,0,0,0,0,0,0,120,31,168,160,45,110,23,
30,176,33,184,0,0,183,32,29,235,2,27,199,23,0,0,23,4,51,120,129,8,244,56,
153,37,180,242,71,104,139,35,8,217,192,0,0,0,0,0,0,240,63,51,120,145,8,244,
56,153,37,180,242,71,104,139,35,8,217,192,0,0,0,0,0,0,0,64,51,120,161,8,
244,56,153,37,180,242,71,104,139,35,8,217,192,0,0,0,0,0,0,0,64,51,120,177,
8,244,56,153,37,180,242,71,104,139,35,8,217,192,0,0,0,0,0,0,16,64,51,120,
193,8,244,56,153,37,180,242,71,104,139,35,8,217,192,0,0,0,0,0,0,16,64,51,
120,209,8,244,56,153,37,180,242,71,104,139,35,8,217,192,0,0,0,0,0,0,16,64,
51,120,225,8,244,56,153,37,180,242,71,104,139,35,8,217,192,0,0,0,0,0,0,32,
64,32,227,194,0,97,57,162,4,246,104,5,34,92,35,68,225,161,166,220,16,16,
137,112,52,41,73,29,185,1,65,196,201,197,145,166,153,246,72,3,137,204,120,
34,74,8,199,1,67,17,162,112,201,84,128,97,144,78,25,42,16,131,169,1,205,66,
8,35,68,225,161,166,239,128,0,10,192,64,196,104,156,50,96,0,2,172,73,240,
117,96,57,170,97,4,104,156,52,52,221,240,0,1,82,1,74,9,129,125,240,0,1,82,
32,148,25,174,137,58,23,51,190,0,0,42,69,64,195,32,156,50,96,0,2,160,81,
238,2,3,107,173,218,3,192,
};
# 1 "duk_error_macros.c"
# 11 "duk_error_macros.c"
static __attribute__ ((unused)) __attribute__((cold)) void duk_err_handle_error_fmt(duk_hthread *thr,
                                                    const char *filename,
                                                    duk_uint_t line_and_code,
                                                    const char *fmt,
                                                    ...) {
 va_list ap;
 char msg[256];
 
# 18 "duk_error_macros.c" 3 4
__builtin_va_start(
# 18 "duk_error_macros.c"
ap
# 18 "duk_error_macros.c" 3 4
,
# 18 "duk_error_macros.c"
fmt
# 18 "duk_error_macros.c" 3 4
)
# 18 "duk_error_macros.c"
                 ;
 (void) vsnprintf(msg, sizeof(msg), fmt, ap);
 msg[sizeof(msg) - 1] = (char) 0;
 duk_err_create_and_throw(thr,
                          (duk_errcode_t) (line_and_code >> 24),
                          msg,
                          filename,
                          (duk_int_t) (line_and_code & 0x00ffffffL));
 
# 26 "duk_error_macros.c" 3 4
__builtin_va_end(
# 26 "duk_error_macros.c"
ap
# 26 "duk_error_macros.c" 3 4
)
# 26 "duk_error_macros.c"
          ;
}

static __attribute__ ((unused)) __attribute__((cold)) void duk_err_handle_error(duk_hthread *thr, const char *filename, duk_uint_t line_and_code, const char *msg) {
 duk_err_create_and_throw(thr,
                          (duk_errcode_t) (line_and_code >> 24),
                          msg,
                          filename,
                          (duk_int_t) (line_and_code & 0x00ffffffL));
}
# 66 "duk_error_macros.c"
static __attribute__ ((unused)) __attribute__((cold)) void duk_err_require_type_index(duk_hthread *thr,
                                                      const char *filename,
                                                      duk_int_t linenumber,
                                                      duk_idx_t idx,
                                                      const char *expect_name) {
 do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) (linenumber); do { } while (0); do { } while (0); duk_err_handle_error_fmt((thr), (filename), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("%s required, found %s (stack index %ld)"), (expect_name), (duk_push_string_readable(thr, idx)), ((long) idx)); } while (0)






                               ;
}

static __attribute__ ((unused)) __attribute__((cold)) void duk_err_error_internal(duk_hthread *thr, const char *filename, duk_int_t linenumber) {
 do { duk_errcode_t duk__err = (1); duk_int_t duk__line = (duk_int_t) (linenumber); do { } while (0); do { } while (0); duk_err_handle_error((thr), (filename), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("internal error")); } while (0);
}
static __attribute__ ((unused)) __attribute__((cold)) void duk_err_error_alloc_failed(duk_hthread *thr, const char *filename, duk_int_t linenumber) {
 do { duk_errcode_t duk__err = (1); duk_int_t duk__line = (duk_int_t) (linenumber); do { } while (0); do { } while (0); duk_err_handle_error((thr), (filename), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("alloc failed")); } while (0);
}
static __attribute__ ((unused)) __attribute__((cold)) void duk_err_error(duk_hthread *thr, const char *filename, duk_int_t linenumber, const char *message) {
 do { duk_errcode_t duk__err = (1); duk_int_t duk__line = (duk_int_t) (linenumber); do { } while (0); do { } while (0); duk_err_handle_error((thr), (filename), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (message)); } while (0);
}
static __attribute__ ((unused)) __attribute__((cold)) void duk_err_range(duk_hthread *thr, const char *filename, duk_int_t linenumber, const char *message) {
 do { duk_errcode_t duk__err = (3); duk_int_t duk__line = (duk_int_t) (linenumber); do { } while (0); do { } while (0); duk_err_handle_error((thr), (filename), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (message)); } while (0);
}
static __attribute__ ((unused)) __attribute__((cold)) void duk_err_range_index(duk_hthread *thr, const char *filename, duk_int_t linenumber, duk_idx_t idx) {
 do { duk_errcode_t duk__err = (3); duk_int_t duk__line = (duk_int_t) (linenumber); do { } while (0); do { } while (0); duk_err_handle_error_fmt((thr), (filename), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("invalid stack index %ld"), ((long) (idx))); } while (0);
}
static __attribute__ ((unused)) __attribute__((cold)) void duk_err_range_push_beyond(duk_hthread *thr, const char *filename, duk_int_t linenumber) {
 do { duk_errcode_t duk__err = (3); duk_int_t duk__line = (duk_int_t) (linenumber); do { } while (0); do { } while (0); duk_err_handle_error((thr), (filename), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("cannot push beyond allocated stack")); } while (0);
}
static __attribute__ ((unused)) __attribute__((cold)) void duk_err_type_invalid_args(duk_hthread *thr, const char *filename, duk_int_t linenumber) {
 do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) (linenumber); do { } while (0); do { } while (0); duk_err_handle_error((thr), (filename), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("invalid args")); } while (0);
}
static __attribute__ ((unused)) __attribute__((cold)) void duk_err_type_invalid_state(duk_hthread *thr, const char *filename, duk_int_t linenumber) {
 do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) (linenumber); do { } while (0); do { } while (0); duk_err_handle_error((thr), (filename), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("invalid state")); } while (0);
}
static __attribute__ ((unused)) __attribute__((cold)) void duk_err_type_invalid_trap_result(duk_hthread *thr, const char *filename, duk_int_t linenumber) {
 do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) (linenumber); do { } while (0); do { } while (0); duk_err_handle_error((thr), (filename), (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("invalid trap result")); } while (0);
}
# 144 "duk_error_macros.c"
static __attribute__ ((unused)) __attribute__((cold)) void duk_default_fatal_handler(void *udata, const char *msg) {
 do { (void) (udata); } while (0);
 do { (void) (msg); } while (0);

 msg = msg ? msg : "NULL";
# 176 "duk_error_macros.c"
 do { } while (0);
 abort();


 do { } while (0);
 for (;;) {

 }
}
# 1 "duk_unicode_support.c"
# 13 "duk_unicode_support.c"
static __attribute__ ((unused)) const duk_int8_t duk_is_idchar_tab[128] = {




 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 0, 0, 0, 0, 0,
 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,
 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0
};






static __attribute__ ((unused)) duk_small_int_t duk_unicode_get_xutf8_length(duk_ucodepoint_t cp) {
 duk_uint_fast32_t x = (duk_uint_fast32_t) cp;
 if (x < 0x80UL) {

  return 1;
 } else if (x < 0x800UL) {

  return 2;
 } else if (x < 0x10000UL) {

  return 3;
 } else if (x < 0x200000UL) {

  return 4;
 } else if (x < 0x4000000UL) {

  return 5;
 } else if (x < (duk_ucodepoint_t) 0x80000000UL) {

  return 6;
 } else {

  return 7;
 }
}
# 81 "duk_unicode_support.c"
static __attribute__ ((unused)) const duk_uint8_t duk_unicode_xutf8_markers[7] = { 0x00, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe };





static __attribute__ ((unused)) duk_small_int_t duk_unicode_encode_xutf8(duk_ucodepoint_t cp, duk_uint8_t *out) {
 duk_uint_fast32_t x = (duk_uint_fast32_t) cp;
 duk_small_int_t len;
 duk_uint8_t marker;
 duk_small_int_t i;

 len = duk_unicode_get_xutf8_length(cp);
 do { } while (0);

 marker = duk_unicode_xutf8_markers[len - 1];

 i = len;
 do { } while (0);
 do {
  i--;
  if (i > 0) {
   out[i] = (duk_uint8_t) (0x80 + (x & 0x3f));
   x >>= 6;
  } else {




   out[0] = (duk_uint8_t) (marker + x);
  }
 } while (i > 0);

 return len;
}





static __attribute__ ((unused)) duk_small_int_t duk_unicode_encode_cesu8(duk_ucodepoint_t cp, duk_uint8_t *out) {
 duk_uint_fast32_t x = (duk_uint_fast32_t) cp;
 duk_small_int_t len;

 if (x < 0x80UL) {
  out[0] = (duk_uint8_t) x;
  len = 1;
 } else if (x < 0x800UL) {
  out[0] = (duk_uint8_t) (0xc0 + ((x >> 6) & 0x1f));
  out[1] = (duk_uint8_t) (0x80 + (x & 0x3f));
  len = 2;
 } else if (x < 0x10000UL) {

  out[0] = (duk_uint8_t) (0xe0 + ((x >> 12) & 0x0f));
  out[1] = (duk_uint8_t) (0x80 + ((x >> 6) & 0x3f));
  out[2] = (duk_uint8_t) (0x80 + (x & 0x3f));
  len = 3;
 } else {
# 166 "duk_unicode_support.c"
  x -= 0x10000UL;

  out[0] = (duk_uint8_t) (0xed);
  out[1] = (duk_uint8_t) (0xa0 + ((x >> 16) & 0x0f));
  out[2] = (duk_uint8_t) (0x80 + ((x >> 10) & 0x3f));
  out[3] = (duk_uint8_t) (0xed);
  out[4] = (duk_uint8_t) (0xb0 + ((x >> 6) & 0x0f));
  out[5] = (duk_uint8_t) (0x80 + (x & 0x3f));
  len = 6;
 }

 return len;
}


static __attribute__ ((unused)) duk_small_int_t duk_unicode_decode_xutf8(duk_hthread *thr,
                                                      const duk_uint8_t **ptr,
                                                      const duk_uint8_t *ptr_start,
                                                      const duk_uint8_t *ptr_end,
                                                      duk_ucodepoint_t *out_cp) {
 const duk_uint8_t *p;
 duk_uint32_t res;
 duk_uint_fast8_t ch;
 duk_small_int_t n;

 do { (void) (thr); } while (0);

 p = *ptr;
 if (p < ptr_start || p >= ptr_end) {
  goto fail;
 }






 ch = (duk_uint_fast8_t) (*p++);
 if (ch < 0x80) {

  res = (duk_uint32_t) (ch & 0x7f);
  n = 0;
 } else if (ch < 0xc0) {

  goto fail;
 } else if (ch < 0xe0) {

  res = (duk_uint32_t) (ch & 0x1f);
  n = 1;
 } else if (ch < 0xf0) {

  res = (duk_uint32_t) (ch & 0x0f);
  n = 2;
 } else if (ch < 0xf8) {

  res = (duk_uint32_t) (ch & 0x07);
  n = 3;
 } else if (ch < 0xfc) {

  res = (duk_uint32_t) (ch & 0x03);
  n = 4;
 } else if (ch < 0xfe) {

  res = (duk_uint32_t) (ch & 0x01);
  n = 5;
 } else if (ch < 0xff) {

  res = (duk_uint32_t) (0);
  n = 6;
 } else {
# 244 "duk_unicode_support.c"
  goto fail;
 }

 do { } while (0);
 if (p + n > ptr_end) {

  goto fail;
 }

 while (n > 0) {
  do { } while (0);
  ch = (duk_uint_fast8_t) (*p++);
# 265 "duk_unicode_support.c"
  res = (res << 6) + (duk_uint32_t) (ch & 0x3f);
  n--;
 }

 *ptr = p;
 *out_cp = res;
 return 1;

fail:
 return 0;
}


static __attribute__ ((unused)) duk_ucodepoint_t duk_unicode_decode_xutf8_checked(duk_hthread *thr,
                                                               const duk_uint8_t **ptr,
                                                               const duk_uint8_t *ptr_start,
                                                               const duk_uint8_t *ptr_end) {
 duk_ucodepoint_t cp;

 if (duk_unicode_decode_xutf8(thr, ptr, ptr_start, ptr_end, &cp)) {
  return cp;
 }
 do { duk_err_error_internal((thr), "duk_unicode_support.c", (duk_int_t) 287); } while (0);
 do { return 0; } while (0);
}
# 332 "duk_unicode_support.c"
static __attribute__ ((unused)) duk_size_t duk_unicode_unvalidated_utf8_length(const duk_uint8_t *data, duk_size_t blen) {
 const duk_uint8_t *p;
 const duk_uint8_t *p_end;
 const duk_uint32_t *p32_end;
 const duk_uint32_t *p32;
 duk_size_t ncont;
 duk_size_t clen;

 ncont = 0;
 p = data;
 p_end = data + blen;
 if (blen < 16) {
  goto skip_fastpath;
 }




 while (((duk_size_t) (const void *) p) & 0x03U) {
  duk_uint8_t x;
  x = *p++;
  if (__builtin_expect((x >= 0x80 && x <= 0xbf), 0)) {
   ncont++;
  }
 }


 p32_end = (const duk_uint32_t *) (const void *) (p + ((duk_size_t) (p_end - p) & (duk_size_t) (~0x03)));
 p32 = (const duk_uint32_t *) (const void *) p;
 while (p32 != (const duk_uint32_t *) p32_end) {
  duk_uint32_t x;
  x = *p32++;
  if (__builtin_expect(((x & 0x80808080UL) == 0), 1)) {
   ;
  } else {




   x ^= 0x80808080UL;
   if (__builtin_expect((!(x & 0xc0000000UL)), 0)) {
    ncont++;
   }
   if (__builtin_expect((!(x & 0x00c00000UL)), 0)) {
    ncont++;
   }
   if (__builtin_expect((!(x & 0x0000c000UL)), 0)) {
    ncont++;
   }
   if (__builtin_expect((!(x & 0x000000c0UL)), 0)) {
    ncont++;
   }
  }
 }
 p = (const duk_uint8_t *) p32;


skip_fastpath:
 while (p != p_end) {
  duk_uint8_t x;
  x = *p++;
  if (__builtin_expect((x >= 0x80 && x <= 0xbf), 0)) {
   ncont++;
  }
 }

 do { } while (0);
 clen = blen - ncont;
 do { } while (0);
 return clen;
}



static __attribute__ ((unused)) duk_bool_t duk_unicode_is_utf8_compatible(const duk_uint8_t *buf, duk_size_t len) {
 duk_size_t i = 0;

 duk_size_t len_safe;






 len_safe = len & ~0x03UL;
 for (; i < len_safe; i += 4) {
  duk_uint8_t t = buf[i] | buf[i + 1] | buf[i + 2] | buf[i + 3];
  if (__builtin_expect(((t & 0x80U) != 0U), 0)) {






   break;
  }
 }


 for (; i < len;) {
  duk_uint8_t t;
  duk_size_t left;
  duk_size_t ncont;
  duk_uint32_t cp;
  duk_uint32_t mincp;

  t = buf[i++];
  if (__builtin_expect(((t & 0x80U) == 0U), 1)) {

   continue;
  }
# 451 "duk_unicode_support.c"
  left = len - i;
  if (t <= 0xdfU) {
   if (t <= 0xbfU) {
    return 0;
   }
   ncont = 1;
   mincp = 0x80UL;
   cp = t & 0x1fU;
  } else if (t <= 0xefU) {
   ncont = 2;
   mincp = 0x800UL;
   cp = t & 0x0fU;
  } else if (t <= 0xf7U) {
   ncont = 3;
   mincp = 0x10000UL;
   cp = t & 0x07U;
  } else {
   return 0;
  }
  if (left < ncont) {
   return 0;
  }
  while (ncont > 0U) {
   t = buf[i++];
   if ((t & 0xc0U) != 0x80U) {
    return 0;
   }
   cp = (cp << 6) + (t & 0x3fU);
   ncont--;
  }
  if (cp < mincp || cp > 0x10ffffUL || (cp >= 0xd800UL && cp <= 0xdfffUL)) {
   return 0;
  }
 }

 return 1;
}
# 497 "duk_unicode_support.c"
static duk_uint32_t duk__uni_decode_value(duk_bitdecoder_ctx *bd_ctx) {
 duk_uint32_t t;

 t = (duk_uint32_t) duk_bd_decode(bd_ctx, 4);
 if (t <= 0x0eU) {
  return t;
 }
 t = (duk_uint32_t) duk_bd_decode(bd_ctx, 8);
 if (t <= 0xfdU) {
  return t + 0x0f;
 }
 if (t == 0xfeU) {
  t = (duk_uint32_t) duk_bd_decode(bd_ctx, 12);
  return t + 0x0fU + 0xfeU;
 } else {
  t = (duk_uint32_t) duk_bd_decode(bd_ctx, 24);
  return t + 0x0fU + 0xfeU + 0x1000UL;
 }
}

static duk_small_int_t duk__uni_range_match(const duk_uint8_t *unitab, duk_size_t unilen, duk_codepoint_t cp) {
 duk_bitdecoder_ctx bd_ctx;
 duk_codepoint_t prev_re;

 do { void *duk__dst = (&bd_ctx); duk_size_t duk__len = (sizeof(bd_ctx)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 bd_ctx.data = (const duk_uint8_t *) unitab;
 bd_ctx.length = (duk_size_t) unilen;

 prev_re = 0;
 for (;;) {
  duk_codepoint_t r1, r2;
  r1 = (duk_codepoint_t) duk__uni_decode_value(&bd_ctx);
  if (r1 == 0) {
   break;
  }
  r2 = (duk_codepoint_t) duk__uni_decode_value(&bd_ctx);

  r1 = prev_re + r1;
  r2 = r1 + r2;
  prev_re = r2;



  do { } while (0)


                                           ;
  if (cp >= r1 && cp <= r2) {
   return 1;
  }
 }

 return 0;
}





static __attribute__ ((unused)) duk_small_int_t duk_unicode_is_whitespace(duk_codepoint_t cp) {
# 607 "duk_unicode_support.c"
 duk_uint_fast8_t lo;
 duk_uint_fast32_t hi;



 lo = (duk_uint_fast8_t) (cp & 0xff);
 hi = (duk_uint_fast32_t) (cp >> 8);

 if (hi == 0x0000UL) {
  if (lo == 0x09U || lo == 0x0bU || lo == 0x0cU || lo == 0x20U || lo == 0xa0U) {
   return 1;
  }
 } else if (hi == 0x0020UL) {
  if (lo <= 0x0aU || lo == 0x2fU || lo == 0x5fU) {
   return 1;
  }
 } else if (cp == 0x1680L || cp == 0x180eL || cp == 0x3000L || cp == 0xfeffL) {
  return 1;
 }

 return 0;
}





static __attribute__ ((unused)) duk_small_int_t duk_unicode_is_line_terminator(duk_codepoint_t cp) {







 if (cp == 0x000aL || cp == 0x000dL || cp == 0x2028L || cp == 0x2029L) {
  return 1;
 }

 return 0;
}





static __attribute__ ((unused)) duk_small_int_t duk_unicode_is_identifier_start(duk_codepoint_t cp) {
# 689 "duk_unicode_support.c"
 if (cp <= 0x7fL) {

  return (cp >= 0) && (duk_is_idchar_tab[cp] > 0);






 }




 if (duk__uni_range_match(duk_unicode_ids_noa, (duk_size_t) sizeof(duk_unicode_ids_noa), (duk_codepoint_t) cp)) {
  return 1;
 }
 return 0;
# 720 "duk_unicode_support.c"
}





static __attribute__ ((unused)) duk_small_int_t duk_unicode_is_identifier_part(duk_codepoint_t cp) {
# 772 "duk_unicode_support.c"
 if (cp <= 0x7fL) {

  return (cp >= 0) && (duk_is_idchar_tab[cp] != 0);






 }




 if (duk__uni_range_match(duk_unicode_ids_noa, sizeof(duk_unicode_ids_noa), (duk_codepoint_t) cp) ||
     duk__uni_range_match(duk_unicode_idp_m_ids_noa, sizeof(duk_unicode_idp_m_ids_noa), (duk_codepoint_t) cp)) {
  return 1;
 }
 return 0;
# 807 "duk_unicode_support.c"
}





static __attribute__ ((unused)) duk_small_int_t duk_unicode_is_letter(duk_codepoint_t cp) {
# 828 "duk_unicode_support.c"
 if (cp <= 0x7fL) {
  if ((cp >= 'a' && cp <= 'z') || (cp >= 'A' && cp <= 'Z')) {
   return 1;
  }
  return 0;
 }




 if (duk__uni_range_match(duk_unicode_ids_noa, sizeof(duk_unicode_ids_noa), (duk_codepoint_t) cp) &&
     !duk__uni_range_match(duk_unicode_ids_m_let_noa, sizeof(duk_unicode_ids_m_let_noa), (duk_codepoint_t) cp)) {
  return 1;
 }
 return 0;
# 859 "duk_unicode_support.c"
}
# 881 "duk_unicode_support.c"
static
duk_codepoint_t duk__slow_case_conversion(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_codepoint_t cp, duk_bitdecoder_ctx *bd_ctx) {
 duk_small_int_t skip = 0;
 duk_small_int_t n;
 duk_small_int_t t;
 duk_small_int_t count;
 duk_codepoint_t tmp_cp;
 duk_codepoint_t start_i;
 duk_codepoint_t start_o;

 do { } while (0);
 do { (void) (thr); } while (0);

 do { } while (0);


 do { } while (0);
 for (;;) {
  skip++;
  n = (duk_small_int_t) duk_bd_decode(bd_ctx, 6);
  if (n == 0x3f) {

   break;
  }
  do { } while (0);

  while (n--) {
   start_i = (duk_codepoint_t) duk_bd_decode(bd_ctx, 16);
   start_o = (duk_codepoint_t) duk_bd_decode(bd_ctx, 16);
   count = (duk_small_int_t) duk_bd_decode(bd_ctx, 7);
   do { } while (0)



                                     ;

   if (cp >= start_i) {
    tmp_cp = cp - start_i;
    if (tmp_cp < (duk_codepoint_t) count * (duk_codepoint_t) skip &&
        (tmp_cp % (duk_codepoint_t) skip) == 0) {
     do { } while (0);
     cp = start_o + tmp_cp;
     goto single;
    }
   }
  }
 }


 n = (duk_small_int_t) duk_bd_decode(bd_ctx, 7);
 do { } while (0);
 while (n--) {
  start_i = (duk_codepoint_t) duk_bd_decode(bd_ctx, 16);
  start_o = (duk_codepoint_t) duk_bd_decode(bd_ctx, 16);
  do { } while (0);
  if (cp == start_i) {
   do { } while (0);
   cp = start_o;
   goto single;
  }
 }


 n = (duk_small_int_t) duk_bd_decode(bd_ctx, 7);
 do { } while (0);
 while (n--) {
  start_i = (duk_codepoint_t) duk_bd_decode(bd_ctx, 16);
  t = (duk_small_int_t) duk_bd_decode(bd_ctx, 2);
  do { } while (0);
  if (cp == start_i) {
   do { } while (0);
   if (bw != 
# 952 "duk_unicode_support.c" 3 4
            ((void *)0)
# 952 "duk_unicode_support.c"
                ) {
    while (t--) {
     tmp_cp = (duk_codepoint_t) duk_bd_decode(bd_ctx, 16);
     do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) ((duk_ucodepoint_t) tmp_cp); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_xutf8(duk__cp, (bw)->p); (bw)->p += duk__enc_len; } while (0);
    }
   }
   return -1;
  } else {
   while (t--) {
    (void) duk_bd_decode(bd_ctx, 16);
   }
  }
 }


 do { } while (0);


single:
 if (bw != 
# 971 "duk_unicode_support.c" 3 4
          ((void *)0)
# 971 "duk_unicode_support.c"
              ) {
  do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) ((duk_ucodepoint_t) cp); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_xutf8(duk__cp, (bw)->p); (bw)->p += duk__enc_len; } while (0);
 }
 return cp;
}
# 987 "duk_unicode_support.c"
static
duk_codepoint_t duk__case_transform_helper(duk_hthread *thr,
                                           duk_bufwriter_ctx *bw,
                                           duk_codepoint_t cp,
                                           duk_codepoint_t prev,
                                           duk_codepoint_t next,
                                           duk_bool_t uppercase) {
 duk_bitdecoder_ctx bd_ctx;


 if (cp < 0x80L) {






  if (uppercase) {
   if (cp >= 'a' && cp <= 'z') {
    cp = cp - 'a' + 'A';
   }
  } else {
   if (cp >= 'A' && cp <= 'Z') {
    cp = cp - 'A' + 'a';
   }
  }

  if (bw != 
# 1014 "duk_unicode_support.c" 3 4
           ((void *)0)
# 1014 "duk_unicode_support.c"
               ) {
   do { do { (((void) 0), ((void) 0)); } while (0); *(bw)->p++ = (duk_uint8_t) ((duk_uint8_t) cp); } while (0);
  }
  return cp;
 }




 if (uppercase) {

 } else {






  if (cp == 0x03a3L &&
      duk_unicode_is_letter(prev) &&
      !duk_unicode_is_letter(next)) {





   cp = 0x03c2L;
   goto singlechar;
  }




 }


 do { void *duk__dst = (&bd_ctx); duk_size_t duk__len = (sizeof(bd_ctx)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 if (uppercase) {
  bd_ctx.data = (const duk_uint8_t *) duk_unicode_caseconv_uc;
  bd_ctx.length = (duk_size_t) sizeof(duk_unicode_caseconv_uc);
 } else {
  bd_ctx.data = (const duk_uint8_t *) duk_unicode_caseconv_lc;
  bd_ctx.length = (duk_size_t) sizeof(duk_unicode_caseconv_lc);
 }
 return duk__slow_case_conversion(thr, bw, cp, &bd_ctx);

singlechar:
 if (bw != 
# 1061 "duk_unicode_support.c" 3 4
          ((void *)0)
# 1061 "duk_unicode_support.c"
              ) {
  do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) ((duk_ucodepoint_t) cp); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_xutf8(duk__cp, (bw)->p); (bw)->p += duk__enc_len; } while (0);
 }
 return cp;






}





static __attribute__ ((unused)) void duk_unicode_case_convert_string(duk_hthread *thr, duk_bool_t uppercase) {
 duk_hstring *h_input;
 duk_bufwriter_ctx bw_alloc;
 duk_bufwriter_ctx *bw;
 const duk_uint8_t *p, *p_start, *p_end;
 duk_codepoint_t prev, curr, next;

 h_input = duk_require_hstring(thr, -1);
 do { } while (0);

 bw = &bw_alloc;
 do { duk_bw_init_pushbuf((thr), (bw), (((h_input)->blen))); } while (0);



 p_start = (const duk_uint8_t *) ((const duk_uint8_t *) ((h_input) + 1));
 p_end = p_start + ((h_input)->blen);
 p = p_start;

 prev = -1;
 do { (void) (prev); } while (0);
 curr = -1;
 next = -1;
 for (;;) {
  prev = curr;
  curr = next;
  next = -1;
  if (p < p_end) {
   next = (duk_codepoint_t) duk_unicode_decode_xutf8_checked(thr, &p, p_start, p_end);
  } else {

   if (curr < 0) {
    break;
   }
  }


  if (curr >= 0) {





   do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (8 * 7); duk__space = (duk_size_t) ((bw)->p_limit - (bw)->p); if (duk__space < duk__sz) { (void) duk_bw_resize((thr), (bw), duk__sz); } } while (0);

   duk__case_transform_helper(thr, bw, (duk_codepoint_t) curr, prev, next, uppercase);
  }
 }

 do { duk_bw_compact((thr), (bw)); } while (0);
 (void) duk_buffer_to_string(thr, -1);

 duk_remove_m2(thr);
}
# 1141 "duk_unicode_support.c"
static __attribute__ ((unused)) duk_codepoint_t duk_unicode_re_canonicalize_char(duk_hthread *thr, duk_codepoint_t cp) {
# 1151 "duk_unicode_support.c"
 duk_codepoint_t y;

 y = duk__case_transform_helper(thr,
                                
# 1154 "duk_unicode_support.c" 3 4
                               ((void *)0)
# 1154 "duk_unicode_support.c"
                                   ,
                                cp,
                                -1,
                                -1,
                                1);

 if ((y < 0) || (cp >= 0x80 && y < 0x80)) {



  return cp;
 }

 return y;

}






static __attribute__ ((unused)) duk_small_int_t duk_unicode_re_is_wordchar(duk_codepoint_t x) {




 if ((x >= '0' && x <= '9') || (x >= 'a' && x <= 'z') || (x >= 'A' && x <= 'Z') || (x == '_')) {
  return 1;
 }
 return 0;
}






static __attribute__ ((unused)) const duk_uint16_t duk_unicode_re_ranges_digit[2] = {
 (duk_uint16_t) 0x0030UL,
 (duk_uint16_t) 0x0039UL,
};
static __attribute__ ((unused)) const duk_uint16_t duk_unicode_re_ranges_white[22] = {
 (duk_uint16_t) 0x0009UL, (duk_uint16_t) 0x000DUL, (duk_uint16_t) 0x0020UL, (duk_uint16_t) 0x0020UL, (duk_uint16_t) 0x00A0UL,
 (duk_uint16_t) 0x00A0UL, (duk_uint16_t) 0x1680UL, (duk_uint16_t) 0x1680UL, (duk_uint16_t) 0x180EUL, (duk_uint16_t) 0x180EUL,
 (duk_uint16_t) 0x2000UL, (duk_uint16_t) 0x200AUL, (duk_uint16_t) 0x2028UL, (duk_uint16_t) 0x2029UL, (duk_uint16_t) 0x202FUL,
 (duk_uint16_t) 0x202FUL, (duk_uint16_t) 0x205FUL, (duk_uint16_t) 0x205FUL, (duk_uint16_t) 0x3000UL, (duk_uint16_t) 0x3000UL,
 (duk_uint16_t) 0xFEFFUL, (duk_uint16_t) 0xFEFFUL,
};
static __attribute__ ((unused)) const duk_uint16_t duk_unicode_re_ranges_wordchar[8] = {
 (duk_uint16_t) 0x0030UL, (duk_uint16_t) 0x0039UL, (duk_uint16_t) 0x0041UL, (duk_uint16_t) 0x005AUL,
 (duk_uint16_t) 0x005FUL, (duk_uint16_t) 0x005FUL, (duk_uint16_t) 0x0061UL, (duk_uint16_t) 0x007AUL,
};
static __attribute__ ((unused)) const duk_uint16_t duk_unicode_re_ranges_not_digit[4] = {
 (duk_uint16_t) 0x0000UL,
 (duk_uint16_t) 0x002FUL,
 (duk_uint16_t) 0x003AUL,
 (duk_uint16_t) 0xFFFFUL,
};
static __attribute__ ((unused)) const duk_uint16_t duk_unicode_re_ranges_not_white[24] = {
 (duk_uint16_t) 0x0000UL, (duk_uint16_t) 0x0008UL, (duk_uint16_t) 0x000EUL, (duk_uint16_t) 0x001FUL, (duk_uint16_t) 0x0021UL,
 (duk_uint16_t) 0x009FUL, (duk_uint16_t) 0x00A1UL, (duk_uint16_t) 0x167FUL, (duk_uint16_t) 0x1681UL, (duk_uint16_t) 0x180DUL,
 (duk_uint16_t) 0x180FUL, (duk_uint16_t) 0x1FFFUL, (duk_uint16_t) 0x200BUL, (duk_uint16_t) 0x2027UL, (duk_uint16_t) 0x202AUL,
 (duk_uint16_t) 0x202EUL, (duk_uint16_t) 0x2030UL, (duk_uint16_t) 0x205EUL, (duk_uint16_t) 0x2060UL, (duk_uint16_t) 0x2FFFUL,
 (duk_uint16_t) 0x3001UL, (duk_uint16_t) 0xFEFEUL, (duk_uint16_t) 0xFF00UL, (duk_uint16_t) 0xFFFFUL,
};
static __attribute__ ((unused)) const duk_uint16_t duk_unicode_re_ranges_not_wordchar[10] = {
 (duk_uint16_t) 0x0000UL, (duk_uint16_t) 0x002FUL, (duk_uint16_t) 0x003AUL, (duk_uint16_t) 0x0040UL, (duk_uint16_t) 0x005BUL,
 (duk_uint16_t) 0x005EUL, (duk_uint16_t) 0x0060UL, (duk_uint16_t) 0x0060UL, (duk_uint16_t) 0x007BUL, (duk_uint16_t) 0xFFFFUL,
};
# 1 "duk_util_memrw.c"
# 12 "duk_util_memrw.c"
union duk__u16_union {
 duk_uint8_t b[2];
 duk_uint16_t x;
};
typedef union duk__u16_union duk__u16_union;

union duk__u32_union {
 duk_uint8_t b[4];
 duk_uint32_t x;
};
typedef union duk__u32_union duk__u32_union;


union duk__u64_union {
 duk_uint8_t b[8];
 duk_uint64_t x;
};
typedef union duk__u64_union duk__u64_union;


static __attribute__ ((unused)) inline __attribute__((always_inline)) duk_uint16_t duk_raw_read_u16_be(const duk_uint8_t *p) {
 duk__u16_union u;
 do { void *duk__dst = ((void *) u.b); const void *duk__src = ((const void *) p); duk_size_t duk__len = ((size_t) 2); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 u.x = ((duk_uint16_t) __builtin_bswap16((duk_uint16_t) ((u.x))));
 return u.x;
}

static __attribute__ ((unused)) inline __attribute__((always_inline)) duk_uint32_t duk_raw_read_u32_be(const duk_uint8_t *p) {
 duk__u32_union u;
 do { void *duk__dst = ((void *) u.b); const void *duk__src = ((const void *) p); duk_size_t duk__len = ((size_t) 4); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 u.x = ((duk_uint32_t) __builtin_bswap32((duk_uint32_t) ((u.x))));
 return u.x;
}

static __attribute__ ((unused)) inline __attribute__((always_inline)) duk_float_t duk_raw_read_float_be(const duk_uint8_t *p) {
 duk_float_union fu;
 do { void *duk__dst = ((void *) fu.uc); const void *duk__src = ((const void *) p); duk_size_t duk__len = ((size_t) 4); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 duk_fltunion_big_to_host(&fu);
 return fu.f;
}

static __attribute__ ((unused)) inline __attribute__((always_inline)) duk_double_t duk_raw_read_double_be(const duk_uint8_t *p) {
 duk_double_union du;
 do { void *duk__dst = ((void *) du.uc); const void *duk__src = ((const void *) p); duk_size_t duk__len = ((size_t) 8); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 duk_dblunion_big_to_host(&du);
 return du.d;
}

static __attribute__ ((unused)) inline __attribute__((always_inline)) duk_uint16_t duk_raw_readinc_u16_be(const duk_uint8_t **p) {
 duk_uint16_t res = duk_raw_read_u16_be(*p);
 *p += 2;
 return res;
}

static __attribute__ ((unused)) inline __attribute__((always_inline)) duk_uint32_t duk_raw_readinc_u32_be(const duk_uint8_t **p) {
 duk_uint32_t res = duk_raw_read_u32_be(*p);
 *p += 4;
 return res;
}

static __attribute__ ((unused)) inline __attribute__((always_inline)) duk_float_t duk_raw_readinc_float_be(const duk_uint8_t **p) {
 duk_float_t res = duk_raw_read_float_be(*p);
 *p += 4;
 return res;
}

static __attribute__ ((unused)) inline __attribute__((always_inline)) duk_double_t duk_raw_readinc_double_be(const duk_uint8_t **p) {
 duk_double_t res = duk_raw_read_double_be(*p);
 *p += 8;
 return res;
}

static __attribute__ ((unused)) inline __attribute__((always_inline)) void duk_raw_write_u16_be(duk_uint8_t *p, duk_uint16_t val) {
 duk__u16_union u;
 u.x = ((duk_uint16_t) __builtin_bswap16((duk_uint16_t) ((val))));
 do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) u.b); duk_size_t duk__len = ((size_t) 2); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
}

static __attribute__ ((unused)) inline __attribute__((always_inline)) void duk_raw_write_u32_be(duk_uint8_t *p, duk_uint32_t val) {
 duk__u32_union u;
 u.x = ((duk_uint32_t) __builtin_bswap32((duk_uint32_t) ((val))));
 do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) u.b); duk_size_t duk__len = ((size_t) 4); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
}

static __attribute__ ((unused)) inline __attribute__((always_inline)) void duk_raw_write_float_be(duk_uint8_t *p, duk_float_t val) {
 duk_float_union fu;
 fu.f = val;
 duk_fltunion_host_to_big(&fu);
 do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) fu.uc); duk_size_t duk__len = ((size_t) 4); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
}

static __attribute__ ((unused)) inline __attribute__((always_inline)) void duk_raw_write_double_be(duk_uint8_t *p, duk_double_t val) {
 duk_double_union du;
 du.d = val;
 duk_dblunion_host_to_big(&du);
 do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) du.uc); duk_size_t duk__len = ((size_t) 8); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
}

static __attribute__ ((unused)) duk_small_int_t duk_raw_write_xutf8(duk_uint8_t *p, duk_ucodepoint_t val) {
 duk_small_int_t len = duk_unicode_encode_xutf8(val, p);
 return len;
}

static __attribute__ ((unused)) duk_small_int_t duk_raw_write_cesu8(duk_uint8_t *p, duk_ucodepoint_t val) {
 duk_small_int_t len = duk_unicode_encode_cesu8(val, p);
 return len;
}

static __attribute__ ((unused)) inline __attribute__((always_inline)) void duk_raw_writeinc_u16_be(duk_uint8_t **p, duk_uint16_t val) {
 duk_raw_write_u16_be(*p, val);
 *p += 2;
}

static __attribute__ ((unused)) inline __attribute__((always_inline)) void duk_raw_writeinc_u32_be(duk_uint8_t **p, duk_uint32_t val) {
 duk_raw_write_u32_be(*p, val);
 *p += 4;
}

static __attribute__ ((unused)) inline __attribute__((always_inline)) void duk_raw_writeinc_float_be(duk_uint8_t **p, duk_float_t val) {
 duk_raw_write_float_be(*p, val);
 *p += 4;
}

static __attribute__ ((unused)) inline __attribute__((always_inline)) void duk_raw_writeinc_double_be(duk_uint8_t **p, duk_double_t val) {
 duk_raw_write_double_be(*p, val);
 *p += 8;
}

static __attribute__ ((unused)) void duk_raw_writeinc_xutf8(duk_uint8_t **p, duk_ucodepoint_t val) {
 duk_small_int_t len = duk_unicode_encode_xutf8(val, *p);
 *p += len;
}

static __attribute__ ((unused)) void duk_raw_writeinc_cesu8(duk_uint8_t **p, duk_ucodepoint_t val) {
 duk_small_int_t len = duk_unicode_encode_cesu8(val, *p);
 *p += len;
}
# 1 "duk_util_misc.c"
# 12 "duk_util_misc.c"
static __attribute__ ((unused)) const duk_uint8_t duk_lc_digits[36] = {
 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
 0x38, 0x39, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e,
 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
 0x77, 0x78, 0x79, 0x7a
};

static __attribute__ ((unused)) const duk_uint8_t duk_uc_nybbles[16] = { 0x30, 0x31, 0x32, 0x33,
                                               0x34, 0x35, 0x36, 0x37,
                                               0x38, 0x39, 0x41, 0x42,
                                               0x43, 0x44, 0x45, 0x46 };





static __attribute__ ((unused)) const duk_int8_t duk_hex_dectab[256] = {

 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1,
 -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
};



static __attribute__ ((unused)) const duk_int16_t duk_hex_dectab_shift4[256] = {
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80, 0x90, -1, -1, -1, -1, -1, -1,
 -1, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
 -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
};
# 87 "duk_util_misc.c"
static __attribute__ ((unused)) const duk_uint16_t duk_hex_enctab[256] = {
# 110 "duk_util_misc.c"
 0x3030U, 0x3130U, 0x3230U, 0x3330U, 0x3430U, 0x3530U, 0x3630U, 0x3730U, 0x3830U, 0x3930U, 0x6130U, 0x6230U, 0x6330U,
 0x6430U, 0x6530U, 0x6630U, 0x3031U, 0x3131U, 0x3231U, 0x3331U, 0x3431U, 0x3531U, 0x3631U, 0x3731U, 0x3831U, 0x3931U,
 0x6131U, 0x6231U, 0x6331U, 0x6431U, 0x6531U, 0x6631U, 0x3032U, 0x3132U, 0x3232U, 0x3332U, 0x3432U, 0x3532U, 0x3632U,
 0x3732U, 0x3832U, 0x3932U, 0x6132U, 0x6232U, 0x6332U, 0x6432U, 0x6532U, 0x6632U, 0x3033U, 0x3133U, 0x3233U, 0x3333U,
 0x3433U, 0x3533U, 0x3633U, 0x3733U, 0x3833U, 0x3933U, 0x6133U, 0x6233U, 0x6333U, 0x6433U, 0x6533U, 0x6633U, 0x3034U,
 0x3134U, 0x3234U, 0x3334U, 0x3434U, 0x3534U, 0x3634U, 0x3734U, 0x3834U, 0x3934U, 0x6134U, 0x6234U, 0x6334U, 0x6434U,
 0x6534U, 0x6634U, 0x3035U, 0x3135U, 0x3235U, 0x3335U, 0x3435U, 0x3535U, 0x3635U, 0x3735U, 0x3835U, 0x3935U, 0x6135U,
 0x6235U, 0x6335U, 0x6435U, 0x6535U, 0x6635U, 0x3036U, 0x3136U, 0x3236U, 0x3336U, 0x3436U, 0x3536U, 0x3636U, 0x3736U,
 0x3836U, 0x3936U, 0x6136U, 0x6236U, 0x6336U, 0x6436U, 0x6536U, 0x6636U, 0x3037U, 0x3137U, 0x3237U, 0x3337U, 0x3437U,
 0x3537U, 0x3637U, 0x3737U, 0x3837U, 0x3937U, 0x6137U, 0x6237U, 0x6337U, 0x6437U, 0x6537U, 0x6637U, 0x3038U, 0x3138U,
 0x3238U, 0x3338U, 0x3438U, 0x3538U, 0x3638U, 0x3738U, 0x3838U, 0x3938U, 0x6138U, 0x6238U, 0x6338U, 0x6438U, 0x6538U,
 0x6638U, 0x3039U, 0x3139U, 0x3239U, 0x3339U, 0x3439U, 0x3539U, 0x3639U, 0x3739U, 0x3839U, 0x3939U, 0x6139U, 0x6239U,
 0x6339U, 0x6439U, 0x6539U, 0x6639U, 0x3061U, 0x3161U, 0x3261U, 0x3361U, 0x3461U, 0x3561U, 0x3661U, 0x3761U, 0x3861U,
 0x3961U, 0x6161U, 0x6261U, 0x6361U, 0x6461U, 0x6561U, 0x6661U, 0x3062U, 0x3162U, 0x3262U, 0x3362U, 0x3462U, 0x3562U,
 0x3662U, 0x3762U, 0x3862U, 0x3962U, 0x6162U, 0x6262U, 0x6362U, 0x6462U, 0x6562U, 0x6662U, 0x3063U, 0x3163U, 0x3263U,
 0x3363U, 0x3463U, 0x3563U, 0x3663U, 0x3763U, 0x3863U, 0x3963U, 0x6163U, 0x6263U, 0x6363U, 0x6463U, 0x6563U, 0x6663U,
 0x3064U, 0x3164U, 0x3264U, 0x3364U, 0x3464U, 0x3564U, 0x3664U, 0x3764U, 0x3864U, 0x3964U, 0x6164U, 0x6264U, 0x6364U,
 0x6464U, 0x6564U, 0x6664U, 0x3065U, 0x3165U, 0x3265U, 0x3365U, 0x3465U, 0x3565U, 0x3665U, 0x3765U, 0x3865U, 0x3965U,
 0x6165U, 0x6265U, 0x6365U, 0x6465U, 0x6565U, 0x6665U, 0x3066U, 0x3166U, 0x3266U, 0x3366U, 0x3466U, 0x3566U, 0x3666U,
 0x3766U, 0x3866U, 0x3966U, 0x6166U, 0x6266U, 0x6366U, 0x6466U, 0x6566U, 0x6666U

};
# 159 "duk_util_misc.c"
static __attribute__ ((unused)) duk_double_t duk_util_get_random_double(duk_hthread *thr) {



 return duk_util_tinyrandom_get_double(thr);

}
# 1 "duk_hobject_class.c"
# 96 "duk_hobject_class.c"
static __attribute__ ((unused)) duk_uint8_t duk_class_number_to_stridx[32] = {
 15,
 4,
 6,
 5,
 3,
 8,
 10,
 12,
 14,
 13,
 9,
 11,
 7,
 27,
 2,
 28,
 29,
 31,
 32,
 16,
 17,
 18,
 19,
 20,
 21,
 22,
 23,
 24,
 25,
 26,
 15,
 15,
};
# 1 "duk_alloc_default.c"
# 11 "duk_alloc_default.c"
static __attribute__ ((unused)) void *duk_default_alloc_function(void *udata, duk_size_t size) {
 void *res;
 do { (void) (udata); } while (0);
 res = malloc(size);
 do { } while (0);
 return res;
}

static __attribute__ ((unused)) void *duk_default_realloc_function(void *udata, void *ptr, duk_size_t newsize) {
 void *res;
 do { (void) (udata); } while (0);
 res = realloc(ptr, newsize);
 do { } while (0);
 return res;
}

static __attribute__ ((unused)) void duk_default_free_function(void *udata, void *ptr) {
 do { } while (0);
 do { (void) (udata); } while (0);
 free(ptr);
}
# 1 "duk_api_buffer.c"






__attribute__ ((visibility("default"))) void *duk_resize_buffer(duk_hthread *thr, duk_idx_t idx, duk_size_t new_size) {
 duk_hbuffer_dynamic *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hbuffer_dynamic *) duk_require_hbuffer(thr, idx);
 do { } while (0);

 if (!((((&(h)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) && !(((&(h)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0))) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 16; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_buffer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("wrong buffer type"))); } while (0); } while (0);
  do { return 
# 17 "duk_api_buffer.c" 3 4
 ((void *)0)
# 17 "duk_api_buffer.c"
 ; } while (0);
 }


 duk_hbuffer_resize(thr, h, new_size);

 return ((h)->curr_alloc);
}

__attribute__ ((visibility("default"))) void *duk_steal_buffer(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size) {
 duk_hbuffer_dynamic *h;
 void *ptr;
 duk_size_t sz;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hbuffer_dynamic *) duk_require_hbuffer(thr, idx);
 do { } while (0);

 if (!((((&(h)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) && !(((&(h)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0))) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 37; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_buffer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("wrong buffer type"))); } while (0); } while (0);
  do { return 
# 38 "duk_api_buffer.c" 3 4
 ((void *)0)
# 38 "duk_api_buffer.c"
 ; } while (0);
 }






 ptr = ((h)->curr_alloc);
 sz = (((duk_hbuffer *) ((duk_hbuffer *) (h)))->size);
 if (out_size) {
  *out_size = sz;
 }
 do { (h)->curr_alloc = (void *) 
# 51 "duk_api_buffer.c" 3 4
((void *)0)
# 51 "duk_api_buffer.c"
; } while (0);
 do { ((duk_hbuffer *) ((duk_hbuffer *) (h)))->size = ((0)); } while (0);

 return ptr;
}

__attribute__ ((visibility("default"))) void duk_config_buffer(duk_hthread *thr, duk_idx_t idx, void *ptr, duk_size_t len) {
 duk_hbuffer_external *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hbuffer_external *) duk_require_hbuffer(thr, idx);
 do { } while (0);

 if (!(((&(h)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0)) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 66; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_buffer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("wrong buffer type"))); } while (0); } while (0);
  do { return; } while (0);
 }
 do { } while (0);

 do { (h)->curr_alloc = (void *) (ptr); } while (0);
 do { ((duk_hbuffer *) ((duk_hbuffer *) (h)))->size = ((len)); } while (0);
}
# 1 "duk_api_bytecode.c"
# 27 "duk_api_bytecode.c"
static const duk_uint8_t *duk__load_string_raw(duk_hthread *thr, const duk_uint8_t *p) {
 duk_uint32_t len;

 len = duk_raw_readinc_u32_be(&(p));;
 duk_push_lstring(thr, (const char *) p, len);
 p += len;
 return p;
}

static const duk_uint8_t *duk__load_buffer_raw(duk_hthread *thr, const duk_uint8_t *p) {
 duk_uint32_t len;
 duk_uint8_t *buf;

 len = duk_raw_readinc_u32_be(&(p));;
 buf = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, (duk_size_t) len);
 do { } while (0);
 do { void *duk__dst = ((void *) buf); const void *duk__src = ((const void *) p); duk_size_t duk__len = ((size_t) len); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 p += len;
 return p;
}

static duk_uint8_t *duk__dump_hstring_raw(duk_uint8_t *p, duk_hstring *h) {
 duk_size_t len;
 duk_uint32_t tmp32;

 do { } while (0);

 len = ((h)->blen);
 do { } while (0);
 tmp32 = (duk_uint32_t) len;
 duk_raw_writeinc_u32_be(&(p), (duk_uint32_t) (tmp32));
 do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) ((const duk_uint8_t *) ((h) + 1))); duk_size_t duk__len = (len); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 p += len;
 return p;
}

static duk_uint8_t *duk__dump_hbuffer_raw(duk_hthread *thr, duk_uint8_t *p, duk_hbuffer *h) {
 duk_size_t len;
 duk_uint32_t tmp32;

 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);

 len = (((duk_hbuffer *) (h))->size);
 do { } while (0);
 tmp32 = (duk_uint32_t) len;
 duk_raw_writeinc_u32_be(&(p), (duk_uint32_t) (tmp32));

 do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) ((((&((h))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h))) + 1)))); duk_size_t duk__len = (len); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0);
 p += len;
 return p;
}

static duk_uint8_t *duk__dump_string_prop(duk_hthread *thr,
                                             duk_uint8_t *p,
                                             duk_bufwriter_ctx *bw_ctx,
                                             duk_hobject *func,
                                             duk_small_uint_t stridx) {
 duk_hstring *h_str;
 duk_tval *tv;

 tv = duk_hobject_find_entry_tval_ptr_stridx(thr->heap, (duk_hobject *) func, stridx);
 if (tv != 
# 90 "duk_api_bytecode.c" 3 4
          ((void *)0) 
# 90 "duk_api_bytecode.c"
               && ((tv)->t == 8)) {
  h_str = ((tv)->v.hstring);
  do { } while (0);
 } else {
  h_str = (((thr))->strs[(15)]);
  do { } while (0);
 }
 do { } while (0);
 p = (((duk_size_t) ((bw_ctx)->p_limit - (p)) >= (4U + ((h_str)->blen))) ? (p) : ((bw_ctx)->p = (p), duk_bw_resize((thr), (bw_ctx), (4U + ((h_str)->blen)))));
 p = duk__dump_hstring_raw(p, h_str);
 return p;
}

static duk_uint8_t *duk__dump_buffer_prop(duk_hthread *thr,
                                             duk_uint8_t *p,
                                             duk_bufwriter_ctx *bw_ctx,
                                             duk_hobject *func,
                                             duk_small_uint_t stridx) {
 duk_tval *tv;

 tv = duk_hobject_find_entry_tval_ptr_stridx(thr->heap, (duk_hobject *) func, stridx);
 if (tv != 
# 111 "duk_api_bytecode.c" 3 4
          ((void *)0) 
# 111 "duk_api_bytecode.c"
               && ((tv)->t == 10)) {
  duk_hbuffer *h_buf;
  h_buf = ((tv)->v.hbuffer);
  do { } while (0);
  do { } while (0);
  p = (((duk_size_t) ((bw_ctx)->p_limit - (p)) >= (4U + (((duk_hbuffer *) (h_buf))->size))) ? (p) : ((bw_ctx)->p = (p), duk_bw_resize((thr), (bw_ctx), (4U + (((duk_hbuffer *) (h_buf))->size)))));
  p = duk__dump_hbuffer_raw(thr, p, h_buf);
 } else {
  p = (((duk_size_t) ((bw_ctx)->p_limit - (p)) >= (4U)) ? (p) : ((bw_ctx)->p = (p), duk_bw_resize((thr), (bw_ctx), (4U))));
  duk_raw_writeinc_u32_be(&(p), (duk_uint32_t) (0));
 }
 return p;
}

static duk_uint8_t *duk__dump_uint32_prop(duk_hthread *thr,
                                             duk_uint8_t *p,
                                             duk_bufwriter_ctx *bw_ctx,
                                             duk_hobject *func,
                                             duk_small_uint_t stridx,
                                             duk_uint32_t def_value) {
 duk_tval *tv;
 duk_uint32_t val;

 tv = duk_hobject_find_entry_tval_ptr_stridx(thr->heap, (duk_hobject *) func, stridx);
 if (tv != 
# 135 "duk_api_bytecode.c" 3 4
          ((void *)0) 
# 135 "duk_api_bytecode.c"
               && ((tv)->t == 0)) {
  val = (duk_uint32_t) ((tv)->v.d);
 } else {
  val = def_value;
 }
 p = (((duk_size_t) ((bw_ctx)->p_limit - (p)) >= (4U)) ? (p) : ((bw_ctx)->p = (p), duk_bw_resize((thr), (bw_ctx), (4U))));
 duk_raw_writeinc_u32_be(&(p), (duk_uint32_t) (val));
 return p;
}

static duk_uint8_t *duk__dump_varmap(duk_hthread *thr, duk_uint8_t *p, duk_bufwriter_ctx *bw_ctx, duk_hobject *func) {
 duk_hobject *h;

 h = duk_hobject_get_varmap(thr, (duk_hobject *) func);
 if (h != 
# 149 "duk_api_bytecode.c" 3 4
         ((void *)0)
# 149 "duk_api_bytecode.c"
             ) {
  duk_uint_fast32_t i;






  for (i = 0; i < (duk_uint_fast32_t) ((h)->e_next); i++) {
   duk_hstring *key;
   duk_tval *tv_val;
   duk_uint32_t val;

   key = (((duk_hstring **) (void *) (((((h)))->props) + ((((h)))->e_size) * sizeof(duk_propvalue)))[(i)]);
   do { } while (0);
   do { } while (0);
   tv_val = (&(((duk_propvalue *) (void *) ((((((h))))->props)))[((i))]).v);
   do { } while (0);
   do { } while (0);






   val = (duk_uint32_t) ((tv_val)->v.d);


   do { } while (0);
   p = (((duk_size_t) ((bw_ctx)->p_limit - (p)) >= (4U + ((key)->blen) + 4U)) ? (p) : ((bw_ctx)->p = (p), duk_bw_resize((thr), (bw_ctx), (4U + ((key)->blen) + 4U))));
   p = duk__dump_hstring_raw(p, key);
   duk_raw_writeinc_u32_be(&(p), (duk_uint32_t) (val));
  }
 }
 p = (((duk_size_t) ((bw_ctx)->p_limit - (p)) >= (4U)) ? (p) : ((bw_ctx)->p = (p), duk_bw_resize((thr), (bw_ctx), (4U))));
 duk_raw_writeinc_u32_be(&(p), (duk_uint32_t) (0));
 return p;
}

static duk_uint8_t *duk__dump_formals(duk_hthread *thr, duk_uint8_t *p, duk_bufwriter_ctx *bw_ctx, duk_hobject *func) {
 duk_harray *h;

 h = duk_hobject_get_formals(thr, (duk_hobject *) func);
 if (h != 
# 192 "duk_api_bytecode.c" 3 4
         ((void *)0)
# 192 "duk_api_bytecode.c"
             ) {
  duk_uint32_t i;







  p = (((duk_size_t) ((bw_ctx)->p_limit - (p)) >= (4U)) ? (p) : ((bw_ctx)->p = (p), duk_bw_resize((thr), (bw_ctx), (4U))));
  do { } while (0);
  duk_raw_writeinc_u32_be(&(p), (duk_uint32_t) (h->length));

  for (i = 0; i < h->length; i++) {
   duk_tval *tv_val;
   duk_hstring *varname;

   tv_val = (&((duk_tval *) (void *) ((((((duk_hobject *) h)))->props) + (((((duk_hobject *) h)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - ((((((duk_hobject *) h)))->e_size))) & 0x07)))[(i)]);
   do { } while (0);
   do { } while (0);

   varname = ((tv_val)->v.hstring);
   do { } while (0);
   do { } while (0);

   do { } while (0);
   p = (((duk_size_t) ((bw_ctx)->p_limit - (p)) >= (4U + ((varname)->blen))) ? (p) : ((bw_ctx)->p = (p), duk_bw_resize((thr), (bw_ctx), (4U + ((varname)->blen)))));
   p = duk__dump_hstring_raw(p, varname);
  }
 } else {
  do { } while (0);
  p = (((duk_size_t) ((bw_ctx)->p_limit - (p)) >= (4U)) ? (p) : ((bw_ctx)->p = (p), duk_bw_resize((thr), (bw_ctx), (4U))));
  duk_raw_writeinc_u32_be(&(p), (duk_uint32_t) (0xffffffffUL));
 }
 return p;
}

static duk_uint8_t *duk__dump_func(duk_hthread *thr, duk_hcompfunc *func, duk_bufwriter_ctx *bw_ctx, duk_uint8_t *p) {
 duk_tval *tv, *tv_end;
 duk_instr_t *ins, *ins_end;
 duk_hobject **fn, **fn_end;
 duk_hstring *h_str;
 duk_uint32_t count_instr;
 duk_uint32_t tmp32;
 duk_uint16_t tmp16;
 duk_double_t d;

 do { } while (0)
# 256 "duk_api_bytecode.c"
                                                                          ;

 do { } while (0);
 count_instr = (duk_uint32_t) ((duk_size_t) (((duk_size_t) (((const duk_uint8_t *) ((duk_instr_t *) (void *) (((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) (((duk_hbuffer_fixed *) (void *) ((((func))))->data))) + 1)) + (((duk_hbuffer *) ((duk_hbuffer *) ((duk_hbuffer_fixed *) (void *) (((func)))->data)))->size)))) - ((const duk_uint8_t *) (((((func))))->bytecode)))) / sizeof(duk_instr_t)));
 p = (((duk_size_t) ((bw_ctx)->p_limit - (p)) >= (3U * 4U + 2U * 2U + 3U * 4U + count_instr * 4U)) ? (p) : ((bw_ctx)->p = (p), duk_bw_resize((thr), (bw_ctx), (3U * 4U + 2U * 2U + 3U * 4U + count_instr * 4U))));


 tmp32 = count_instr;
 duk_raw_writeinc_u32_be(&(p), (duk_uint32_t) (tmp32));
 tmp32 = (duk_uint32_t) ((duk_size_t) (((duk_size_t) (((const duk_uint8_t *) ((duk_tval *) (void *) (((((func))))->funcs))) - ((const duk_uint8_t *) ((duk_tval *) (void *) ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) (((duk_hbuffer_fixed *) (void *) (((((func)))))->data))) + 1)))))) / sizeof(duk_tval)));
 duk_raw_writeinc_u32_be(&(p), (duk_uint32_t) (tmp32));
 tmp32 = (duk_uint32_t) ((duk_size_t) (((duk_size_t) (((const duk_uint8_t *) ((duk_hobject **) (void *) (((((func))))->bytecode))) - ((const duk_uint8_t *) (((((func))))->funcs)))) / sizeof(duk_hobject *)));
 duk_raw_writeinc_u32_be(&(p), (duk_uint32_t) (tmp32));
 tmp16 = func->nregs;
 duk_raw_writeinc_u16_be(&(p), (duk_uint16_t) (tmp16));
 tmp16 = func->nargs;
 duk_raw_writeinc_u16_be(&(p), (duk_uint16_t) (tmp16));






 duk_raw_writeinc_u32_be(&(p), (duk_uint32_t) (0));
 duk_raw_writeinc_u32_be(&(p), (duk_uint32_t) (0));

 tmp32 = (((duk_heaphdr *) func)->h_flags & (~0x00000003UL));
 tmp32 &= ~((1UL << (7 + (14))));
 duk_raw_writeinc_u32_be(&(p), (duk_uint32_t) (tmp32));




 ins = (((func))->bytecode);
 ins_end = ((duk_instr_t *) (void *) (((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) (((duk_hbuffer_fixed *) (void *) ((func))->data))) + 1)) + (((duk_hbuffer *) ((duk_hbuffer *) ((duk_hbuffer_fixed *) (void *) (func)->data)))->size)));
 do { } while (0);





 while (ins != ins_end) {
  tmp32 = (duk_uint32_t) (*ins);
  duk_raw_writeinc_u32_be(&(p), (duk_uint32_t) (tmp32));
  ins++;
 }



 tv = ((duk_tval *) (void *) ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) (((duk_hbuffer_fixed *) (void *) (((func)))->data))) + 1)));
 tv_end = ((duk_tval *) (void *) (((func))->funcs));
 while (tv != tv_end) {

  do { } while (0);

  if (((tv)->t == 8)) {
   h_str = ((tv)->v.hstring);
   do { } while (0);
   do { } while (0);
   p = (((duk_size_t) ((bw_ctx)->p_limit - (p)) >= (1U + 4U + ((h_str)->blen))) ? (p) : ((bw_ctx)->p = (p), duk_bw_resize((thr), (bw_ctx), (1U + 4U + ((h_str)->blen)))));
   *p++ = 0x00;
   p = duk__dump_hstring_raw(p, h_str);
  } else {
   do { } while (0);
   p = (((duk_size_t) ((bw_ctx)->p_limit - (p)) >= (1U + 8U)) ? (p) : ((bw_ctx)->p = (p), duk_bw_resize((thr), (bw_ctx), (1U + 8U))));
   *p++ = 0x01;
   d = ((tv)->v.d);
   duk_raw_writeinc_double_be(&(p), (duk_double_t) (d));
  }
  tv++;
 }


 fn = (duk_hobject **) (((func))->funcs);
 fn_end = (duk_hobject **) ((duk_hobject **) (void *) (((func))->bytecode));
 while (fn != fn_end) {






  do { } while (0);
  p = duk__dump_func(thr, (duk_hcompfunc *) *fn, bw_ctx, p);
  fn++;
 }
# 352 "duk_api_bytecode.c"
 p = duk__dump_uint32_prop(thr, p, bw_ctx, (duk_hobject *) func, 87, (duk_uint32_t) func->nargs);

 p = duk__dump_string_prop(thr, p, bw_ctx, (duk_hobject *) func, 93);


 p = duk__dump_string_prop(thr, p, bw_ctx, (duk_hobject *) func, 94);


 p = duk__dump_buffer_prop(thr, p, bw_ctx, (duk_hobject *) func, 102);

 p = duk__dump_varmap(thr, p, bw_ctx, (duk_hobject *) func);
 p = duk__dump_formals(thr, p, bw_ctx, (duk_hobject *) func);

 do { } while (0);

 return p;
}
# 385 "duk_api_bytecode.c"
static const duk_uint8_t *duk__load_func(duk_hthread *thr, const duk_uint8_t *p, const duk_uint8_t *p_end) {
 duk_hcompfunc *h_fun;
 duk_hbuffer *h_data;
 duk_size_t data_size;
 duk_uint32_t count_instr, count_const, count_funcs;
 duk_uint32_t n;
 duk_uint32_t tmp32;
 duk_small_uint_t const_type;
 duk_uint8_t *fun_data;
 duk_uint8_t *q;
 duk_idx_t idx_base;
 duk_tval *tv1;
 duk_uarridx_t arr_idx;
 duk_uarridx_t arr_limit;
 duk_hobject *func_env;
 duk_bool_t need_pop;






 do { } while (0);

 do { } while (0);

 do { do { } while (0); } while (0);
 count_instr = duk_raw_readinc_u32_be(&(p));;
 count_const = duk_raw_readinc_u32_be(&(p));;
 count_funcs = duk_raw_readinc_u32_be(&(p));;

 data_size = sizeof(duk_tval) * count_const + sizeof(duk_hobject *) * count_funcs + sizeof(duk_instr_t) * count_instr;

 do { } while (0)



                                      ;





 duk_require_stack(thr, (duk_idx_t) (2 + count_const + count_funcs));
 idx_base = duk_get_top(thr);




 h_fun = duk_push_hcompfunc(thr);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 h_fun->nregs = duk_raw_readinc_u16_be(&(p));;
 h_fun->nargs = duk_raw_readinc_u16_be(&(p));;




 p += 8;



 tmp32 = duk_raw_readinc_u32_be(&(p));;
 do { ((duk_heaphdr *) h_fun)->h_flags = (((duk_heaphdr *) h_fun)->h_flags & ~((~0x00000003UL))) | (tmp32); } while (0);


 do { } while (0);





 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 fun_data = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, data_size);
 do { } while (0);


 do { } while (0);
 do { do { } while (0); } while (0);





 q = fun_data + sizeof(duk_tval) * count_const + sizeof(duk_hobject *) * count_funcs;
 for (n = count_instr; n > 0; n--) {
  *((duk_instr_t *) (void *) q) = duk_raw_readinc_u32_be(&(p));;
  q += sizeof(duk_instr_t);
 }



 for (n = count_const; n > 0; n--) {
  do { do { } while (0); } while (0);
  const_type = ((duk_uint8_t) (*(p)++));
  switch (const_type) {
  case 0x00: {
   p = duk__load_string_raw(thr, p);
   break;
  }
  case 0x01: {



   duk_tval tv_tmp;
   duk_double_t val;
   do { do { } while (0); } while (0);
   val = duk_raw_readinc_double_be(&(p));;
   do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((val)); ; duk__tv = ((&tv_tmp)); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0);
   duk_push_tval(thr, &tv_tmp);
   break;
  }
  default: {
   goto format_error;
  }
  }
 }


 for (n = count_funcs; n > 0; n--) {
  p = duk__load_func(thr, p, p_end);
  if (p == 
# 521 "duk_api_bytecode.c" 3 4
          ((void *)0)
# 521 "duk_api_bytecode.c"
              ) {
   goto format_error;
  }
 }
# 535 "duk_api_bytecode.c"
 h_data = (duk_hbuffer *) duk_known_hbuffer(thr, idx_base + 1);
 do { } while (0);
 do { (h_fun)->data = (duk_hbuffer *) (h_data); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_data))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);

 tv1 = duk_get_tval(thr, idx_base + 2);
 do { } while (0);

 q = fun_data;
 do { void *duk__dst = ((void *) q); const void *duk__src = ((const void *) tv1); duk_size_t duk__len = (sizeof(duk_tval) * count_const); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0);
 for (n = count_const; n > 0; n--) {
  do { duk_tval *duk__tv = ((duk_tval *) (void *) q); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  q += sizeof(duk_tval);
 }
 tv1 += count_const;

 do { (h_fun)->funcs = ((duk_hobject **) (void *) q); } while (0);
 for (n = count_funcs; n > 0; n--) {
  duk_hobject *h_obj;

  do { } while (0);
  h_obj = ((tv1)->v.hobject);
  do { } while (0);
  tv1++;
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_obj))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);

  *((duk_hobject **) (void *) q) = h_obj;
  q += sizeof(duk_hobject *);
 }

 do { (h_fun)->bytecode = ((duk_instr_t *) (void *) q); } while (0);




 do { } while (0);
 duk_set_top(thr, idx_base + 1);


 tmp32 = duk_raw_readinc_u32_be(&(p));;
 duk_push_uint((thr), (duk_uint_t) (tmp32));
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (87)) << 8) + (duk_uint_t) (((1U << 2)))));


 p = duk__load_string_raw(thr, p);
 func_env = thr->builtins[1];
 do { } while (0);
 need_pop = 0;
 if ((((&((duk_hobject *) h_fun)->hdr)->h_flags & ((1UL << (7 + (12))))) != 0)) {




  duk_hdecenv *new_env;

  new_env =
      duk_hdecenv_alloc(thr, (1UL << (7 + (0))) | (((duk_uint_t) (16)) << (7 + (20))));
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { ((duk_hobject *) new_env)->prototype = (func_env); } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (func_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);

  func_env = (duk_hobject *) new_env;

  duk_push_hobject(thr, (duk_hobject *) new_env);

  duk_dup_m2(thr);
  duk_dup(thr, idx_base);
  duk_xdef_prop(thr, -3, 0);

  need_pop = 1;
 }
 do { } while (0);
 do { (h_fun)->lex_env = (func_env); } while (0);
 do { (h_fun)->var_env = (func_env); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (func_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (func_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 if (need_pop) {
  duk_pop(thr);
 }
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (93)) << 8) + (duk_uint_t) (((1U << 2)))));



 p = duk__load_string_raw(thr, p);
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (94)) << 8) + (duk_uint_t) (((1U << 2)))));


 if ((((&((duk_hobject *) h_fun)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0)) {




  duk_push_object(thr);
  do { } while (0);
  duk_dup_m2(thr);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (51)) << 8) + (duk_uint_t) (((1U << 0) | (1U << 2)))))


                                                   ;
  duk_compact_m1(thr);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (50)) << 8) + (duk_uint_t) (((1U << 0)))));
 }


 p = duk__load_buffer_raw(thr, p);
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (102)) << 8) + (duk_uint_t) (((1U << 0) | (1U << 2)))));


 duk_push_bare_object(thr);
 for (;;) {

  p = duk__load_string_raw(thr, p);
  if (duk_get_length(thr, -1) == 0) {
   duk_pop(thr);
   break;
  }
  tmp32 = duk_raw_readinc_u32_be(&(p));;
  duk_push_uint((thr), (duk_uint_t) (tmp32));
  duk_put_prop(thr, -3);
 }
 duk_compact_m1(thr);
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (100)) << 8) + (duk_uint_t) (0)));




 arr_limit = duk_raw_readinc_u32_be(&(p));;
 if (arr_limit != 0xffffffffUL) {
  duk_push_bare_array(thr);
  for (arr_idx = 0; arr_idx < arr_limit; arr_idx++) {
   p = duk__load_string_raw(thr, p);
   duk_put_prop_index(thr, -2, arr_idx);
  }
  duk_compact_m1(thr);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (99)) << 8) + (duk_uint_t) (0)));
 } else {
  do { } while (0);
 }


 do { } while (0);
 do { } while (0);
 return p;

format_error:
 return 
# 685 "duk_api_bytecode.c" 3 4
       ((void *)0)
# 685 "duk_api_bytecode.c"
           ;
}

__attribute__ ((visibility("default"))) void duk_dump_function(duk_hthread *thr) {
 duk_hcompfunc *func;
 duk_bufwriter_ctx bw_ctx_alloc;
 duk_bufwriter_ctx *bw_ctx = &bw_ctx_alloc;
 duk_uint8_t *p;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);





 func = duk_require_hcompfunc(thr, -1);
 do { } while (0);
 do { } while (0);




 do { duk_bw_init_pushbuf((thr), (bw_ctx), (256)); } while (0);
 p = ((bw_ctx)->p);
 *p++ = 0xbf;
 p = duk__dump_func(thr, func, bw_ctx, p);
 do { (bw_ctx)->p = (p); } while (0);
 do { duk_bw_compact((thr), (bw_ctx)); } while (0);

 do { } while (0);

 duk_remove_m2(thr);
}

__attribute__ ((visibility("default"))) void duk_load_function(duk_hthread *thr) {
 const duk_uint8_t *p_buf, *p, *p_end;
 duk_size_t sz;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 p_buf = (duk_uint8_t *) duk_require_buffer(thr, -1, &sz);
 do { } while (0);
# 737 "duk_api_bytecode.c"
 p = p_buf;
 p_end = p_buf + sz;
 if (sz < 1 || p[0] != 0xbf) {
  goto format_error;
 }
 p++;

 p = duk__load_func(thr, p, p_end);
 if (p == 
# 745 "duk_api_bytecode.c" 3 4
         ((void *)0)
# 745 "duk_api_bytecode.c"
             ) {
  goto format_error;
 }

 duk_remove_m2(thr);
 return;

format_error:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 753; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_bytecode.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid bytecode"))); } while (0); } while (0);
 do { return; } while (0);
}
# 1 "duk_api_call.c"
# 23 "duk_api_call.c"
struct duk__pcall_prop_args {
 duk_idx_t obj_idx;
 duk_idx_t nargs;
 duk_small_uint_t call_flags;
};
typedef struct duk__pcall_prop_args duk__pcall_prop_args;

struct duk__pcall_method_args {
 duk_idx_t nargs;
 duk_small_uint_t call_flags;
};
typedef struct duk__pcall_method_args duk__pcall_method_args;

struct duk__pcall_args {
 duk_idx_t nargs;
 duk_small_uint_t call_flags;
};
typedef struct duk__pcall_args duk__pcall_args;





static duk_idx_t duk__call_get_idx_func(duk_hthread *thr, duk_idx_t nargs, duk_idx_t other) {
 duk_idx_t idx_func;



 do { } while (0);

 idx_func = duk_get_top(thr) - nargs - other;
 if (__builtin_expect(((idx_func | nargs) < 0), 0)) {
  do { duk_err_type_invalid_args((thr), "duk_api_call.c", (duk_int_t) 55); } while (0);
  do { return 0; } while (0);
 }
 do { } while (0);
 return idx_func;
}





static duk_idx_t duk__call_get_idx_func_unvalidated(duk_hthread *thr, duk_idx_t nargs, duk_idx_t other) {
 duk_idx_t idx_func;



 do { } while (0);
 do { } while (0);

 idx_func = duk_get_top(thr) - nargs - other;
 do { } while (0);
 do { } while (0);
 return idx_func;
}




static void duk__call_prop_prep_stack(duk_hthread *thr, duk_idx_t normalized_obj_idx, duk_idx_t nargs) {
 do { } while (0);
 do { } while (0);

 do { } while (0)


                                               ;




 duk_dup(thr, -nargs - 1);
 (void) duk_get_prop(thr, normalized_obj_idx);

 do { } while (0);


 if (__builtin_expect((!duk_is_function((thr), (-1))), 0)) {
  duk_tval *tv_base;
  duk_tval *tv_key;


  tv_base = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (normalized_obj_idx));
  tv_key = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-nargs - 2));
  do { } while (0);
  do { } while (0);

  duk_call_setup_propcall_error(thr, tv_base, tv_key);
 }




 duk_replace(thr, -nargs - 2);



 duk_dup(thr, normalized_obj_idx);
 duk_insert(thr, -nargs - 1);


}

__attribute__ ((visibility("default"))) void duk_call(duk_hthread *thr, duk_idx_t nargs) {
 duk_small_uint_t call_flags;
 duk_idx_t idx_func;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 idx_func = duk__call_get_idx_func(thr, nargs, 1);
 do { } while (0);

 duk_insert_undefined(thr, idx_func + 1);

 call_flags = 0;
 duk_handle_call_unprotected(thr, idx_func, call_flags);
}

__attribute__ ((visibility("default"))) void duk_call_method(duk_hthread *thr, duk_idx_t nargs) {
 duk_small_uint_t call_flags;
 duk_idx_t idx_func;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 idx_func = duk__call_get_idx_func(thr, nargs, 2);
 do { } while (0);

 call_flags = 0;
 duk_handle_call_unprotected(thr, idx_func, call_flags);
}

__attribute__ ((visibility("default"))) void duk_call_prop(duk_hthread *thr, duk_idx_t obj_idx, duk_idx_t nargs) {







 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 if (__builtin_expect((nargs < 0), 0)) {
  do { duk_err_type_invalid_args((thr), "duk_api_call.c", (duk_int_t) 167); } while (0);
  do { return; } while (0);
 }

 duk__call_prop_prep_stack(thr, obj_idx, nargs);

 duk_call_method(thr, nargs);
}

static duk_ret_t duk__pcall_raw(duk_hthread *thr, void *udata) {
 duk__pcall_args *args;
 duk_idx_t idx_func;
 duk_int_t ret;

 do { } while (0);
 do { } while (0);

 args = (duk__pcall_args *) udata;
 idx_func = duk__call_get_idx_func_unvalidated(thr, args->nargs, 1);
 do { } while (0);

 duk_insert_undefined(thr, idx_func + 1);

 ret = duk_handle_call_unprotected(thr, idx_func, args->call_flags);
 do { } while (0);
 do { (void) (ret); } while (0);

 return 1;
}

__attribute__ ((visibility("default"))) duk_int_t duk_pcall(duk_hthread *thr, duk_idx_t nargs) {
 duk__pcall_args args;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 args.nargs = nargs;
 if (__builtin_expect((nargs < 0), 0)) {
  do { duk_err_type_invalid_args((thr), "duk_api_call.c", (duk_int_t) 204); } while (0);
  do { return 1; } while (0);
 }
 args.call_flags = 0;

 return duk_safe_call(thr, duk__pcall_raw, (void *) &args , nargs + 1 , 1 );
}

static duk_ret_t duk__pcall_method_raw(duk_hthread *thr, void *udata) {
 duk__pcall_method_args *args;
 duk_idx_t idx_func;
 duk_int_t ret;

 do { } while (0);
 do { } while (0);

 args = (duk__pcall_method_args *) udata;

 idx_func = duk__call_get_idx_func_unvalidated(thr, args->nargs, 2);
 do { } while (0);

 ret = duk_handle_call_unprotected(thr, idx_func, args->call_flags);
 do { } while (0);
 do { (void) (ret); } while (0);

 return 1;
}

static __attribute__ ((unused)) duk_int_t duk_pcall_method_flags(duk_hthread *thr, duk_idx_t nargs, duk_small_uint_t call_flags) {
 duk__pcall_method_args args;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 args.nargs = nargs;
 if (__builtin_expect((nargs < 0), 0)) {
  do { duk_err_type_invalid_args((thr), "duk_api_call.c", (duk_int_t) 239); } while (0);
  do { return 1; } while (0);
 }
 args.call_flags = call_flags;

 return duk_safe_call(thr, duk__pcall_method_raw, (void *) &args , nargs + 2 , 1 );
}

__attribute__ ((visibility("default"))) duk_int_t duk_pcall_method(duk_hthread *thr, duk_idx_t nargs) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 return duk_pcall_method_flags(thr, nargs, 0);
}

static duk_ret_t duk__pcall_prop_raw(duk_hthread *thr, void *udata) {
 duk__pcall_prop_args *args;
 duk_idx_t obj_idx;
 duk_int_t ret;

 do { } while (0);
 do { } while (0);

 args = (duk__pcall_prop_args *) udata;

 obj_idx = duk_require_normalize_index(thr, args->obj_idx);
 duk__call_prop_prep_stack(thr, obj_idx, args->nargs);

 ret = duk_handle_call_unprotected_nargs(thr, args->nargs, args->call_flags);
 do { } while (0);
 do { (void) (ret); } while (0);
 return 1;
}

__attribute__ ((visibility("default"))) duk_int_t duk_pcall_prop(duk_hthread *thr, duk_idx_t obj_idx, duk_idx_t nargs) {
 duk__pcall_prop_args args;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 args.obj_idx = obj_idx;
 args.nargs = nargs;
 if (__builtin_expect((nargs < 0), 0)) {
  do { duk_err_type_invalid_args((thr), "duk_api_call.c", (duk_int_t) 280); } while (0);
  do { return 1; } while (0);
 }
 args.call_flags = 0;

 return duk_safe_call(thr, duk__pcall_prop_raw, (void *) &args , nargs + 1 , 1 );
}

__attribute__ ((visibility("default"))) duk_int_t duk_safe_call(duk_hthread *thr, duk_safe_call_function func, void *udata, duk_idx_t nargs, duk_idx_t nrets) {
 duk_int_t rc;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
# 301 "duk_api_call.c"
 if (__builtin_expect(((nargs | nrets) < 0 || thr->valstack_top < thr->valstack_bottom + nargs || thr->valstack_end + nargs < thr->valstack_top + nrets), 0)

                                                                        ) {
  do { } while (0)
# 315 "duk_api_call.c"
                                 ;
  do { duk_err_type_invalid_args((thr), "duk_api_call.c", (duk_int_t) 316); } while (0);
  do { return 1; } while (0);
 }

 rc = duk_handle_safe_call(thr,
                           func,
                           udata,
                           nargs,
                           nrets);

 return rc;
}

__attribute__ ((visibility("default"))) void duk_new(duk_hthread *thr, duk_idx_t nargs) {
 duk_idx_t idx_func;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 idx_func = duk__call_get_idx_func(thr, nargs, 1);
 do { } while (0);

 duk_push_object(thr);
 duk_insert(thr, idx_func + 1);

 duk_handle_call_unprotected(thr, idx_func, (1U << 1));
}

static duk_ret_t duk__pnew_helper(duk_hthread *thr, void *udata) {
 duk_idx_t nargs;

 do { } while (0);
 nargs = *((duk_idx_t *) udata);

 duk_new(thr, nargs);
 return 1;
}

__attribute__ ((visibility("default"))) duk_int_t duk_pnew(duk_hthread *thr, duk_idx_t nargs) {
 duk_int_t rc;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);






 if (__builtin_expect((nargs < 0), 0)) {
  do { duk_err_type_invalid_args((thr), "duk_api_call.c", (duk_int_t) 364); } while (0);
  do { return 1; } while (0);
 }

 rc = duk_safe_call(thr, duk__pnew_helper, (void *) &nargs , nargs + 1 , 1 );
 return rc;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_constructor_call(duk_hthread *thr) {
 duk_activation *act;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 act = thr->callstack_curr;
 if (act != 
# 378 "duk_api_call.c" 3 4
           ((void *)0)
# 378 "duk_api_call.c"
               ) {
  return ((act->flags & (1U << 2)) != 0 ? 1 : 0);
 }
 return 0;
}

__attribute__ ((visibility("default"))) void duk_require_constructor_call(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 if (!duk_is_constructor_call(thr)) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 388; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_call.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("constructor requires 'new'"))); } while (0); } while (0);
  do { return; } while (0);
 }
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_strict_call(duk_hthread *thr) {
 duk_activation *act;
# 405 "duk_api_call.c"
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 act = thr->callstack_curr;
 if (act != 
# 408 "duk_api_call.c" 3 4
           ((void *)0)
# 408 "duk_api_call.c"
               ) {
  return ((act->flags & (1U << 0)) != 0 ? 1 : 0);
 } else {

  return 1;
 }
}





__attribute__ ((visibility("default"))) duk_int_t duk_get_current_magic(duk_hthread *thr) {
 duk_activation *act;
 duk_hobject *func;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 act = thr->callstack_curr;
 if (act) {
  func = ((act)->func);
  if (!func) {
   duk_tval *tv = &act->tv_func;
   duk_small_uint_t lf_flags;
   lf_flags = ((duk_small_uint_t) ((tv)->v_extra));
   return (duk_int_t) ((duk_int32_t) (duk_int8_t) (((duk_uint16_t) (lf_flags)) >> 8));
  }
  do { } while (0);

  if ((((&(func)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)) {
   duk_hnatfunc *nf = (duk_hnatfunc *) func;
   return (duk_int_t) nf->magic;
  }
 }
 return 0;
}

__attribute__ ((visibility("default"))) duk_int_t duk_get_magic(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;
 duk_hobject *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_require_tval(thr, idx);
 if (((tv)->t == 9)) {
  h = ((tv)->v.hobject);
  do { } while (0);
  if (!(((&(h)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)) {
   goto type_error;
  }
  return (duk_int_t) ((duk_hnatfunc *) h)->magic;
 } else if (((tv)->t == 6)) {
  duk_small_uint_t lf_flags = ((duk_small_uint_t) ((tv)->v_extra));
  return (duk_int_t) ((duk_int32_t) (duk_int8_t) (((duk_uint16_t) (lf_flags)) >> 8));
 }


type_error:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 466; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_call.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("unexpected type"))); } while (0); } while (0);
 do { return 0; } while (0);
}

__attribute__ ((visibility("default"))) void duk_set_magic(duk_hthread *thr, duk_idx_t idx, duk_int_t magic) {
 duk_hnatfunc *nf;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 nf = duk_require_hnatfunc(thr, idx);
 do { } while (0);
 nf->magic = (duk_int16_t) magic;
}
# 487 "duk_api_call.c"
static __attribute__ ((unused)) void duk_resolve_nonbound_function(duk_hthread *thr) {
 duk_tval *tv;

 do { } while (0);

 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));
 if (((tv)->t == 9)) {
  duk_hobject *h;

  h = ((tv)->v.hobject);
  do { } while (0);
  if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0)) {
   duk_push_tval(thr, &((duk_hboundfunc *) (void *) h)->target);
   duk_replace(thr, -2);
# 511 "duk_api_call.c"
   do { } while (0);
  }
 }




}
# 1 "duk_api_codec.c"
# 20 "duk_api_codec.c"
static const duk_uint8_t *duk__prep_codec_arg(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_len) {
 const void *def_ptr = (const void *) out_len;
 const void *ptr;
 duk_bool_t isbuffer;

 do { } while (0);
 do { } while (0);
 do { } while (0);

 ptr = (const void *)
     duk_get_buffer_data_raw(thr, idx, out_len, 
# 30 "duk_api_codec.c" 3 4
                                               ((void *)0) 
# 30 "duk_api_codec.c"
                                                               , 0 , 0 , &isbuffer);
 if (isbuffer) {
  do { } while (0);
  if (__builtin_expect((ptr == 
# 33 "duk_api_codec.c" 3 4
     ((void *)0)
# 33 "duk_api_codec.c"
     ), 0)) {
   ptr = def_ptr;
  }
  do { } while (0);
 } else {



  ptr = (const void *) duk_to_lstring(thr, idx, out_len);
  do { } while (0);
 }
 do { } while (0);
 return (const duk_uint8_t *) ptr;
}







static const duk_int8_t duk__base64_decode_nequal_step[5] = {
 3,
 2,
 1,
 -1,
 0,
};


static const duk_uint8_t duk__base64_enctab_fast[64] = {
 0x41U, 0x42U, 0x43U, 0x44U, 0x45U, 0x46U, 0x47U, 0x48U, 0x49U, 0x4aU, 0x4bU, 0x4cU, 0x4dU, 0x4eU, 0x4fU, 0x50U,
 0x51U, 0x52U, 0x53U, 0x54U, 0x55U, 0x56U, 0x57U, 0x58U, 0x59U, 0x5aU, 0x61U, 0x62U, 0x63U, 0x64U, 0x65U, 0x66U,
 0x67U, 0x68U, 0x69U, 0x6aU, 0x6bU, 0x6cU, 0x6dU, 0x6eU, 0x6fU, 0x70U, 0x71U, 0x72U, 0x73U, 0x74U, 0x75U, 0x76U,
 0x77U, 0x78U, 0x79U, 0x7aU, 0x30U, 0x31U, 0x32U, 0x33U, 0x34U, 0x35U, 0x36U, 0x37U, 0x38U, 0x39U, 0x2bU, 0x2fU
};
# 78 "duk_api_codec.c"
static const duk_int8_t duk__base64_dectab_fast[256] = {
 -3, -3, -3, -3, -3, -3, -3, -3, -3, -1, -1, -3, -3, -1, -3, -3,
 -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,
 -1, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, 62, -3, -3, -3, 63,
 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -3, -3, -3, -2, -3, -3,
 -3, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,
 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -3, -3, -3, -3, -3,
 -3, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -3, -3, -3, -3, -3,
 -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,
 -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,
 -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,
 -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,
 -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,
 -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,
 -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3,
 -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3, -3
};



static inline __attribute__((always_inline)) void duk__base64_encode_fast_3(const duk_uint8_t *src, duk_uint8_t *dst) {
 duk_uint_t t;

 t = (duk_uint_t) src[0];
 t = (t << 8) + (duk_uint_t) src[1];
 t = (t << 8) + (duk_uint_t) src[2];

 dst[0] = duk__base64_enctab_fast[t >> 18];
 dst[1] = duk__base64_enctab_fast[(t >> 12) & 0x3fU];
 dst[2] = duk__base64_enctab_fast[(t >> 6) & 0x3fU];
 dst[3] = duk__base64_enctab_fast[t & 0x3fU];
# 121 "duk_api_codec.c"
}

static inline __attribute__((always_inline)) void duk__base64_encode_fast_2(const duk_uint8_t *src, duk_uint8_t *dst) {
 duk_uint_t t;

 t = (duk_uint_t) src[0];
 t = (t << 8) + (duk_uint_t) src[1];
 dst[0] = duk__base64_enctab_fast[t >> 10];
 dst[1] = duk__base64_enctab_fast[(t >> 4) & 0x3fU];
 dst[2] = duk__base64_enctab_fast[(t << 2) & 0x3fU];
 dst[3] = 0x3d;
}

static inline __attribute__((always_inline)) void duk__base64_encode_fast_1(const duk_uint8_t *src, duk_uint8_t *dst) {
 duk_uint_t t;

 t = (duk_uint_t) src[0];
 dst[0] = duk__base64_enctab_fast[t >> 2];
 dst[1] = duk__base64_enctab_fast[(t << 4) & 0x3fU];
 dst[2] = 0x3d;
 dst[3] = 0x3d;
}

static void duk__base64_encode_helper(const duk_uint8_t *src, duk_size_t srclen, duk_uint8_t *dst) {
 duk_size_t n;
 const duk_uint8_t *p;
 duk_uint8_t *q;

 n = srclen;
 p = src;
 q = dst;

 if (n >= 16U) {





  const duk_uint8_t *p_end_fast;

  p_end_fast = p + ((n / 12U) * 12U);
  do { } while (0);
  do {
   duk__base64_encode_fast_3(p, q);
   duk__base64_encode_fast_3(p + 3, q + 4);
   duk__base64_encode_fast_3(p + 6, q + 8);
   duk__base64_encode_fast_3(p + 9, q + 12);
   p += 12;
   q += 16;
  } while (__builtin_expect((p != p_end_fast), 1));

  do { } while (0);
  n = (duk_size_t) (src + srclen - p);
  do { } while (0);
 }


 while (n >= 3U) {
  duk__base64_encode_fast_3(p, q);
  p += 3;
  q += 4;
  n -= 3U;
 }
 do { } while (0);
 if (n == 1U) {
  duk__base64_encode_fast_1(p, q);





 } else if (n == 2U) {
  duk__base64_encode_fast_2(p, q);





 } else {
  do { } while (0);
  ;
 }
}
# 279 "duk_api_codec.c"
static duk_bool_t duk__base64_decode_helper(const duk_uint8_t *src,
                                               duk_size_t srclen,
                                               duk_uint8_t *dst,
                                               duk_uint8_t **out_dst_final) {
 duk_int_t x;
 duk_uint_t t;
 duk_small_uint_t n_equal;
 duk_int8_t step;
 const duk_uint8_t *p;
 const duk_uint8_t *p_end;
 const duk_uint8_t *p_end_safe;
 duk_uint8_t *q;

 do { } while (0);

 p = src;
 p_end = src + srclen;
 p_end_safe = p_end - 8;
 q = dst;







 for (;;) {







  while (__builtin_expect((p <= p_end_safe), 1)) {
   duk_int_t t1, t2;
# 325 "duk_api_codec.c"
   do { } while (0)


                                              ;

   t1 = (duk_int_t) duk__base64_dectab_fast[p[0]];
   t1 = (duk_int_t) ((duk_uint_t) t1 << 6) | (duk_int_t) duk__base64_dectab_fast[p[1]];
   t1 = (duk_int_t) ((duk_uint_t) t1 << 6) | (duk_int_t) duk__base64_dectab_fast[p[2]];
   t1 = (duk_int_t) ((duk_uint_t) t1 << 6) | (duk_int_t) duk__base64_dectab_fast[p[3]];

   t2 = (duk_int_t) duk__base64_dectab_fast[p[4]];
   t2 = (duk_int_t) ((duk_uint_t) t2 << 6) | (duk_int_t) duk__base64_dectab_fast[p[5]];
   t2 = (duk_int_t) ((duk_uint_t) t2 << 6) | (duk_int_t) duk__base64_dectab_fast[p[6]];
   t2 = (duk_int_t) ((duk_uint_t) t2 << 6) | (duk_int_t) duk__base64_dectab_fast[p[7]];

   q[0] = (duk_uint8_t) (((duk_uint_t) t1 >> 16) & 0xffU);
   q[1] = (duk_uint8_t) (((duk_uint_t) t1 >> 8) & 0xffU);
   q[2] = (duk_uint8_t) ((duk_uint_t) t1 & 0xffU);

   q[3] = (duk_uint8_t) (((duk_uint_t) t2 >> 16) & 0xffU);
   q[4] = (duk_uint8_t) (((duk_uint_t) t2 >> 8) & 0xffU);
   q[5] = (duk_uint8_t) ((duk_uint_t) t2 & 0xffU);


   if (__builtin_expect(((t1 | t2) >= 0), 1)) {
    p += 8;
    q += 6;
   } else if (t1 >= 0) {
    do { } while (0)
                                                                                                     ;
    do { } while (0);
    p += 4;
    q += 3;
    break;
   } else {
    do { } while (0)
                                                                                                    ;
    do { } while (0);
    break;
   }
  }
# 377 "duk_api_codec.c"
  t = 1UL;
  for (;;) {
   do { } while (0)


                                           ;

   if (__builtin_expect((p < p_end), 1)) {
    x = duk__base64_dectab_fast[*p++];
    if (__builtin_expect((x >= 0), 1)) {
     do { } while (0);
     t = (t << 6) + (duk_uint_t) x;
     if (t >= 0x1000000UL) {
      break;
     }
    } else if (x == -1) {
     continue;
    } else if (x == -2) {
     p--;
     break;
    } else {
     do { } while (0);
     goto decode_error;
    }
   } else {
    break;
   }
  }




  n_equal = 0;
  while (t < 0x1000000UL) {
   t = (t << 6) + 0U;
   n_equal++;
  }
# 427 "duk_api_codec.c"
  q[0] = (duk_uint8_t) ((t >> 16) & 0xffU);
  q[1] = (duk_uint8_t) ((t >> 8) & 0xffU);
  q[2] = (duk_uint8_t) (t & 0xffU);

  do { } while (0);
  step = duk__base64_decode_nequal_step[n_equal];
  if (__builtin_expect((step < 0), 0)) {
   goto decode_error;
  }
  q += step;
# 457 "duk_api_codec.c"
  for (;;) {
   if (__builtin_expect((p >= p_end), 0)) {
    goto done;
   }
   x = duk__base64_dectab_fast[*p++];
   if (x == -1 || x == -2) {
    ;
   } else {
    p--;
    break;
   }
  }
 }

done:
 do { } while (0);

 do { } while (0);

 *out_dst_final = q;
 return 1;

decode_error:
 return 0;
}
# 626 "duk_api_codec.c"
__attribute__ ((visibility("default"))) const char *duk_base64_encode(duk_hthread *thr, duk_idx_t idx) {
 const duk_uint8_t *src;
 duk_size_t srclen;
 duk_size_t dstlen;
 duk_uint8_t *dst;
 const char *ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);
 src = duk__prep_codec_arg(thr, idx, &srclen);
 do { } while (0);







 if (srclen > 3221225469UL) {
  goto type_error;
 }
 dstlen = (srclen + 2U) / 3U * 4U;
 dst = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, dstlen);

 duk__base64_encode_helper((const duk_uint8_t *) src, srclen, dst);

 ret = duk_buffer_to_string(thr, -1);
 duk_replace(thr, idx);
 return ret;

type_error:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 658; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_codec.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("base64 encode failed"))); } while (0); } while (0);
 do { return 
# 659 "duk_api_codec.c" 3 4
((void *)0)
# 659 "duk_api_codec.c"
; } while (0);
}

__attribute__ ((visibility("default"))) void duk_base64_decode(duk_hthread *thr, duk_idx_t idx) {
 const duk_uint8_t *src;
 duk_size_t srclen;
 duk_size_t dstlen;
 duk_uint8_t *dst;
 duk_uint8_t *dst_final;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);
 src = duk__prep_codec_arg(thr, idx, &srclen);
 do { } while (0);
# 682 "duk_api_codec.c"
 dstlen = (srclen / 4) * 3 + 6;
 dst = (duk_uint8_t *) duk_push_buffer_raw((thr), (dstlen), (1 << 0) );


 if (!duk__base64_decode_helper((const duk_uint8_t *) src, srclen, dst, &dst_final)) {
  goto type_error;
 }


 (void) duk_resize_buffer(thr, -1, (duk_size_t) (dst_final - dst));
 duk_replace(thr, idx);
 return;

type_error:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 696; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_codec.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("base64 decode failed"))); } while (0); } while (0);
 do { return; } while (0);
}
# 718 "duk_api_codec.c"
__attribute__ ((visibility("default"))) const char *duk_hex_encode(duk_hthread *thr, duk_idx_t idx) {
 const duk_uint8_t *inp;
 duk_size_t len;
 duk_size_t i;
 duk_uint8_t *buf;
 const char *ret;

 duk_size_t len_safe;
 duk_uint16_t *p16;


 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);
 inp = duk__prep_codec_arg(thr, idx, &len);
 do { } while (0);


 buf = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, len * 2);
 do { } while (0);


 do { } while (0);
 p16 = (duk_uint16_t *) (void *) buf;
 len_safe = len & ~0x03U;
 for (i = 0; i < len_safe; i += 4) {
  p16[0] = duk_hex_enctab[inp[i]];
  p16[1] = duk_hex_enctab[inp[i + 1]];
  p16[2] = duk_hex_enctab[inp[i + 2]];
  p16[3] = duk_hex_enctab[inp[i + 3]];
  p16 += 4;
 }
 for (; i < len; i++) {
  *p16++ = duk_hex_enctab[inp[i]];
 }
# 769 "duk_api_codec.c"
 ret = duk_buffer_to_string(thr, -1);
 duk_replace(thr, idx);
 return ret;
}

__attribute__ ((visibility("default"))) void duk_hex_decode(duk_hthread *thr, duk_idx_t idx) {
 const duk_uint8_t *inp;
 duk_size_t len;
 duk_size_t i;
 duk_int_t t;
 duk_uint8_t *buf;

 duk_int_t chk;
 duk_uint8_t *p;
 duk_size_t len_safe;


 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);
 inp = duk__prep_codec_arg(thr, idx, &len);
 do { } while (0);

 if (len & 0x01) {
  goto type_error;
 }


 buf = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, len / 2);
 do { } while (0);


 p = buf;
 len_safe = len & ~0x07U;
 for (i = 0; i < len_safe; i += 8) {
  t = ((duk_int_t) duk_hex_dectab_shift4[inp[i]]) | ((duk_int_t) duk_hex_dectab[inp[i + 1]]);
  chk = t;
  p[0] = (duk_uint8_t) t;
  t = ((duk_int_t) duk_hex_dectab_shift4[inp[i + 2]]) | ((duk_int_t) duk_hex_dectab[inp[i + 3]]);
  chk |= t;
  p[1] = (duk_uint8_t) t;
  t = ((duk_int_t) duk_hex_dectab_shift4[inp[i + 4]]) | ((duk_int_t) duk_hex_dectab[inp[i + 5]]);
  chk |= t;
  p[2] = (duk_uint8_t) t;
  t = ((duk_int_t) duk_hex_dectab_shift4[inp[i + 6]]) | ((duk_int_t) duk_hex_dectab[inp[i + 7]]);
  chk |= t;
  p[3] = (duk_uint8_t) t;
  p += 4;


  if (__builtin_expect((chk < 0), 0)) {
   goto type_error;
  }
 }
 for (; i < len; i += 2) {




  t = (duk_int_t) ((((duk_uint_t) (duk_int_t) duk_hex_dectab[inp[i]]) << 4U) |
                   ((duk_uint_t) (duk_int_t) duk_hex_dectab[inp[i + 1]]));
  if (__builtin_expect((t < 0), 0)) {
   goto type_error;
  }
  *p++ = (duk_uint8_t) t;
 }
# 850 "duk_api_codec.c"
 duk_replace(thr, idx);
 return;

type_error:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 854; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_codec.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("hex decode failed"))); } while (0); } while (0);
 do { return; } while (0);
}
# 875 "duk_api_codec.c"
__attribute__ ((visibility("default"))) const char *duk_json_encode(duk_hthread *thr, duk_idx_t idx) {



 const char *ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);




 idx = duk_require_normalize_index(thr, idx);
 duk_bi_json_stringify_helper(thr,
                              idx ,
                              
# 889 "duk_api_codec.c" 3 4
                             (-0x7fffffff - 1) 
# 889 "duk_api_codec.c"
                                                               ,
                              
# 890 "duk_api_codec.c" 3 4
                             (-0x7fffffff - 1) 
# 890 "duk_api_codec.c"
                                                            ,
                              0 );
 do { } while (0);
 duk_replace(thr, idx);
 ret = duk_get_string(thr, idx);

 do { } while (0);

 return ret;
}

__attribute__ ((visibility("default"))) void duk_json_decode(duk_hthread *thr, duk_idx_t idx) {




 do { do { } while (0); do { } while (0); do { } while (0); } while (0);




 idx = duk_require_normalize_index(thr, idx);
 duk_bi_json_parse_helper(thr, idx , 
# 912 "duk_api_codec.c" 3 4
                                                 (-0x7fffffff - 1) 
# 912 "duk_api_codec.c"
                                                                                  , 0 );
 duk_replace(thr, idx);

 do { } while (0);
}
# 1 "duk_api_compile.c"






typedef struct duk__compile_raw_args duk__compile_raw_args;
struct duk__compile_raw_args {
 duk_size_t src_length;
 const duk_uint8_t *src_buffer;
 duk_uint_t flags;
};


__attribute__ ((visibility("default"))) duk_int_t duk_eval_raw(duk_hthread *thr, const char *src_buffer, duk_size_t src_length, duk_uint_t flags) {
 duk_int_t rc;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
# 29 "duk_api_compile.c"
 rc = duk_compile_raw(thr,
                      src_buffer,
                      src_length,
                      flags | (1U << 3));



 if (rc != 0) {
  rc = 1;
  goto got_rc;
 }

 duk_push_global_object(thr);

 if (flags & (1U << 7)) {
  rc = duk_pcall_method(thr, 0);
 } else {
  duk_call_method(thr, 0);
  rc = 0;
 }



got_rc:
 if (flags & (1U << 8)) {
  duk_pop(thr);
 }

 return rc;
}


static duk_ret_t duk__do_compile(duk_hthread *thr, void *udata) {
 duk__compile_raw_args *comp_args;
 duk_uint_t flags;
 duk_hcompfunc *h_templ;

 do { } while (0);
 do { } while (0);
# 78 "duk_api_compile.c"
 comp_args = (duk__compile_raw_args *) udata;
 flags = comp_args->flags;

 if (flags & (1U << 11)) {

  duk_push_hstring_stridx(thr, (flags & (1U << 3)) ? 33 : 108);
 }



 if (!comp_args->src_buffer) {
  duk_hstring *h_sourcecode;

  h_sourcecode = duk_get_hstring(thr, -2);
  if ((flags & (1U << 9)) ||
      (h_sourcecode == 
# 93 "duk_api_compile.c" 3 4
                      ((void *)0)
# 93 "duk_api_compile.c"
                          )) {
   do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 94; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_compile.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("no sourcecode"))); } while (0); } while (0);
   do { return 0; } while (0);
  }
  do { } while (0);
  comp_args->src_buffer = (const duk_uint8_t *) ((const duk_uint8_t *) ((h_sourcecode) + 1));
  comp_args->src_length = (duk_size_t) ((h_sourcecode)->blen);
 }
 do { } while (0);

 if (flags & (1U << 4)) {
  flags |= (1U << 3) | (1U << 12);
 }



 duk_js_compile(thr, comp_args->src_buffer, comp_args->src_length, flags);



 if (flags & (1U << 9)) {
  ;
 } else {
  duk_remove_m2(thr);
 }



 h_templ = (duk_hcompfunc *) duk_known_hobject(thr, -1);
 duk_js_push_closure(thr,
                     h_templ,
                     thr->builtins[1],
                     thr->builtins[1],
                     1 );
 duk_remove_m2(thr);



 return 1;
}

__attribute__ ((visibility("default"))) duk_int_t duk_compile_raw(duk_hthread *thr, const char *src_buffer, duk_size_t src_length, duk_uint_t flags) {
 duk__compile_raw_args comp_args_alloc;
 duk__compile_raw_args *comp_args = &comp_args_alloc;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 if ((flags & (1U << 10)) && (src_buffer != 
# 140 "duk_api_compile.c" 3 4
                                                   ((void *)0)
# 140 "duk_api_compile.c"
                                                       )) {



  src_length = strlen(src_buffer);
 }

 comp_args->src_buffer = (const duk_uint8_t *) src_buffer;
 comp_args->src_length = src_length;
 comp_args->flags = flags;



 if (flags & (1U << 7)) {
  duk_int_t rc;
  duk_int_t nargs;
  duk_int_t nrets = 1;





  nargs = flags & 0x07;
  do { } while (0);
  rc = duk_safe_call(thr, duk__do_compile, (void *) comp_args, nargs, nrets);


  return rc;
 }

 (void) duk__do_compile(thr, (void *) comp_args);


 return 0;
}
# 1 "duk_api_debug.c"







__attribute__ ((visibility("default"))) void duk_push_context_dump(duk_hthread *thr) {
 duk_idx_t idx;
 duk_idx_t top;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);





 top = duk_get_top(thr);
 duk_push_bare_array(thr);
 for (idx = 0; idx < top; idx++) {
  duk_dup(thr, idx);
  duk_put_prop_index(thr, -2, (duk_uarridx_t) idx);
 }




 duk_bi_json_stringify_helper(thr,
                              duk_get_top_index(thr),
                              
# 30 "duk_api_debug.c" 3 4
                             (-0x7fffffff - 1)
# 30 "duk_api_debug.c"
                                              ,
                              
# 31 "duk_api_debug.c" 3 4
                             (-0x7fffffff - 1)
# 31 "duk_api_debug.c"
                                              ,
                              (1U << 2) | (1U << 0) |
                                  (1U << 1) );

 duk_push_sprintf(thr, "ctx: top=%ld, stack=%s", (long) top, (const char *) duk_safe_to_lstring((thr), (-1), 
# 35 "duk_api_debug.c" 3 4
                                                                           ((void *)0)
# 35 "duk_api_debug.c"
                                                                           ));
 duk_replace(thr, -3);
 duk_pop(thr);
 do { } while (0);
}
# 205 "duk_api_debug.c"
__attribute__ ((visibility("default"))) void duk_debugger_attach(duk_hthread *thr,
                                      duk_debug_read_function read_cb,
                                      duk_debug_write_function write_cb,
                                      duk_debug_peek_function peek_cb,
                                      duk_debug_read_flush_function read_flush_cb,
                                      duk_debug_write_flush_function write_flush_cb,
                                      duk_debug_request_function request_cb,
                                      duk_debug_detached_function detached_cb,
                                      void *udata) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { (void) (read_cb); } while (0);
 do { (void) (write_cb); } while (0);
 do { (void) (peek_cb); } while (0);
 do { (void) (read_flush_cb); } while (0);
 do { (void) (write_flush_cb); } while (0);
 do { (void) (request_cb); } while (0);
 do { (void) (detached_cb); } while (0);
 do { (void) (udata); } while (0);
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 223; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_debug.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("no debugger support"))); } while (0); } while (0);
 do { return; } while (0);
}

__attribute__ ((visibility("default"))) void duk_debugger_detach(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 229; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_debug.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("no debugger support"))); } while (0); } while (0);
 do { return; } while (0);
}

__attribute__ ((visibility("default"))) void duk_debugger_cooperate(duk_hthread *thr) {

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { (void) (thr); } while (0);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_debugger_notify(duk_hthread *thr, duk_idx_t nvalues) {
 duk_idx_t top;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 top = duk_get_top(thr);
 if (top < nvalues) {
  do { do { duk_err_range(((thr)), "duk_api_debug.c", (duk_int_t) 246, ("invalid count")); } while (0); } while (0);
  do { return 0; } while (0);
 }


 duk_pop_n(thr, nvalues);
 return 0;
}

__attribute__ ((visibility("default"))) void duk_debugger_pause(duk_hthread *thr) {

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { (void) (thr); } while (0);
}
# 1 "duk_api_heap.c"






typedef struct duk_internal_thread_state duk_internal_thread_state;

struct duk_internal_thread_state {
 duk_ljstate lj;
 duk_bool_t creating_error;
 duk_hthread *curr_thread;
 duk_uint8_t thread_state;
 duk_int_t call_recursion_depth;
};

__attribute__ ((visibility("default"))) duk_hthread *duk_create_heap(duk_alloc_function alloc_func,
                                          duk_realloc_function realloc_func,
                                          duk_free_function free_func,
                                          void *heap_udata,
                                          duk_fatal_function fatal_handler) {
 duk_heap *heap = 
# 22 "duk_api_heap.c" 3 4
                 ((void *)0)
# 22 "duk_api_heap.c"
                     ;
 duk_hthread *thr;
# 33 "duk_api_heap.c"
 if (!alloc_func) {
  do { } while (0);
  do { } while (0);

  alloc_func = duk_default_alloc_function;
  realloc_func = duk_default_realloc_function;
  free_func = duk_default_free_function;




 } else {
  do { } while (0);
  do { } while (0);
 }

 if (!fatal_handler) {
  fatal_handler = duk_default_fatal_handler;
 }

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 heap = duk_heap_alloc(alloc_func, realloc_func, free_func, heap_udata, fatal_handler);
 if (!heap) {
  return 
# 60 "duk_api_heap.c" 3 4
        ((void *)0)
# 60 "duk_api_heap.c"
            ;
 }
 thr = heap->heap_thread;
 do { } while (0);
 do { } while (0);
 return thr;
}

__attribute__ ((visibility("default"))) void duk_destroy_heap(duk_hthread *thr) {
 duk_heap *heap;

 if (!thr) {
  return;
 }
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 heap = thr->heap;
 do { } while (0);

 duk_heap_free(heap);
}

__attribute__ ((visibility("default"))) void duk_suspend(duk_hthread *thr, duk_thread_state *state) {
 duk_internal_thread_state *snapshot = (duk_internal_thread_state *) (void *) state;
 duk_heap *heap;
 duk_ljstate *lj;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);






 do { } while (0);




 do { } while (0);

 heap = thr->heap;
 lj = &heap->lj;

 duk_push_tval(thr, &lj->value1);
 duk_push_tval(thr, &lj->value2);


 do { void *duk__dst = ((void *) &snapshot->lj); const void *duk__src = ((const void *) lj); duk_size_t duk__len = (sizeof(duk_ljstate)); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 snapshot->creating_error = heap->creating_error;
 snapshot->curr_thread = heap->curr_thread;
 snapshot->thread_state = thr->state;
 snapshot->call_recursion_depth = heap->call_recursion_depth;

 lj->jmpbuf_ptr = 
# 115 "duk_api_heap.c" 3 4
                 ((void *)0)
# 115 "duk_api_heap.c"
                     ;
 lj->type = 0;
 do { duk_tval *duk__tv; duk__tv = (&lj->value1); duk__tv->t = 2; } while (0);
 do { duk_tval *duk__tv; duk__tv = (&lj->value2); duk__tv->t = 2; } while (0);
 heap->creating_error = 0;
 heap->curr_thread = 
# 120 "duk_api_heap.c" 3 4
                    ((void *)0)
# 120 "duk_api_heap.c"
                        ;
 heap->call_recursion_depth = 0;

 thr->state = 1;
}

__attribute__ ((visibility("default"))) void duk_resume(duk_hthread *thr, const duk_thread_state *state) {
 const duk_internal_thread_state *snapshot = (const duk_internal_thread_state *) (const void *) state;
 duk_heap *heap;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);




 do { } while (0);
 do { } while (0);

 thr->state = snapshot->thread_state;

 heap = thr->heap;

 do { void *duk__dst = ((void *) &heap->lj); const void *duk__src = ((const void *) &snapshot->lj); duk_size_t duk__len = (sizeof(duk_ljstate)); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 heap->creating_error = snapshot->creating_error;
 heap->curr_thread = snapshot->curr_thread;
 heap->call_recursion_depth = snapshot->call_recursion_depth;

 duk_pop_2(thr);
}


__attribute__ ((visibility("default"))) void duk_set_global_object(duk_hthread *thr) {
 duk_hobject *h_glob;
 duk_hobject *h_prev_glob;
 duk_hobjenv *h_env;
 duk_hobject *h_prev_env;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 do { } while (0);

 h_glob = duk_require_hobject(thr, -1);
 do { } while (0);





 h_prev_glob = thr->builtins[0];
 do { (void) (h_prev_glob); } while (0);
 thr->builtins[0] = h_glob;
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_glob))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 do { if ((h_prev_glob) != 
# 174 "duk_api_heap.c" 3 4
((void *)0)
# 174 "duk_api_heap.c"
) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((h_prev_glob))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
# 185 "duk_api_heap.c"
 h_env = duk_hobjenv_alloc(thr, (1UL << (7 + (0))) | (((duk_uint_t) (15)) << (7 + (20))));
 do { } while (0);
 do { } while (0);

 do { } while (0);
 do { } while (0);
 h_env->target = h_glob;
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_glob))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 do { } while (0);



 h_prev_env = thr->builtins[1];
 thr->builtins[1] = (duk_hobject *) h_env;
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk_hobject *) h_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 do { if ((h_prev_env) != 
# 200 "duk_api_heap.c" 3 4
((void *)0)
# 200 "duk_api_heap.c"
) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((h_prev_env))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
 do { (void) (h_env); } while (0);
 do { (void) (h_prev_env); } while (0);



 duk_pop(thr);


}
# 1 "duk_api_inspect.c"
# 10 "duk_api_inspect.c"
static void duk__inspect_multiple_uint(duk_hthread *thr, const char *fmt, duk_int_t *vals) {
 duk_int_t val;
 const char *p;
 const char *p_curr;
 duk_size_t len;

 for (p = fmt;;) {
  len = strlen(p);
  p_curr = p;
  p += len + 1;
  if (len == 0) {

   break;
  }
  val = *vals++;
  if (val >= 0) {

   duk_push_string(thr, p_curr);
   duk_push_int(thr, val);
   duk_put_prop(thr, -3);
  }
 }
}
# 57 "duk_api_inspect.c"
__attribute__ ((visibility("default"))) void duk_inspect_value(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;
 duk_heaphdr *h;




 duk_int_t vals[14];

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);


 do { void *duk__dst = ((void *) &vals); duk_small_int_t duk__val = ((int) 0xff); duk_size_t duk__len = (sizeof(vals)); do { } while (0); (void) memset(duk__dst, duk__val, (size_t) duk__len); } while (0);
 do { } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 h = (((tv)->t & 0x08) ? ((tv)->v.heaphdr) : 
# 73 "duk_api_inspect.c" 3 4
                                                                 ((void *)0)
# 73 "duk_api_inspect.c"
                                                                     );

 vals[0] = duk_get_type_tval(tv);
 vals[1] = (duk_int_t) ((tv)->t);

 duk_push_bare_object(thr);
 tv = 
# 79 "duk_api_inspect.c" 3 4
     ((void *)0)
# 79 "duk_api_inspect.c"
         ;

 if (h == 
# 81 "duk_api_inspect.c" 3 4
         ((void *)0)
# 81 "duk_api_inspect.c"
             ) {
  goto finish;
 }
 duk_push_pointer(thr, (void *) h);
 duk_put_prop_literal_raw((thr), (-2), ("hptr"), sizeof(("hptr")) - 1U);
# 94 "duk_api_inspect.c"
 vals[2] = (duk_int_t) ((h)->h_refcount);

 vals[13] = 0;




 switch ((duk_small_int_t) ((h)->h_flags & 0x00000003UL)) {
 case 0: {
  duk_hstring *h_str = (duk_hstring *) h;
  vals[3] = (duk_int_t) (sizeof(duk_hstring) + ((h_str)->blen) + 1);





  break;
 }
 case 1: {
  duk_hobject *h_obj = (duk_hobject *) h;


  if ((((&((h_obj))->hdr)->h_flags & ((1UL << (7 + (15))))) != 0)) {
   vals[3] = sizeof(duk_harray);
  } else if ((((&(h_obj)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
   vals[3] = sizeof(duk_hcompfunc);
  } else if ((((&(h_obj)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)) {
   vals[3] = sizeof(duk_hnatfunc);
  } else if (((((&((h_obj))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 18)) {
   vals[3] = sizeof(duk_hthread);
   vals[12] = ((duk_hthread *) h_obj)->state;

  } else if ((((&(h_obj)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {
   vals[3] = sizeof(duk_hbufobj);


  } else {
   vals[3] = (duk_small_uint_t) sizeof(duk_hobject);
  }

  vals[4] = (duk_int_t) (((&(h_obj)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL));
  vals[5] = (duk_int_t) (((((h_obj))->e_size)) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((h_obj))->e_size)))) & 0x07) + ((((h_obj))->a_size)) * sizeof(duk_tval) + ((((h_obj))->h_size)) * sizeof(duk_uint32_t));
  vals[6] = (duk_int_t) ((h_obj)->e_size);
  vals[7] = (duk_int_t) ((h_obj)->e_next);
  vals[8] = (duk_int_t) ((h_obj)->a_size);
  vals[9] = (duk_int_t) ((h_obj)->h_size);
# 149 "duk_api_inspect.c"
  if ((((&(h_obj)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
   duk_hbuffer *h_data = (duk_hbuffer *) ((duk_hbuffer_fixed *) (void *) ((duk_hcompfunc *) h_obj)->data);
   vals[10] = (duk_int_t) (h_data ? (((duk_hbuffer *) (h_data))->size) : 0);
  }
  break;
 }
 case 2: {
  duk_hbuffer *h_buf = (duk_hbuffer *) h;

  if ((((&(h_buf)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0)) {
   if ((((&(h_buf)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0)) {
    vals[13] = 2;
    vals[3] = (duk_uint_t) (sizeof(duk_hbuffer_external));
   } else {



    vals[13] = 1;
    vals[3] = (duk_uint_t) (sizeof(duk_hbuffer_dynamic));
   }
   vals[11] = (duk_int_t) ((((duk_hbuffer *) (h_buf))->size));
  } else {
   do { } while (0);
   vals[3] = (duk_int_t) (sizeof(duk_hbuffer_fixed) + (((duk_hbuffer *) (h_buf))->size));
  }
  break;
 }
 }

finish:
 duk__inspect_multiple_uint(thr,
                            "type"
                            "\x00"
                            "itag"
                            "\x00"
                            "refc"
                            "\x00"
                            "hbytes"
                            "\x00"
                            "class"
                            "\x00"
                            "pbytes"
                            "\x00"
                            "esize"
                            "\x00"
                            "enext"
                            "\x00"
                            "asize"
                            "\x00"
                            "hsize"
                            "\x00"
                            "bcbytes"
                            "\x00"
                            "dbytes"
                            "\x00"
                            "tstate"
                            "\x00"
                            "variant"
                            "\x00"
                            "\x00",
                            (duk_int_t *) &vals);
}

__attribute__ ((visibility("default"))) void duk_inspect_callstack_entry(duk_hthread *thr, duk_int_t level) {
 duk_activation *act;
 duk_uint_fast32_t pc;
 duk_uint_fast32_t line;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);





 act = duk_hthread_get_activation_for_level(thr, level);
 if (act == 
# 224 "duk_api_inspect.c" 3 4
           ((void *)0)
# 224 "duk_api_inspect.c"
               ) {
  duk_push_undefined(thr);
  return;
 }
 duk_push_bare_object(thr);





 pc = duk_hthread_get_act_prev_pc(thr, act);

 duk_push_tval(thr, &act->tv_func);

 duk_push_uint(thr, (duk_uint_t) pc);
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-3)) << 16) + ((duk_uint_t) (90))));


 line = duk_hobject_pc2line_query(thr, -1, pc);



 duk_push_uint(thr, (duk_uint_t) line);
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-3)) << 16) + ((duk_uint_t) (91))));

 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (133))));





}
# 1 "duk_api_memory.c"






__attribute__ ((visibility("default"))) void *duk_alloc_raw(duk_hthread *thr, duk_size_t size) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 return ((thr->heap)->alloc_func((thr->heap)->heap_udata, (size)));
}

__attribute__ ((visibility("default"))) void duk_free_raw(duk_hthread *thr, void *ptr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 ((thr->heap)->free_func((thr->heap)->heap_udata, (void *) (ptr)));
}

__attribute__ ((visibility("default"))) void *duk_realloc_raw(duk_hthread *thr, void *ptr, duk_size_t size) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 return ((thr->heap)->realloc_func((thr->heap)->heap_udata, (void *) (ptr), (size)));
}

__attribute__ ((visibility("default"))) void *duk_alloc(duk_hthread *thr, duk_size_t size) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 return duk_heap_mem_alloc((thr->heap), (size));
}

__attribute__ ((visibility("default"))) void duk_free(duk_hthread *thr, void *ptr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 duk_heap_mem_free((thr)->heap, (ptr));
}

__attribute__ ((visibility("default"))) void *duk_realloc(duk_hthread *thr, void *ptr, duk_size_t size) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
# 50 "duk_api_memory.c"
 return duk_heap_mem_realloc((thr->heap), (ptr), (size));
}

__attribute__ ((visibility("default"))) void duk_get_memory_functions(duk_hthread *thr, duk_memory_functions *out_funcs) {
 duk_heap *heap;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 heap = thr->heap;
 out_funcs->alloc_func = heap->alloc_func;
 out_funcs->realloc_func = heap->realloc_func;
 out_funcs->free_func = heap->free_func;
 out_funcs->udata = heap->heap_udata;
}

__attribute__ ((visibility("default"))) void duk_gc(duk_hthread *thr, duk_uint_t flags) {
 duk_heap *heap;
 duk_small_uint_t ms_flags;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 heap = thr->heap;
 do { } while (0);

 do { } while (0);
 do { } while (0);
 ms_flags = (duk_small_uint_t) flags;
 duk_heap_mark_and_sweep(heap, ms_flags);
}
# 1 "duk_api_object.c"
# 15 "duk_api_object.c"
__attribute__ ((visibility("default"))) duk_bool_t duk_get_prop(duk_hthread *thr, duk_idx_t obj_idx) {
 duk_tval *tv_obj;
 duk_tval *tv_key;
 duk_bool_t rc;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);





 tv_obj = duk_require_tval(thr, obj_idx);
 tv_key = duk_require_tval(thr, -1);

 rc = duk_hobject_getprop(thr, tv_obj, tv_key);
 do { } while (0);


 duk_remove_m2(thr);
 do { } while (0);
 return rc;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_get_prop_string(duk_hthread *thr, duk_idx_t obj_idx, const char *key) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_string(thr, key);
 return duk_get_prop(thr, obj_idx);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_get_prop_lstring(duk_hthread *thr, duk_idx_t obj_idx, const char *key, duk_size_t key_len) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_lstring(thr, key, key_len);
 return duk_get_prop(thr, obj_idx);
}


__attribute__ ((visibility("default"))) duk_bool_t duk_get_prop_literal_raw(duk_hthread *thr, duk_idx_t obj_idx, const char *key, duk_size_t key_len) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_literal_raw(thr, key, key_len);
 return duk_get_prop(thr, obj_idx);
}


__attribute__ ((visibility("default"))) duk_bool_t duk_get_prop_index(duk_hthread *thr, duk_idx_t obj_idx, duk_uarridx_t arr_idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 duk_push_uint((thr), (duk_uint_t) (arr_idx));
 return duk_get_prop(thr, obj_idx);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_get_prop_heapptr(duk_hthread *thr, duk_idx_t obj_idx, void *ptr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_heapptr(thr, ptr);
 return duk_get_prop(thr, obj_idx);
}

static __attribute__ ((unused)) duk_bool_t duk_get_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_hstring(thr, ((thr)->strs[(stridx)]));
 return duk_get_prop(thr, obj_idx);
}

static __attribute__ ((unused)) duk_bool_t duk_get_prop_stridx_short_raw(duk_hthread *thr, duk_uint_t packed_args) {
 return duk_get_prop_stridx(thr, (duk_idx_t) (duk_int16_t) (packed_args >> 16), (duk_small_uint_t) (packed_args & 0xffffUL));
}

static __attribute__ ((unused)) duk_bool_t duk_get_prop_stridx_boolean(duk_hthread *thr,
                                                    duk_idx_t obj_idx,
                                                    duk_small_uint_t stridx,
                                                    duk_bool_t *out_has_prop) {
 duk_bool_t rc;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 rc = duk_get_prop_stridx(thr, obj_idx, stridx);
 if (out_has_prop) {
  *out_has_prop = rc;
 }
 return duk_to_boolean_top_pop(thr);
}
# 122 "duk_api_object.c"
static __attribute__ ((unused)) duk_bool_t duk_xget_owndataprop(duk_hthread *thr, duk_idx_t obj_idx) {
 duk_hobject *h_obj;
 duk_hstring *h_key;
 duk_tval *tv_val;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);





 h_obj = duk_get_hobject(thr, obj_idx);
 if (h_obj == 
# 134 "duk_api_object.c" 3 4
             ((void *)0)
# 134 "duk_api_object.c"
                 ) {
  return 0;
 }
 h_key = duk_require_hstring(thr, -1);

 tv_val = duk_hobject_find_entry_tval_ptr(thr->heap, h_obj, h_key);
 if (tv_val == 
# 140 "duk_api_object.c" 3 4
              ((void *)0)
# 140 "duk_api_object.c"
                  ) {
  return 0;
 }

 duk_push_tval(thr, tv_val);
 duk_remove_m2(thr);

 return 1;
}

static __attribute__ ((unused)) duk_bool_t duk_xget_owndataprop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_hstring(thr, ((thr)->strs[(stridx)]));
 return duk_xget_owndataprop(thr, obj_idx);
}

static __attribute__ ((unused)) duk_bool_t duk_xget_owndataprop_stridx_short_raw(duk_hthread *thr, duk_uint_t packed_args) {
 return duk_xget_owndataprop_stridx(thr,
                                    (duk_idx_t) (duk_int16_t) (packed_args >> 16),
                                    (duk_small_uint_t) (packed_args & 0xffffUL));
}

static duk_bool_t duk__put_prop_shared(duk_hthread *thr, duk_idx_t obj_idx, duk_idx_t idx_key) {
 duk_tval *tv_obj;
 duk_tval *tv_key;
 duk_tval *tv_val;
 duk_bool_t throw_flag;
 duk_bool_t rc;
# 180 "duk_api_object.c"
 do { } while (0);

 tv_obj = duk_require_tval(thr, obj_idx);
 tv_key = duk_require_tval(thr, idx_key);
 tv_val = duk_require_tval(thr, idx_key ^ 1);
 throw_flag = duk_is_strict_call(thr);

 rc = duk_hobject_putprop(thr, tv_obj, tv_key, tv_val, throw_flag);
 do { } while (0);

 duk_pop_2(thr);
 return rc;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_put_prop(duk_hthread *thr, duk_idx_t obj_idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__put_prop_shared(thr, obj_idx, -2);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_put_prop_string(duk_hthread *thr, duk_idx_t obj_idx, const char *key) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);





 obj_idx = duk_normalize_index(thr, obj_idx);
 (void) duk_push_string(thr, key);
 return duk__put_prop_shared(thr, obj_idx, -1);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_put_prop_lstring(duk_hthread *thr, duk_idx_t obj_idx, const char *key, duk_size_t key_len) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj_idx = duk_normalize_index(thr, obj_idx);
 (void) duk_push_lstring(thr, key, key_len);
 return duk__put_prop_shared(thr, obj_idx, -1);
}


__attribute__ ((visibility("default"))) duk_bool_t duk_put_prop_literal_raw(duk_hthread *thr, duk_idx_t obj_idx, const char *key, duk_size_t key_len) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);

 obj_idx = duk_normalize_index(thr, obj_idx);
 (void) duk_push_literal_raw(thr, key, key_len);
 return duk__put_prop_shared(thr, obj_idx, -1);
}


__attribute__ ((visibility("default"))) duk_bool_t duk_put_prop_index(duk_hthread *thr, duk_idx_t obj_idx, duk_uarridx_t arr_idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 duk_push_uint((thr), (duk_uint_t) (arr_idx));
 return duk__put_prop_shared(thr, obj_idx, -1);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_put_prop_heapptr(duk_hthread *thr, duk_idx_t obj_idx, void *ptr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_heapptr(thr, ptr);
 return duk__put_prop_shared(thr, obj_idx, -1);
}

static __attribute__ ((unused)) duk_bool_t duk_put_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 duk_push_hstring(thr, ((thr)->strs[(stridx)]));
 return duk__put_prop_shared(thr, obj_idx, -1);
}

static __attribute__ ((unused)) duk_bool_t duk_put_prop_stridx_short_raw(duk_hthread *thr, duk_uint_t packed_args) {
 return duk_put_prop_stridx(thr, (duk_idx_t) (duk_int16_t) (packed_args >> 16), (duk_small_uint_t) (packed_args & 0xffffUL));
}

__attribute__ ((visibility("default"))) duk_bool_t duk_del_prop(duk_hthread *thr, duk_idx_t obj_idx) {
 duk_tval *tv_obj;
 duk_tval *tv_key;
 duk_bool_t throw_flag;
 duk_bool_t rc;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);





 tv_obj = duk_require_tval(thr, obj_idx);
 tv_key = duk_require_tval(thr, -1);
 throw_flag = duk_is_strict_call(thr);

 rc = duk_hobject_delprop(thr, tv_obj, tv_key, throw_flag);
 do { } while (0);

 duk_pop(thr);
 return rc;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_del_prop_string(duk_hthread *thr, duk_idx_t obj_idx, const char *key) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_string(thr, key);
 return duk_del_prop(thr, obj_idx);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_del_prop_lstring(duk_hthread *thr, duk_idx_t obj_idx, const char *key, duk_size_t key_len) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_lstring(thr, key, key_len);
 return duk_del_prop(thr, obj_idx);
}


__attribute__ ((visibility("default"))) duk_bool_t duk_del_prop_literal_raw(duk_hthread *thr, duk_idx_t obj_idx, const char *key, duk_size_t key_len) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_literal_raw(thr, key, key_len);
 return duk_del_prop(thr, obj_idx);
}


__attribute__ ((visibility("default"))) duk_bool_t duk_del_prop_index(duk_hthread *thr, duk_idx_t obj_idx, duk_uarridx_t arr_idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 duk_push_uint((thr), (duk_uint_t) (arr_idx));
 return duk_del_prop(thr, obj_idx);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_del_prop_heapptr(duk_hthread *thr, duk_idx_t obj_idx, void *ptr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_heapptr(thr, ptr);
 return duk_del_prop(thr, obj_idx);
}

static __attribute__ ((unused)) duk_bool_t duk_del_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 duk_push_hstring(thr, ((thr)->strs[(stridx)]));
 return duk_del_prop(thr, obj_idx);
}
# 347 "duk_api_object.c"
__attribute__ ((visibility("default"))) duk_bool_t duk_has_prop(duk_hthread *thr, duk_idx_t obj_idx) {
 duk_tval *tv_obj;
 duk_tval *tv_key;
 duk_bool_t rc;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);





 tv_obj = duk_require_tval(thr, obj_idx);
 tv_key = duk_require_tval(thr, -1);

 rc = duk_hobject_hasprop(thr, tv_obj, tv_key);
 do { } while (0);

 duk_pop(thr);
 return rc;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_has_prop_string(duk_hthread *thr, duk_idx_t obj_idx, const char *key) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_string(thr, key);
 return duk_has_prop(thr, obj_idx);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_has_prop_lstring(duk_hthread *thr, duk_idx_t obj_idx, const char *key, duk_size_t key_len) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_lstring(thr, key, key_len);
 return duk_has_prop(thr, obj_idx);
}


__attribute__ ((visibility("default"))) duk_bool_t duk_has_prop_literal_raw(duk_hthread *thr, duk_idx_t obj_idx, const char *key, duk_size_t key_len) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_literal_raw(thr, key, key_len);
 return duk_has_prop(thr, obj_idx);
}


__attribute__ ((visibility("default"))) duk_bool_t duk_has_prop_index(duk_hthread *thr, duk_idx_t obj_idx, duk_uarridx_t arr_idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 duk_push_uint((thr), (duk_uint_t) (arr_idx));
 return duk_has_prop(thr, obj_idx);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_has_prop_heapptr(duk_hthread *thr, duk_idx_t obj_idx, void *ptr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 (void) duk_push_heapptr(thr, ptr);
 return duk_has_prop(thr, obj_idx);
}

static __attribute__ ((unused)) duk_bool_t duk_has_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 duk_push_hstring(thr, ((thr)->strs[(stridx)]));
 return duk_has_prop(thr, obj_idx);
}
# 435 "duk_api_object.c"
static __attribute__ ((unused)) void duk_xdef_prop(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t desc_flags) {
 duk_hobject *obj;
 duk_hstring *key;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 obj = duk_require_hobject(thr, obj_idx);
 do { } while (0);
 key = duk_to_property_key_hstring(thr, -2);
 do { } while (0);
 do { } while (0);

 duk_hobject_define_property_internal(thr, obj, key, desc_flags);

 duk_pop(thr);
}

static __attribute__ ((unused)) void duk_xdef_prop_index(duk_hthread *thr, duk_idx_t obj_idx, duk_uarridx_t arr_idx, duk_small_uint_t desc_flags) {
 duk_hobject *obj;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 obj = duk_require_hobject(thr, obj_idx);
 do { } while (0);

 duk_hobject_define_property_internal_arridx(thr, obj, arr_idx, desc_flags);

}

static __attribute__ ((unused)) void duk_xdef_prop_stridx(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx, duk_small_uint_t desc_flags) {
 duk_hobject *obj;
 duk_hstring *key;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 obj = duk_require_hobject(thr, obj_idx);
 do { } while (0);
 key = ((thr)->strs[(stridx)]);
 do { } while (0);
 do { } while (0);

 duk_hobject_define_property_internal(thr, obj, key, desc_flags);

}

static __attribute__ ((unused)) void duk_xdef_prop_stridx_short_raw(duk_hthread *thr, duk_uint_t packed_args) {
 duk_xdef_prop_stridx(thr,
                      (duk_idx_t) (duk_int8_t) (packed_args >> 24),
                      (duk_small_uint_t) (packed_args >> 8) & 0xffffUL,
                      (duk_small_uint_t) (packed_args & 0xffL));
}
# 513 "duk_api_object.c"
static __attribute__ ((unused)) void duk_xdef_prop_stridx_thrower(duk_hthread *thr, duk_idx_t obj_idx, duk_small_uint_t stridx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 duk_push_hstring_stridx(thr, stridx);
 duk_push_hobject_bidx(thr, 33);
 duk_dup_top(thr);
 duk_def_prop(thr, obj_idx, (1U << 8) | (1U << 7) | (1U << 9));
}


__attribute__ ((visibility("default"))) void duk_get_prop_desc(duk_hthread *thr, duk_idx_t obj_idx, duk_uint_t flags) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { (void) (flags); } while (0);

 duk_hobject_object_get_own_property_descriptor(thr, obj_idx);
}


__attribute__ ((visibility("default"))) void duk_def_prop(duk_hthread *thr, duk_idx_t obj_idx, duk_uint_t flags) {
 duk_idx_t idx_base;
 duk_hobject *obj;
 duk_hstring *key;
 duk_idx_t idx_value;
 duk_hobject *get;
 duk_hobject *set;
 duk_uint_t is_data_desc;
 duk_uint_t is_acc_desc;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 obj = duk_require_hobject(thr, obj_idx);

 is_data_desc = flags & ((1U << 6) | (1U << 3));
 is_acc_desc = flags & ((1U << 7) | (1U << 8));
 if (is_data_desc && is_acc_desc) {




  goto fail_invalid_desc;
 }

 idx_base = duk_get_top_index(thr);
 if (flags & (1U << 8)) {
  ((void) duk_check_type_mask((thr), (idx_base), ((1U << 1U) | (1U << 6U) | (1U << 9U)) | (1U << 10)));
  set = duk_get_hobject_promote_mask((thr), (idx_base), (1U << 9U));
  if (set != 
# 560 "duk_api_object.c" 3 4
            ((void *)0) 
# 560 "duk_api_object.c"
                 && !(((&((set))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)) {
   goto fail_not_callable;
  }
  idx_base--;
 } else {
  set = 
# 565 "duk_api_object.c" 3 4
       ((void *)0)
# 565 "duk_api_object.c"
           ;
 }
 if (flags & (1U << 7)) {
  ((void) duk_check_type_mask((thr), (idx_base), ((1U << 1U) | (1U << 6U) | (1U << 9U)) | (1U << 10)));
  get = duk_get_hobject_promote_mask((thr), (idx_base), (1U << 9U));
  if (get != 
# 570 "duk_api_object.c" 3 4
            ((void *)0) 
# 570 "duk_api_object.c"
                 && !(((&((get))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)) {
   goto fail_not_callable;
  }
  idx_base--;
 } else {
  get = 
# 575 "duk_api_object.c" 3 4
       ((void *)0)
# 575 "duk_api_object.c"
           ;
 }
 if (flags & (1U << 6)) {
  idx_value = idx_base;
  idx_base--;
 } else {
  idx_value = (duk_idx_t) -1;
 }
 key = duk_to_property_key_hstring(thr, idx_base);
 do { } while (0);

 duk_require_valid_index(thr, idx_base);

 duk_hobject_define_property_helper(thr, flags , obj, key, idx_value, get, set, 1 );



 duk_set_top(thr, idx_base);



 return;

fail_invalid_desc:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 599; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_object.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid descriptor"))); } while (0); } while (0);
 do { return; } while (0);

fail_not_callable:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 603; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_object.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not callable"))); } while (0); } while (0);
 do { return; } while (0);
}





__attribute__ ((visibility("default"))) void duk_compact(duk_hthread *thr, duk_idx_t obj_idx) {
 duk_hobject *obj;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 obj = duk_get_hobject(thr, obj_idx);
 if (obj) {

  duk_hobject_compact_props(thr, obj);
 }
}

static __attribute__ ((unused)) void duk_compact_m1(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 duk_compact(thr, -1);
}



__attribute__ ((visibility("default"))) void duk_enum(duk_hthread *thr, duk_idx_t obj_idx, duk_uint_t enum_flags) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 duk_dup(thr, obj_idx);
 duk_require_hobject_promote_mask(thr, -1, (1U << 9U) | (1U << 7U));
 duk_hobject_enumerator_create(thr, enum_flags);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_next(duk_hthread *thr, duk_idx_t enum_index, duk_bool_t get_value) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 duk_require_hobject(thr, enum_index);
 duk_dup(thr, enum_index);
 return duk_hobject_enumerator_next(thr, get_value);
}

static __attribute__ ((unused)) void duk_seal_freeze_raw(duk_hthread *thr, duk_idx_t obj_idx, duk_bool_t is_freeze) {
 duk_tval *tv;
 duk_hobject *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_require_tval(thr, obj_idx);
 do { } while (0);







 switch (((tv)->t)) {
 case 10:



  if (is_freeze) {
   goto fail_cannot_freeze;
  }
  break;
 case 6:

  break;
 case 9:
  h = ((tv)->v.hobject);
  do { } while (0);
  if (is_freeze && (((&(h)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {



   do { } while (0);
   goto fail_cannot_freeze;
  }
  duk_hobject_object_seal_freeze_helper(thr, h, is_freeze);




  duk_hobject_compact_props(thr, h);
  break;
 default:

  break;
 }
 return;

fail_cannot_freeze:
 do { duk_err_type_invalid_args((thr), "duk_api_object.c", (duk_int_t) 698); } while (0);
 do { return; } while (0);
}

__attribute__ ((visibility("default"))) void duk_seal(duk_hthread *thr, duk_idx_t obj_idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 duk_seal_freeze_raw(thr, obj_idx, 0 );
}

__attribute__ ((visibility("default"))) void duk_freeze(duk_hthread *thr, duk_idx_t obj_idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 duk_seal_freeze_raw(thr, obj_idx, 1 );
}





__attribute__ ((visibility("default"))) void duk_put_function_list(duk_hthread *thr, duk_idx_t obj_idx, const duk_function_list_entry *funcs) {
 const duk_function_list_entry *ent = funcs;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 if (ent != 
# 724 "duk_api_object.c" 3 4
           ((void *)0)
# 724 "duk_api_object.c"
               ) {
  while (ent->key != 
# 725 "duk_api_object.c" 3 4
                    ((void *)0)
# 725 "duk_api_object.c"
                        ) {
   duk_push_c_function(thr, ent->value, ent->nargs);
   duk_put_prop_string(thr, obj_idx, ent->key);
   ent++;
  }
 }
}

__attribute__ ((visibility("default"))) void duk_put_number_list(duk_hthread *thr, duk_idx_t obj_idx, const duk_number_list_entry *numbers) {
 const duk_number_list_entry *ent = numbers;
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 obj_idx = duk_require_normalize_index(thr, obj_idx);
 if (ent != 
# 740 "duk_api_object.c" 3 4
           ((void *)0)
# 740 "duk_api_object.c"
               ) {
  while (ent->key != 
# 741 "duk_api_object.c" 3 4
                    ((void *)0)
# 741 "duk_api_object.c"
                        ) {
   tv = thr->valstack_top++;
   do { } while (0);
   do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((ent->value)); ; duk__tv = ((tv)); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0);
   duk_put_prop_string(thr, obj_idx, ent->key);
   ent++;
  }
 }
}





__attribute__ ((visibility("default"))) duk_bool_t duk_get_global_string(duk_hthread *thr, const char *key) {
 duk_bool_t ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);



 duk_push_hobject(thr, thr->builtins[0]);
 ret = duk_get_prop_string(thr, -1, key);
 duk_remove_m2(thr);
 return ret;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_get_global_lstring(duk_hthread *thr, const char *key, duk_size_t key_len) {
 duk_bool_t ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);



 duk_push_hobject(thr, thr->builtins[0]);
 ret = duk_get_prop_lstring(thr, -1, key, key_len);
 duk_remove_m2(thr);
 return ret;
}


__attribute__ ((visibility("default"))) duk_bool_t duk_get_global_literal_raw(duk_hthread *thr, const char *key, duk_size_t key_len) {
 duk_bool_t ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);



 duk_push_hobject(thr, thr->builtins[0]);
 ret = duk_get_prop_literal_raw(thr, -1, key, key_len);
 duk_remove_m2(thr);
 return ret;
}


__attribute__ ((visibility("default"))) duk_bool_t duk_get_global_heapptr(duk_hthread *thr, void *ptr) {
 duk_bool_t ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);



 duk_push_hobject(thr, thr->builtins[0]);
 ret = duk_get_prop_heapptr(thr, -1, ptr);
 duk_remove_m2(thr);
 return ret;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_put_global_string(duk_hthread *thr, const char *key) {
 duk_bool_t ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);



 duk_push_hobject(thr, thr->builtins[0]);
 duk_insert(thr, -2);
 ret = duk_put_prop_string(thr, -2, key);
 duk_pop(thr);
 return ret;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_put_global_lstring(duk_hthread *thr, const char *key, duk_size_t key_len) {
 duk_bool_t ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);



 duk_push_hobject(thr, thr->builtins[0]);
 duk_insert(thr, -2);
 ret = duk_put_prop_lstring(thr, -2, key, key_len);
 duk_pop(thr);
 return ret;
}


__attribute__ ((visibility("default"))) duk_bool_t duk_put_global_literal_raw(duk_hthread *thr, const char *key, duk_size_t key_len) {
 duk_bool_t ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);



 duk_push_hobject(thr, thr->builtins[0]);
 duk_insert(thr, -2);
 ret = duk_put_prop_literal_raw(thr, -2, key, key_len);
 duk_pop(thr);
 return ret;
}


__attribute__ ((visibility("default"))) duk_bool_t duk_put_global_heapptr(duk_hthread *thr, void *ptr) {
 duk_bool_t ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);



 duk_push_hobject(thr, thr->builtins[0]);
 duk_insert(thr, -2);
 ret = duk_put_prop_heapptr(thr, -2, ptr);
 duk_pop(thr);
 return ret;
}





static __attribute__ ((unused)) duk_bool_t duk_get_method_stridx(duk_hthread *thr, duk_idx_t idx, duk_small_uint_t stridx) {
 (void) duk_get_prop_stridx(thr, idx, stridx);
 if (((duk_get_type_mask((thr), (-1)) & ((1U << 2U) | (1U << 1U))) ? 1 : 0)) {
  duk_pop_nodecref_unsafe(thr);
  return 0;
 }
 if (!duk_is_function((thr), (-1))) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 888; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_object.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not callable"))); } while (0); } while (0);
  do { return 0; } while (0);
 }
 return 1;
}





__attribute__ ((visibility("default"))) void duk_get_prototype(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *obj;
 duk_hobject *proto;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 obj = duk_require_hobject(thr, idx);
 do { } while (0);


 proto = ((obj)->prototype);
 if (proto) {
  duk_push_hobject(thr, proto);
 } else {
  duk_push_undefined(thr);
 }
}

__attribute__ ((visibility("default"))) void duk_set_prototype(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *obj;
 duk_hobject *proto;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 obj = duk_require_hobject(thr, idx);
 do { } while (0);
 ((void) duk_check_type_mask((thr), (-1), ((1U << 1U) | (1U << 6U)) | (1U << 10)));
 proto = duk_get_hobject(thr, -1);
# 935 "duk_api_object.c"
 duk_hobject_set_prototype_updref((thr), (obj), (proto));

 duk_pop(thr);
}

static __attribute__ ((unused)) void duk_clear_prototype(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *obj;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 obj = duk_require_hobject(thr, idx);
 do { } while (0);
# 955 "duk_api_object.c"
 duk_hobject_set_prototype_updref((thr), (obj), (
# 955 "duk_api_object.c" 3 4
((void *)0)
# 955 "duk_api_object.c"
));
}

static __attribute__ ((unused)) duk_bool_t duk_is_bare_object(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *obj;
 duk_hobject *proto;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 obj = duk_require_hobject(thr, idx);
 do { } while (0);

 proto = ((obj)->prototype);
 return (proto == 
# 968 "duk_api_object.c" 3 4
                 ((void *)0)
# 968 "duk_api_object.c"
                     );
}
# 981 "duk_api_object.c"
__attribute__ ((visibility("default"))) void duk_get_finalizer(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);





 duk_get_prop_stridx(thr, idx, 105);
}

__attribute__ ((visibility("default"))) void duk_set_finalizer(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *h;
 duk_bool_t callable;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = duk_require_hobject(thr, idx);
 callable = duk_is_function((thr), (-1));






 duk_put_prop_stridx(thr, idx, 105);
# 1018 "duk_api_object.c"
 if (callable) {
  do { do { } while (0); (&(h)->hdr)->h_flags |= ((1UL << (7 + (14)))); } while (0);
 } else {
  do { do { } while (0); (&(h)->hdr)->h_flags &= ~(((1UL << (7 + (14))))); } while (0);
 }
}
# 1 "duk_api_random.c"






__attribute__ ((visibility("default"))) duk_double_t duk_random(duk_hthread *thr) {
 return (duk_double_t) duk_util_get_random_double(thr);
}
# 1 "duk_api_stack.c"
# 19 "duk_api_stack.c"
static duk_idx_t
duk__push_c_function_raw(duk_hthread *thr, duk_c_function func, duk_idx_t nargs, duk_uint_t flags, duk_small_uint_t proto_bidx);
# 35 "duk_api_stack.c"
static const char * const duk__symbol_type_strings[4] = { "hidden", "global", "local", "wellknown" };


static const duk_uint_t duk__type_from_tag[] = {
 4U, 4U,
 1U, 2U, 3U, 8U, 9U,
 0U, 5U, 6U, 7U,
};
static const duk_uint_t duk__type_mask_from_tag[] = {
 (1U << 4U), (1U << 4U),
 (1U << 1U), (1U << 2U), (1U << 3U), (1U << 8U), (1U << 9U),
 (1U << 0U), (1U << 5U), (1U << 6U), (1U << 7U),
};
# 69 "duk_api_stack.c"
static duk_small_uint_t duk__get_symbol_type(duk_hstring *h) {
 const duk_uint8_t *data;
 duk_size_t len;

 do { } while (0);
 do { } while (0);
 do { } while (0);

 data = (const duk_uint8_t *) ((const duk_uint8_t *) ((h) + 1));
 len = ((h)->blen);
 do { } while (0);



 if (data[0] == 0xffU) {
  return 0;
 } else if (data[0] == 0x82U) {
  return 0;
 } else if (data[0] == 0x80U) {
  return 1;
 } else if (data[len - 1] != 0xffU) {
  return 2;
 } else {
  return 3;
 }
}

static const char *duk__get_symbol_type_string(duk_hstring *h) {
 duk_small_uint_t idx;
 idx = duk__get_symbol_type(h);
 do { } while (0);
 return duk__symbol_type_strings[idx];
}

static duk_heaphdr *duk__get_tagged_heaphdr_raw(duk_hthread *thr, duk_idx_t idx, duk_uint_t tag);

static duk_int_t duk__api_coerce_d2i(duk_hthread *thr, duk_idx_t idx, duk_int_t def_value, duk_bool_t require) {
 duk_tval *tv;
 duk_small_int_t c;
 duk_double_t d;

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
# 141 "duk_api_stack.c"
 if (((tv)->t == 0)) {
  d = ((tv)->v.d);
  c = (duk_small_int_t) 
# 143 "duk_api_stack.c" 3 4
                       __builtin_fpclassify (0, 1, 4, 3, 2, 
# 143 "duk_api_stack.c"
                       d
# 143 "duk_api_stack.c" 3 4
                       )
# 143 "duk_api_stack.c"
                                        ;
  if (c == 
# 144 "duk_api_stack.c" 3 4
          0
# 144 "duk_api_stack.c"
                    ) {
   return 0;
  } else if (d < (duk_double_t) 
# 146 "duk_api_stack.c" 3 4
                               (-0x7fffffff - 1)
# 146 "duk_api_stack.c"
                                          ) {

   return 
# 148 "duk_api_stack.c" 3 4
         (-0x7fffffff - 1)
# 148 "duk_api_stack.c"
                    ;
  } else if (d > (duk_double_t) 0x7fffffff) {

   return 0x7fffffff;
  } else {

   return (duk_int_t) d;
  }
 }

 if (require) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 159, (idx), ("number")); } while (0);
  do { return 0; } while (0);
 }

 return def_value;
}

static duk_uint_t duk__api_coerce_d2ui(duk_hthread *thr, duk_idx_t idx, duk_uint_t def_value, duk_bool_t require) {
 duk_tval *tv;
 duk_small_int_t c;
 duk_double_t d;



 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
# 192 "duk_api_stack.c"
 if (((tv)->t == 0)) {
  d = ((tv)->v.d);
  c = (duk_small_int_t) 
# 194 "duk_api_stack.c" 3 4
                       __builtin_fpclassify (0, 1, 4, 3, 2, 
# 194 "duk_api_stack.c"
                       d
# 194 "duk_api_stack.c" 3 4
                       )
# 194 "duk_api_stack.c"
                                        ;
  if (c == 
# 195 "duk_api_stack.c" 3 4
          0
# 195 "duk_api_stack.c"
                    ) {
   return 0;
  } else if (d < 0.0) {

   return (duk_uint_t) 0;
  } else if (d > (duk_double_t) 
# 200 "duk_api_stack.c" 3 4
                               (0x7fffffff * 2U + 1U)
# 200 "duk_api_stack.c"
                                           ) {

   return (duk_uint_t) 
# 202 "duk_api_stack.c" 3 4
                      (0x7fffffff * 2U + 1U)
# 202 "duk_api_stack.c"
                                  ;
  } else {

   return (duk_uint_t) d;
  }
 }

 if (require) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 210, (idx), ("number")); } while (0);
  do { return 0; } while (0);
 }

 return def_value;
}
# 226 "duk_api_stack.c"
__attribute__ ((visibility("default"))) duk_idx_t duk_normalize_index(duk_hthread *thr, duk_idx_t idx) {
 duk_uidx_t vs_size;
 duk_uidx_t uidx;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
# 240 "duk_api_stack.c"
 do { } while (0);
 vs_size = (duk_uidx_t) (thr->valstack_top - thr->valstack_bottom);
 do { } while (0);

 if (idx < 0) {
  uidx = vs_size + (duk_uidx_t) idx;
 } else {

  do { } while (0);
  uidx = (duk_uidx_t) idx;
 }


 do { } while (0);

 if (__builtin_expect((uidx < vs_size), 1)) {
  return (duk_idx_t) uidx;
 }
 return 
# 258 "duk_api_stack.c" 3 4
       (-0x7fffffff - 1)
# 258 "duk_api_stack.c"
                        ;
}

__attribute__ ((visibility("default"))) duk_idx_t duk_require_normalize_index(duk_hthread *thr, duk_idx_t idx) {
 duk_uidx_t vs_size;
 duk_uidx_t uidx;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 do { } while (0);
 vs_size = (duk_uidx_t) (thr->valstack_top - thr->valstack_bottom);
 do { } while (0);

 if (idx < 0) {
  uidx = vs_size + (duk_uidx_t) idx;
 } else {
  do { } while (0);
  uidx = (duk_uidx_t) idx;
 }


 do { } while (0);

 if (__builtin_expect((uidx < vs_size), 1)) {
  return (duk_idx_t) uidx;
 }
 do { duk_err_range_index((thr), "duk_api_stack.c", (duk_int_t) 285, (idx)); } while (0);
 do { return 0; } while (0);
}

static __attribute__ ((unused)) duk_tval *duk_get_tval(duk_hthread *thr, duk_idx_t idx) {
 duk_uidx_t vs_size;
 duk_uidx_t uidx;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 do { } while (0);
 vs_size = (duk_uidx_t) (thr->valstack_top - thr->valstack_bottom);
 do { } while (0);

 if (idx < 0) {
  uidx = vs_size + (duk_uidx_t) idx;
 } else {
  do { } while (0);
  uidx = (duk_uidx_t) idx;
 }


 do { } while (0);

 if (__builtin_expect((uidx < vs_size), 1)) {
  return thr->valstack_bottom + uidx;
 }
 return 
# 313 "duk_api_stack.c" 3 4
       ((void *)0)
# 313 "duk_api_stack.c"
           ;
}







static const duk_tval_unused duk__const_tval_unused = { 7, 0, 0.0 };

static __attribute__ ((unused)) duk_tval *duk_get_tval_or_unused(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval(thr, idx);
 if (tv != 
# 330 "duk_api_stack.c" 3 4
          ((void *)0)
# 330 "duk_api_stack.c"
              ) {
  return tv;
 }
 return (duk_tval *) ((void *) (duk_uintptr_t) (&duk__const_tval_unused));
}

static __attribute__ ((unused)) duk_tval *duk_require_tval(duk_hthread *thr, duk_idx_t idx) {
 duk_uidx_t vs_size;
 duk_uidx_t uidx;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 do { } while (0);
 vs_size = (duk_uidx_t) (thr->valstack_top - thr->valstack_bottom);
 do { } while (0);


 if (idx < 0) {
  uidx = vs_size + (duk_uidx_t) idx;
 } else {
  do { } while (0);
  uidx = (duk_uidx_t) idx;
 }


 do { } while (0);

 if (__builtin_expect((uidx < vs_size), 1)) {
  return thr->valstack_bottom + uidx;
 }
 do { duk_err_range_index((thr), "duk_api_stack.c", (duk_int_t) 361, (idx)); } while (0);
 do { return 
# 362 "duk_api_stack.c" 3 4
((void *)0)
# 362 "duk_api_stack.c"
; } while (0);
}


__attribute__ ((visibility("default"))) duk_bool_t duk_is_valid_index(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 return (duk_normalize_index(thr, idx) >= 0);
}


__attribute__ ((visibility("default"))) void duk_require_valid_index(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 if (__builtin_expect((duk_normalize_index(thr, idx) < 0), 0)) {
  do { duk_err_range_index((thr), "duk_api_stack.c", (duk_int_t) 379, (idx)); } while (0);
  do { return; } while (0);
 }
}





__attribute__ ((visibility("default"))) duk_idx_t duk_get_top(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 return (duk_idx_t) (thr->valstack_top - thr->valstack_bottom);
}




static __attribute__ ((unused)) duk_idx_t duk_get_top_require_min(duk_hthread *thr, duk_idx_t min_top) {
 duk_idx_t ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 ret = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom);
 if (__builtin_expect((ret < min_top), 0)) {
  do { duk_err_type_invalid_args((thr), "duk_api_stack.c", (duk_int_t) 404); } while (0);
  do { return 0; } while (0);
 }
 return ret;
}





__attribute__ ((visibility("default"))) void duk_set_top(duk_hthread *thr, duk_idx_t idx) {
 duk_uidx_t vs_size;
 duk_uidx_t vs_limit;
 duk_uidx_t uidx;
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 do { } while (0);
 do { } while (0);
 vs_size = (duk_uidx_t) (thr->valstack_top - thr->valstack_bottom);
 vs_limit = (duk_uidx_t) (thr->valstack_end - thr->valstack_bottom);

 if (idx < 0) {



  uidx = vs_size + (duk_uidx_t) idx;
 } else {



  uidx = (duk_uidx_t) idx;
 }


 do { } while (0);
 do { } while (0);





 if (__builtin_expect((uidx > vs_limit), 0)) {
  do { duk_err_range_index((thr), "duk_api_stack.c", (duk_int_t) 449, (idx)); } while (0);
  do { return; } while (0);
 }

 do { } while (0);







 if (uidx >= vs_size) {
# 473 "duk_api_stack.c"
  thr->valstack_top = thr->valstack_bottom + uidx;
 } else {


  duk_uidx_t count;
  duk_tval *tv_end;

  count = vs_size - uidx;
  do { } while (0);
  tv = thr->valstack_top;
  tv_end = tv - count;
  do { } while (0);
  do {
   tv--;
   do { } while (0);
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 2; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz((((thr))), duk__h); } } } while (0); } while (0);
  } while (tv != tv_end);
  thr->valstack_top = tv_end;
  do { duk_refzero_check_fast((thr)); } while (0);
# 506 "duk_api_stack.c"
 }
}
# 517 "duk_api_stack.c"
static __attribute__ ((unused)) void duk_set_top_unsafe(duk_hthread *thr, duk_idx_t idx) {
 duk_uidx_t uidx;
 duk_uidx_t vs_size;
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 uidx = (duk_uidx_t) idx;
 vs_size = (duk_uidx_t) (thr->valstack_top - thr->valstack_bottom);

 if (uidx >= vs_size) {
# 544 "duk_api_stack.c"
  thr->valstack_top = thr->valstack_bottom + uidx;
 } else {


  duk_uidx_t count;
  duk_tval *tv_end;

  count = vs_size - uidx;
  do { } while (0);
  tv = thr->valstack_top;
  tv_end = tv - count;
  do { } while (0);
  do {
   tv--;
   do { } while (0);
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 2; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz((((thr))), duk__h); } } } while (0); } while (0);
  } while (tv != tv_end);
  thr->valstack_top = tv_end;
  do { duk_refzero_check_fast((thr)); } while (0);
# 577 "duk_api_stack.c"
 }
}






static __attribute__ ((unused)) void duk_set_top_and_wipe(duk_hthread *thr, duk_idx_t top, duk_idx_t idx_wipe_start) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 duk_set_top_unsafe(thr, idx_wipe_start);
 duk_set_top_unsafe(thr, top);
}

__attribute__ ((visibility("default"))) duk_idx_t duk_get_top_index(duk_hthread *thr) {
 duk_idx_t ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 ret = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom) - 1;
 if (__builtin_expect((ret < 0), 0)) {




  return 
# 608 "duk_api_stack.c" 3 4
        (-0x7fffffff - 1)
# 608 "duk_api_stack.c"
                         ;
 }
 return ret;
}




static __attribute__ ((unused)) duk_idx_t duk_get_top_index_unsafe(duk_hthread *thr) {
 duk_idx_t ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 ret = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom) - 1;
 return ret;
}

__attribute__ ((visibility("default"))) duk_idx_t duk_require_top_index(duk_hthread *thr) {
 duk_idx_t ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 ret = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom) - 1;
 if (__builtin_expect((ret < 0), 0)) {
  do { duk_err_range_index((thr), "duk_api_stack.c", (duk_int_t) 632, (-1)); } while (0);
  do { return 0; } while (0);
 }
 return ret;
}
# 662 "duk_api_stack.c"
static __attribute__((cold)) __attribute__((noinline)) duk_bool_t duk__resize_valstack(duk_hthread *thr, duk_size_t new_size) {
 duk_tval *pre_valstack;
 duk_tval *pre_bottom;
 duk_tval *pre_top;
 duk_tval *pre_end;
 duk_tval *pre_alloc_end;
 duk_ptrdiff_t ptr_diff;
 duk_tval *new_valstack;
 duk_size_t new_alloc_size;
 duk_tval *tv_prev_alloc_end;
 duk_tval *p;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 pre_valstack = thr->valstack;
 pre_bottom = thr->valstack_bottom;
 pre_top = thr->valstack_top;
 pre_end = thr->valstack_end;
 pre_alloc_end = thr->valstack_alloc_end;

 do { (void) (pre_valstack); } while (0);
 do { (void) (pre_bottom); } while (0);
 do { (void) (pre_top); } while (0);
 do { (void) (pre_end); } while (0);
 do { (void) (pre_alloc_end); } while (0);
# 708 "duk_api_stack.c"
 new_alloc_size = sizeof(duk_tval) * new_size;
 new_valstack = (duk_tval *) duk_heap_mem_realloc_indirect((thr->heap), (duk_hthread_get_valstack_ptr), ((void *) thr), (new_alloc_size));
 if (__builtin_expect((new_valstack == 
# 710 "duk_api_stack.c" 3 4
    ((void *)0)
# 710 "duk_api_stack.c"
    ), 0)) {



  do { } while (0);
  do { } while (0)

                                                   ;
  return 0;
 }
# 758 "duk_api_stack.c"
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);




 ptr_diff = (duk_ptrdiff_t) ((duk_uint8_t *) new_valstack - (duk_uint8_t *) thr->valstack);
 tv_prev_alloc_end = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_alloc_end + ptr_diff);
 thr->valstack = new_valstack;
 thr->valstack_bottom = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ptr_diff);
 thr->valstack_top = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_top + ptr_diff);
 thr->valstack_end = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_end + ptr_diff);
 thr->valstack_alloc_end = (duk_tval *) (void *) ((duk_uint8_t *) new_valstack + new_alloc_size);


 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0)
# 803 "duk_api_stack.c"
                                                                        ;


 p = tv_prev_alloc_end;
 while (p < thr->valstack_alloc_end) {

  do { duk_tval *duk__tv; duk__tv = (p); duk__tv->t = 2; } while (0);
  p++;
 }
# 822 "duk_api_stack.c"
 return 1;
}

static __attribute__((cold)) __attribute__((noinline)) duk_bool_t duk__valstack_grow(duk_hthread *thr, duk_size_t min_bytes, duk_bool_t throw_on_error) {
 duk_size_t min_size;
 duk_size_t new_size;

 do { } while (0);
 min_size = min_bytes / sizeof(duk_tval);





 new_size = min_size + (min_size >> 2);







 if (__builtin_expect((new_size > 1000000L || new_size < min_size), 0)) {



  if (throw_on_error) {
   do { duk_err_range((thr), "duk_api_stack.c", (duk_int_t) 849, ("valstack limit")); } while (0);
   do { return 0; } while (0);
  }
  return 0;
 }

 if (duk__resize_valstack(thr, new_size) == 0) {
  if (throw_on_error) {
   do { duk_err_error_alloc_failed((thr), "duk_api_stack.c", (duk_int_t) 857); } while (0);
   do { return 0; } while (0);
  }
  return 0;
 }

 thr->valstack_end = thr->valstack + min_size;
 do { } while (0);

 return 1;
}




static __attribute__ ((unused)) inline void duk_valstack_grow_check_throw(duk_hthread *thr, duk_size_t min_bytes) {
 duk_tval *tv;

 tv = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + min_bytes);
 if (__builtin_expect((thr->valstack_end >= tv), 1)) {
  return;
 }
 if (__builtin_expect((thr->valstack_alloc_end >= tv), 1)) {



  thr->valstack_end = tv;
  return;
 }
 (void) duk__valstack_grow(thr, min_bytes, 1 );
}


static __attribute__ ((unused)) inline duk_bool_t duk_valstack_grow_check_nothrow(duk_hthread *thr, duk_size_t min_bytes) {
 duk_tval *tv;

 tv = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + min_bytes);
 if (__builtin_expect((thr->valstack_end >= tv), 1)) {
  return 1;
 }
 if (__builtin_expect((thr->valstack_alloc_end >= tv), 1)) {
  thr->valstack_end = tv;
  return 1;
 }
 return duk__valstack_grow(thr, min_bytes, 0 );
}


static __attribute__ ((unused)) void duk_valstack_shrink_check_nothrow(duk_hthread *thr, duk_bool_t snug) {
 duk_size_t alloc_bytes;
 duk_size_t reserve_bytes;
 duk_size_t shrink_bytes;

 alloc_bytes = (duk_size_t) ((duk_uint8_t *) thr->valstack_alloc_end - (duk_uint8_t *) thr->valstack);
 reserve_bytes = (duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack);
 do { } while (0);
# 921 "duk_api_stack.c"
 if (snug) {
  shrink_bytes = reserve_bytes;
 } else {
  duk_size_t proportion, slack;






  proportion = alloc_bytes >> 2;
  if (alloc_bytes - reserve_bytes < proportion) {

   return;
  }






  do { } while (0);
  slack = alloc_bytes >> 4;



  shrink_bytes = reserve_bytes + slack / sizeof(duk_tval) * sizeof(duk_tval);
 }






 do { } while (0)


                                       ;
 do { } while (0);
 if (shrink_bytes >= alloc_bytes) {



  return;
 }
 do { } while (0);

 do { } while (0);

 duk__resize_valstack(thr, shrink_bytes / sizeof(duk_tval));
}

__attribute__ ((visibility("default"))) duk_bool_t duk_check_stack(duk_hthread *thr, duk_idx_t extra) {
 duk_size_t min_new_bytes;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 if (__builtin_expect((extra < 0 || extra > 1000000L), 0)) {
  if (extra < 0) {



   extra = 0;
  } else {

   extra = 1000000L;
  }
 }

 min_new_bytes = (duk_size_t) ((duk_uint8_t *) thr->valstack_top - (duk_uint8_t *) thr->valstack) +
                 sizeof(duk_tval) * ((duk_size_t) extra + 32U);
 return duk_valstack_grow_check_nothrow(thr, min_new_bytes);
}

__attribute__ ((visibility("default"))) void duk_require_stack(duk_hthread *thr, duk_idx_t extra) {
 duk_size_t min_new_bytes;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 if (__builtin_expect((extra < 0 || extra > 1000000L), 0)) {
  if (extra < 0) {



   extra = 0;
  } else {

   extra = 1000000L;
  }
 }

 min_new_bytes = (duk_size_t) ((duk_uint8_t *) thr->valstack_top - (duk_uint8_t *) thr->valstack) +
                 sizeof(duk_tval) * ((duk_size_t) extra + 32U);
 duk_valstack_grow_check_throw(thr, min_new_bytes);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_check_stack_top(duk_hthread *thr, duk_idx_t top) {
 duk_size_t min_new_bytes;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 if (__builtin_expect((top < 0 || top > 1000000L), 0)) {
  if (top < 0) {



   top = 0;
  } else {

   top = 1000000L;
  }
 }

 do { } while (0);
 min_new_bytes = (duk_size_t) ((duk_uint8_t *) thr->valstack_bottom - (duk_uint8_t *) thr->valstack) +
                 sizeof(duk_tval) * ((duk_size_t) top + 32U);
 return duk_valstack_grow_check_nothrow(thr, min_new_bytes);
}

__attribute__ ((visibility("default"))) void duk_require_stack_top(duk_hthread *thr, duk_idx_t top) {
 duk_size_t min_new_bytes;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 if (__builtin_expect((top < 0 || top > 1000000L), 0)) {
  if (top < 0) {



   top = 0;
  } else {

   top = 1000000L;
  }
 }

 do { } while (0);
 min_new_bytes = (duk_size_t) ((duk_uint8_t *) thr->valstack_bottom - (duk_uint8_t *) thr->valstack) +
                 sizeof(duk_tval) * ((duk_size_t) top + 32U);
 duk_valstack_grow_check_throw(thr, min_new_bytes);
}





__attribute__ ((visibility("default"))) void duk_swap(duk_hthread *thr, duk_idx_t idx1, duk_idx_t idx2) {
 duk_tval *tv1;
 duk_tval *tv2;
 duk_tval tv_tmp;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv1 = duk_require_tval(thr, idx1);
 do { } while (0);
 tv2 = duk_require_tval(thr, idx2);
 do { } while (0);


 do { *(&tv_tmp) = *(tv1); } while (0);
 do { *(tv1) = *(tv2); } while (0);
 do { *(tv2) = *(&tv_tmp); } while (0);
}

__attribute__ ((visibility("default"))) void duk_swap_top(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 duk_swap(thr, idx, -1);
}

__attribute__ ((visibility("default"))) void duk_dup(duk_hthread *thr, duk_idx_t from_idx) {
 duk_tval *tv_from;
 duk_tval *tv_to;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 1098); } while (0); } } while (0);

 tv_from = duk_require_tval(thr, from_idx);
 tv_to = thr->valstack_top++;
 do { } while (0);
 do { } while (0);
 do { *(tv_to) = *(tv_from); } while (0);
 do { duk_tval *duk__tv = ((tv_to)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
}

__attribute__ ((visibility("default"))) void duk_dup_top(duk_hthread *thr) {



 duk_tval *tv_from;
 duk_tval *tv_to;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 1116); } while (0); } } while (0);

 if (__builtin_expect((thr->valstack_top - thr->valstack_bottom <= 0), 0)) {
  do { duk_err_range_index((thr), "duk_api_stack.c", (duk_int_t) 1119, (-1)); } while (0);
  do { return; } while (0);
 }
 tv_from = thr->valstack_top - 1;
 tv_to = thr->valstack_top++;
 do { } while (0);
 do { } while (0);
 do { *(tv_to) = *(tv_from); } while (0);
 do { duk_tval *duk__tv = ((tv_to)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);

}

static __attribute__ ((unused)) void duk_dup_0(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 duk_dup(thr, 0);
}
static __attribute__ ((unused)) void duk_dup_1(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 duk_dup(thr, 1);
}
static __attribute__ ((unused)) void duk_dup_2(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 duk_dup(thr, 2);
}
static __attribute__ ((unused)) void duk_dup_m2(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 duk_dup(thr, -2);
}
static __attribute__ ((unused)) void duk_dup_m3(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 duk_dup(thr, -3);
}
static __attribute__ ((unused)) void duk_dup_m4(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 duk_dup(thr, -4);
}

__attribute__ ((visibility("default"))) void duk_insert(duk_hthread *thr, duk_idx_t to_idx) {
 duk_tval *p;
 duk_tval *q;
 duk_tval tv_tmp;
 duk_size_t nbytes;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 p = duk_require_tval(thr, to_idx);
 do { } while (0);
 q = duk_require_tval(thr, -1);
 do { } while (0);

 do { } while (0);







 nbytes = (duk_size_t) (((duk_uint8_t *) q) - ((duk_uint8_t *) p));

 do { } while (0)



                                              ;




 do { *(&tv_tmp) = *(q); } while (0);
 do { void *duk__dst = ((void *) (p + 1)); const void *duk__src = ((const void *) p); duk_size_t duk__len = ((size_t) nbytes); do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } while (0);
 do { *(p) = *(&tv_tmp); } while (0);
}

static __attribute__ ((unused)) void duk_insert_undefined(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 duk_push_undefined(thr);
 duk_insert(thr, idx);
}

static __attribute__ ((unused)) void duk_insert_undefined_n(duk_hthread *thr, duk_idx_t idx, duk_idx_t count) {
 duk_tval *tv, *tv_end;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);

 tv = duk_reserve_gap(thr, idx, count);
 tv_end = tv + count;
 while (tv != tv_end) {
  do { duk_tval *duk__tv; duk__tv = (tv); duk__tv->t = 2; } while (0);
  tv++;
 }
}

__attribute__ ((visibility("default"))) void duk_pull(duk_hthread *thr, duk_idx_t from_idx) {
 duk_tval *p;
 duk_tval *q;
 duk_tval tv_tmp;
 duk_size_t nbytes;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);







 p = duk_require_tval(thr, from_idx);
 do { } while (0);
 q = duk_require_tval(thr, -1);
 do { } while (0);

 do { } while (0);

 nbytes = (duk_size_t) (((duk_uint8_t *) q) - ((duk_uint8_t *) p));

 do { } while (0)



                                              ;




 do { *(&tv_tmp) = *(p); } while (0);
 do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) (p + 1)); duk_size_t duk__len = ((size_t) nbytes); do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } while (0);
 do { *(q) = *(&tv_tmp); } while (0);
}

__attribute__ ((visibility("default"))) void duk_replace(duk_hthread *thr, duk_idx_t to_idx) {
 duk_tval *tv1;
 duk_tval *tv2;
 duk_tval tv_tmp;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv1 = duk_require_tval(thr, -1);
 do { } while (0);
 tv2 = duk_require_tval(thr, to_idx);
 do { } while (0);




 do { *(&tv_tmp) = *(tv2); } while (0);
 do { *(tv2) = *(tv1); } while (0);
 do { duk_tval *duk__tv; duk__tv = (tv1); duk__tv->t = 2; } while (0);
 thr->valstack_top--;
 do { duk_tval *duk__tv = ((&tv_tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((thr)), duk__h); } } } while (0);
}

__attribute__ ((visibility("default"))) void duk_copy(duk_hthread *thr, duk_idx_t from_idx, duk_idx_t to_idx) {
 duk_tval *tv1;
 duk_tval *tv2;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv1 = duk_require_tval(thr, from_idx);
 do { } while (0);
 tv2 = duk_require_tval(thr, to_idx);
 do { } while (0);


 do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv2); tv__src = (tv1); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((tv__dst))->t & 0x08)) { h__obj = ((tv__dst)->v.heaphdr); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);
}

__attribute__ ((visibility("default"))) void duk_remove(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *p;
 duk_tval *q;

 duk_tval tv_tmp;

 duk_size_t nbytes;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 p = duk_require_tval(thr, idx);
 do { } while (0);
 q = duk_require_tval(thr, -1);
 do { } while (0);

 do { } while (0);
# 1315 "duk_api_stack.c"
 do { *(&tv_tmp) = *(p); } while (0);


 nbytes = (duk_size_t) (((duk_uint8_t *) q) - ((duk_uint8_t *) p));
 do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) (p + 1)); duk_size_t duk__len = ((size_t) nbytes); do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } while (0);

 do { duk_tval *duk__tv; duk__tv = (q); duk__tv->t = 2; } while (0);
 thr->valstack_top--;


 do { duk_tval *duk__tv = ((&tv_tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((thr)), duk__h); } } } while (0);

}

static __attribute__ ((unused)) void duk_remove_unsafe(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 duk_remove(thr, idx);
}

static __attribute__ ((unused)) void duk_remove_m2(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 duk_remove(thr, -2);
}

static __attribute__ ((unused)) void duk_remove_n(duk_hthread *thr, duk_idx_t idx, duk_idx_t count) {
# 1352 "duk_api_stack.c"
 duk_tval *tv_src;
 duk_tval *tv_dst;
 duk_tval *tv_newtop;
 duk_tval *tv;
 duk_size_t bytes;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);

 tv_dst = thr->valstack_bottom + idx;
 do { } while (0);
 tv_src = tv_dst + count;
 do { } while (0);
 bytes = (duk_size_t) ((duk_uint8_t *) thr->valstack_top - (duk_uint8_t *) tv_src);

 for (tv = tv_dst; tv < tv_src; tv++) {
  do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz(((thr)), duk__h); } } } while (0);
 }

 do { void *duk__dst = ((void *) tv_dst); const void *duk__src = ((const void *) tv_src); duk_size_t duk__len = (bytes); do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } while (0);

 tv_newtop = thr->valstack_top - count;
 for (tv = tv_newtop; tv < thr->valstack_top; tv++) {
  do { duk_tval *duk__tv; duk__tv = (tv); duk__tv->t = 2; } while (0);
 }
 thr->valstack_top = tv_newtop;





}

static __attribute__ ((unused)) void duk_remove_n_unsafe(duk_hthread *thr, duk_idx_t idx, duk_idx_t count) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 duk_remove_n(thr, idx, count);
}





__attribute__ ((visibility("default"))) void duk_xcopymove_raw(duk_hthread *to_thr, duk_hthread *from_thr, duk_idx_t count, duk_bool_t is_copy) {
 void *src;
 duk_size_t nbytes;
 duk_tval *p;
 duk_tval *q;



 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 if (__builtin_expect((to_thr == from_thr), 0)) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 1410; do { } while (0); do { } while (0); duk_err_handle_error(((to_thr)), "duk_api_stack.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid context"))); } while (0); } while (0);
  do { return; } while (0);
 }
 if (__builtin_expect(((duk_uidx_t) count > (duk_uidx_t) 1000000L), 0)) {



  do { do { duk_err_range(((to_thr)), "duk_api_stack.c", (duk_int_t) 1417, ("invalid count")); } while (0); } while (0);
  do { return; } while (0);
 }
 do { } while (0);

 nbytes = sizeof(duk_tval) * (duk_size_t) count;
 if (__builtin_expect((nbytes == 0), 0)) {
  return;
 }
 do { } while (0);
 if (__builtin_expect(((duk_size_t) ((duk_uint8_t *) to_thr->valstack_end - (duk_uint8_t *) to_thr->valstack_top) < nbytes), 0)) {
  do { duk_err_range_push_beyond((to_thr), "duk_api_stack.c", (duk_int_t) 1428); } while (0);
  do { return; } while (0);
 }
 src = (void *) ((duk_uint8_t *) from_thr->valstack_top - nbytes);
 if (__builtin_expect((src < (void *) from_thr->valstack_bottom), 0)) {
  do { do { duk_err_range(((to_thr)), "duk_api_stack.c", (duk_int_t) 1433, ("invalid count")); } while (0); } while (0);
  do { return; } while (0);
 }




 do { } while (0);
 do { void *duk__dst = ((void *) to_thr->valstack_top); const void *duk__src = ((const void *) src); duk_size_t duk__len = ((size_t) nbytes); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);

 p = to_thr->valstack_top;
 to_thr->valstack_top = (duk_tval *) (void *) (((duk_uint8_t *) p) + nbytes);

 if (is_copy) {

  q = to_thr->valstack_top;
  while (p < q) {
   do { duk_tval *duk__tv = ((p)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   p++;
  }
 } else {

  p = from_thr->valstack_top;
  q = (duk_tval *) (void *) (((duk_uint8_t *) p) - nbytes);
  from_thr->valstack_top = q;

  while (p > q) {
   p--;
   do { duk_tval *duk__tv; duk__tv = (p); duk__tv->t = 2; } while (0);

  }
 }
}






static __attribute__ ((unused)) duk_tval *duk_reserve_gap(duk_hthread *thr, duk_idx_t idx_base, duk_idx_t count) {
 duk_tval *tv_src;
 duk_tval *tv_dst;
 duk_size_t gap_bytes;
 duk_size_t copy_bytes;




 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);

 tv_src = thr->valstack_bottom + idx_base;
 gap_bytes = (duk_size_t) count * sizeof(duk_tval);
 tv_dst = (duk_tval *) (void *) ((duk_uint8_t *) tv_src + gap_bytes);
 copy_bytes = (duk_size_t) ((duk_uint8_t *) thr->valstack_top - (duk_uint8_t *) tv_src);
 thr->valstack_top = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_top + gap_bytes);
 do { void *duk__dst = ((void *) tv_dst); const void *duk__src = ((const void *) tv_src); duk_size_t duk__len = (copy_bytes); do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } while (0);




 return tv_src;
}





__attribute__ ((visibility("default"))) void duk_require_undefined(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (__builtin_expect((!((tv)->t == 2)), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 1510, (idx), ("undefined")); } while (0);
  do { return; } while (0);
 }
}

__attribute__ ((visibility("default"))) void duk_require_null(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (__builtin_expect((!((tv)->t == 3)), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 1523, (idx), ("null")); } while (0);
  do { return; } while (0);
 }
}

static inline __attribute__((always_inline)) duk_bool_t duk__get_boolean_raw(duk_hthread *thr, duk_idx_t idx, duk_bool_t def_value) {
 duk_bool_t ret;
 duk_tval *tv;

 do { } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (((tv)->t == 4)) {
  ret = ((duk_small_uint_t) (tv)->v.i);
  do { } while (0);
 } else {
  ret = def_value;

 }

 return ret;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_get_boolean(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 return duk__get_boolean_raw(thr, idx, 0);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_get_boolean_default(duk_hthread *thr, duk_idx_t idx, duk_bool_t def_value) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 return duk__get_boolean_raw(thr, idx, def_value);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_require_boolean(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;
 duk_bool_t ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (__builtin_expect((((tv)->t == 4)), 1)) {
  ret = ((duk_small_uint_t) (tv)->v.i);
  do { } while (0);
  return ret;
 } else {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 1572, (idx), ("boolean")); } while (0);
  do { return 0; } while (0);
 }
}

__attribute__ ((visibility("default"))) duk_bool_t duk_opt_boolean(duk_hthread *thr, duk_idx_t idx, duk_bool_t def_value) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 if (duk_check_type_mask(thr, idx, (1U << 0U) | (1U << 1U))) {
  return def_value;
 }
 return duk_require_boolean(thr, idx);
}

static inline __attribute__((always_inline)) duk_double_t duk__get_number_raw(duk_hthread *thr, duk_idx_t idx, duk_double_t def_value) {
 duk_double_union ret;
 duk_tval *tv;

 do { } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);





     if ((((tv))->t == 0)) {




  ret.d = ((tv)->v.d);
  do { } while (0);
 } else {
  ret.d = def_value;

 }

 return ret.d;
}

__attribute__ ((visibility("default"))) duk_double_t duk_get_number(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__get_number_raw(thr, idx, 
# 1616 "duk_api_stack.c" 3 4
                                     (__builtin_nanf (""))
# 1616 "duk_api_stack.c"
                                                   );
}

__attribute__ ((visibility("default"))) duk_double_t duk_get_number_default(duk_hthread *thr, duk_idx_t idx, duk_double_t def_value) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__get_number_raw(thr, idx, def_value);
}

__attribute__ ((visibility("default"))) duk_double_t duk_require_number(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;
 duk_double_union ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (__builtin_expect((!((tv)->t == 0)), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 1633, (idx), ("number")); } while (0);
  do { return 0.0; } while (0);
 }

 ret.d = ((tv)->v.d);





 do { } while (0);
 return ret.d;
}

__attribute__ ((visibility("default"))) duk_double_t duk_opt_number(duk_hthread *thr, duk_idx_t idx, duk_double_t def_value) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 if (duk_check_type_mask(thr, idx, (1U << 0U) | (1U << 1U))) {

  return def_value;
 }
 return duk_require_number(thr, idx);
}

__attribute__ ((visibility("default"))) duk_int_t duk_get_int(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 return (duk_int_t) duk__api_coerce_d2i(thr, idx, 0 , 0 );
}

__attribute__ ((visibility("default"))) duk_uint_t duk_get_uint(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 return (duk_uint_t) duk__api_coerce_d2ui(thr, idx, 0 , 0 );
}

__attribute__ ((visibility("default"))) duk_int_t duk_get_int_default(duk_hthread *thr, duk_idx_t idx, duk_int_t def_value) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 return (duk_int_t) duk__api_coerce_d2i(thr, idx, def_value, 0 );
}

__attribute__ ((visibility("default"))) duk_uint_t duk_get_uint_default(duk_hthread *thr, duk_idx_t idx, duk_uint_t def_value) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 return (duk_uint_t) duk__api_coerce_d2ui(thr, idx, def_value, 0 );
}

__attribute__ ((visibility("default"))) duk_int_t duk_require_int(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 return (duk_int_t) duk__api_coerce_d2i(thr, idx, 0 , 1 );
}

__attribute__ ((visibility("default"))) duk_uint_t duk_require_uint(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 return (duk_uint_t) duk__api_coerce_d2ui(thr, idx, 0 , 1 );
}

__attribute__ ((visibility("default"))) duk_int_t duk_opt_int(duk_hthread *thr, duk_idx_t idx, duk_int_t def_value) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 if (duk_check_type_mask(thr, idx, (1U << 0U) | (1U << 1U))) {
  return def_value;
 }
 return duk_require_int(thr, idx);
}

__attribute__ ((visibility("default"))) duk_uint_t duk_opt_uint(duk_hthread *thr, duk_idx_t idx, duk_uint_t def_value) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 if (duk_check_type_mask(thr, idx, (1U << 0U) | (1U << 1U))) {
  return def_value;
 }
 return duk_require_uint(thr, idx);
}

__attribute__ ((visibility("default"))) const char *duk_get_lstring(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_len) {
 duk_hstring *h;
 const char *ret;
 duk_size_t len;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = duk_get_hstring(thr, idx);
 if (h != 
# 1719 "duk_api_stack.c" 3 4
         ((void *)0)
# 1719 "duk_api_stack.c"
             ) {
  len = ((h)->blen);
  ret = (const char *) ((const duk_uint8_t *) ((h) + 1));
 } else {
  len = 0;
  ret = 
# 1724 "duk_api_stack.c" 3 4
       ((void *)0)
# 1724 "duk_api_stack.c"
           ;
 }

 if (out_len != 
# 1727 "duk_api_stack.c" 3 4
               ((void *)0)
# 1727 "duk_api_stack.c"
                   ) {
  *out_len = len;
 }
 return ret;
}

__attribute__ ((visibility("default"))) const char *duk_require_lstring(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_len) {
 duk_hstring *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = duk_require_hstring(thr, idx);
 do { } while (0);
 if (out_len) {
  *out_len = ((h)->blen);
 }
 return (const char *) ((const duk_uint8_t *) ((h) + 1));
}

static __attribute__ ((unused)) const char *duk_require_lstring_notsymbol(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_len) {
 duk_hstring *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = duk_require_hstring_notsymbol(thr, idx);
 do { } while (0);
 if (out_len) {
  *out_len = ((h)->blen);
 }
 return (const char *) ((const duk_uint8_t *) ((h) + 1));
}

__attribute__ ((visibility("default"))) const char *duk_get_string(duk_hthread *thr, duk_idx_t idx) {
 duk_hstring *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = duk_get_hstring(thr, idx);
 if (h != 
# 1765 "duk_api_stack.c" 3 4
         ((void *)0)
# 1765 "duk_api_stack.c"
             ) {
  return (const char *) ((const duk_uint8_t *) ((h) + 1));
 } else {
  return 
# 1768 "duk_api_stack.c" 3 4
        ((void *)0)
# 1768 "duk_api_stack.c"
            ;
 }
}

__attribute__ ((visibility("default"))) const char *duk_opt_lstring(duk_hthread *thr,
                                         duk_idx_t idx,
                                         duk_size_t *out_len,
                                         const char *def_ptr,
                                         duk_size_t def_len) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 if (duk_check_type_mask(thr, idx, (1U << 0U) | (1U << 1U))) {
  if (out_len != 
# 1780 "duk_api_stack.c" 3 4
                ((void *)0)
# 1780 "duk_api_stack.c"
                    ) {
   *out_len = def_len;
  }
  return def_ptr;
 }
 return duk_require_lstring(thr, idx, out_len);
}

__attribute__ ((visibility("default"))) const char *duk_opt_string(duk_hthread *thr, duk_idx_t idx, const char *def_ptr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 if (duk_check_type_mask(thr, idx, (1U << 0U) | (1U << 1U))) {
  return def_ptr;
 }
 return duk_require_string(thr, idx);
}

__attribute__ ((visibility("default"))) const char *duk_get_lstring_default(duk_hthread *thr,
                                                 duk_idx_t idx,
                                                 duk_size_t *out_len,
                                                 const char *def_ptr,
                                                 duk_size_t def_len) {
 duk_hstring *h;
 const char *ret;
 duk_size_t len;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = duk_get_hstring(thr, idx);
 if (h != 
# 1809 "duk_api_stack.c" 3 4
         ((void *)0)
# 1809 "duk_api_stack.c"
             ) {
  len = ((h)->blen);
  ret = (const char *) ((const duk_uint8_t *) ((h) + 1));
 } else {
  len = def_len;
  ret = def_ptr;
 }

 if (out_len != 
# 1817 "duk_api_stack.c" 3 4
               ((void *)0)
# 1817 "duk_api_stack.c"
                   ) {
  *out_len = len;
 }
 return ret;
}

__attribute__ ((visibility("default"))) const char *duk_get_string_default(duk_hthread *thr, duk_idx_t idx, const char *def_value) {
 duk_hstring *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = duk_get_hstring(thr, idx);
 if (h != 
# 1829 "duk_api_stack.c" 3 4
         ((void *)0)
# 1829 "duk_api_stack.c"
             ) {
  return (const char *) ((const duk_uint8_t *) ((h) + 1));
 } else {
  return def_value;
 }
}

static __attribute__ ((unused)) const char *duk_get_string_notsymbol(duk_hthread *thr, duk_idx_t idx) {
 duk_hstring *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = duk_get_hstring_notsymbol(thr, idx);
 if (h) {
  return (const char *) ((const duk_uint8_t *) ((h) + 1));
 } else {
  return 
# 1845 "duk_api_stack.c" 3 4
        ((void *)0)
# 1845 "duk_api_stack.c"
            ;
 }
}

__attribute__ ((visibility("default"))) const char *duk_require_string(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 return duk_require_lstring(thr, idx, 
# 1852 "duk_api_stack.c" 3 4
                                     ((void *)0)
# 1852 "duk_api_stack.c"
                                         );
}

static __attribute__ ((unused)) const char *duk_require_string_notsymbol(duk_hthread *thr, duk_idx_t idx) {
 duk_hstring *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = duk_require_hstring_notsymbol(thr, idx);
 do { } while (0);
 return (const char *) ((const duk_uint8_t *) ((h) + 1));
}

__attribute__ ((visibility("default"))) void duk_require_object(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (__builtin_expect((!((tv)->t == 9)), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 1873, (idx), ("object")); } while (0);
  do { return; } while (0);
 }
}

static void *duk__get_pointer_raw(duk_hthread *thr, duk_idx_t idx, void *def_value) {
 duk_tval *tv;
 void *p;

 do { } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (!((tv)->t == 5)) {
  return def_value;
 }

 p = ((tv)->v.voidptr);
 return p;
}

__attribute__ ((visibility("default"))) void *duk_get_pointer(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__get_pointer_raw(thr, idx, 
# 1896 "duk_api_stack.c" 3 4
                                      ((void *)0) 
# 1896 "duk_api_stack.c"
                                                        );
}

__attribute__ ((visibility("default"))) void *duk_opt_pointer(duk_hthread *thr, duk_idx_t idx, void *def_value) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 if (duk_check_type_mask(thr, idx, (1U << 0U) | (1U << 1U))) {
  return def_value;
 }
 return duk_require_pointer(thr, idx);
}

__attribute__ ((visibility("default"))) void *duk_get_pointer_default(duk_hthread *thr, duk_idx_t idx, void *def_value) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__get_pointer_raw(thr, idx, def_value);
}

__attribute__ ((visibility("default"))) void *duk_require_pointer(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;
 void *p;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);




 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (__builtin_expect((!((tv)->t == 5)), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 1925, (idx), ("pointer")); } while (0);
  do { return 
# 1926 "duk_api_stack.c" 3 4
 ((void *)0)
# 1926 "duk_api_stack.c"
 ; } while (0);
 }
 p = ((tv)->v.voidptr);
 return p;
}
# 1951 "duk_api_stack.c"
static void *duk__get_buffer_helper(duk_hthread *thr,
                                       duk_idx_t idx,
                                       duk_size_t *out_size,
                                       void *def_ptr,
                                       duk_size_t def_size,
                                       duk_bool_t throw_flag) {
 duk_hbuffer *h;
 void *ret;
 duk_size_t len;
 duk_tval *tv;

 do { } while (0);

 if (out_size != 
# 1964 "duk_api_stack.c" 3 4
                ((void *)0)
# 1964 "duk_api_stack.c"
                    ) {
  *out_size = 0;
 }

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (__builtin_expect((((tv)->t == 10)), 1)) {
  h = ((tv)->v.hbuffer);
  do { } while (0);

  len = (((duk_hbuffer *) (h))->size);
  ret = ((((&((h))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h))) + 1)));
 } else {
  if (throw_flag) {
   do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 1978, (idx), ("buffer")); } while (0);
   do { return 
# 1979 "duk_api_stack.c" 3 4
  ((void *)0)
# 1979 "duk_api_stack.c"
  ; } while (0);
  }
  len = def_size;
  ret = def_ptr;
 }

 if (out_size != 
# 1985 "duk_api_stack.c" 3 4
                ((void *)0)
# 1985 "duk_api_stack.c"
                    ) {
  *out_size = len;
 }
 return ret;
}

__attribute__ ((visibility("default"))) void *duk_get_buffer(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 return duk__get_buffer_helper(thr, idx, out_size, 
# 1994 "duk_api_stack.c" 3 4
                                                  ((void *)0) 
# 1994 "duk_api_stack.c"
                                                                  , 0 , 0 );
}

__attribute__ ((visibility("default"))) void *duk_opt_buffer(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size, void *def_ptr, duk_size_t def_size) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 if (duk_check_type_mask(thr, idx, (1U << 0U) | (1U << 1U))) {
  if (out_size != 
# 2001 "duk_api_stack.c" 3 4
                 ((void *)0)
# 2001 "duk_api_stack.c"
                     ) {
   *out_size = def_size;
  }
  return def_ptr;
 }
 return duk_require_buffer(thr, idx, out_size);
}

__attribute__ ((visibility("default"))) void *duk_get_buffer_default(duk_hthread *thr,
                                          duk_idx_t idx,
                                          duk_size_t *out_size,
                                          void *def_ptr,
                                          duk_size_t def_len) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 return duk__get_buffer_helper(thr, idx, out_size, def_ptr, def_len, 0 );
}

__attribute__ ((visibility("default"))) void *duk_require_buffer(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 return duk__get_buffer_helper(thr, idx, out_size, 
# 2022 "duk_api_stack.c" 3 4
                                                  ((void *)0) 
# 2022 "duk_api_stack.c"
                                                                  , 0 , 1 );
}






static __attribute__ ((unused)) void *duk_get_buffer_data_raw(duk_hthread *thr,
                                           duk_idx_t idx,
                                           duk_size_t *out_size,
                                           void *def_ptr,
                                           duk_size_t def_size,
                                           duk_bool_t throw_flag,
                                           duk_bool_t *out_isbuffer) {
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 if (out_isbuffer != 
# 2041 "duk_api_stack.c" 3 4
                    ((void *)0)
# 2041 "duk_api_stack.c"
                        ) {
  *out_isbuffer = 0;
 }
 if (out_size != 
# 2044 "duk_api_stack.c" 3 4
                ((void *)0)
# 2044 "duk_api_stack.c"
                    ) {
  *out_size = def_size;
 }

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);

 if (((tv)->t == 10)) {
  duk_hbuffer *h = ((tv)->v.hbuffer);
  do { } while (0);
  if (out_size != 
# 2054 "duk_api_stack.c" 3 4
                 ((void *)0)
# 2054 "duk_api_stack.c"
                     ) {
   *out_size = (((duk_hbuffer *) (h))->size);
  }
  if (out_isbuffer != 
# 2057 "duk_api_stack.c" 3 4
                     ((void *)0)
# 2057 "duk_api_stack.c"
                         ) {
   *out_isbuffer = 1;
  }
  return (void *) ((((&((h))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h))) + 1)));
 }

 else if (((tv)->t == 9)) {
  duk_hobject *h = ((tv)->v.hobject);
  do { } while (0);
  if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {



   duk_hbufobj *h_bufobj = (duk_hbufobj *) h;
   do { } while (0);

   if (h_bufobj->buf != 
# 2073 "duk_api_stack.c" 3 4
                       ((void *)0) 
# 2073 "duk_api_stack.c"
                            && (((void) 0), ((void) 0), ((h_bufobj)->offset + (h_bufobj)->length <= (((duk_hbuffer *) ((h_bufobj)->buf))->size)))) {
    duk_uint8_t *p;

    p = (duk_uint8_t *) ((((&((h_bufobj->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h_bufobj->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h_bufobj->buf))) + 1)));
    if (out_size != 
# 2077 "duk_api_stack.c" 3 4
                   ((void *)0)
# 2077 "duk_api_stack.c"
                       ) {
     *out_size = (duk_size_t) h_bufobj->length;
    }
    if (out_isbuffer != 
# 2080 "duk_api_stack.c" 3 4
                       ((void *)0)
# 2080 "duk_api_stack.c"
                           ) {
     *out_isbuffer = 1;
    }
    return (void *) (p + h_bufobj->offset);
   }

  }
 }


 if (throw_flag) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2091, (idx), ("buffer")); } while (0);
  do { return 
# 2092 "duk_api_stack.c" 3 4
 ((void *)0)
# 2092 "duk_api_stack.c"
 ; } while (0);
 }
 return def_ptr;
}

__attribute__ ((visibility("default"))) void *duk_get_buffer_data(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk_get_buffer_data_raw(thr, idx, out_size, 
# 2099 "duk_api_stack.c" 3 4
                                                   ((void *)0) 
# 2099 "duk_api_stack.c"
                                                                   , 0 , 0 , 
# 2099 "duk_api_stack.c" 3 4
                                                                                                       ((void *)0)
# 2099 "duk_api_stack.c"
                                                                                                           );
}

__attribute__ ((visibility("default"))) void *duk_get_buffer_data_default(duk_hthread *thr,
                                               duk_idx_t idx,
                                               duk_size_t *out_size,
                                               void *def_ptr,
                                               duk_size_t def_size) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk_get_buffer_data_raw(thr, idx, out_size, def_ptr, def_size, 0 , 
# 2108 "duk_api_stack.c" 3 4
                                                                                        ((void *)0)
# 2108 "duk_api_stack.c"
                                                                                            );
}

__attribute__ ((visibility("default"))) void *duk_opt_buffer_data(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size, void *def_ptr, duk_size_t def_size) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 if (duk_check_type_mask(thr, idx, (1U << 0U) | (1U << 1U))) {
  if (out_size != 
# 2115 "duk_api_stack.c" 3 4
                 ((void *)0)
# 2115 "duk_api_stack.c"
                     ) {
   *out_size = def_size;
  }
  return def_ptr;
 }
 return duk_require_buffer_data(thr, idx, out_size);
}

__attribute__ ((visibility("default"))) void *duk_require_buffer_data(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk_get_buffer_data_raw(thr, idx, out_size, 
# 2125 "duk_api_stack.c" 3 4
                                                   ((void *)0) 
# 2125 "duk_api_stack.c"
                                                                   , 0 , 1 , 
# 2125 "duk_api_stack.c" 3 4
                                                                                                       ((void *)0)
# 2125 "duk_api_stack.c"
                                                                                                           );
}






static duk_heaphdr *duk__get_tagged_heaphdr_raw(duk_hthread *thr, duk_idx_t idx, duk_uint_t tag) {
 duk_tval *tv;
 duk_heaphdr *ret;

 do { } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (((tv)->t) != tag) {
  return (duk_heaphdr *) 
# 2142 "duk_api_stack.c" 3 4
                        ((void *)0)
# 2142 "duk_api_stack.c"
                            ;
 }

 ret = ((tv)->v.heaphdr);
 do { } while (0);
 return ret;
}

static __attribute__ ((unused)) duk_hstring *duk_get_hstring(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return (duk_hstring *) duk__get_tagged_heaphdr_raw(thr, idx, 8);
}

static __attribute__ ((unused)) duk_hstring *duk_get_hstring_notsymbol(duk_hthread *thr, duk_idx_t idx) {
 duk_hstring *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hstring *) duk__get_tagged_heaphdr_raw(thr, idx, 8);
 if (__builtin_expect((h && (((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
  return 
# 2162 "duk_api_stack.c" 3 4
        ((void *)0)
# 2162 "duk_api_stack.c"
            ;
 }
 return h;
}

static __attribute__ ((unused)) duk_hstring *duk_require_hstring(duk_hthread *thr, duk_idx_t idx) {
 duk_hstring *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hstring *) duk__get_tagged_heaphdr_raw(thr, idx, 8);
 if (__builtin_expect((h == 
# 2173 "duk_api_stack.c" 3 4
    ((void *)0)
# 2173 "duk_api_stack.c"
    ), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2174, (idx), ("string")); } while (0);
  do { return 
# 2175 "duk_api_stack.c" 3 4
 ((void *)0)
# 2175 "duk_api_stack.c"
 ; } while (0);
 }
 return h;
}

static __attribute__ ((unused)) duk_hstring *duk_require_hstring_notsymbol(duk_hthread *thr, duk_idx_t idx) {
 duk_hstring *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hstring *) duk__get_tagged_heaphdr_raw(thr, idx, 8);
 if (__builtin_expect((h == 
# 2186 "duk_api_stack.c" 3 4
    ((void *)0) 
# 2186 "duk_api_stack.c"
    || (((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2187, (idx), ("string")); } while (0);
  do { return 
# 2188 "duk_api_stack.c" 3 4
 ((void *)0)
# 2188 "duk_api_stack.c"
 ; } while (0);
 }
 return h;
}

static __attribute__ ((unused)) duk_hobject *duk_get_hobject(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return (duk_hobject *) duk__get_tagged_heaphdr_raw(thr, idx, 9);
}

static __attribute__ ((unused)) duk_hobject *duk_require_hobject(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hobject *) duk__get_tagged_heaphdr_raw(thr, idx, 9);
 if (__builtin_expect((h == 
# 2204 "duk_api_stack.c" 3 4
    ((void *)0)
# 2204 "duk_api_stack.c"
    ), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2205, (idx), ("object")); } while (0);
  do { return 
# 2206 "duk_api_stack.c" 3 4
 ((void *)0)
# 2206 "duk_api_stack.c"
 ; } while (0);
 }
 return h;
}

static __attribute__ ((unused)) duk_hbuffer *duk_get_hbuffer(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return (duk_hbuffer *) duk__get_tagged_heaphdr_raw(thr, idx, 10);
}

static __attribute__ ((unused)) duk_hbuffer *duk_require_hbuffer(duk_hthread *thr, duk_idx_t idx) {
 duk_hbuffer *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hbuffer *) duk__get_tagged_heaphdr_raw(thr, idx, 10);
 if (__builtin_expect((h == 
# 2222 "duk_api_stack.c" 3 4
    ((void *)0)
# 2222 "duk_api_stack.c"
    ), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2223, (idx), ("buffer")); } while (0);
  do { return 
# 2224 "duk_api_stack.c" 3 4
 ((void *)0)
# 2224 "duk_api_stack.c"
 ; } while (0);
 }
 return h;
}

static __attribute__ ((unused)) duk_hthread *duk_get_hthread(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hobject *) duk__get_tagged_heaphdr_raw(thr, idx, 9);
 if (__builtin_expect((h != 
# 2235 "duk_api_stack.c" 3 4
    ((void *)0) 
# 2235 "duk_api_stack.c"
    && !((((&((h))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 18)), 0)) {
  h = 
# 2236 "duk_api_stack.c" 3 4
     ((void *)0)
# 2236 "duk_api_stack.c"
         ;
 }
 return (duk_hthread *) h;
}

static __attribute__ ((unused)) duk_hthread *duk_require_hthread(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hobject *) duk__get_tagged_heaphdr_raw(thr, idx, 9);
 if (__builtin_expect((!(h != 
# 2247 "duk_api_stack.c" 3 4
    ((void *)0) 
# 2247 "duk_api_stack.c"
    && ((((&((h))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 18))), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2248, (idx), ("thread")); } while (0);
  do { return 
# 2249 "duk_api_stack.c" 3 4
 ((void *)0)
# 2249 "duk_api_stack.c"
 ; } while (0);
 }
 return (duk_hthread *) h;
}

static __attribute__ ((unused)) duk_hcompfunc *duk_get_hcompfunc(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hobject *) duk__get_tagged_heaphdr_raw(thr, idx, 9);
 if (__builtin_expect((h != 
# 2260 "duk_api_stack.c" 3 4
    ((void *)0) 
# 2260 "duk_api_stack.c"
    && !(((&(h)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)), 0)) {
  h = 
# 2261 "duk_api_stack.c" 3 4
     ((void *)0)
# 2261 "duk_api_stack.c"
         ;
 }
 return (duk_hcompfunc *) h;
}

static __attribute__ ((unused)) duk_hcompfunc *duk_require_hcompfunc(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hobject *) duk__get_tagged_heaphdr_raw(thr, idx, 9);
 if (__builtin_expect((!(h != 
# 2272 "duk_api_stack.c" 3 4
    ((void *)0) 
# 2272 "duk_api_stack.c"
    && (((&(h)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0))), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2273, (idx), ("compiledfunction")); } while (0);
  do { return 
# 2274 "duk_api_stack.c" 3 4
 ((void *)0)
# 2274 "duk_api_stack.c"
 ; } while (0);
 }
 return (duk_hcompfunc *) h;
}

static __attribute__ ((unused)) duk_hnatfunc *duk_get_hnatfunc(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hobject *) duk__get_tagged_heaphdr_raw(thr, idx, 9);
 if (__builtin_expect((h != 
# 2285 "duk_api_stack.c" 3 4
    ((void *)0) 
# 2285 "duk_api_stack.c"
    && !(((&(h)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)), 0)) {
  h = 
# 2286 "duk_api_stack.c" 3 4
     ((void *)0)
# 2286 "duk_api_stack.c"
         ;
 }
 return (duk_hnatfunc *) h;
}

static __attribute__ ((unused)) duk_hnatfunc *duk_require_hnatfunc(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = (duk_hobject *) duk__get_tagged_heaphdr_raw(thr, idx, 9);
 if (__builtin_expect((!(h != 
# 2297 "duk_api_stack.c" 3 4
    ((void *)0) 
# 2297 "duk_api_stack.c"
    && (((&(h)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0))), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2298, (idx), ("nativefunction")); } while (0);
  do { return 
# 2299 "duk_api_stack.c" 3 4
 ((void *)0)
# 2299 "duk_api_stack.c"
 ; } while (0);
 }
 return (duk_hnatfunc *) h;
}

__attribute__ ((visibility("default"))) duk_c_function duk_get_c_function(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;
 duk_hobject *h;
 duk_hnatfunc *f;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (__builtin_expect((!((tv)->t == 9)), 0)) {
  return 
# 2314 "duk_api_stack.c" 3 4
        ((void *)0)
# 2314 "duk_api_stack.c"
            ;
 }
 h = ((tv)->v.hobject);
 do { } while (0);

 if (__builtin_expect((!(((&(h)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)), 0)) {
  return 
# 2320 "duk_api_stack.c" 3 4
        ((void *)0)
# 2320 "duk_api_stack.c"
            ;
 }
 do { } while (0);
 f = (duk_hnatfunc *) h;

 return f->func;
}

__attribute__ ((visibility("default"))) duk_c_function duk_opt_c_function(duk_hthread *thr, duk_idx_t idx, duk_c_function def_value) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 if (duk_check_type_mask(thr, idx, (1U << 0U) | (1U << 1U))) {
  return def_value;
 }
 return duk_require_c_function(thr, idx);
}

__attribute__ ((visibility("default"))) duk_c_function duk_get_c_function_default(duk_hthread *thr, duk_idx_t idx, duk_c_function def_value) {
 duk_c_function ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 ret = duk_get_c_function(thr, idx);
 if (ret != 
# 2343 "duk_api_stack.c" 3 4
           ((void *)0)
# 2343 "duk_api_stack.c"
               ) {
  return ret;
 }

 return def_value;
}

__attribute__ ((visibility("default"))) duk_c_function duk_require_c_function(duk_hthread *thr, duk_idx_t idx) {
 duk_c_function ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 ret = duk_get_c_function(thr, idx);
 if (__builtin_expect((!ret), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2357, (idx), ("nativefunction")); } while (0);
  do { return ret; } while (0);
 }
 return ret;
}

__attribute__ ((visibility("default"))) void duk_require_function(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 if (__builtin_expect((!duk_is_function(thr, idx)), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2366, (idx), ("function")); } while (0);
  do { return; } while (0);
 }
}

__attribute__ ((visibility("default"))) void duk_require_constructable(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = duk_require_hobject_accept_mask(thr, idx, (1U << 9U));
 if (__builtin_expect((h != 
# 2377 "duk_api_stack.c" 3 4
    ((void *)0) 
# 2377 "duk_api_stack.c"
    && !(((&(h)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0)), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2378, (idx), ("constructable")); } while (0);
  do { return; } while (0);
 }

}

__attribute__ ((visibility("default"))) duk_hthread *duk_get_context(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 return duk_get_hthread(thr, idx);
}

__attribute__ ((visibility("default"))) duk_hthread *duk_require_context(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 return duk_require_hthread(thr, idx);
}

__attribute__ ((visibility("default"))) duk_hthread *duk_opt_context(duk_hthread *thr, duk_idx_t idx, duk_hthread *def_value) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 if (duk_check_type_mask(thr, idx, (1U << 0U) | (1U << 1U))) {
  return def_value;
 }
 return duk_require_context(thr, idx);
}

__attribute__ ((visibility("default"))) duk_hthread *duk_get_context_default(duk_hthread *thr, duk_idx_t idx, duk_hthread *def_value) {
 duk_hthread *ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 ret = duk_get_context(thr, idx);
 if (ret != 
# 2411 "duk_api_stack.c" 3 4
           ((void *)0)
# 2411 "duk_api_stack.c"
               ) {
  return ret;
 }

 return def_value;
}

__attribute__ ((visibility("default"))) void *duk_get_heapptr(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;
 void *ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (__builtin_expect((!((tv)->t & 0x08)), 0)) {
  return (void *) 
# 2427 "duk_api_stack.c" 3 4
                 ((void *)0)
# 2427 "duk_api_stack.c"
                     ;
 }

 ret = (void *) ((tv)->v.heaphdr);
 do { } while (0);
 return ret;
}

__attribute__ ((visibility("default"))) void *duk_opt_heapptr(duk_hthread *thr, duk_idx_t idx, void *def_value) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 if (duk_check_type_mask(thr, idx, (1U << 0U) | (1U << 1U))) {
  return def_value;
 }
 return duk_require_heapptr(thr, idx);
}

__attribute__ ((visibility("default"))) void *duk_get_heapptr_default(duk_hthread *thr, duk_idx_t idx, void *def_value) {
 void *ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 ret = duk_get_heapptr(thr, idx);
 if (ret != 
# 2450 "duk_api_stack.c" 3 4
           ((void *)0)
# 2450 "duk_api_stack.c"
               ) {
  return ret;
 }

 return def_value;
}

__attribute__ ((visibility("default"))) void *duk_require_heapptr(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;
 void *ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (__builtin_expect((!((tv)->t & 0x08)), 0)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2466, (idx), ("heapobject")); } while (0);
  do { return 
# 2467 "duk_api_stack.c" 3 4
 ((void *)0)
# 2467 "duk_api_stack.c"
 ; } while (0);
 }

 ret = (void *) ((tv)->v.heaphdr);
 do { } while (0);
 return ret;
}


static duk_hobject *duk__get_hobject_promote_mask_raw(duk_hthread *thr, duk_idx_t idx, duk_uint_t type_mask) {
 duk_uint_t val_mask;
 duk_hobject *res;

 do { } while (0);

 res = duk_get_hobject(thr, idx);
 if (__builtin_expect((res != 
# 2483 "duk_api_stack.c" 3 4
    ((void *)0)
# 2483 "duk_api_stack.c"
    ), 1)) {
  do { } while (0);
  return res;
 }

 val_mask = duk_get_type_mask(thr, idx);
 if (val_mask & type_mask) {
  if (type_mask & (1U << 11)) {
   res = duk_to_hobject(thr, idx);
   do { } while (0);
   return res;
  } else {
   return 
# 2495 "duk_api_stack.c" 3 4
         ((void *)0)
# 2495 "duk_api_stack.c"
             ;
  }
 }

 if (type_mask & (1U << 10)) {
  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2500, (idx), ("object")); } while (0);
  do { return 
# 2501 "duk_api_stack.c" 3 4
 ((void *)0)
# 2501 "duk_api_stack.c"
 ; } while (0);
 }
 return 
# 2503 "duk_api_stack.c" 3 4
       ((void *)0)
# 2503 "duk_api_stack.c"
           ;
}
# 2513 "duk_api_stack.c"
static __attribute__ ((unused)) duk_hobject *duk_get_hobject_promote_mask(duk_hthread *thr, duk_idx_t idx, duk_uint_t type_mask) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__get_hobject_promote_mask_raw(thr, idx, type_mask | (1U << 11));
}




static __attribute__ ((unused)) duk_hobject *duk_require_hobject_promote_mask(duk_hthread *thr, duk_idx_t idx, duk_uint_t type_mask) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__get_hobject_promote_mask_raw(thr, idx, type_mask | (1U << 10) | (1U << 11));
}




static __attribute__ ((unused)) duk_hobject *duk_require_hobject_accept_mask(duk_hthread *thr, duk_idx_t idx, duk_uint_t type_mask) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__get_hobject_promote_mask_raw(thr, idx, type_mask | (1U << 10));
}

static __attribute__ ((unused)) duk_hobject *duk_get_hobject_with_class(duk_hthread *thr, duk_idx_t idx, duk_small_uint_t classnum) {
 duk_hobject *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);

 h = (duk_hobject *) duk__get_tagged_heaphdr_raw(thr, idx, 9);
 if (__builtin_expect((h != 
# 2542 "duk_api_stack.c" 3 4
    ((void *)0) 
# 2542 "duk_api_stack.c"
    && (((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) != classnum), 0)) {
  h = 
# 2543 "duk_api_stack.c" 3 4
     ((void *)0)
# 2543 "duk_api_stack.c"
         ;
 }
 return h;
}

static __attribute__ ((unused)) duk_hobject *duk_require_hobject_with_class(duk_hthread *thr, duk_idx_t idx, duk_small_uint_t classnum) {
 duk_hobject *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);

 h = (duk_hobject *) duk__get_tagged_heaphdr_raw(thr, idx, 9);
 if (__builtin_expect((!(h != 
# 2556 "duk_api_stack.c" 3 4
    ((void *)0) 
# 2556 "duk_api_stack.c"
    && (((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == classnum)), 0)) {
  duk_hstring *h_class;
  h_class = ((thr)->strs[(duk_class_number_to_stridx[(classnum)])]);
  do { (void) (h_class); } while (0);

  do { duk_err_require_type_index((thr), "duk_api_stack.c", (duk_int_t) 2561, (idx), ((const char *) ((const duk_uint8_t *) ((h_class) + 1)))); } while (0);
  do { return 
# 2562 "duk_api_stack.c" 3 4
 ((void *)0)
# 2562 "duk_api_stack.c"
 ; } while (0);
 }
 return h;
}

__attribute__ ((visibility("default"))) duk_size_t duk_get_length(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);

 switch (((tv)->t)) {
 case 2:
 case 3:
 case 4:
 case 5:
  return 0;
# 2599 "duk_api_stack.c"
 case 8: {
  duk_hstring *h = ((tv)->v.hstring);
  do { } while (0);
  if (__builtin_expect(((((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
   return 0;
  }
  return (duk_size_t) duk_hstring_get_charlen((h));
 }
 case 10: {
  duk_hbuffer *h = ((tv)->v.hbuffer);
  do { } while (0);
  return (duk_size_t) (((duk_hbuffer *) (h))->size);
 }
 case 6: {





  duk_size_t ret;
  duk_get_prop_stridx(thr, idx, 87);
  ret = (duk_size_t) duk_to_number_m1(thr);
  duk_pop_unsafe(thr);
  return ret;
 }

 case 9: {
  duk_hobject *h = ((tv)->v.hobject);
  do { } while (0);
  return (duk_size_t) duk_hobject_get_length(thr, h);
 }



 default:

  do { } while (0);
  return 0;
 }

 do { __builtin_unreachable(); } while (0);
}
# 2652 "duk_api_stack.c"
static duk_heaphdr *duk__known_heaphdr(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;
 duk_heaphdr *h;

 do { } while (0);
 if (idx < 0) {
  tv = thr->valstack_top + idx;
 } else {
  tv = thr->valstack_bottom + idx;
 }
 do { } while (0);
 do { } while (0);
 h = ((tv)->v.heaphdr);
 do { } while (0);
 return h;
}

static __attribute__ ((unused)) duk_hstring *duk_known_hstring(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 return (duk_hstring *) duk__known_heaphdr(thr, idx);
}

static __attribute__ ((unused)) duk_hobject *duk_known_hobject(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 return (duk_hobject *) duk__known_heaphdr(thr, idx);
}

static __attribute__ ((unused)) duk_hbuffer *duk_known_hbuffer(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 return (duk_hbuffer *) duk__known_heaphdr(thr, idx);
}

static __attribute__ ((unused)) duk_hcompfunc *duk_known_hcompfunc(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 return (duk_hcompfunc *) duk__known_heaphdr(thr, idx);
}

static __attribute__ ((unused)) duk_hnatfunc *duk_known_hnatfunc(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 return (duk_hnatfunc *) duk__known_heaphdr(thr, idx);
}

__attribute__ ((visibility("default"))) void duk_set_length(duk_hthread *thr, duk_idx_t idx, duk_size_t len) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_normalize_index(thr, idx);
 duk_push_uint(thr, (duk_uint_t) len);
 duk_put_prop_stridx(thr, idx, 87);
}
# 2717 "duk_api_stack.c"
static duk_bool_t duk__defaultvalue_coerce_attempt(duk_hthread *thr, duk_idx_t idx, duk_small_uint_t func_stridx) {
 if (duk_get_prop_stridx(thr, idx, func_stridx)) {

  if (duk_is_function((thr), (-1))) {
   duk_dup(thr, idx);
   duk_call_method(thr, 0);
   if (duk_check_type_mask((thr), (-1), (1U << 1U) | (1U << 2U) | (1U << 3U) | (1U << 4U) | (1U << 5U) | (1U << 8U))) {
    duk_replace(thr, idx);
    return 1;
   }

  }
 }
 duk_pop_unsafe(thr);
 return 0;
}

__attribute__ ((visibility("default"))) void duk_to_undefined(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_require_tval(thr, idx);
 do { } while (0);
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 2; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
}

__attribute__ ((visibility("default"))) void duk_to_null(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_require_tval(thr, idx);
 do { } while (0);
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 3; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
}


static const char * const duk__toprim_hint_strings[3] = { "default", "string", "number" };
static void duk__to_primitive_helper(duk_hthread *thr, duk_idx_t idx, duk_int_t hint, duk_bool_t check_symbol) {

 duk_small_uint_t coercers[2];

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 idx = duk_require_normalize_index(thr, idx);


 if (!duk_check_type_mask(thr, idx, (1U << 6U) | (1U << 9U) | (1U << 7U))) {
  do { } while (0);
  return;
 }




 if (check_symbol && duk_get_method_stridx(thr, idx, 76)) {
  do { } while (0);
  duk_dup(thr, idx);
  duk_push_string(thr, duk__toprim_hint_strings[hint]);
  duk_call_method(thr, 1);
  if (duk_check_type_mask(thr, -1, (1U << 6U) | (1U << 9U) | (1U << 7U))) {
   goto fail;
  }
  duk_replace(thr, idx);
  return;
 }
# 2798 "duk_api_stack.c"
 if (hint == 0) {
  hint = 2;
 }
# 2814 "duk_api_stack.c"
 coercers[0] = 40;
 coercers[1] = 82;
 if (hint == 1) {
  coercers[0] = 82;
  coercers[1] = 40;
 }

 if (duk__defaultvalue_coerce_attempt(thr, idx, coercers[0])) {
  do { } while (0);
  return;
 }

 if (duk__defaultvalue_coerce_attempt(thr, idx, coercers[1])) {
  do { } while (0);
  return;
 }

fail:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 2832; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_stack.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("coercion to primitive failed"))); } while (0); } while (0);
 do { return; } while (0);
}

__attribute__ ((visibility("default"))) void duk_to_primitive(duk_hthread *thr, duk_idx_t idx, duk_int_t hint) {
 duk__to_primitive_helper(thr, idx, hint, 1 );
}


static __attribute__ ((unused)) void duk_to_primitive_ordinary(duk_hthread *thr, duk_idx_t idx, duk_int_t hint) {
 duk__to_primitive_helper(thr, idx, hint, 0 );
}



__attribute__ ((visibility("default"))) duk_bool_t duk_to_boolean(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;
 duk_bool_t val;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);
 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (idx));
 do { } while (0);

 val = duk_js_toboolean(tv);
 do { } while (0);


 do { } while (0);
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((val)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
 return val;
}

static __attribute__ ((unused)) duk_bool_t duk_to_boolean_top_pop(duk_hthread *thr) {
 duk_tval *tv;
 duk_bool_t val;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_require_tval(thr, -1);
 do { } while (0);

 val = duk_js_toboolean(tv);
 do { } while (0);

 duk_pop_unsafe(thr);
 return val;
}

__attribute__ ((visibility("default"))) duk_double_t duk_to_number(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;
 duk_double_t d;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);




 idx = duk_require_normalize_index(thr, idx);
 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (idx));
 do { } while (0);
 d = duk_js_tonumber(thr, tv);


 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (idx));
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((d)); ; duk__tv = (tv__dst); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
 return d;
}

static __attribute__ ((unused)) duk_double_t duk_to_number_m1(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk_to_number(thr, -1);
}
static __attribute__ ((unused)) duk_double_t duk_to_number_m2(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk_to_number(thr, -2);
}

static __attribute__ ((unused)) duk_double_t duk_to_number_tval(duk_hthread *thr, duk_tval *tv) {
# 2922 "duk_api_stack.c"
 duk_double_t res;
 duk_tval *tv_dst;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { do { } while (0); } while (0);

 tv_dst = thr->valstack_top++;
 do { *(tv_dst) = *(tv); } while (0);
 do { duk_tval *duk__tv = ((tv_dst)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 res = duk_to_number_m1(thr);

 tv_dst = --thr->valstack_top;
 do { } while (0);
 do { } while (0);
 do { duk_tval *duk__tv; duk__tv = (tv_dst); duk__tv->t = 2; } while (0);

 return res;

}





typedef duk_double_t (*duk__toint_coercer)(duk_hthread *thr, duk_tval *tv);

static duk_double_t duk__to_int_uint_helper(duk_hthread *thr, duk_idx_t idx, duk__toint_coercer coerce_func) {
 duk_tval *tv;
 duk_double_t d;

 do { } while (0);

 tv = duk_require_tval(thr, idx);
 do { } while (0);
# 2966 "duk_api_stack.c"
 d = coerce_func(thr, tv);




 tv = duk_require_tval(thr, idx);
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((d)); ; duk__tv = (tv__dst); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
 return d;
}

__attribute__ ((visibility("default"))) duk_int_t duk_to_int(duk_hthread *thr, duk_idx_t idx) {



 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 (void) duk__to_int_uint_helper(thr, idx, duk_js_tointeger);
 return (duk_int_t) duk__api_coerce_d2i(thr, idx, 0 , 0 );
}

__attribute__ ((visibility("default"))) duk_uint_t duk_to_uint(duk_hthread *thr, duk_idx_t idx) {



 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 (void) duk__to_int_uint_helper(thr, idx, duk_js_tointeger);
 return (duk_uint_t) duk__api_coerce_d2ui(thr, idx, 0 , 0 );
}

__attribute__ ((visibility("default"))) duk_int32_t duk_to_int32(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;
 duk_int32_t ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_require_tval(thr, idx);
 do { } while (0);
 ret = duk_js_toint32(thr, tv);


 tv = duk_require_tval(thr, idx);
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = ((tv)); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((((duk_double_t) (ret)))); ; duk__tv = ((tv__dst)); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((((thr)))), duk__h); } } } while (0); } while (0);
 return ret;
}

__attribute__ ((visibility("default"))) duk_uint32_t duk_to_uint32(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;
 duk_uint32_t ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_require_tval(thr, idx);
 do { } while (0);
 ret = duk_js_touint32(thr, tv);


 tv = duk_require_tval(thr, idx);
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = ((tv)); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((((duk_double_t) (ret)))); ; duk__tv = ((tv__dst)); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((((thr)))), duk__h); } } } while (0); } while (0);
 return ret;
}

__attribute__ ((visibility("default"))) duk_uint16_t duk_to_uint16(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;
 duk_uint16_t ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_require_tval(thr, idx);
 do { } while (0);
 ret = duk_js_touint16(thr, tv);


 tv = duk_require_tval(thr, idx);
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = ((tv)); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((((duk_double_t) (ret)))); ; duk__tv = ((tv__dst)); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((((thr)))), duk__h); } } } while (0); } while (0);
 return ret;
}



static __attribute__ ((unused)) duk_uint8_t duk_to_uint8clamped(duk_hthread *thr, duk_idx_t idx) {
 duk_double_t d;
 duk_double_t t;
 duk_uint8_t ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);






 d = duk_to_number(thr, idx);
 if (d <= 0.0) {
  return 0;
 } else if (d >= 255) {
  return 255;
 } else if (
# 3061 "duk_api_stack.c" 3 4
           __builtin_isnan (
# 3061 "duk_api_stack.c"
           d
# 3061 "duk_api_stack.c" 3 4
           )
# 3061 "duk_api_stack.c"
                       ) {

  return 0;
 }

 t = d - floor(d);
 if (duk_double_equals(t, 0.5)) {

  ret = (duk_uint8_t) d;
  ret = (ret + 1) & 0xfe;


 } else {

  ret = (duk_uint8_t) (d + 0.5);
 }
 return ret;
}


__attribute__ ((visibility("default"))) const char *duk_to_lstring(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_len) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 (void) duk_to_string(thr, idx);
 do { } while (0);
 return duk_require_lstring(thr, idx, out_len);
}

static duk_ret_t duk__safe_to_string_raw(duk_hthread *thr, void *udata) {
 do { } while (0);
 do { (void) (udata); } while (0);

 (void) duk_to_string(thr, -1);
 return 1;
}

__attribute__ ((visibility("default"))) const char *duk_safe_to_lstring(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_len) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);






 duk_dup(thr, idx);
 (void) duk_safe_call(thr, duk__safe_to_string_raw, 
# 3108 "duk_api_stack.c" 3 4
                                                   ((void *)0) 
# 3108 "duk_api_stack.c"
                                                                 , 1 , 1 );
 if (!duk_is_string(thr, -1)) {

  (void) duk_safe_call(thr, duk__safe_to_string_raw, 
# 3111 "duk_api_stack.c" 3 4
                                                    ((void *)0) 
# 3111 "duk_api_stack.c"
                                                                  , 1 , 1 );
  if (!duk_is_string(thr, -1)) {

   duk_pop_unsafe(thr);
   duk_push_hstring_stridx(thr, 12);
  } else {
   ;
  }
 } else {

  ;
 }
 do { } while (0);

 duk_replace(thr, idx);
 do { } while (0);
 return duk_get_lstring(thr, idx, out_len);
}

__attribute__ ((visibility("default"))) const char *duk_to_stacktrace(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 idx = duk_require_normalize_index(thr, idx);






 if (duk_is_object(thr, idx)) {
  (void) duk_get_prop_string(thr, idx, "stack");
  if (duk_is_string(thr, -1)) {
   duk_replace(thr, idx);
  } else {
   duk_pop(thr);
  }
 }

 return duk_to_string(thr, idx);
}

static duk_ret_t duk__safe_to_stacktrace_raw(duk_hthread *thr, void *udata) {
 do { } while (0);
 do { (void) (udata); } while (0);

 (void) duk_to_stacktrace(thr, -1);

 return 1;
}

__attribute__ ((visibility("default"))) const char *duk_safe_to_stacktrace(duk_hthread *thr, duk_idx_t idx) {
 duk_int_t rc;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 idx = duk_require_normalize_index(thr, idx);

 duk_dup(thr, idx);
 rc = duk_safe_call(thr, duk__safe_to_stacktrace_raw, 
# 3167 "duk_api_stack.c" 3 4
                                                     ((void *)0) 
# 3167 "duk_api_stack.c"
                                                                   , 1 , 1 );
 if (rc != 0) {




  rc = duk_safe_call(thr, duk__safe_to_stacktrace_raw, 
# 3173 "duk_api_stack.c" 3 4
                                                      ((void *)0) 
# 3173 "duk_api_stack.c"
                                                                    , 1 , 1 );
  if (rc != 0) {
   duk_pop_unsafe(thr);
   duk_push_hstring_stridx(thr, 12);
  }
 }
 duk_replace(thr, idx);

 return duk_get_string(thr, idx);
}

static __attribute__ ((unused)) duk_hstring *duk_to_property_key_hstring(duk_hthread *thr, duk_idx_t idx) {
 duk_hstring *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 duk_to_primitive(thr, idx, 1);
 h = duk_get_hstring(thr, idx);
 if (h == 
# 3191 "duk_api_stack.c" 3 4
         ((void *)0)
# 3191 "duk_api_stack.c"
             ) {





  h = duk_to_hstring(thr, idx);
 }
 do { } while (0);
 return h;
}
# 3215 "duk_api_stack.c"
static __attribute__ ((unused)) void duk_push_class_string_tval(duk_hthread *thr, duk_tval *tv, duk_bool_t avoid_side_effects) {
 duk_hobject *h_obj;
 duk_small_uint_t classnum;
 duk_small_uint_t stridx;
 duk_tval tv_tmp;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);


 do { *(&tv_tmp) = *(tv); } while (0);
 tv = &tv_tmp;
# 3245 "duk_api_stack.c"
 duk_push_literal_raw((thr), ("[object "), sizeof(("[object ")) - 1U);

 switch (((tv)->t)) {
 case 7:
 case 2: {
  duk_push_hstring_stridx(thr, 0);
  goto finish;
 }
 case 3: {
  duk_push_hstring_stridx(thr, 1);
  goto finish;
 }
 }

 duk_push_tval(thr, tv);
 tv = 
# 3260 "duk_api_stack.c" 3 4
     ((void *)0)
# 3260 "duk_api_stack.c"
         ;
 h_obj = duk_to_hobject(thr, -1);
 do { } while (0);
 if (duk_js_isarray_hobject(h_obj)) {
  stridx = 6;
 } else {







  if (!avoid_side_effects) {
   (void) duk_get_prop_stridx(thr, -1, 78);
   if (duk_is_string_notsymbol(thr, -1)) {
    duk_remove_m2(thr);
    goto finish;
   }
   duk_pop_unsafe(thr);
  }




  classnum = (((&(h_obj)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL));
  stridx = duk_class_number_to_stridx[(classnum)];
 }
 duk_pop_unsafe(thr);
 duk_push_hstring_stridx(thr, stridx);

finish:

 duk_push_literal_raw((thr), ("]"), sizeof(("]")) - 1U);
 duk_concat(thr, 3);
}


static __attribute__ ((unused)) duk_int_t
duk_to_int_clamped_raw(duk_hthread *thr, duk_idx_t idx, duk_int_t minval, duk_int_t maxval, duk_bool_t *out_clamped) {
 duk_tval *tv;
 duk_tval tv_tmp;
 duk_double_t d, dmin, dmax;
 duk_int_t res;
 duk_bool_t clamped = 0;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_require_tval(thr, idx);
 do { } while (0);
 d = duk_js_tointeger(thr, tv);

 dmin = (duk_double_t) minval;
 dmax = (duk_double_t) maxval;

 if (d < dmin) {
  clamped = 1;
  res = minval;
  d = dmin;
 } else if (d > dmax) {
  clamped = 1;
  res = maxval;
  d = dmax;
 } else {
  res = (duk_int_t) d;
 }
 do { (void) (d); } while (0);



 tv = duk_get_tval(thr, idx);
 do { } while (0);
 do { *(&tv_tmp) = *(tv); } while (0);
# 3345 "duk_api_stack.c"
 do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = (d); ; duk__tv = (tv); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0);

 do { duk_tval *duk__tv = ((&tv_tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((thr)), duk__h); } } } while (0);

 if (out_clamped) {
  *out_clamped = clamped;
 } else {

  if (clamped) {
   do { duk_err_range((thr), "duk_api_stack.c", (duk_int_t) 3354, ("number outside range")); } while (0);
   do { return 0; } while (0);
  }
 }

 return res;
}

static __attribute__ ((unused)) duk_int_t duk_to_int_clamped(duk_hthread *thr, duk_idx_t idx, duk_idx_t minval, duk_idx_t maxval) {
 duk_bool_t dummy;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 return duk_to_int_clamped_raw(thr, idx, minval, maxval, &dummy);
}

static __attribute__ ((unused)) duk_int_t duk_to_int_check_range(duk_hthread *thr, duk_idx_t idx, duk_int_t minval, duk_int_t maxval) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk_to_int_clamped_raw(thr, idx, minval, maxval, 
# 3372 "duk_api_stack.c" 3 4
                                                        ((void *)0)
# 3372 "duk_api_stack.c"
                                                            );
}

__attribute__ ((visibility("default"))) const char *duk_to_string(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);
 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (idx));
 do { } while (0);

 switch (((tv)->t)) {
 case 2: {
  duk_push_hstring_stridx(thr, 58);
  break;
 }
 case 3: {
  duk_push_hstring_stridx(thr, 155);
  break;
 }
 case 4: {
  if (((duk_small_uint_t) (tv)->v.i)) {
   duk_push_hstring_stridx(thr, 156);
  } else {
   duk_push_hstring_stridx(thr, 157);
  }
  break;
 }
 case 8: {






  duk_hstring *h;
  h = ((tv)->v.hstring);
  do { } while (0);
  if (__builtin_expect(((((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
   do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 3412; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_stack.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("cannot string coerce Symbol"))); } while (0); } while (0);
   do { goto skip_replace; } while (0);
  } else {
   goto skip_replace;
  }



  break;
 }
 case 10:
 case 9: {






  duk_to_primitive(thr, idx, 1);
  do { } while (0);
  do { } while (0);
  return duk_to_string(thr, idx);
 }
 case 5: {
  void *ptr = ((tv)->v.voidptr);
  if (ptr != 
# 3437 "duk_api_stack.c" 3 4
            ((void *)0)
# 3437 "duk_api_stack.c"
                ) {
   duk_push_sprintf(thr, "%p", (void *) ptr);
  } else {




   duk_push_hstring_stridx(thr, 155);
  }
  break;
 }
 case 6: {

  duk_push_lightfunc_tostring(thr, tv);
  break;
 }



 default: {

  do { } while (0);
  do { } while (0);
  duk_push_tval(thr, tv);
  duk_numconv_stringify(thr, 10 , 0 , 0 );
  break;
 }
 }

 duk_replace(thr, idx);

skip_replace:
 do { } while (0);
 return duk_require_string(thr, idx);
}

static __attribute__ ((unused)) duk_hstring *duk_to_hstring(duk_hthread *thr, duk_idx_t idx) {
 duk_hstring *ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 duk_to_string(thr, idx);
 ret = duk_get_hstring(thr, idx);
 do { } while (0);
 return ret;
}

static __attribute__ ((unused)) duk_hstring *duk_to_hstring_m1(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk_to_hstring(thr, -1);
}

static __attribute__ ((unused)) duk_hstring *duk_to_hstring_acceptsymbol(duk_hthread *thr, duk_idx_t idx) {
 duk_hstring *ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 ret = duk_get_hstring(thr, idx);
 if (__builtin_expect((ret && (((&(ret)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
  return ret;
 }
 return duk_to_hstring(thr, idx);
}
# 3508 "duk_api_stack.c"
__attribute__ ((visibility("default"))) const char *duk_buffer_to_string(duk_hthread *thr, duk_idx_t idx) {
 void *ptr_src;
 duk_size_t len;
 const char *res;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);

 ptr_src = duk_require_buffer_data(thr, idx, &len);
 do { } while (0);

 res = duk_push_lstring(thr, (const char *) ptr_src, len);
 duk_replace(thr, idx);
 return res;
}

__attribute__ ((visibility("default"))) void *duk_to_buffer_raw(duk_hthread *thr, duk_idx_t idx, duk_size_t *out_size, duk_uint_t mode) {
 duk_hbuffer *h_buf;
 const duk_uint8_t *src_data;
 duk_size_t src_size;
 duk_uint8_t *dst_data;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);

 h_buf = duk_get_hbuffer(thr, idx);
 if (h_buf != 
# 3536 "duk_api_stack.c" 3 4
             ((void *)0)
# 3536 "duk_api_stack.c"
                 ) {





  duk_uint_t tmp;
  duk_uint8_t *tmp_ptr;

  tmp_ptr = (duk_uint8_t *) ((((&((h_buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h_buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h_buf))) + 1)));
  src_data = (const duk_uint8_t *) tmp_ptr;
  src_size = (((duk_hbuffer *) (h_buf))->size);

  tmp = ((((&(h_buf)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? 1 : 0);
  if ((tmp == mode && !(((&(h_buf)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0)) || mode == 2) {



   dst_data = tmp_ptr;
   goto skip_copy;
  }
 } else {





  src_data = (const duk_uint8_t *) duk_to_lstring(thr, idx, &src_size);
 }

 dst_data = (duk_uint8_t *) duk_push_buffer_raw((thr), (src_size), ((mode == 1)) ? (1 << 0) : 0);

 do { void *duk__dst = ((void *) dst_data); const void *duk__src = ((const void *) src_data); duk_size_t duk__len = ((size_t) src_size); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0);

 duk_replace(thr, idx);
skip_copy:

 if (out_size) {
  *out_size = src_size;
 }
 return dst_data;
}

__attribute__ ((visibility("default"))) void *duk_to_pointer(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;
 void *res;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);
 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (idx));
 do { } while (0);

 switch (((tv)->t)) {
 case 2:
 case 3:
 case 4:
  res = 
# 3593 "duk_api_stack.c" 3 4
       ((void *)0)
# 3593 "duk_api_stack.c"
           ;
  break;
 case 5:
  res = ((tv)->v.voidptr);
  break;
 case 8:
 case 9:
 case 10:



  res = (void *) ((tv)->v.heaphdr);
  break;
 case 6:




  res = 
# 3611 "duk_api_stack.c" 3 4
       ((void *)0)
# 3611 "duk_api_stack.c"
           ;
  break;



 default:

  do { } while (0);
  do { } while (0);
  res = 
# 3620 "duk_api_stack.c" 3 4
       ((void *)0)
# 3620 "duk_api_stack.c"
           ;
  break;
 }

 duk_push_pointer(thr, res);
 duk_replace(thr, idx);
 return res;
}

static void duk__push_func_from_lightfunc(duk_hthread *thr, duk_c_function func, duk_small_uint_t lf_flags) {
 duk_idx_t nargs;
 duk_uint_t flags = 0;
 duk_small_uint_t lf_len;
 duk_hnatfunc *nf;

 nargs = (duk_idx_t) ((lf_flags) &0x0fU);
 if (nargs == 0x0f) {
  nargs = (duk_idx_t) ((duk_int_t) (-1));
 }

 flags = (1UL << (7 + (0))) | (1UL << (7 + (1))) | (1UL << (7 + (2))) |
         (1UL << (7 + (7))) | (1UL << (7 + (5))) | (1UL << (7 + (11))) | (1UL << (7 + (9))) |
         (1UL << (7 + (10))) | (((duk_uint_t) (3)) << (7 + (20)));
 (void) duk__push_c_function_raw(thr, func, nargs, flags, 6);

 lf_len = (((lf_flags) >> 4) & 0x0fU);
 if ((duk_idx_t) lf_len != nargs) {

  duk_push_int(thr, (duk_int_t) lf_len);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (87)) << 8) + (duk_uint_t) (0)));
 }


 duk_push_lightfunc_name_raw(thr, func, lf_flags);
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (93)) << 8) + (duk_uint_t) (((1U << 2)))));


 nf = duk_known_hnatfunc(thr, -1);
 nf->magic = (duk_int16_t) ((duk_int32_t) (duk_int8_t) (((duk_uint16_t) (lf_flags)) >> 8));
}

__attribute__ ((visibility("default"))) void duk_to_object(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;
 duk_uint_t flags = 0;
 duk_small_int_t proto = 0;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);
 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (idx));
 do { } while (0);

 switch (((tv)->t)) {



 case 2:
 case 3: {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 3678; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_stack.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not object coercible"))); } while (0); } while (0);
  do { return; } while (0);
  break;
 }
 case 4: {
  flags =
      (1UL << (7 + (0))) | (1UL << (7 + (7))) | (((duk_uint_t) (5)) << (7 + (20)));
  proto = 12;
  goto create_object;
 }
 case 8: {
  duk_hstring *h;
  h = ((tv)->v.hstring);
  do { } while (0);
  if (__builtin_expect(((((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
   flags = (1UL << (7 + (0))) | (1UL << (7 + (7))) |
           (((duk_uint_t) (14)) << (7 + (20)));
   proto = 38;
  } else {
   flags = (1UL << (7 + (0))) | (1UL << (7 + (7))) | (1UL << (7 + (16))) |
           (((duk_uint_t) (12)) << (7 + (20)));
   proto = 10;
  }
  goto create_object;
 }
 case 9: {

  break;
 }

 case 10: {







  duk_hbuffer *h_buf;

  h_buf = ((tv)->v.hbuffer);
  do { } while (0);
  duk_hbufobj_push_uint8array_from_plain(thr, h_buf);
  goto replace_value;
 }

 case 5: {
  flags =
      (1UL << (7 + (0))) | (1UL << (7 + (7))) | (((duk_uint_t) (17)) << (7 + (20)));
  proto = 36;
  goto create_object;
 }
 case 6: {
# 3740 "duk_api_stack.c"
  duk_small_uint_t lf_flags;
  duk_c_function func;

  do { (lf_flags) = (duk_uint32_t) (tv)->v_extra; (func) = (tv)->v.lightfunc; } while (0);
  duk__push_func_from_lightfunc(thr, func, lf_flags);
  goto replace_value;
 }



 default: {
  do { } while (0);
  do { } while (0);
  flags =
      (1UL << (7 + (0))) | (1UL << (7 + (7))) | (((duk_uint_t) (10)) << (7 + (20)));
  proto = 14;
  goto create_object;
 }
 }
 do { } while (0);
 return;

create_object:
 (void) duk_push_object_helper(thr, flags, proto);
# 3772 "duk_api_stack.c"
 duk_dup(thr, idx);
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (106)) << 8) + (duk_uint_t) (0)));

replace_value:
 duk_replace(thr, idx);
 do { } while (0);
}

static __attribute__ ((unused)) duk_hobject *duk_to_hobject(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 duk_to_object(thr, idx);
 ret = duk_known_hobject(thr, idx);
 return ret;
}





static duk_bool_t duk__tag_check(duk_hthread *thr, duk_idx_t idx, duk_small_uint_t tag) {
 duk_tval *tv;

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 return (((tv)->t) == tag);
}

static duk_bool_t duk__obj_flag_any_default_false(duk_hthread *thr, duk_idx_t idx, duk_uint_t flag_mask) {
 duk_hobject *obj;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 obj = duk_get_hobject(thr, idx);
 if (obj) {
  return (((((duk_heaphdr *) obj)->h_flags & (flag_mask)) != 0) ? 1 : 0);
 }
 return 0;
}

static __attribute__ ((unused)) duk_int_t duk_get_type_tval(duk_tval *tv) {
 do { } while (0);
# 3847 "duk_api_stack.c"
 do { } while (0);
 do { } while (0);
 return (duk_int_t) duk__type_from_tag[((tv)->t) - 0];

}

__attribute__ ((visibility("default"))) duk_int_t duk_get_type(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);

 return duk_get_type_tval(tv);
}
# 3881 "duk_api_stack.c"
static __attribute__ ((unused)) duk_small_uint_t duk_get_class_number(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;
 duk_hobject *obj;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);

 switch (((tv)->t)) {
 case 9:
  obj = ((tv)->v.hobject);
  do { } while (0);
  return (((&(obj)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL));
 case 10:

  return 22;
 case 6:

  return 3;
 default:

  return 0;
 }
}

__attribute__ ((visibility("default"))) duk_bool_t duk_check_type(duk_hthread *thr, duk_idx_t idx, duk_int_t type) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 return (duk_get_type(thr, idx) == type) ? 1 : 0;
}

static __attribute__ ((unused)) duk_uint_t duk_get_type_mask_tval(duk_tval *tv) {
 do { } while (0);
# 3946 "duk_api_stack.c"
 do { } while (0);
 do { } while (0);
 return duk__type_mask_from_tag[((tv)->t) - 0];

}

__attribute__ ((visibility("default"))) duk_uint_t duk_get_type_mask(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);

 return duk_get_type_mask_tval(tv);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_check_type_mask(duk_hthread *thr, duk_idx_t idx, duk_uint_t mask) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 if (__builtin_expect(((duk_get_type_mask(thr, idx) & mask) != 0U), 1)) {
  return 1;
 }
 if (mask & (1U << 10)) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 3970; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_stack.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("unexpected type"))); } while (0); } while (0);
  do { return 0; } while (0);
 }
 return 0;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_undefined(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__tag_check(thr, idx, 2);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_null(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__tag_check(thr, idx, 3);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_boolean(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__tag_check(thr, idx, 4);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_number(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
# 4003 "duk_api_stack.c"
 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 return ((tv)->t == 0);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_nan(duk_hthread *thr, duk_idx_t idx) {






 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);


 if (!((tv)->t == 0)) {
  return 0;
 }
 return (duk_bool_t) 
# 4026 "duk_api_stack.c" 3 4
                    __builtin_isnan (
# 4026 "duk_api_stack.c"
                    ((tv)->v.d)
# 4026 "duk_api_stack.c" 3 4
                    )
# 4026 "duk_api_stack.c"
                                                      ;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_string(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__tag_check(thr, idx, 8);
}

static __attribute__ ((unused)) duk_bool_t duk_is_string_notsymbol(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk_get_hstring_notsymbol(thr, idx) != 
# 4036 "duk_api_stack.c" 3 4
                                              ((void *)0)
# 4036 "duk_api_stack.c"
                                                  ;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_object(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__tag_check(thr, idx, 9);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_buffer(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__tag_check(thr, idx, 10);
}


__attribute__ ((visibility("default"))) duk_bool_t duk_is_buffer_data(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (((tv)->t == 10)) {
  return 1;
 } else if (((tv)->t == 9)) {
  duk_hobject *h = ((tv)->v.hobject);
  do { } while (0);
  if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {
   return 1;
  }
 }
 return 0;
}
# 4077 "duk_api_stack.c"
__attribute__ ((visibility("default"))) duk_bool_t duk_is_pointer(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__tag_check(thr, idx, 5);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_lightfunc(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__tag_check(thr, idx, 6);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_symbol(duk_hthread *thr, duk_idx_t idx) {
 duk_hstring *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 h = duk_get_hstring(thr, idx);



 if (__builtin_expect((h != 
# 4095 "duk_api_stack.c" 3 4
    ((void *)0) 
# 4095 "duk_api_stack.c"
    && (((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 1)) {
  return 1;
 }
 return 0;
}


__attribute__ ((visibility("default"))) duk_bool_t duk_is_array(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval(thr, idx);
 if (tv) {
  return duk_js_isarray(tv);
 }
 return 0;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_function(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 if (((tv)->t == 9)) {
  duk_hobject *h;
  h = ((tv)->v.hobject);
  do { } while (0);
  return (((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0) ? 1 : 0;
 }
 if (((tv)->t == 6)) {
  return 1;
 }
 return 0;
}

static __attribute__ ((unused)) duk_bool_t duk_is_callable_tval(duk_hthread *thr, duk_tval *tv) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 do { (void) (thr); } while (0);

 if (((tv)->t == 9)) {
  duk_hobject *h;
  h = ((tv)->v.hobject);
  do { } while (0);
  return (((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0) ? 1 : 0;
 }
 if (((tv)->t == 6)) {
  return 1;
 }
 return 0;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_constructable(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 if (((tv)->t == 9)) {
  duk_hobject *h;
  h = ((tv)->v.hobject);
  do { } while (0);
  return (((&(h)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0) ? 1 : 0;
 }
 if (((tv)->t == 6)) {
  return 1;
 }
 return 0;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_c_function(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__obj_flag_any_default_false(thr, idx, (1UL << (7 + (5))));
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_ecmascript_function(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__obj_flag_any_default_false(thr, idx, (1UL << (7 + (4))));
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_bound_function(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__obj_flag_any_default_false(thr, idx, (1UL << (7 + (3))));
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_thread(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *obj;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 obj = duk_get_hobject(thr, idx);
 if (obj) {
  return ((((&(obj)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 18 ? 1 : 0);
 }
 return 0;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_fixed_buffer(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (((tv)->t == 10)) {
  duk_hbuffer *h = ((tv)->v.hbuffer);
  do { } while (0);
  return ((((&(h)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? 0 : 1);
 }
 return 0;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_dynamic_buffer(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (((tv)->t == 10)) {
  duk_hbuffer *h = ((tv)->v.hbuffer);
  do { } while (0);
  return ((((&(h)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) && !(((&(h)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0) ? 1 : 0);
 }
 return 0;
}

__attribute__ ((visibility("default"))) duk_bool_t duk_is_external_buffer(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_get_tval_or_unused(thr, idx);
 do { } while (0);
 if (((tv)->t == 10)) {
  duk_hbuffer *h = ((tv)->v.hbuffer);
  do { } while (0);
  return ((((&(h)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) && (((&(h)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0) ? 1 : 0);
 }
 return 0;
}

__attribute__ ((visibility("default"))) duk_errcode_t duk_get_error_code(duk_hthread *thr, duk_idx_t idx) {
 duk_hobject *h;
 duk_uint_t sanity;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = duk_get_hobject(thr, idx);

 sanity = 10000L;
 do {
  if (!h) {
   return 0;
  }



  if (h == thr->builtins[22]) {
   return 2;
  }
  if (h == thr->builtins[24]) {
   return 3;
  }
  if (h == thr->builtins[26]) {
   return 4;
  }
  if (h == thr->builtins[28]) {
   return 5;
  }
  if (h == thr->builtins[30]) {
   return 6;
  }
  if (h == thr->builtins[32]) {
   return 7;
  }
  if (h == thr->builtins[20]) {
   return 1;
  }

  h = ((h)->prototype);
 } while (--sanity > 0);

 return 0;
}





static __attribute__ ((unused)) void duk_push_tval(duk_hthread *thr, duk_tval *tv) {
 duk_tval *tv_slot;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4293); } while (0); } } while (0);
 tv_slot = thr->valstack_top++;
 do { *(tv_slot) = *(tv); } while (0);
 do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
}

__attribute__ ((visibility("default"))) void duk_push_undefined(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4302); } while (0); } } while (0);




 thr->valstack_top++;
 do { } while (0);
}

__attribute__ ((visibility("default"))) void duk_push_null(duk_hthread *thr) {
 duk_tval *tv_slot;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4315); } while (0); } } while (0);
 tv_slot = thr->valstack_top++;
 do { duk_tval *duk__tv; duk__tv = (tv_slot); duk__tv->t = 3; } while (0);
}

__attribute__ ((visibility("default"))) void duk_push_boolean(duk_hthread *thr, duk_bool_t val) {
 duk_tval *tv_slot;
 duk_small_int_t b;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4325); } while (0); } } while (0);
 b = (val ? 1 : 0);
 tv_slot = thr->valstack_top++;
 do { duk_tval *duk__tv; duk__tv = (tv_slot); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) (b); } while (0);
}

__attribute__ ((visibility("default"))) void duk_push_true(duk_hthread *thr) {
 duk_tval *tv_slot;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4335); } while (0); } } while (0);
 tv_slot = thr->valstack_top++;
 do { duk_tval *duk__tv; duk__tv = ((tv_slot)); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) (1); } while (0);
}

__attribute__ ((visibility("default"))) void duk_push_false(duk_hthread *thr) {
 duk_tval *tv_slot;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4344); } while (0); } } while (0);
 tv_slot = thr->valstack_top++;
 do { duk_tval *duk__tv; duk__tv = ((tv_slot)); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) (0); } while (0);
}


__attribute__ ((visibility("default"))) void duk_push_number(duk_hthread *thr, duk_double_t val) {
 duk_tval *tv_slot;
 duk_double_union du;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4355); } while (0); } } while (0);
 du.d = val;
 ;
 tv_slot = thr->valstack_top++;
 do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = (du.d); ; duk__tv = (tv_slot); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0);
}

__attribute__ ((visibility("default"))) void duk_push_int(duk_hthread *thr, duk_int_t val) {
# 4380 "duk_api_stack.c"
 duk_tval *tv_slot;
 duk_double_t d;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4384); } while (0); } } while (0);
 d = (duk_double_t) val;
 tv_slot = thr->valstack_top++;
 do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = (d); ; duk__tv = (tv_slot); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0);

}

__attribute__ ((visibility("default"))) void duk_push_uint(duk_hthread *thr, duk_uint_t val) {
# 4410 "duk_api_stack.c"
 duk_tval *tv_slot;
 duk_double_t d;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4414); } while (0); } } while (0);
 d = (duk_double_t) val;
 tv_slot = thr->valstack_top++;
 do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = (d); ; duk__tv = (tv_slot); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0);

}

__attribute__ ((visibility("default"))) void duk_push_nan(duk_hthread *thr) {
 duk_tval *tv_slot;
 duk_double_union du;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4426); } while (0); } } while (0);
 do { (&du)->d = 
# 4427 "duk_api_stack.c" 3 4
(__builtin_nanf (""))
# 4427 "duk_api_stack.c"
; } while (0);
 do { } while (0);
 tv_slot = thr->valstack_top++;
 do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = (du.d); ; duk__tv = (tv_slot); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0);
}

__attribute__ ((visibility("default"))) const char *duk_push_lstring(duk_hthread *thr, const char *str, duk_size_t len) {
 duk_hstring *h;
 duk_tval *tv_slot;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);


 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4440); } while (0); } } while (0);






 if (__builtin_expect((str == 
# 4447 "duk_api_stack.c" 3 4
    ((void *)0)
# 4447 "duk_api_stack.c"
    ), 0)) {
  len = 0U;
 }


 if (__builtin_expect((len > (0x7fffffffUL)), 0)) {
  do { duk_err_range((thr), "duk_api_stack.c", (duk_int_t) 4453, ("string too long")); } while (0);
  do { return 
# 4454 "duk_api_stack.c" 3 4
 ((void *)0)
# 4454 "duk_api_stack.c"
 ; } while (0);
 }

 h = duk_heap_strtable_intern_checked(thr, (const duk_uint8_t *) str, (duk_uint32_t) len);
 do { } while (0);

 tv_slot = thr->valstack_top++;
 do { duk_tval *duk__tv; duk__tv = (tv_slot); duk__tv->t = 8; duk__tv->v.hstring = (h); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);

 return (const char *) ((const duk_uint8_t *) ((h) + 1));
}

__attribute__ ((visibility("default"))) const char *duk_push_string(duk_hthread *thr, const char *str) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 if (str) {
  return duk_push_lstring(thr, str, strlen(str));
 } else {
  duk_push_null(thr);
  return 
# 4474 "duk_api_stack.c" 3 4
        ((void *)0)
# 4474 "duk_api_stack.c"
            ;
 }
}



__attribute__ ((visibility("default"))) const char *duk_push_literal_raw(duk_hthread *thr, const char *str, duk_size_t len) {
 duk_hstring *h;
 duk_tval *tv_slot;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);


 if (__builtin_expect((len > (0x7fffffffUL)), 0)) {
  do { duk_err_range((thr), "duk_api_stack.c", (duk_int_t) 4490, ("string too long")); } while (0);
  do { return 
# 4491 "duk_api_stack.c" 3 4
 ((void *)0)
# 4491 "duk_api_stack.c"
 ; } while (0);
 }

 h = duk_heap_strtable_intern_literal_checked(thr, (const duk_uint8_t *) str, (duk_uint32_t) len);
 do { } while (0);

 tv_slot = thr->valstack_top++;
 do { duk_tval *duk__tv; duk__tv = (tv_slot); duk__tv->t = 8; duk__tv->v.hstring = (h); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);

 return (const char *) ((const duk_uint8_t *) ((h) + 1));
}
# 4514 "duk_api_stack.c"
__attribute__ ((visibility("default"))) void duk_push_pointer(duk_hthread *thr, void *val) {
 duk_tval *tv_slot;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4518); } while (0); } } while (0);
 tv_slot = thr->valstack_top++;
 do { duk_tval *duk__tv; duk__tv = (tv_slot); duk__tv->t = 5; duk__tv->v.voidptr = (val); } while (0);
}

static __attribute__ ((unused)) duk_hstring *duk_push_uint_to_hstring(duk_hthread *thr, duk_uint_t i) {
 duk_hstring *h_tmp;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);


 duk_push_uint(thr, (duk_uint_t) i);
 h_tmp = duk_to_hstring_m1(thr);
 do { } while (0);
 return h_tmp;
}

static void duk__push_this_helper(duk_hthread *thr, duk_small_uint_t check_object_coercible) {
 duk_tval *tv_slot;

 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4538); } while (0); } } while (0);

 do { } while (0);
 tv_slot = thr->valstack_top++;

 if (__builtin_expect((thr->callstack_curr == 
# 4543 "duk_api_stack.c" 3 4
    ((void *)0)
# 4543 "duk_api_stack.c"
    ), 0)) {
  if (check_object_coercible) {
   goto type_error;
  }

 } else {
  duk_tval *tv;


  do { } while (0);
  tv = thr->valstack_bottom - 1;
  if (check_object_coercible && (((tv)->t == 2) || ((tv)->t == 3))) {

   goto type_error;
  }

  do { *(tv_slot) = *(tv); } while (0);
  do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 }
 return;

type_error:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 4565; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_stack.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not object coercible"))); } while (0); } while (0);
 do { return; } while (0);
}

__attribute__ ((visibility("default"))) void duk_push_this(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 duk__push_this_helper(thr, 0 );
}

static __attribute__ ((unused)) void duk_push_this_check_object_coercible(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 duk__push_this_helper(thr, 1 );
}

static __attribute__ ((unused)) duk_hobject *duk_push_this_coercible_to_object(duk_hthread *thr) {
 duk_hobject *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 duk__push_this_helper(thr, 1 );
 h = duk_to_hobject(thr, -1);
 do { } while (0);
 return h;
}

static __attribute__ ((unused)) duk_hstring *duk_push_this_coercible_to_string(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 duk__push_this_helper(thr, 1 );
 return duk_to_hstring_m1(thr);
}

static __attribute__ ((unused)) duk_tval *duk_get_borrowed_this_tval(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 return thr->valstack_bottom - 1;
}

__attribute__ ((visibility("default"))) void duk_push_new_target(duk_hthread *thr) {
 duk_activation *act;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
# 4631 "duk_api_stack.c"
 act = thr->callstack_curr;
 for (;;) {
  if (act == 
# 4633 "duk_api_stack.c" 3 4
            ((void *)0)
# 4633 "duk_api_stack.c"
                ) {
   break;
  }

  if (act->flags & (1U << 2)) {
   duk_push_tval(thr, &act->tv_func);
   return;
  } else if (act->flags & (1U << 4)) {
   act = act->parent;
  } else {
   break;
  }
 }

 duk_push_undefined(thr);
}

__attribute__ ((visibility("default"))) void duk_push_current_function(duk_hthread *thr) {
 duk_activation *act;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 act = thr->callstack_curr;
 if (act != 
# 4656 "duk_api_stack.c" 3 4
           ((void *)0)
# 4656 "duk_api_stack.c"
               ) {
  duk_push_tval(thr, &act->tv_func);
 } else {
  duk_push_undefined(thr);
 }
}

__attribute__ ((visibility("default"))) void duk_push_current_thread(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 if (thr->heap->curr_thread) {
  duk_push_hobject(thr, (duk_hobject *) thr->heap->curr_thread);
 } else {
  duk_push_undefined(thr);
 }
}

__attribute__ ((visibility("default"))) void duk_push_global_object(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 duk_push_hobject_bidx(thr, 0);
}


static void duk__push_stash(duk_hthread *thr) {
 if (!(((void) 0), ((void) 0), duk_xget_owndataprop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (106))))) {
  do { } while (0);
  duk_pop_unsafe(thr);
  duk_push_bare_object(thr);
  duk_dup_top(thr);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-3)) << 24) + (((duk_uint_t) (106)) << 8) + (duk_uint_t) (((1U << 2)))))


                                                  ;
 }
 duk_remove_m2(thr);
}

__attribute__ ((visibility("default"))) void duk_push_heap_stash(duk_hthread *thr) {
 duk_heap *heap;
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 heap = thr->heap;
 do { } while (0);
 duk_push_hobject(thr, heap->heap_object);
 duk__push_stash(thr);
}

__attribute__ ((visibility("default"))) void duk_push_global_stash(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 duk_push_global_object(thr);
 duk__push_stash(thr);
}

__attribute__ ((visibility("default"))) void duk_push_thread_stash(duk_hthread *thr, duk_hthread *target_thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 if (__builtin_expect((target_thr == 
# 4711 "duk_api_stack.c" 3 4
    ((void *)0)
# 4711 "duk_api_stack.c"
    ), 0)) {
  do { duk_err_type_invalid_args((thr), "duk_api_stack.c", (duk_int_t) 4712); } while (0);
  do { return; } while (0);
 }
 duk_push_hobject(thr, (duk_hobject *) target_thr);
 duk__push_stash(thr);
}


static duk_int_t duk__try_push_vsprintf(duk_hthread *thr, void *buf, duk_size_t sz, const char *fmt, va_list ap) {
 duk_int_t len;

 do { } while (0);
 do { (void) (thr); } while (0);


 len = vsnprintf((char *) buf, sz, fmt, ap);
 if (len < (duk_int_t) sz) {



  return (duk_int_t) len;
 }
 return -1;
}

__attribute__ ((visibility("default"))) const char *duk_push_vsprintf(duk_hthread *thr, const char *fmt, va_list ap) {
 duk_uint8_t stack_buf[256L];
 duk_size_t sz = 256L;
 duk_bool_t pushed_buf = 0;
 void *buf;
 duk_int_t len;
 const char *res;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);


 if (!fmt) {
  duk_hstring *h_str;
  duk_push_hstring_empty(thr);
  h_str = duk_known_hstring(thr, -1);
  return (const char *) ((const duk_uint8_t *) ((h_str) + 1));
 }


 sz = strlen(fmt) + 16;
 if (sz < 256L) {
  sz = 256L;
 }
 do { } while (0);




 for (;;) {
  va_list ap_copy;

  if (sz <= sizeof(stack_buf)) {
   buf = stack_buf;
  } else if (!pushed_buf) {
   pushed_buf = 1;
   buf = duk_push_buffer_raw((thr), (sz), (1 << 0) );
  } else {
   buf = duk_resize_buffer(thr, -1, sz);
  }
  do { } while (0);

  
# 4778 "duk_api_stack.c" 3 4
 __builtin_va_copy(
# 4778 "duk_api_stack.c"
 ap_copy
# 4778 "duk_api_stack.c" 3 4
 ,
# 4778 "duk_api_stack.c"
 ap
# 4778 "duk_api_stack.c" 3 4
 )
# 4778 "duk_api_stack.c"
                         ;
  len = duk__try_push_vsprintf(thr, buf, sz, fmt, ap_copy);
  
# 4780 "duk_api_stack.c" 3 4
 __builtin_va_end(
# 4780 "duk_api_stack.c"
 ap_copy
# 4780 "duk_api_stack.c" 3 4
 )
# 4780 "duk_api_stack.c"
                ;
  if (len >= 0) {
   break;
  }


  sz = sz * 2;
  if (__builtin_expect((sz >= (1L * 1024L * 1024L * 1024L)), 0)) {
   do { duk_err_range((thr), "duk_api_stack.c", (duk_int_t) 4788, ("result too long")); } while (0);
   do { return 
# 4789 "duk_api_stack.c" 3 4
  ((void *)0)
# 4789 "duk_api_stack.c"
  ; } while (0);
  }
 }




 res = duk_push_lstring(thr, (const char *) buf, (duk_size_t) len);
 if (pushed_buf) {
  duk_remove_m2(thr);
 }
 return res;
}

__attribute__ ((visibility("default"))) const char *duk_push_sprintf(duk_hthread *thr, const char *fmt, ...) {
 va_list ap;
 const char *ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);


 
# 4810 "duk_api_stack.c" 3 4
__builtin_va_start(
# 4810 "duk_api_stack.c"
ap
# 4810 "duk_api_stack.c" 3 4
,
# 4810 "duk_api_stack.c"
fmt
# 4810 "duk_api_stack.c" 3 4
)
# 4810 "duk_api_stack.c"
                 ;
 ret = duk_push_vsprintf(thr, fmt, ap);
 
# 4812 "duk_api_stack.c" 3 4
__builtin_va_end(
# 4812 "duk_api_stack.c"
ap
# 4812 "duk_api_stack.c" 3 4
)
# 4812 "duk_api_stack.c"
          ;

 return ret;
}

static __attribute__ ((unused)) duk_hobject *duk_push_object_helper(duk_hthread *thr,
                                                 duk_uint_t hobject_flags_and_class,
                                                 duk_small_int_t prototype_bidx) {
 duk_tval *tv_slot;
 duk_hobject *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4826); } while (0); } } while (0);

 h = duk_hobject_alloc(thr, hobject_flags_and_class);
 do { } while (0);

 do { } while (0);

 tv_slot = thr->valstack_top;
 do { duk_tval *duk__tv; duk__tv = (tv_slot); duk__tv->t = 9; duk__tv->v.hobject = (h); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 thr->valstack_top++;



 if (prototype_bidx >= 0) {
  do { duk_hthread *duk__thr = (thr); duk_hobject *duk__obj = (h); duk_hobject *duk__proto = (thr->builtins[prototype_bidx]); do { (void) (duk__thr); } while (0); do { } while (0); do { (duk__obj)->prototype = (duk__proto); } while (0); do { if ((duk__proto) != 
# 4841 "duk_api_stack.c" 3 4
 ((void *)0)
# 4841 "duk_api_stack.c"
 ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk__proto)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0); } while (0);
 } else {
  do { } while (0);
  do { } while (0);
 }

 return h;
}

static __attribute__ ((unused)) duk_hobject *duk_push_object_helper_proto(duk_hthread *thr, duk_uint_t hobject_flags_and_class, duk_hobject *proto) {
 duk_hobject *h;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h = duk_push_object_helper(thr, hobject_flags_and_class, -1);
 do { } while (0);
 do { duk_hthread *duk__thr = (thr); duk_hobject *duk__obj = (h); duk_hobject *duk__proto = (proto); do { (void) (duk__thr); } while (0); do { } while (0); do { (duk__obj)->prototype = (duk__proto); } while (0); do { if ((duk__proto) != 
# 4857 "duk_api_stack.c" 3 4
((void *)0)
# 4857 "duk_api_stack.c"
) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk__proto)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0); } while (0);
 return h;
}

__attribute__ ((visibility("default"))) duk_idx_t duk_push_object(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 (void) duk_push_object_helper(thr,
                               (1UL << (7 + (0))) | (1UL << (7 + (7))) |
                                   (((duk_uint_t) (1)) << (7 + (20))),
                               3);
 return duk_get_top_index_unsafe(thr);
}

__attribute__ ((visibility("default"))) duk_idx_t duk_push_array(duk_hthread *thr) {
 duk_uint_t flags;
 duk_harray *obj;
 duk_idx_t ret;
 duk_tval *tv_slot;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 flags = (1UL << (7 + (0))) | (1UL << (7 + (7))) | (1UL << (7 + (8))) |
         (1UL << (7 + (15))) | (((duk_uint_t) (2)) << (7 + (20)));

 obj = duk_harray_alloc(thr, flags);
 do { } while (0);

 do { duk_hthread *duk__thr = (thr); duk_hobject *duk__obj = ((duk_hobject *) obj); duk_hobject *duk__proto = (thr->builtins[8]); do { (void) (duk__thr); } while (0); do { } while (0); do { (duk__obj)->prototype = (duk__proto); } while (0); do { if ((duk__proto) != 
# 4885 "duk_api_stack.c" 3 4
((void *)0)
# 4885 "duk_api_stack.c"
) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk__proto)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0); } while (0);

 tv_slot = thr->valstack_top;
 do { duk_tval *duk__tv; duk__tv = (tv_slot); duk__tv->t = 9; duk__tv->v.hobject = ((duk_hobject *) obj); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (obj))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 ret = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom);
 thr->valstack_top++;

 do { } while (0);
 return ret;
}

__attribute__ ((visibility("default"))) duk_idx_t duk_push_bare_array(duk_hthread *thr) {
 duk_uint_t flags;
 duk_harray *obj;
 duk_idx_t ret;
 duk_tval *tv_slot;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 flags = (1UL << (7 + (0))) | (1UL << (7 + (7))) | (1UL << (7 + (8))) |
         (1UL << (7 + (15))) | (((duk_uint_t) (2)) << (7 + (20)));

 obj = duk_harray_alloc(thr, flags);
 do { } while (0);

 tv_slot = thr->valstack_top;
 do { duk_tval *duk__tv; duk__tv = (tv_slot); duk__tv->t = 9; duk__tv->v.hobject = ((duk_hobject *) obj); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (obj))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 ret = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom);
 thr->valstack_top++;

 do { } while (0);
 return ret;
}

static __attribute__ ((unused)) duk_harray *duk_push_harray(duk_hthread *thr) {

 duk_harray *a;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 (void) duk_push_array(thr);
 do { } while (0);
 a = (duk_harray *) ((thr->valstack_top - 1)->v.hobject);
 do { } while (0);
 return a;
}




static __attribute__ ((unused)) duk_harray *duk_push_harray_with_size(duk_hthread *thr, duk_uint32_t size) {
 duk_harray *a;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 a = duk_push_harray(thr);

 duk_hobject_realloc_props(thr, (duk_hobject *) a, 0, size, 0, 0);
 a->length = size;
 return a;
}

static __attribute__ ((unused)) duk_tval *duk_push_harray_with_size_outptr(duk_hthread *thr, duk_uint32_t size) {
 duk_harray *a;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 a = duk_push_harray_with_size(thr, size);
 do { } while (0);
 return ((duk_tval *) (void *) (((((duk_hobject *) a))->props) + ((((duk_hobject *) a))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((duk_hobject *) a))->e_size))) & 0x07)));
}

__attribute__ ((visibility("default"))) duk_idx_t duk_push_thread_raw(duk_hthread *thr, duk_uint_t flags) {
 duk_hthread *obj;
 duk_idx_t ret;
 duk_tval *tv_slot;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 4966); } while (0); } } while (0);

 obj = duk_hthread_alloc(thr, (1UL << (7 + (0))) | (((duk_uint_t) (18)) << (7 + (20))));
 do { } while (0);
 obj->state = 1;






 obj->strs = thr->strs;


 do { } while (0);


 tv_slot = thr->valstack_top;
 do { duk_tval *duk__tv; duk__tv = (tv_slot); duk__tv->t = 9; duk__tv->v.hobject = ((duk_hobject *) obj); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) &(obj)->obj)); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 ret = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom);
 thr->valstack_top++;


 if (__builtin_expect((!duk_hthread_init_stacks(thr->heap, obj)), 0)) {
  do { duk_err_error_alloc_failed((thr), "duk_api_stack.c", (duk_int_t) 4991); } while (0);
  do { return 0; } while (0);
 }


 if (flags & (1U << 0)) {
  duk_hthread_create_builtin_objects(obj);
 } else {
  duk_hthread_copy_builtin_objects(thr, obj);
 }


 do { duk_hthread *duk__thr = (thr); duk_hobject *duk__obj = ((duk_hobject *) obj); duk_hobject *duk__proto = (obj->builtins[35]); do { (void) (duk__thr); } while (0); do { } while (0); do { (duk__obj)->prototype = (duk__proto); } while (0); do { if ((duk__proto) != 
# 5003 "duk_api_stack.c" 3 4
((void *)0)
# 5003 "duk_api_stack.c"
) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk__proto)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0); } while (0);




 do { } while (0);

 return ret;
}

static __attribute__ ((unused)) duk_hcompfunc *duk_push_hcompfunc(duk_hthread *thr) {
 duk_hcompfunc *obj;
 duk_tval *tv_slot;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 5019); } while (0); } } while (0);






 obj = duk_hcompfunc_alloc(thr,
                           (1UL << (7 + (0))) | (1UL << (7 + (2))) | (1UL << (7 + (4))) |
                               (((duk_uint_t) (3)) << (7 + (20))));
 if (__builtin_expect((obj == 
# 5029 "duk_api_stack.c" 3 4
    ((void *)0)
# 5029 "duk_api_stack.c"
    ), 0)) {
  do { duk_err_error_alloc_failed((thr), "duk_api_stack.c", (duk_int_t) 5030); } while (0);
  do { return 
# 5031 "duk_api_stack.c" 3 4
 ((void *)0)
# 5031 "duk_api_stack.c"
 ; } while (0);
 }

 do { } while (0);

 tv_slot = thr->valstack_top;
 do { duk_tval *duk__tv; duk__tv = (tv_slot); duk__tv->t = 9; duk__tv->v.hobject = ((duk_hobject *) obj); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (obj))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 thr->valstack_top++;


 do { } while (0);
 do { duk_hthread *duk__thr = (thr); duk_hobject *duk__obj = ((duk_hobject *) obj); duk_hobject *duk__proto = (thr->builtins[5]); do { (void) (duk__thr); } while (0); do { } while (0); do { (duk__obj)->prototype = (duk__proto); } while (0); do { if ((duk__proto) != 
# 5043 "duk_api_stack.c" 3 4
((void *)0)
# 5043 "duk_api_stack.c"
) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk__proto)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0); } while (0);

 return obj;
}

static __attribute__ ((unused)) duk_hboundfunc *duk_push_hboundfunc(duk_hthread *thr) {
 duk_hboundfunc *obj;
 duk_tval *tv_slot;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 5054); } while (0); } } while (0);
 obj = duk_hboundfunc_alloc(thr->heap,
                            (1UL << (7 + (0))) | (1UL << (7 + (3))) | (1UL << (7 + (1))) |
                                (1UL << (7 + (2))) | (((duk_uint_t) (3)) << (7 + (20))));
 if (!obj) {
  do { duk_err_error_alloc_failed((thr), "duk_api_stack.c", (duk_int_t) 5059); } while (0);
  do { return 
# 5060 "duk_api_stack.c" 3 4
 ((void *)0)
# 5060 "duk_api_stack.c"
 ; } while (0);
 }

 tv_slot = thr->valstack_top++;
 do { duk_tval *duk__tv; duk__tv = (tv_slot); duk__tv->t = 9; duk__tv->v.hobject = ((duk_hobject *) obj); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (obj))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);




 do { } while (0);

 return obj;
}

static duk_idx_t
duk__push_c_function_raw(duk_hthread *thr, duk_c_function func, duk_idx_t nargs, duk_uint_t flags, duk_small_uint_t proto_bidx) {
 duk_hnatfunc *obj;
 duk_idx_t ret;
 duk_tval *tv_slot;
 duk_int16_t func_nargs;

 do { } while (0);

 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 5084); } while (0); } } while (0);

 if (__builtin_expect((func == 
# 5086 "duk_api_stack.c" 3 4
    ((void *)0)
# 5086 "duk_api_stack.c"
    ), 0)) {
  goto api_error;
 }
 if (nargs >= 0 && nargs < ((duk_int16_t) 0x7fff)) {
  func_nargs = (duk_int16_t) nargs;
 } else if (nargs == ((duk_int_t) (-1))) {
  func_nargs = ((duk_int16_t) -1);
 } else {
  goto api_error;
 }

 obj = duk_hnatfunc_alloc(thr, flags);
 do { } while (0);

 obj->func = func;
 obj->nargs = func_nargs;

 do { } while (0)

                                         ;

 tv_slot = thr->valstack_top;
 do { duk_tval *duk__tv; duk__tv = (tv_slot); duk__tv->t = 9; duk__tv->v.hobject = ((duk_hobject *) obj); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (obj))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 ret = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom);
 thr->valstack_top++;

 do { } while (0);
 do { duk_hthread *duk__thr = (thr); duk_hobject *duk__obj = ((duk_hobject *) obj); duk_hobject *duk__proto = (thr->builtins[proto_bidx]); do { (void) (duk__thr); } while (0); do { } while (0); do { (duk__obj)->prototype = (duk__proto); } while (0); do { if ((duk__proto) != 
# 5114 "duk_api_stack.c" 3 4
((void *)0)
# 5114 "duk_api_stack.c"
) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk__proto)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0); } while (0);
 return ret;

api_error:
 do { duk_err_type_invalid_args((thr), "duk_api_stack.c", (duk_int_t) 5118); } while (0);
 do { return 0; } while (0);
}

__attribute__ ((visibility("default"))) duk_idx_t duk_push_c_function(duk_hthread *thr, duk_c_function func, duk_int_t nargs) {
 duk_uint_t flags;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 flags = (1UL << (7 + (0))) | (1UL << (7 + (1))) | (1UL << (7 + (2))) |
         (1UL << (7 + (7))) | (1UL << (7 + (5))) | (1UL << (7 + (11))) | (1UL << (7 + (9))) |
         (1UL << (7 + (10))) | (((duk_uint_t) (3)) << (7 + (20)));




 return duk__push_c_function_raw(thr, func, nargs, flags, 6);
}

static __attribute__ ((unused)) void duk_push_c_function_builtin(duk_hthread *thr, duk_c_function func, duk_int_t nargs) {
 duk_uint_t flags;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 flags = (1UL << (7 + (0))) | (1UL << (7 + (1))) | (1UL << (7 + (2))) |
         (1UL << (7 + (7))) | (1UL << (7 + (5))) | (1UL << (7 + (11))) | (1UL << (7 + (9))) |
         (1UL << (7 + (10))) | (((duk_uint_t) (3)) << (7 + (20)));


 (void) duk__push_c_function_raw(thr, func, nargs, flags, 5);
}

static __attribute__ ((unused)) void duk_push_c_function_builtin_noconstruct(duk_hthread *thr, duk_c_function func, duk_int_t nargs) {
 duk_uint_t flags;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 flags = (1UL << (7 + (0))) | (1UL << (7 + (2))) | (1UL << (7 + (7))) | (1UL << (7 + (5))) |
         (1UL << (7 + (11))) | (1UL << (7 + (9))) | (1UL << (7 + (10))) |
         (((duk_uint_t) (3)) << (7 + (20)));


 (void) duk__push_c_function_raw(thr, func, nargs, flags, 5);
}

__attribute__ ((visibility("default"))) duk_idx_t
duk_push_c_lightfunc(duk_hthread *thr, duk_c_function func, duk_idx_t nargs, duk_idx_t length, duk_int_t magic) {
 duk_small_uint_t lf_flags;
 duk_tval *tv_slot;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 5170); } while (0); } } while (0);

 if (nargs >= 0x00 && nargs <= 0x0e) {

 } else if (nargs == ((duk_int_t) (-1))) {
  nargs = 0x0f;
 } else {
  goto api_error;
 }
 if (__builtin_expect((!(length >= 0x00 && length <= 0x0f)), 0)) {
  goto api_error;
 }
 if (__builtin_expect((!(magic >= (-0x80) && magic <= 0x7f)), 0)) {
  goto api_error;
 }

 lf_flags = ((((duk_small_uint_t) ((duk_small_int_t) magic)) & 0xffU) << 8) | (((duk_small_uint_t) length) << 4) | ((duk_small_uint_t) nargs);
 tv_slot = thr->valstack_top++;
 do { } while (0);
 do { duk_tval *duk__tv; duk__tv = (tv_slot); duk__tv->t = 6; duk__tv->v_extra = (lf_flags); duk__tv->v.lightfunc = (duk_c_function) (func); } while (0);
 do { } while (0);
 return (duk_idx_t) (tv_slot - thr->valstack_bottom);

api_error:
 do { duk_err_type_invalid_args((thr), "duk_api_stack.c", (duk_int_t) 5194); } while (0);
 do { return 0; } while (0);
}


static __attribute__ ((unused)) duk_hbufobj *duk_push_bufobj_raw(duk_hthread *thr,
                                              duk_uint_t hobject_flags_and_class,
                                              duk_small_int_t prototype_bidx) {
 duk_hbufobj *obj;
 duk_tval *tv_slot;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 5208); } while (0); } } while (0);

 obj = duk_hbufobj_alloc(thr, hobject_flags_and_class);
 do { } while (0);

 do { duk_hthread *duk__thr = (thr); duk_hobject *duk__obj = ((duk_hobject *) obj); duk_hobject *duk__proto = (thr->builtins[prototype_bidx]); do { (void) (duk__thr); } while (0); do { } while (0); do { (duk__obj)->prototype = (duk__proto); } while (0); do { if ((duk__proto) != 
# 5213 "duk_api_stack.c" 3 4
((void *)0)
# 5213 "duk_api_stack.c"
) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk__proto)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0); } while (0);
 do { } while (0);

 tv_slot = thr->valstack_top;
 do { duk_tval *duk__tv; duk__tv = (tv_slot); duk__tv->t = 9; duk__tv->v.hobject = ((duk_hobject *) obj); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (obj))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 thr->valstack_top++;

 return obj;
}
# 5232 "duk_api_stack.c"
static const duk_uint32_t duk__bufobj_flags_lookup[] = {

 (((19) << 24) | ((39) << 16) | ((0) << 8) | ((0) << 4) | (0))



                  ,
 (((22) << 24) | ((50) << 16) | ((0) << 8) | ((0) << 4) | (1))



                  ,
 (((20) << 24) | ((40) << 16) | ((0) << 8) | ((0) << 4) | (0))



                  ,
 (((21) << 24) | ((41) << 16) | ((2) << 8) | ((0) << 4) | (1))



                  ,
 (((22) << 24) | ((42) << 16) | ((0) << 8) | ((0) << 4) | (1))



                  ,
 (((23) << 24) | ((43) << 16) | ((1) << 8) | ((0) << 4) | (1))



                  ,
 (((24) << 24) | ((44) << 16) | ((4) << 8) | ((1) << 4) | (1))



                  ,
 (((25) << 24) | ((45) << 16) | ((3) << 8) | ((1) << 4) | (1))



                  ,
 (((26) << 24) | ((46) << 16) | ((6) << 8) | ((2) << 4) | (1))



                  ,
 (((27) << 24) | ((47) << 16) | ((5) << 8) | ((2) << 4) | (1))



                  ,
 (((28) << 24) | ((48) << 16) | ((7) << 8) | ((2) << 4) | (1))



                  ,
 (((29) << 24) | ((49) << 16) | ((8) << 8) | ((3) << 4) | (1))




};



__attribute__ ((visibility("default"))) void duk_push_buffer_object(duk_hthread *thr,
                                         duk_idx_t idx_buffer,
                                         duk_size_t byte_offset,
                                         duk_size_t byte_length,
                                         duk_uint_t flags) {
 duk_hbufobj *h_bufobj;
 duk_hbuffer *h_val;
 duk_hobject *h_arraybuf;
 duk_uint32_t tmp;
 duk_uint_t classnum;
 duk_uint_t protobidx;
 duk_uint_t lookupidx;
 duk_uint_t uint_offset, uint_length, uint_added;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);




 uint_offset = (duk_uint_t) byte_offset;
 uint_length = (duk_uint_t) byte_length;
 if (sizeof(duk_size_t) != sizeof(duk_uint_t)) {
  if (__builtin_expect(((duk_size_t) uint_offset != byte_offset || (duk_size_t) uint_length != byte_length), 0)) {
   goto range_error;
  }
 }

 do { } while (0);
 lookupidx = flags;
 if (__builtin_expect((lookupidx >= sizeof(duk__bufobj_flags_lookup) / sizeof(duk_uint32_t)), 0)) {
  goto arg_error;
 }
 tmp = duk__bufobj_flags_lookup[lookupidx];
 classnum = tmp >> 24;
 protobidx = (tmp >> 16) & 0xff;

 h_arraybuf = duk_get_hobject(thr, idx_buffer);
 if (h_arraybuf != 
# 5335 "duk_api_stack.c" 3 4
                  ((void *)0) 
# 5335 "duk_api_stack.c"
                       &&
     flags != 0 &&
     (((&(h_arraybuf)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 19 ) {
  duk_uint_t tmp_offset;

  do { } while (0);
  h_val = ((duk_hbufobj *) h_arraybuf)->buf;
  if (__builtin_expect((h_val == 
# 5342 "duk_api_stack.c" 3 4
     ((void *)0)
# 5342 "duk_api_stack.c"
     ), 0)) {
   goto arg_error;
  }

  tmp_offset = uint_offset + ((duk_hbufobj *) h_arraybuf)->offset;
  if (__builtin_expect((tmp_offset < uint_offset), 0)) {
   goto range_error;
  }
  uint_offset = tmp_offset;





 } else {



  h_arraybuf = 
# 5360 "duk_api_stack.c" 3 4
              ((void *)0)
# 5360 "duk_api_stack.c"
                  ;
  h_val = duk_require_hbuffer(thr, idx_buffer);
 }


 uint_added = uint_offset + uint_length;
 if (__builtin_expect((uint_added < uint_offset), 0)) {
  goto range_error;
 }
 do { } while (0);

 do { } while (0);

 h_bufobj = duk_push_bufobj_raw(thr,
                                (1UL << (7 + (0))) | (1UL << (7 + (6))) | (((duk_uint_t) (classnum)) << (7 + (20))),
                                (duk_small_int_t) protobidx);
 do { } while (0);

 h_bufobj->buf = h_val;
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_val))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 h_bufobj->buf_prop = h_arraybuf;
 do { if ((h_arraybuf) != 
# 5381 "duk_api_stack.c" 3 4
((void *)0)
# 5381 "duk_api_stack.c"
) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((h_arraybuf)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0);
 h_bufobj->offset = uint_offset;
 h_bufobj->length = uint_length;
 h_bufobj->shift = (tmp >> 4) & 0x0f;
 h_bufobj->elem_type = (tmp >> 8) & 0xff;
 h_bufobj->is_typedarray = tmp & 0x0f;
 do { } while (0);







 return;

range_error:
 do { duk_err_range((thr), "duk_api_stack.c", (duk_int_t) 5398, ("invalid args")); } while (0);
 do { return; } while (0);

arg_error:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 5402; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_api_stack.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid args"))); } while (0); } while (0);
 do { return; } while (0);
}
# 5421 "duk_api_stack.c"
__attribute__ ((visibility("default"))) duk_idx_t duk_push_error_object_va_raw(duk_hthread *thr,
                                                    duk_errcode_t err_code,
                                                    const char *filename,
                                                    duk_int_t line,
                                                    const char *fmt,
                                                    va_list ap) {
 duk_hobject *proto;

 duk_small_uint_t augment_flags;


 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { (void) (filename); } while (0);
 do { (void) (line); } while (0);



 augment_flags = 0;
 if (err_code & (1L << 24)) {
  augment_flags = (1U << 0);
 }

 err_code = err_code & (~(1L << 24));


 proto = duk_error_prototype_from_code(thr, err_code);
 (void) duk_push_object_helper_proto(thr,
                                     (1UL << (7 + (0))) | (1UL << (7 + (7))) |
                                         (((duk_uint_t) (7)) << (7 + (20))),
                                     proto);


 if (fmt) {
  duk_push_vsprintf(thr, fmt, ap);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (52)) << 8) + (duk_uint_t) (((1U << 0) | (1U << 2)))));
 } else {






  duk_push_int(thr, err_code);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (52)) << 8) + (duk_uint_t) (((1U << 0) | (1U << 2)))));
 }






 duk_err_augment_error_create(thr, thr, filename, line, augment_flags);


 return duk_get_top_index_unsafe(thr);
}

__attribute__ ((visibility("default"))) duk_idx_t
duk_push_error_object_raw(duk_hthread *thr, duk_errcode_t err_code, const char *filename, duk_int_t line, const char *fmt, ...) {
 va_list ap;
 duk_idx_t ret;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 
# 5486 "duk_api_stack.c" 3 4
__builtin_va_start(
# 5486 "duk_api_stack.c"
ap
# 5486 "duk_api_stack.c" 3 4
,
# 5486 "duk_api_stack.c"
fmt
# 5486 "duk_api_stack.c" 3 4
)
# 5486 "duk_api_stack.c"
                 ;
 ret = duk_push_error_object_va_raw(thr, err_code, filename, line, fmt, ap);
 
# 5488 "duk_api_stack.c" 3 4
__builtin_va_end(
# 5488 "duk_api_stack.c"
ap
# 5488 "duk_api_stack.c" 3 4
)
# 5488 "duk_api_stack.c"
          ;
 return ret;
}
# 5510 "duk_api_stack.c"
__attribute__ ((visibility("default"))) void *duk_push_buffer_raw(duk_hthread *thr, duk_size_t size, duk_small_uint_t flags) {
 duk_tval *tv_slot;
 duk_hbuffer *h;
 void *buf_data;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 5517); } while (0); } } while (0);


 if (__builtin_expect((size > (0x7ffffffeUL)), 0)) {
  do { duk_err_range((thr), "duk_api_stack.c", (duk_int_t) 5521, ("buffer too long")); } while (0);
  do { return 
# 5522 "duk_api_stack.c" 3 4
 ((void *)0)
# 5522 "duk_api_stack.c"
 ; } while (0);
 }

 h = duk_hbuffer_alloc(thr->heap, size, flags, &buf_data);
 if (__builtin_expect((h == 
# 5526 "duk_api_stack.c" 3 4
    ((void *)0)
# 5526 "duk_api_stack.c"
    ), 0)) {
  do { duk_err_error_alloc_failed((thr), "duk_api_stack.c", (duk_int_t) 5527); } while (0);
  do { return 
# 5528 "duk_api_stack.c" 3 4
 ((void *)0)
# 5528 "duk_api_stack.c"
 ; } while (0);
 }

 tv_slot = thr->valstack_top;
 do { duk_tval *duk__tv; duk__tv = (tv_slot); duk__tv->t = 10; duk__tv->v.hbuffer = (h); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 thr->valstack_top++;

 return (void *) buf_data;
}

static __attribute__ ((unused)) void *duk_push_fixed_buffer_nozero(duk_hthread *thr, duk_size_t len) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk_push_buffer_raw(thr, len, (1 << 2));
}

static __attribute__ ((unused)) void *duk_push_fixed_buffer_zero(duk_hthread *thr, duk_size_t len) {
 void *ptr;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 ptr = duk_push_buffer_raw(thr, len, 0);
 do { } while (0);






 return ptr;
}


__attribute__ ((visibility("default"))) duk_idx_t duk_push_proxy(duk_hthread *thr, duk_uint_t proxy_flags) {
 duk_hobject *h_target;
 duk_hobject *h_handler;
 duk_hproxy *h_proxy;
 duk_tval *tv_slot;
 duk_uint_t flags;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { (void) (proxy_flags); } while (0);
# 5582 "duk_api_stack.c"
 h_target = duk_require_hobject_promote_mask(thr, -2, (1U << 9U) | (1U << 7U));
 do { } while (0);
 if ((((&((h_target))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)) {
  goto fail_args;
 }
# 5598 "duk_api_stack.c"
 h_handler = duk_require_hobject_promote_mask(thr, -1, (1U << 9U) | (1U << 7U));
 do { } while (0);
 if ((((&((h_handler))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)) {
  goto fail_args;
 }
# 5611 "duk_api_stack.c"
 flags = (((duk_heaphdr *) h_target)->h_flags & (~0x00000003UL)) & ((1UL << (7 + (2))) | (1UL << (7 + (1))));
 flags |= (1UL << (7 + (0))) | (1UL << (7 + (18)));
 if (flags & (1UL << (7 + (2)))) {
  flags |= (((duk_uint_t) (3)) << (7 + (20))) | (1UL << (7 + (19)));
 } else {
  flags |= (((duk_uint_t) (1)) << (7 + (20)));
 }

 h_proxy = duk_hproxy_alloc(thr, flags);
 do { } while (0);
 do { } while (0);





 do { } while (0);
 h_proxy->target = h_target;
 do { } while (0);
 h_proxy->handler = h_handler;
 do { } while (0);

 do { } while (0);
 do { } while (0);
 tv_slot = thr->valstack_top - 2;
 do { } while (0);
 do { duk_tval *duk__tv; duk__tv = (tv_slot); duk__tv->t = 9; duk__tv->v.hobject = ((duk_hobject *) h_proxy); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk_hobject *) h_proxy))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 tv_slot++;
 do { duk_tval *duk__tv; duk__tv = (tv_slot); duk__tv->t = 2; } while (0);
 thr->valstack_top = tv_slot;

 do { } while (0);

 return (duk_idx_t) (thr->valstack_top - thr->valstack_bottom - 1);

fail_args:
 do { duk_err_type_invalid_args((thr), "duk_api_stack.c", (duk_int_t) 5648); } while (0);
 do { return 0; } while (0);
}
# 5754 "duk_api_stack.c"
__attribute__ ((visibility("default"))) duk_idx_t duk_push_heapptr(duk_hthread *thr, void *ptr) {
 duk_idx_t ret;
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
# 5771 "duk_api_stack.c"
 do { if (__builtin_expect((thr->valstack_top >= thr->valstack_end), 0)) { do { duk_err_range_push_beyond((thr), "duk_api_stack.c", (duk_int_t) 5771); } while (0); } } while (0);

 ret = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom);
 tv = thr->valstack_top++;

 if (ptr == 
# 5776 "duk_api_stack.c" 3 4
           ((void *)0)
# 5776 "duk_api_stack.c"
               ) {
  do { } while (0);
  return ret;
 }

 do { } while (0);
# 5800 "duk_api_stack.c"
 if (__builtin_expect(((((((duk_heaphdr *) ptr))->h_flags & ((1UL << (2 + (2))))) != 0)), 0)) {
  duk_heaphdr *curr;

  do { } while (0);

  curr = (duk_heaphdr *) ptr;
  do { do { } while (0); ((curr))->h_flags &= ~(((1UL << (2 + (2))))); } while (0);





  do { do { } while (0); ((curr))->h_flags &= ~(((1UL << (2 + (3))))); } while (0);





  do { } while (0);
  (--(curr)->h_refcount);

  duk_heap_remove_from_finalize_list((thr->heap), (curr));
  duk_heap_insert_into_heap_allocated((thr->heap), (curr));


 }

 switch ((((duk_heaphdr *) ptr)->h_flags & 0x00000003UL)) {
 case 0:
  do { duk_tval *duk__tv; duk__tv = (tv); duk__tv->t = 8; duk__tv->v.hstring = ((duk_hstring *) ptr); } while (0);
  break;
 case 1:
  do { duk_tval *duk__tv; duk__tv = (tv); duk__tv->t = 9; duk__tv->v.hobject = ((duk_hobject *) ptr); } while (0);
  break;
 default:
  do { } while (0);
  do { duk_tval *duk__tv; duk__tv = (tv); duk__tv->t = 10; duk__tv->v.hbuffer = ((duk_hbuffer *) ptr); } while (0);
  break;
 }

 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ptr)); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);

 return ret;
}


__attribute__ ((visibility("default"))) duk_idx_t duk_push_bare_object(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 (void) duk_push_object_helper(thr,
                               (1UL << (7 + (0))) | (1UL << (7 + (7))) |
                                   (((duk_uint_t) (1)) << (7 + (20))),
                               -1);
 return duk_get_top_index_unsafe(thr);
}

static __attribute__ ((unused)) void duk_push_hstring(duk_hthread *thr, duk_hstring *h) {
 duk_tval tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 do { duk_tval *duk__tv; duk__tv = (&tv); duk__tv->t = 8; duk__tv->v.hstring = (h); } while (0);
 duk_push_tval(thr, &tv);
}

static __attribute__ ((unused)) void duk_push_hstring_stridx(duk_hthread *thr, duk_small_uint_t stridx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 duk_push_hstring(thr, ((thr)->strs[(stridx)]));
}

static __attribute__ ((unused)) void duk_push_hstring_empty(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 duk_push_hstring(thr, ((thr)->strs[(15)]));
}

static __attribute__ ((unused)) void duk_push_hobject(duk_hthread *thr, duk_hobject *h) {
 duk_tval tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 do { duk_tval *duk__tv; duk__tv = (&tv); duk__tv->t = 9; duk__tv->v.hobject = (h); } while (0);
 duk_push_tval(thr, &tv);
}

static __attribute__ ((unused)) void duk_push_hbuffer(duk_hthread *thr, duk_hbuffer *h) {
 duk_tval tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 do { duk_tval *duk__tv; duk__tv = (&tv); duk__tv->t = 10; duk__tv->v.hbuffer = (h); } while (0);
 duk_push_tval(thr, &tv);
}

static __attribute__ ((unused)) void duk_push_hobject_bidx(duk_hthread *thr, duk_small_int_t builtin_idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);

 duk_push_hobject(thr, thr->builtins[builtin_idx]);
}





static inline __attribute__((always_inline)) void duk__pop_n_unsafe_raw(duk_hthread *thr, duk_idx_t count) {
 duk_tval *tv;

 duk_tval *tv_end;


 do { } while (0);
 do { } while (0);
 do { } while (0);


 tv = thr->valstack_top;
 tv_end = tv - count;
 while (tv != tv_end) {
  tv--;
  do { } while (0);
  do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 2; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz((((thr))), duk__h); } } } while (0); } while (0);
 }
 thr->valstack_top = tv;
 do { duk_refzero_check_fast((thr)); } while (0);
# 5940 "duk_api_stack.c"
 do { } while (0);
}

__attribute__ ((visibility("default"))) void duk_pop_n(duk_hthread *thr, duk_idx_t count) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 if (__builtin_expect(((duk_uidx_t) (thr->valstack_top - thr->valstack_bottom) < (duk_uidx_t) count), 0)) {
  do { do { duk_err_range(((thr)), "duk_api_stack.c", (duk_int_t) 5948, ("invalid count")); } while (0); } while (0);
  do { return; } while (0);
 }
 do { } while (0);

 duk__pop_n_unsafe_raw(thr, count);
}







static __attribute__ ((unused)) void duk_pop_n_unsafe(duk_hthread *thr, duk_idx_t count) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 duk__pop_n_unsafe_raw(thr, count);
}




static __attribute__ ((unused)) void duk_pop_n_nodecref_unsafe(duk_hthread *thr, duk_idx_t count) {
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 tv = thr->valstack_top;
 while (count > 0) {
  count--;
  tv--;
  do { } while (0);
  do { duk_tval *duk__tv; duk__tv = (tv); duk__tv->t = 2; } while (0);
 }
 thr->valstack_top = tv;

 do { } while (0);
}
# 6013 "duk_api_stack.c"
static inline __attribute__((always_inline)) void duk__pop_unsafe_raw(duk_hthread *thr) {
 duk_tval *tv;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 tv = --thr->valstack_top;
 do { } while (0);

 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 2; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);




 do { } while (0);
}
__attribute__ ((visibility("default"))) void duk_pop(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 do { } while (0);
 if (__builtin_expect((thr->valstack_top == thr->valstack_bottom), 0)) {
  do { do { duk_err_range(((thr)), "duk_api_stack.c", (duk_int_t) 6036, ("invalid count")); } while (0); } while (0);
  do { return; } while (0);
 }

 duk__pop_unsafe_raw(thr);
}
static __attribute__ ((unused)) void duk_pop_unsafe(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 duk__pop_unsafe_raw(thr);
}
static __attribute__ ((unused)) void duk_pop_nodecref_unsafe(duk_hthread *thr) {
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 tv = --thr->valstack_top;
 do { } while (0);
 do { duk_tval *duk__tv; duk__tv = (tv); duk__tv->t = 2; } while (0);

 do { } while (0);
}
# 6068 "duk_api_stack.c"
static __attribute__ ((unused)) void duk_pop_undefined(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);
 thr->valstack_top--;

 do { } while (0);
}
# 6095 "duk_api_stack.c"
static inline __attribute__((always_inline)) void duk__pop_2_unsafe_raw(duk_hthread *thr) {
 duk_tval *tv;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 tv = --thr->valstack_top;
 do { } while (0);

 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 2; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);



 tv = --thr->valstack_top;
 do { } while (0);

 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 2; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);




 do { } while (0);
}
__attribute__ ((visibility("default"))) void duk_pop_2(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 do { } while (0);
 if (__builtin_expect((thr->valstack_top - 2 < thr->valstack_bottom), 0)) {
  do { do { duk_err_range(((thr)), "duk_api_stack.c", (duk_int_t) 6125, ("invalid count")); } while (0); } while (0);
  do { return; } while (0);
 }

 duk__pop_2_unsafe_raw(thr);
}
static __attribute__ ((unused)) void duk_pop_2_unsafe(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 duk__pop_2_unsafe_raw(thr);
}
static __attribute__ ((unused)) void duk_pop_2_nodecref_unsafe(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);
 do { } while (0);
 thr->valstack_top -= 2;

 do { } while (0);
}


__attribute__ ((visibility("default"))) void duk_pop_3(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 duk_pop_n(thr, 3);
}

static __attribute__ ((unused)) void duk_pop_3_unsafe(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 duk_pop_n_unsafe(thr, 3);
}

static __attribute__ ((unused)) void duk_pop_3_nodecref_unsafe(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 duk_pop_n_nodecref_unsafe(thr, 3);
}







static __attribute__ ((unused)) void duk_pack(duk_hthread *thr, duk_idx_t count) {
 duk_tval *tv_src;
 duk_tval *tv_dst;
 duk_tval *tv_curr;
 duk_tval *tv_limit;
 duk_idx_t top;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 do { } while (0);
 top = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom);
 do { } while (0);
 if (__builtin_expect(((duk_uidx_t) count > (duk_uidx_t) top), 0)) {

  do { do { duk_err_range(((thr)), "duk_api_stack.c", (duk_int_t) 6184, ("invalid count")); } while (0); } while (0);
  do { return; } while (0);
 }
 do { } while (0);





 do { } while (0);
 do { } while (0);

 tv_dst = duk_push_harray_with_size_outptr(thr, (duk_uint32_t) count);
 do { } while (0);
 do { } while (0);




 tv_src = thr->valstack_top - count - 1;
 do { void *duk__dst = ((void *) tv_dst); const void *duk__src = ((const void *) tv_src); duk_size_t duk__len = ((size_t) count * sizeof(duk_tval)); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0);





 tv_dst = tv_src;
 tv_src = thr->valstack_top - 1;
 do { *(tv_dst) = *(tv_src); } while (0);


 tv_curr = tv_dst + 1;
 tv_limit = thr->valstack_top;
 while (tv_curr != tv_limit) {

  do { duk_tval *duk__tv; duk__tv = (tv_curr); duk__tv->t = 2; } while (0);
  tv_curr++;
 }
 thr->valstack_top = tv_dst + 1;
}

static __attribute__ ((unused)) duk_idx_t duk_unpack_array_like(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv = duk_require_tval(thr, idx);
 if (__builtin_expect((((tv)->t == 9)), 1)) {
  duk_hobject *h;
  duk_uint32_t len;
  duk_uint32_t i;

  h = ((tv)->v.hobject);
  do { } while (0);
  do { (void) (h); } while (0);


  if (__builtin_expect(((((&((h))->hdr)->h_flags & ((1UL << (7 + (15))))) != 0) && ((duk_harray *) h)->length <= ((h)->a_size)), 1)) {
   duk_harray *h_arr;
   duk_tval *tv_src;
   duk_tval *tv_dst;

   h_arr = (duk_harray *) h;
   len = h_arr->length;
   if (__builtin_expect((len >= 0x80000000UL), 0)) {
    goto fail_over_2g;
   }
   duk_require_stack(thr, (duk_idx_t) len);
# 6262 "duk_api_stack.c"
   if (__builtin_expect((len != h_arr->length || h_arr->length > (((duk_hobject *) h_arr)->a_size)), 0)) {
    goto skip_fast;
   }






   do { } while (0);
   tv_src = ((duk_tval *) (void *) ((((h))->props) + (((h))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - ((((h))->e_size))) & 0x07)));
   tv_dst = thr->valstack_top;
   while (len-- > 0) {
    do { } while (0);
    if (__builtin_expect((((tv_src)->t == 7)), 0)) {




     do { } while (0);
    } else {
     do { *(tv_dst) = *(tv_src); } while (0);
     do { duk_tval *duk__tv = ((tv_dst)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
    }
    tv_src++;
    tv_dst++;
   }
   do { } while (0);
   thr->valstack_top = tv_dst;
   return (duk_idx_t) h_arr->length;
  }
 skip_fast:







  idx = duk_normalize_index(thr, idx);
  duk_get_prop_stridx(thr, idx, 87);
  len = duk_to_uint32(thr, -1);
  if (__builtin_expect((len >= 0x80000000UL), 0)) {
   goto fail_over_2g;
  }
  duk_pop_unsafe(thr);
  do { } while (0);

  duk_require_stack(thr, (duk_idx_t) len);
  for (i = 0; i < len; i++) {
   duk_get_prop_index(thr, idx, (duk_uarridx_t) i);
  }
  return (duk_idx_t) len;
 } else if (((tv)->t == 2) || ((tv)->t == 3)) {
  return 0;
 }

 do { duk_err_type_invalid_args((thr), "duk_api_stack.c", (duk_int_t) 6319); } while (0);
 do { return 0; } while (0);

fail_over_2g:
 do { do { duk_err_range(((thr)), "duk_api_stack.c", (duk_int_t) 6323, ("invalid length")); } while (0); } while (0);
 do { return 0; } while (0);
}






#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsuggest-attribute=noreturn"




__attribute__ ((visibility("default"))) void duk_throw_raw(duk_hthread *thr) {
 duk_tval *tv_val;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 if (__builtin_expect((thr->valstack_top == thr->valstack_bottom), 0)) {
  do { duk_err_type_invalid_args((thr), "duk_api_stack.c", (duk_int_t) 6347); } while (0);
  do { return; } while (0);
 }
# 6360 "duk_api_stack.c"
 duk_hthread_sync_and_null_currpc(thr);


 do { } while (0);
 duk_err_augment_error_throw(thr);

 do { } while (0);

 tv_val = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));
 duk_err_setup_ljstate1(thr, 1, tv_val);
# 6379 "duk_api_stack.c"
 duk_err_longjmp(thr);
 do { __builtin_unreachable(); } while (0);
}

__attribute__ ((visibility("default"))) void duk_fatal_raw(duk_hthread *thr, const char *err_msg) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);





 thr->heap->fatal_func(thr->heap->heap_udata, err_msg);





 do { } while (0);
 for (;;) {

 }
}

__attribute__ ((visibility("default"))) void duk_error_va_raw(duk_hthread *thr,
                                   duk_errcode_t err_code,
                                   const char *filename,
                                   duk_int_t line,
                                   const char *fmt,
                                   va_list ap) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 duk_push_error_object_va_raw(thr, err_code, filename, line, fmt, ap);
 (void) (duk_throw_raw((thr)), (duk_ret_t) 0);
 do { return; } while (0);
}

__attribute__ ((visibility("default"))) void duk_error_raw(duk_hthread *thr,
                                duk_errcode_t err_code,
                                const char *filename,
                                duk_int_t line,
                                const char *fmt,
                                ...) {
 va_list ap;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 
# 6430 "duk_api_stack.c" 3 4
__builtin_va_start(
# 6430 "duk_api_stack.c"
ap
# 6430 "duk_api_stack.c" 3 4
,
# 6430 "duk_api_stack.c"
fmt
# 6430 "duk_api_stack.c" 3 4
)
# 6430 "duk_api_stack.c"
                 ;
 duk_push_error_object_va_raw(thr, err_code, filename, line, fmt, ap);
 
# 6432 "duk_api_stack.c" 3 4
__builtin_va_end(
# 6432 "duk_api_stack.c"
ap
# 6432 "duk_api_stack.c" 3 4
)
# 6432 "duk_api_stack.c"
          ;
 (void) (duk_throw_raw((thr)), (duk_ret_t) 0);
 do { return; } while (0);
}


#pragma GCC diagnostic pop
# 6510 "duk_api_stack.c"
__attribute__ ((visibility("default"))) duk_bool_t duk_equals(duk_hthread *thr, duk_idx_t idx1, duk_idx_t idx2) {
 duk_tval *tv1, *tv2;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv1 = duk_get_tval(thr, idx1);
 tv2 = duk_get_tval(thr, idx2);
 if ((tv1 == 
# 6517 "duk_api_stack.c" 3 4
            ((void *)0)
# 6517 "duk_api_stack.c"
                ) || (tv2 == 
# 6517 "duk_api_stack.c" 3 4
                             ((void *)0)
# 6517 "duk_api_stack.c"
                                 )) {
  return 0;
 }




 return duk_js_equals_helper((thr), (tv1), (tv2), 0);
}

__attribute__ ((visibility("default"))) duk_bool_t duk_strict_equals(duk_hthread *thr, duk_idx_t idx1, duk_idx_t idx2) {
 duk_tval *tv1, *tv2;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv1 = duk_get_tval(thr, idx1);
 tv2 = duk_get_tval(thr, idx2);
 if ((tv1 == 
# 6534 "duk_api_stack.c" 3 4
            ((void *)0)
# 6534 "duk_api_stack.c"
                ) || (tv2 == 
# 6534 "duk_api_stack.c" 3 4
                             ((void *)0)
# 6534 "duk_api_stack.c"
                                 )) {
  return 0;
 }


 return duk_js_equals_helper(
# 6539 "duk_api_stack.c" 3 4
       ((void *)0)
# 6539 "duk_api_stack.c"
       , (tv1), (tv2), (1U << 1));
}

__attribute__ ((visibility("default"))) duk_bool_t duk_samevalue(duk_hthread *thr, duk_idx_t idx1, duk_idx_t idx2) {
 duk_tval *tv1, *tv2;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 tv1 = duk_get_tval(thr, idx1);
 tv2 = duk_get_tval(thr, idx2);
 if ((tv1 == 
# 6549 "duk_api_stack.c" 3 4
            ((void *)0)
# 6549 "duk_api_stack.c"
                ) || (tv2 == 
# 6549 "duk_api_stack.c" 3 4
                             ((void *)0)
# 6549 "duk_api_stack.c"
                                 )) {
  return 0;
 }


 return duk_js_equals_helper(
# 6554 "duk_api_stack.c" 3 4
       ((void *)0)
# 6554 "duk_api_stack.c"
       , (tv1), (tv2), (1U << 0));
}





__attribute__ ((visibility("default"))) duk_bool_t duk_instanceof(duk_hthread *thr, duk_idx_t idx1, duk_idx_t idx2) {
 duk_tval *tv1, *tv2;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);







 tv1 = duk_require_tval(thr, idx1);
 do { } while (0);
 tv2 = duk_require_tval(thr, idx2);
 do { } while (0);

 return duk_js_instanceof(thr, tv1, tv2);
}





static __attribute__ ((unused)) void duk_push_lightfunc_name_raw(duk_hthread *thr, duk_c_function func, duk_small_uint_t lf_flags) {
# 6597 "duk_api_stack.c"
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 duk_push_literal_raw((thr), ("light_"), sizeof(("light_")) - 1U);
 duk_push_string_funcptr(thr, (duk_uint8_t *) &func, sizeof(func));
 duk_push_sprintf(thr, "_%04x", (unsigned int) lf_flags);
 duk_concat(thr, 3);
}

static __attribute__ ((unused)) void duk_push_lightfunc_name(duk_hthread *thr, duk_tval *tv) {
 duk_c_function func;
 duk_small_uint_t lf_flags;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 do { (lf_flags) = (duk_uint32_t) (tv)->v_extra; (func) = (tv)->v.lightfunc; } while (0);
 duk_push_lightfunc_name_raw(thr, func, lf_flags);
}

static __attribute__ ((unused)) void duk_push_lightfunc_tostring(duk_hthread *thr, duk_tval *tv) {
 duk_c_function func;
 duk_small_uint_t lf_flags;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 do { (lf_flags) = (duk_uint32_t) (tv)->v_extra; (func) = (tv)->v.lightfunc; } while (0);
 duk_push_literal_raw((thr), ("function "), sizeof(("function ")) - 1U);
 duk_push_lightfunc_name_raw(thr, func, lf_flags);
 duk_push_literal_raw((thr), ("() { [lightfunc code] }"), sizeof(("() { [lightfunc code] }")) - 1U);
 duk_concat(thr, 3);
}
# 6637 "duk_api_stack.c"
static __attribute__ ((unused)) void duk_push_string_funcptr(duk_hthread *thr, duk_uint8_t *ptr, duk_size_t sz) {
 duk_uint8_t buf[32 * 2];
 duk_uint8_t *p, *q;
 duk_small_uint_t i;
 duk_small_uint_t t;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 p = buf;

 q = ptr + sz;



 for (i = 0; i < sz; i++) {

  t = *(--q);



  *p++ = duk_lc_digits[t >> 4];
  *p++ = duk_lc_digits[t & 0x0f];
 }

 duk_push_lstring(thr, (const char *) buf, sz * 2);
}
# 6682 "duk_api_stack.c"
static void duk__push_hstring_readable_unicode(duk_hthread *thr, duk_hstring *h_input, duk_small_uint_t maxchars) {
 const duk_uint8_t *p, *p_start, *p_end;
 duk_uint8_t buf[7 * 96 + 2 + 3 ];
 duk_uint8_t *q;
 duk_ucodepoint_t cp;
 duk_small_uint_t nchars;

 do { } while (0);
 do { } while (0);
 do { } while (0);

 p_start = (const duk_uint8_t *) ((const duk_uint8_t *) ((h_input) + 1));
 p_end = p_start + ((h_input)->blen);
 p = p_start;
 q = buf;

 nchars = 0;
 *q++ = (duk_uint8_t) 0x27;
 for (;;) {
  if (p >= p_end) {
   break;
  }
  if (nchars == maxchars) {
   *q++ = (duk_uint8_t) 0x2e;
   *q++ = (duk_uint8_t) 0x2e;
   *q++ = (duk_uint8_t) 0x2e;
   break;
  }
  if (duk_unicode_decode_xutf8(thr, &p, p_start, p_end, &cp)) {
   if (cp < 0x20 || cp == 0x7f || cp == 0x27 || cp == 0x5c) {
    do { } while (0);
    do { } while (0);
    *q++ = (duk_uint8_t) 0x5c;
    *q++ = (duk_uint8_t) 0x78;
    *q++ = (duk_uint8_t) duk_lc_digits[cp >> 4];
    *q++ = (duk_uint8_t) duk_lc_digits[cp & 0x0f];
   } else {
    q += duk_unicode_encode_xutf8(cp, q);
   }
  } else {
   p++;
   *q++ = (duk_uint8_t) 0x3f;
  }
  nchars++;
 }
 *q++ = (duk_uint8_t) 0x27;

 duk_push_lstring(thr, (const char *) buf, (duk_size_t) (q - buf));
}

static const char *duk__push_string_tval_readable(duk_hthread *thr, duk_tval *tv, duk_bool_t error_aware) {
 do { } while (0);


 if (tv == 
# 6736 "duk_api_stack.c" 3 4
          ((void *)0)
# 6736 "duk_api_stack.c"
              ) {
  duk_push_literal_raw((thr), ("none"), sizeof(("none")) - 1U);
 } else {
  switch (((tv)->t)) {
  case 8: {
   duk_hstring *h = ((tv)->v.hstring);
   if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)) {



    duk_push_literal_raw((thr), ("[Symbol "), sizeof(("[Symbol ")) - 1U);
    duk_push_string(thr, duk__get_symbol_type_string(h));
    duk_push_literal_raw((thr), (" "), sizeof((" ")) - 1U);
    duk__push_hstring_readable_unicode(thr, h, 32);
    duk_push_literal_raw((thr), ("]"), sizeof(("]")) - 1U);
    duk_concat(thr, 5);
    break;
   }
   duk__push_hstring_readable_unicode(thr, h, 32);
   break;
  }
  case 9: {
   duk_hobject *h = ((tv)->v.hobject);
   do { } while (0);

   if (error_aware && duk_hobject_prototype_chain_contains(thr,
                                                           h,
                                                           thr->builtins[20],
                                                           1 )) {







    duk_tval *tv_msg;
    tv_msg = duk_hobject_find_entry_tval_ptr_stridx(thr->heap, h, 52);
    if (tv_msg != 
# 6774 "duk_api_stack.c" 3 4
                 ((void *)0) 
# 6774 "duk_api_stack.c"
                      && ((tv_msg)->t == 8)) {



     duk__push_hstring_readable_unicode(thr,
                                        ((tv_msg)->v.hstring),
                                        96);
     break;
    }
   }
   duk_push_class_string_tval(thr, tv, 1 );
   break;
  }
  case 10: {





   duk_hbuffer *h = ((tv)->v.hbuffer);
   do { } while (0);
   duk_push_sprintf(thr, "[buffer:%ld]", (long) (((duk_hbuffer *) (h))->size));
   break;
  }
  case 5: {



   duk_push_tval(thr, tv);
   duk_push_sprintf(thr, "(%s)", duk_to_string(thr, -1));
   duk_remove_m2(thr);
   break;
  }
  default: {
   duk_push_tval(thr, tv);
   break;
  }
  }
 }

 return duk_to_string(thr, -1);
}
static __attribute__ ((unused)) const char *duk_push_string_tval_readable(duk_hthread *thr, duk_tval *tv) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__push_string_tval_readable(thr, tv, 0 );
}

static __attribute__ ((unused)) const char *duk_push_string_readable(duk_hthread *thr, duk_idx_t idx) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk_push_string_tval_readable(thr, duk_get_tval(thr, idx));
}

static __attribute__ ((unused)) const char *duk_push_string_tval_readable_error(duk_hthread *thr, duk_tval *tv) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 return duk__push_string_tval_readable(thr, tv, 1 );
}

static __attribute__ ((unused)) void duk_push_symbol_descriptive_string(duk_hthread *thr, duk_hstring *h) {
 const duk_uint8_t *p;
 const duk_uint8_t *p_end;
 const duk_uint8_t *q;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);


 duk_push_literal_raw((thr), ("Symbol("), sizeof(("Symbol(")) - 1U);
 p = (const duk_uint8_t *) ((const duk_uint8_t *) ((h) + 1));
 p_end = p + ((h)->blen);
 do { } while (0);
 p++;
 for (q = p; q < p_end; q++) {
  if (*q == 0xffU) {





   break;
  }
 }
 duk_push_lstring(thr, (const char *) p, (duk_size_t) (q - p));
 duk_push_literal_raw((thr), (")"), sizeof((")")) - 1U);
 duk_concat(thr, 3);
}
# 6885 "duk_api_stack.c"
static __attribute__ ((unused)) void duk_copy_tvals_incref(duk_hthread *thr, duk_tval *tv_dst, duk_tval *tv_src, duk_size_t count) {
 duk_tval *tv;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { (void) (thr); } while (0);
 do { } while (0);

 do { void *duk__dst = ((void *) tv_dst); const void *duk__src = ((const void *) tv_src); duk_size_t duk__len = (count * sizeof(duk_tval)); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0);

 tv = tv_dst;
 while (count-- > 0) {
  do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  tv++;
 }
}
# 1 "duk_api_string.c"






static void duk__concat_and_join_helper(duk_hthread *thr, duk_idx_t count_in, duk_bool_t is_join) {
 duk_uint_t count;
 duk_uint_t i;
 duk_size_t idx;
 duk_size_t len;
 duk_hstring *h;
 duk_uint8_t *buf;

 do { } while (0);

 if (__builtin_expect((count_in <= 0), 0)) {
  if (count_in < 0) {
   do { do { duk_err_range(((thr)), "duk_api_string.c", (duk_int_t) 19, ("invalid count")); } while (0); } while (0);
   do { return; } while (0);
  }
  do { } while (0);
  duk_push_hstring_empty(thr);
  return;
 }
 count = (duk_uint_t) count_in;

 if (is_join) {
  duk_size_t t1, t2, limit;
  h = duk_to_hstring(thr, -((duk_idx_t) count) - 1);
  do { } while (0);


  t1 = (duk_size_t) ((h)->blen);
  t2 = (duk_size_t) (count - 1);
  limit = (duk_size_t) (0x7fffffffUL);
  if (__builtin_expect((t2 != 0 && t1 > limit / t2), 0)) {

   goto error_overflow;
  }
  len = (duk_size_t) (t1 * t2);
 } else {
  len = (duk_size_t) 0;
 }

 for (i = count; i >= 1; i--) {
  duk_size_t new_len;
  h = duk_to_hstring(thr, -((duk_idx_t) i));
  new_len = len + (duk_size_t) ((h)->blen);




  if (new_len < len ||
      new_len > (duk_size_t) (0x7fffffffUL)) {
   goto error_overflow;
  }
  len = new_len;
 }

 do { } while (0);




 buf = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, len);
 do { } while (0);



 idx = 0;
 for (i = count; i >= 1; i--) {
  if (is_join && i != count) {
   h = duk_require_hstring(thr, -((duk_idx_t) count) - 2);
   do { void *duk__dst = (buf + idx); const void *duk__src = (((const duk_uint8_t *) ((h) + 1))); duk_size_t duk__len = (((h)->blen)); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
   idx += ((h)->blen);
  }
  h = duk_require_hstring(thr, -((duk_idx_t) i) - 1);
  do { void *duk__dst = (buf + idx); const void *duk__src = (((const duk_uint8_t *) ((h) + 1))); duk_size_t duk__len = (((h)->blen)); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
  idx += ((h)->blen);
 }

 do { } while (0);





 if (is_join) {
  duk_replace(thr, -((duk_idx_t) count) - 2);
  duk_pop_n(thr, (duk_idx_t) count);
 } else {
  duk_replace(thr, -((duk_idx_t) count) - 1);
  duk_pop_n(thr, (duk_idx_t) (count - 1));
 }



 (void) duk_buffer_to_string(thr, -1);


 return;

error_overflow:
 do { duk_err_range((thr), "duk_api_string.c", (duk_int_t) 105, ("result too long")); } while (0);
 do { return; } while (0);
}

__attribute__ ((visibility("default"))) void duk_concat(duk_hthread *thr, duk_idx_t count) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 duk__concat_and_join_helper(thr, count, 0 );
}







static __attribute__ ((unused)) void duk_concat_2(duk_hthread *thr) {
 duk_hstring *h1;
 duk_hstring *h2;
 duk_uint8_t *buf;
 duk_size_t len1;
 duk_size_t len2;
 duk_size_t len;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);

 h1 = duk_to_hstring(thr, -2);
 h2 = duk_to_hstring(thr, -1);
 len1 = (duk_size_t) ((h1)->blen);
 len2 = (duk_size_t) ((h2)->blen);
 len = len1 + len2;
 if (__builtin_expect((len < len1 || len > (duk_size_t) (0x7fffffffUL)), 0)
                                                             ) {
  goto error_overflow;
 }
 buf = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, len);
 do { } while (0);

 do { void *duk__dst = ((void *) buf); const void *duk__src = ((const void *) ((const duk_uint8_t *) ((h1) + 1))); duk_size_t duk__len = ((size_t) len1); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 do { void *duk__dst = ((void *) (buf + len1)); const void *duk__src = ((const void *) ((const duk_uint8_t *) ((h2) + 1))); duk_size_t duk__len = ((size_t) len2); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 (void) duk_buffer_to_string(thr, -1);



 duk_replace(thr, -3);
 duk_pop_unsafe(thr);
 return;

error_overflow:
 do { duk_err_range((thr), "duk_api_string.c", (duk_int_t) 155, ("result too long")); } while (0);
 do { return; } while (0);
}


__attribute__ ((visibility("default"))) void duk_join(duk_hthread *thr, duk_idx_t count) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 duk__concat_and_join_helper(thr, count, 1 );
}





__attribute__ ((visibility("default"))) void duk_decode_string(duk_hthread *thr, duk_idx_t idx, duk_decode_char_function callback, void *udata) {
 duk_hstring *h_input;
 const duk_uint8_t *p, *p_start, *p_end;
 duk_codepoint_t cp;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 h_input = duk_require_hstring(thr, idx);
 do { } while (0);

 p_start = (const duk_uint8_t *) ((const duk_uint8_t *) ((h_input) + 1));
 p_end = p_start + ((h_input)->blen);
 p = p_start;

 for (;;) {
  if (p >= p_end) {
   break;
  }
  cp = (duk_codepoint_t) duk_unicode_decode_xutf8_checked(thr, &p, p_start, p_end);
  callback(udata, cp);
 }
}

__attribute__ ((visibility("default"))) void duk_map_string(duk_hthread *thr, duk_idx_t idx, duk_map_char_function callback, void *udata) {
 duk_hstring *h_input;
 duk_bufwriter_ctx bw_alloc;
 duk_bufwriter_ctx *bw;
 const duk_uint8_t *p, *p_start, *p_end;
 duk_codepoint_t cp;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_normalize_index(thr, idx);

 h_input = duk_require_hstring(thr, idx);
 do { } while (0);

 bw = &bw_alloc;
 do { duk_bw_init_pushbuf((thr), (bw), (((h_input)->blen))); } while (0);

 p_start = (const duk_uint8_t *) ((const duk_uint8_t *) ((h_input) + 1));
 p_end = p_start + ((h_input)->blen);
 p = p_start;

 for (;;) {




  if (p >= p_end) {
   break;
  }
  cp = (duk_codepoint_t) duk_unicode_decode_xutf8_checked(thr, &p, p_start, p_end);
  cp = callback(udata, cp);

  do { do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (7); duk__space = (duk_size_t) (((bw))->p_limit - ((bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((thr)), ((bw)), duk__sz); } } while (0); do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) ((cp)); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_xutf8(duk__cp, ((bw))->p); ((bw))->p += duk__enc_len; } while (0); } while (0);
 }

 do { duk_bw_compact((thr), (bw)); } while (0);
 (void) duk_buffer_to_string(thr, -1);
 duk_replace(thr, idx);
}

__attribute__ ((visibility("default"))) void duk_substring(duk_hthread *thr, duk_idx_t idx, duk_size_t start_offset, duk_size_t end_offset) {
 duk_hstring *h;
 duk_hstring *res;
 duk_size_t start_byte_offset;
 duk_size_t end_byte_offset;
 duk_size_t charlen;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);
 h = duk_require_hstring(thr, idx);
 do { } while (0);

 charlen = duk_hstring_get_charlen((h));
 if (end_offset >= charlen) {
  end_offset = charlen;
 }
 if (start_offset > end_offset) {
  start_offset = end_offset;
 }

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 do { } while (0);
 do { } while (0);

 start_byte_offset = (duk_size_t) duk_heap_strcache_offset_char2byte(thr, h, (duk_uint_fast32_t) start_offset);
 end_byte_offset = (duk_size_t) duk_heap_strcache_offset_char2byte(thr, h, (duk_uint_fast32_t) end_offset);

 do { } while (0);
 do { } while (0);


 res = duk_heap_strtable_intern_checked(thr,
                                        ((const duk_uint8_t *) ((h) + 1)) + start_byte_offset,
                                        (duk_uint32_t) (end_byte_offset - start_byte_offset));

 duk_push_hstring(thr, res);
 duk_replace(thr, idx);
}




__attribute__ ((visibility("default"))) void duk_trim(duk_hthread *thr, duk_idx_t idx) {
 duk_hstring *h;
 const duk_uint8_t *p, *p_start, *p_end, *p_tmp1, *p_tmp2;
 const duk_uint8_t *q_start, *q_end;
 duk_codepoint_t cp;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);

 idx = duk_require_normalize_index(thr, idx);
 h = duk_require_hstring(thr, idx);
 do { } while (0);

 p_start = ((const duk_uint8_t *) ((h) + 1));
 p_end = p_start + ((h)->blen);

 p = p_start;
 while (p < p_end) {
  p_tmp1 = p;
  cp = (duk_codepoint_t) duk_unicode_decode_xutf8_checked(thr, &p_tmp1, p_start, p_end);
  if (!(duk_unicode_is_whitespace(cp) || duk_unicode_is_line_terminator(cp))) {
   break;
  }
  p = p_tmp1;
 }
 q_start = p;
 if (p == p_end) {

  q_end = p;
  goto scan_done;
 }

 p = p_end;
 while (p > p_start) {
  p_tmp1 = p;
  while (p > p_start) {
   p--;
   if (((*p) & 0xc0) != 0x80) {
    break;
   }
  }
  p_tmp2 = p;

  cp = (duk_codepoint_t) duk_unicode_decode_xutf8_checked(thr, &p_tmp2, p_start, p_end);
  if (!(duk_unicode_is_whitespace(cp) || duk_unicode_is_line_terminator(cp))) {
   p = p_tmp1;
   break;
  }
 }
 q_end = p;

scan_done:



 if (q_end < q_start) {
  q_end = q_start;
 }

 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0)



                                            ;

 if (q_start == p_start && q_end == p_end) {
  do { } while (0);
  return;
 }

 duk_push_lstring(thr, (const char *) q_start, (duk_size_t) (q_end - q_start));
 duk_replace(thr, idx);
}

__attribute__ ((visibility("default"))) duk_codepoint_t duk_char_code_at(duk_hthread *thr, duk_idx_t idx, duk_size_t char_offset) {
 duk_hstring *h;
 duk_ucodepoint_t cp;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);





 h = duk_require_hstring(thr, idx);
 do { } while (0);

 do { } while (0);
 if (char_offset >= duk_hstring_get_charlen((h))) {
  return 0;
 }

 do { } while (0);
 cp = duk_hstring_char_code_at_raw(thr, h, (duk_uint_t) char_offset, 0 );
 return (duk_codepoint_t) cp;
}
# 1 "duk_api_time.c"






static __attribute__ ((unused)) duk_double_t duk_time_get_ecmascript_time(duk_hthread *thr) {



 do { (void) (thr); } while (0);
 return (duk_double_t) duk_bi_date_get_now_gettimeofday();
}

static __attribute__ ((unused)) duk_double_t duk_time_get_ecmascript_time_nofrac(duk_hthread *thr) {



 do { (void) (thr); } while (0);
 return (duk_double_t) floor(duk_bi_date_get_now_gettimeofday());
}

static __attribute__ ((unused)) duk_double_t duk_time_get_monotonic_time(duk_hthread *thr) {
 do { (void) (thr); } while (0);



 return (duk_double_t) duk_bi_date_get_now_gettimeofday();

}

__attribute__ ((visibility("default"))) duk_double_t duk_get_now(duk_hthread *thr) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { (void) (thr); } while (0);


 return duk_time_get_ecmascript_time(thr);
}
# 49 "duk_api_time.c"
__attribute__ ((visibility("default"))) void duk_time_to_components(duk_hthread *thr, duk_double_t timeval, duk_time_components *comp) {
 duk_int_t parts[8];
 duk_double_t dparts[8];
 duk_uint_t flags;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);




 flags = (1 << 2) | (1 << 0);

 duk_bi_date_timeval_to_parts(timeval, parts, dparts, flags);



 do { } while (0);
 comp->year = dparts[0];
 comp->month = dparts[1] - 1.0;
 comp->day = dparts[2];
 comp->hours = dparts[3];
 comp->minutes = dparts[4];
 comp->seconds = dparts[5];
 comp->milliseconds = dparts[6];
 comp->weekday = dparts[7];
}

__attribute__ ((visibility("default"))) duk_double_t duk_components_to_time(duk_hthread *thr, duk_time_components *comp) {
 duk_double_t d;
 duk_double_t dparts[8];
 duk_uint_t flags;

 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);






 flags = 0;





 dparts[0] = comp->year;
 dparts[1] = comp->month;
 dparts[2] = comp->day - 1.0;
 dparts[3] = comp->hours;
 dparts[4] = comp->minutes;
 dparts[5] = comp->seconds;
 dparts[6] = comp->milliseconds;
 dparts[7] = 0;

 d = duk_bi_date_get_timeval_from_dparts(dparts, flags);

 return d;
}
# 1 "duk_bi_array.c"
# 59 "duk_bi_array.c"
static duk_uint32_t duk__push_this_obj_len_u32(duk_hthread *thr) {
 duk_uint32_t len;


 (void) duk_push_this_coercible_to_object(thr);
 do { } while (0);
 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (87))));
 len = duk_to_uint32(thr, -1);


 return len;
}

static duk_uint32_t duk__push_this_obj_len_u32_limited(duk_hthread *thr) {




 duk_uint32_t ret = duk__push_this_obj_len_u32(thr);
 if (__builtin_expect((ret >= 0x80000000UL), 0)) {
  do { do { duk_err_range(((thr)), "duk_bi_array.c", (duk_int_t) 79, ("invalid length")); } while (0); } while (0);
  do { return 0U; } while (0);
 }
 return ret;
}
# 92 "duk_bi_array.c"
static duk_harray *duk__arraypart_fastpath_this(duk_hthread *thr) {
 duk_tval *tv;
 duk_hobject *h;
 duk_uint_t flags_mask, flags_bits, flags_value;

 do { } while (0);
 tv = (((void) 0), (thr)->valstack_bottom - 1);




 if (!((tv)->t == 9)) {
  do { } while (0);
  return 
# 105 "duk_bi_array.c" 3 4
        ((void *)0)
# 105 "duk_bi_array.c"
            ;
 }
 h = ((tv)->v.hobject);
 do { } while (0);
 flags_mask = (1UL << (7 + (8))) | (1UL << (7 + (15))) | (1UL << (2 + (4)));
 flags_bits = (1UL << (7 + (8))) | (1UL << (7 + (15)));
 flags_value = (((duk_heaphdr *) h)->h_flags);
 if ((flags_value & flags_mask) != flags_bits) {
  do { } while (0);
  return 
# 114 "duk_bi_array.c" 3 4
        ((void *)0)
# 114 "duk_bi_array.c"
            ;
 }







 if (((duk_harray *) h)->length > ((h)->a_size)) {
  do { } while (0);
  return 
# 125 "duk_bi_array.c" 3 4
        ((void *)0)
# 125 "duk_bi_array.c"
            ;
 }


 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);
 return (duk_harray *) h;
}






static __attribute__ ((unused)) duk_ret_t duk_bi_array_constructor(duk_hthread *thr) {
 duk_idx_t nargs;
 duk_harray *a;
 duk_double_t d;
 duk_uint32_t len;
 duk_uint32_t len_prealloc;

 nargs = duk_get_top(thr);

 if (nargs == 1 && duk_is_number(thr, 0)) {

  d = duk_get_number(thr, 0);
  len = duk_to_uint32(thr, 0);
  if (!duk_double_equals((duk_double_t) len, d)) {
   do { do { do { duk_err_range((((thr))), "duk_bi_array.c", (duk_int_t) 156, ("invalid length")); } while (0); } while (0); return 0; } while (0);
  }




  len_prealloc = len < 64 ? len : 64;
  a = duk_push_harray_with_size(thr, len_prealloc);
  do { } while (0);
  do { } while (0);
  a->length = len;
  return 1;
 }

 duk_pack(thr, nargs);
 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_array_constructor_is_array(duk_hthread *thr) {
 do { } while (0);
 duk_push_boolean(thr, duk_js_isarray(((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (0))));
 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_to_string(duk_hthread *thr) {
 (void) duk_push_this_coercible_to_object(thr);
 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (38))));


 if (!duk_is_function((thr), (-1))) {
# 204 "duk_bi_array.c"
  do { } while (0);
  duk_set_top(thr, 0);
  return duk_bi_object_prototype_to_string(thr);
 }



 duk_insert(thr, -2);



 do { } while (0)
                                                                                                                           ;
 duk_call_method(thr, 0);

 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_concat(duk_hthread *thr) {
 duk_idx_t i, n;
 duk_uint32_t j, idx, len;
 duk_hobject *h;
 duk_size_t tmp_len;
# 243 "duk_bi_array.c"
 (void) duk_push_this_coercible_to_object(thr);
 duk_insert(thr, 0);
 n = duk_get_top(thr);
 duk_push_array(thr);
# 255 "duk_bi_array.c"
 idx = 0;
 for (i = 0; i < n; i++) {
  duk_bool_t spreadable;
  duk_bool_t need_has_check;

  do { } while (0);



  h = duk_get_hobject(thr, i);

  if (h == 
# 266 "duk_bi_array.c" 3 4
          ((void *)0)
# 266 "duk_bi_array.c"
              ) {
   spreadable = 0;
  } else {

   duk_get_prop_stridx(thr, i, 79);
   if (duk_is_undefined(thr, -1)) {
    spreadable = duk_js_isarray_hobject(h);
   } else {
    spreadable = duk_to_boolean(thr, -1);
   }
   duk_pop_nodecref_unsafe(thr);



  }

  if (!spreadable) {
   duk_dup(thr, i);
   duk_xdef_prop_index((thr), (-2), (idx), ((1U << 0) | (1U << 1) | (1U << 2)));
   idx++;
   if (__builtin_expect((idx == 0U), 0)) {




    goto fail_wrap;
   }
   continue;
  }

  do { } while (0);
  need_has_check = ((((&((h))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0) != 0);



  tmp_len = duk_get_length(thr, i);
  len = (duk_uint32_t) tmp_len;
  if (__builtin_expect((tmp_len != (duk_size_t) len), 0)) {
   goto fail_wrap;
  }
  if (__builtin_expect((idx + len < idx), 0)) {



   goto fail_wrap;
  }
  for (j = 0; j < len; j++) {



   if (need_has_check) {
    if (duk_has_prop_index(thr, i, j)) {
     duk_get_prop_index(thr, i, j);
     duk_xdef_prop_index((thr), (-2), (idx), ((1U << 0) | (1U << 1) | (1U << 2)));
    }
   } else {
    if (duk_get_prop_index(thr, i, j)) {
     duk_xdef_prop_index((thr), (-2), (idx), ((1U << 0) | (1U << 1) | (1U << 2)));
    } else {
     duk_pop_undefined(thr);
    }
   }
   idx++;
   do { } while (0);
  }
 }






 duk_push_uint((thr), (duk_uint_t) (idx));
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (87)) << 8) + (duk_uint_t) (((1U << 0)))));

 do { } while (0);
 return 1;

fail_wrap:
 do { do { duk_err_range(((thr)), "duk_bi_array.c", (duk_int_t) 345, ("invalid length")); } while (0); } while (0);
 do { return 0; } while (0);
}
# 362 "duk_bi_array.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_join_shared(duk_hthread *thr) {
 duk_uint32_t len, count;
 duk_uint32_t idx;
 duk_small_int_t to_locale_string = duk_get_current_magic(thr);
 duk_idx_t valstack_required;





 duk_set_top(thr, 1);
 if (duk_is_undefined(thr, 0)) {
  duk_pop_undefined(thr);
  duk_push_hstring_stridx(thr, 63);
 } else {
  duk_to_string(thr, 0);
 }

 len = duk__push_this_obj_len_u32(thr);



 do { } while (0)


                                           ;


 valstack_required = (duk_idx_t) ((len >= 4096 ? 4096 : len) + 4);
 duk_require_stack(thr, valstack_required);

 duk_dup_0(thr);



 count = 0;
 idx = 0;
 for (;;) {
  do { } while (0);
  if (count >= 4096 ||
      idx >= len) {

   do { } while (0);
   duk_join(thr, (duk_idx_t) count);
   duk_dup_0(thr);
   duk_insert(thr, -2);
   count = 1;
  }
  if (idx >= len) {

   break;
  }

  duk_get_prop_index(thr, 1, (duk_uarridx_t) idx);
  if (((duk_get_type_mask((thr), (-1)) & ((1U << 2U) | (1U << 1U))) ? 1 : 0)) {
   duk_pop_nodecref_unsafe(thr);
   duk_push_hstring_empty(thr);
  } else {
   if (to_locale_string) {
    duk_to_object(thr, -1);
    (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (39))));
    duk_insert(thr, -2);
    duk_call_method(thr, 0);
   }
   duk_to_string(thr, -1);
  }

  count++;
  idx++;
 }



 return 1;
}






static duk_ret_t duk__array_pop_fastpath(duk_hthread *thr, duk_harray *h_arr) {
 duk_tval *tv_arraypart;
 duk_tval *tv_val;
 duk_uint32_t len;

 tv_arraypart = ((duk_tval *) (void *) (((((duk_hobject *) h_arr))->props) + ((((duk_hobject *) h_arr))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((duk_hobject *) h_arr))->e_size))) & 0x07)));
 len = h_arr->length;
 if (len <= 0) {

  return 0;
 }

 len--;
 h_arr->length = len;





 do { } while (0);
 tv_val = tv_arraypart + len;
 if (((tv_val)->t == 7)) {



  do { } while (0);
  do { } while (0);
 } else {

  do { *(thr->valstack_top) = *(tv_val); } while (0);
  do { duk_tval *duk__tv; duk__tv = (tv_val); duk__tv->t = 7; } while (0);
 }
 thr->valstack_top++;



 return 1;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_pop(duk_hthread *thr) {
 duk_uint32_t len;
 duk_uint32_t idx;

 duk_harray *h_arr;


 do { } while (0);


 h_arr = duk__arraypart_fastpath_this(thr);
 if (h_arr) {
  return duk__array_pop_fastpath(thr, h_arr);
 }




 len = duk__push_this_obj_len_u32(thr);
 if (len == 0) {
  duk_push_int(thr, 0);
  (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (87))));
  return 0;
 }
 idx = len - 1;

 duk_get_prop_index(thr, 0, (duk_uarridx_t) idx);
 duk_del_prop_index(thr, 0, (duk_uarridx_t) idx);
 duk_push_uint((thr), (duk_uint_t) (idx));
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (87))));
 return 1;
}


static duk_ret_t duk__array_push_fastpath(duk_hthread *thr, duk_harray *h_arr) {
 duk_tval *tv_arraypart;
 duk_tval *tv_src;
 duk_tval *tv_dst;
 duk_uint32_t len;
 duk_idx_t i, n;

 len = h_arr->length;
 tv_arraypart = ((duk_tval *) (void *) (((((duk_hobject *) h_arr))->props) + ((((duk_hobject *) h_arr))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((duk_hobject *) h_arr))->e_size))) & 0x07)));

 n = (duk_idx_t) (thr->valstack_top - thr->valstack_bottom);
 do { } while (0);
 do { } while (0);
 if (__builtin_expect((len + (duk_uint32_t) n < len), 0)) {
  do { } while (0);
  do { do { do { duk_err_range((((thr))), "duk_bi_array.c", (duk_int_t) 532, ("invalid length")); } while (0); } while (0); return 0; } while (0);
 }
 if (len + (duk_uint32_t) n > (((duk_hobject *) h_arr)->a_size)) {





  return 0;
 }

 tv_src = thr->valstack_bottom;
 tv_dst = tv_arraypart + len;
 for (i = 0; i < n; i++) {



  do { *(tv_dst) = *(tv_src); } while (0);
  do { duk_tval *duk__tv; duk__tv = (tv_src); duk__tv->t = 2; } while (0);
  tv_src++;
  tv_dst++;
 }
 thr->valstack_top = thr->valstack_bottom;
 len += (duk_uint32_t) n;
 h_arr->length = len;

 do { } while (0);
 duk_push_uint(thr, (duk_uint_t) len);
 return 1;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_push(duk_hthread *thr) {






 duk_uint32_t len;
 duk_idx_t i, n;

 duk_harray *h_arr;



 h_arr = duk__arraypart_fastpath_this(thr);
 if (h_arr) {
  duk_ret_t rc;
  rc = duk__array_push_fastpath(thr, h_arr);
  if (rc != 0) {
   return rc;
  }
  do { } while (0);
 }


 n = duk_get_top(thr);
 len = duk__push_this_obj_len_u32(thr);
# 604 "duk_bi_array.c"
 if (len + (duk_uint32_t) n < len) {
  do { } while (0);
  do { do { do { duk_err_range((((thr))), "duk_bi_array.c", (duk_int_t) 606, ("invalid length")); } while (0); } while (0); return 0; } while (0);
 }

 for (i = 0; i < n; i++) {
  duk_dup(thr, i);
  duk_put_prop_index(thr, -3, (duk_uarridx_t) (len + (duk_uint32_t) i));
 }
 len += (duk_uint32_t) n;

 duk_push_uint((thr), (duk_uint_t) (len));
 duk_dup_top(thr);
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-4)) << 16) + ((duk_uint_t) (87))));


 return 1;
}
# 633 "duk_bi_array.c"
static duk_small_int_t duk__array_sort_compare(duk_hthread *thr, duk_int_t idx1, duk_int_t idx2) {
 duk_bool_t have1, have2;
 duk_bool_t undef1, undef2;
 duk_small_int_t ret;
 duk_idx_t idx_obj = 1;
 duk_idx_t idx_fn = 0;
 duk_hstring *h1, *h2;
# 656 "duk_bi_array.c"
 if (idx1 == idx2) {
  do { } while (0)

                                    ;
  return 0;
 }

 have1 = duk_get_prop_index(thr, idx_obj, (duk_uarridx_t) idx1);
 have2 = duk_get_prop_index(thr, idx_obj, (duk_uarridx_t) idx2);

 do { } while (0)





                                                          ;

 if (have1) {
  if (have2) {
   ;
  } else {
   ret = -1;
   goto pop_ret;
  }
 } else {
  if (have2) {
   ret = 1;
   goto pop_ret;
  } else {
   ret = 0;
   goto pop_ret;
  }
 }

 undef1 = duk_is_undefined(thr, -2);
 undef2 = duk_is_undefined(thr, -1);
 if (undef1) {
  if (undef2) {
   ret = 0;
   goto pop_ret;
  } else {
   ret = 1;
   goto pop_ret;
  }
 } else {
  if (undef2) {
   ret = -1;
   goto pop_ret;
  } else {
   ;
  }
 }

 if (!duk_is_undefined(thr, idx_fn)) {
  duk_double_t d;


  duk_dup(thr, idx_fn);
  duk_insert(thr, -3);
  duk_call(thr, 2);






  d = duk_to_number_m1(thr);
  if (d < 0.0) {
   ret = -1;
  } else if (d > 0.0) {
   ret = 1;
  } else {



   ret = 0;
  }

  duk_pop_nodecref_unsafe(thr);
  do { } while (0);
  return ret;
 }




 h1 = duk_to_hstring(thr, -2);
 h2 = duk_to_hstring_m1(thr);
 do { } while (0);
 do { } while (0);

 ret = duk_js_string_compare(h1, h2);
 goto pop_ret;

pop_ret:
 duk_pop_2_unsafe(thr);
 do { } while (0);
 return ret;
}

static void duk__array_sort_swap(duk_hthread *thr, duk_int_t l, duk_int_t r) {
 duk_bool_t have_l, have_r;
 duk_idx_t idx_obj = 1;

 if (l == r) {
  return;
 }


 have_l = duk_get_prop_index(thr, idx_obj, (duk_uarridx_t) l);
 have_r = duk_get_prop_index(thr, idx_obj, (duk_uarridx_t) r);

 if (have_r) {

  duk_put_prop_index(thr, idx_obj, (duk_uarridx_t) l);
 } else {
  duk_del_prop_index(thr, idx_obj, (duk_uarridx_t) l);
  duk_pop_undefined(thr);
 }

 if (have_l) {
  duk_put_prop_index(thr, idx_obj, (duk_uarridx_t) r);
 } else {
  duk_del_prop_index(thr, idx_obj, (duk_uarridx_t) r);
  duk_pop_undefined(thr);
 }
}
# 816 "duk_bi_array.c"
static void duk__array_qsort(duk_hthread *thr, duk_int_t lo, duk_int_t hi) {
 duk_int_t p, l, r;



 do { } while (0);

 do { } while (0);







 if (hi - lo < 1) {
  do { } while (0);
  return;
 }
 do { } while (0);
 do { } while (0);


 p = lo + (duk_int_t) (duk_util_get_random_double(thr) * (duk_double_t) (hi - lo + 1));
 do { } while (0);
 do { } while (0);


 duk__array_sort_swap(thr, p, lo);
 p = lo;
 do { } while (0);

 l = lo + 1;
 r = hi;
 for (;;) {

  for (;;) {
   do { } while (0);
   if (l >= hi) {
    break;
   }
   if (duk__array_sort_compare(thr, l, p) >= 0) {
    break;
   }
   l++;
  }
  for (;;) {
   do { } while (0);
   if (r <= lo) {
    break;
   }
   if (duk__array_sort_compare(thr, p, r) >= 0) {
    break;
   }
   r--;
  }
  if (l >= r) {
   goto done;
  }
  do { } while (0);

  do { } while (0);

  duk__array_sort_swap(thr, l, r);

  do { } while (0);
  l++;
  r--;
 }
done:

 do { } while (0);
 do { } while (0);
# 897 "duk_bi_array.c"
 do { } while (0);
 duk__array_sort_swap(thr, lo, r);





 do { } while (0);
 duk__array_qsort(thr, lo, r - 1);
 duk__array_qsort(thr, r + 1, hi);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_sort(duk_hthread *thr) {
 duk_uint32_t len;




 len = duk__push_this_obj_len_u32_limited(thr);






 if (len > 0) {

  duk__array_qsort(thr, (duk_int_t) 0, (duk_int_t) (len - 1));
 }

 do { } while (0);
 duk_pop_nodecref_unsafe(thr);
 return 1;
}
# 945 "duk_bi_array.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_splice(duk_hthread *thr) {
 duk_idx_t nargs;
 duk_uint32_t len_u32;
 duk_int_t len;
 duk_bool_t have_delcount;
 duk_int_t item_count;
 duk_int_t act_start;
 duk_int_t del_count;
 duk_int_t i, n;

 do { (void) (have_delcount); } while (0);

 nargs = duk_get_top(thr);
 if (nargs < 2) {
  duk_set_top(thr, 2);
  nargs = 2;
  have_delcount = 0;
 } else {
  have_delcount = 1;
 }




 len_u32 = duk__push_this_obj_len_u32_limited(thr);
 len = (duk_int_t) len_u32;
 do { } while (0);

 act_start = duk_to_int_clamped(thr, 0, -len, len);
 if (act_start < 0) {
  act_start = len + act_start;
 }
 do { } while (0);


 if (have_delcount) {

  del_count = duk_to_int_clamped(thr, 1, 0, len - act_start);

 } else {





  del_count = len - act_start;
 }


 do { } while (0);
 item_count = (duk_int_t) (nargs - 2);

 do { } while (0);
 do { } while (0);


 if (((duk_double_t) len) - ((duk_double_t) del_count) + ((duk_double_t) item_count) > (duk_double_t) 
# 1001 "duk_bi_array.c" 3 4
                                                                                                     (4294967295U)
# 1001 "duk_bi_array.c"
                                                                                                                   ) {
  do { } while (0);
  do { do { do { duk_err_range((((thr))), "duk_bi_array.c", (duk_int_t) 1003, ("invalid length")); } while (0); } while (0); return 0; } while (0);
 }

 duk_push_array(thr);
# 1016 "duk_bi_array.c"
 do { } while (0);



 for (i = 0; i < del_count; i++) {
  if (duk_get_prop_index(thr, -3, (duk_uarridx_t) (act_start + i))) {
   duk_xdef_prop_index((thr), (-2), ((duk_uarridx_t) i), ((1U << 0) | (1U << 1) | (1U << 2)));
  } else {
   duk_pop_undefined(thr);
  }
 }
 duk_push_uint((thr), (duk_uint_t) ((duk_uint32_t) del_count));
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (87)) << 8) + (duk_uint_t) (((1U << 0)))));



 if (item_count < del_count) {






  do { } while (0);

  n = len - del_count;
  for (i = act_start; i < n; i++) {
   if (duk_get_prop_index(thr, -3, (duk_uarridx_t) (i + del_count))) {
    duk_put_prop_index(thr, -4, (duk_uarridx_t) (i + item_count));
   } else {
    duk_pop_undefined(thr);
    duk_del_prop_index(thr, -3, (duk_uarridx_t) (i + item_count));
   }
  }

  do { } while (0);


  n = len - del_count + item_count;
  for (i = len - 1; i >= n; i--) {
   duk_del_prop_index(thr, -3, (duk_uarridx_t) i);
  }

  do { } while (0);
 } else if (item_count > del_count) {






  do { } while (0);


  for (i = len - del_count - 1; i >= act_start; i--) {
   if (duk_get_prop_index(thr, -3, (duk_uarridx_t) (i + del_count))) {
    duk_put_prop_index(thr, -4, (duk_uarridx_t) (i + item_count));
   } else {
    duk_pop_undefined(thr);
    duk_del_prop_index(thr, -3, (duk_uarridx_t) (i + item_count));
   }
  }

  do { } while (0);
 } else {





 }
 do { } while (0);



 for (i = 0; i < item_count; i++) {
  duk_dup(thr, i + 2);
  duk_put_prop_index(thr, -4, (duk_uarridx_t) (act_start + i));
 }





 duk_push_uint((thr), (duk_uint_t) ((duk_uint32_t) (len - del_count + item_count)));
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-4)) << 16) + ((duk_uint_t) (87))));


 do { } while (0);
 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_reverse(duk_hthread *thr) {
 duk_uint32_t len;
 duk_uint32_t middle;
 duk_uint32_t lower, upper;
 duk_bool_t have_lower, have_upper;

 len = duk__push_this_obj_len_u32(thr);
 middle = len / 2;





 for (lower = 0; lower < middle; lower++) {
  do { } while (0);
  do { } while (0);

  do { } while (0);
  upper = len - lower - 1;

  have_lower = duk_get_prop_index(thr, -2, (duk_uarridx_t) lower);
  have_upper = duk_get_prop_index(thr, -3, (duk_uarridx_t) upper);



  if (have_upper) {
   duk_put_prop_index(thr, -4, (duk_uarridx_t) lower);
  } else {
   duk_del_prop_index(thr, -4, (duk_uarridx_t) lower);
   duk_pop_undefined(thr);
  }

  if (have_lower) {
   duk_put_prop_index(thr, -3, (duk_uarridx_t) upper);
  } else {
   duk_del_prop_index(thr, -3, (duk_uarridx_t) upper);
   duk_pop_undefined(thr);
  }

  do { } while (0);
 }

 do { } while (0);
 duk_pop_unsafe(thr);
 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_slice(duk_hthread *thr) {
 duk_uint32_t len_u32;
 duk_int_t len;
 duk_int_t start, end;
 duk_int_t i;
 duk_uarridx_t idx;
 duk_uint32_t res_length = 0;




 len_u32 = duk__push_this_obj_len_u32_limited(thr);
 len = (duk_int_t) len_u32;
 do { } while (0);

 duk_push_array(thr);
# 1187 "duk_bi_array.c"
 start = duk_to_int_clamped(thr, 0, -len, len);
 if (start < 0) {
  start = len + start;
 }



 if (duk_is_undefined(thr, 1)) {
  end = len;
 } else {
  end = duk_to_int_clamped(thr, 1, -len, len);
  if (end < 0) {
   end = len + end;
  }
 }
 do { } while (0);
 do { } while (0);

 idx = 0;
 for (i = start; i < end; i++) {
  do { } while (0);
  if (duk_get_prop_index(thr, 2, (duk_uarridx_t) i)) {
   duk_xdef_prop_index((thr), (4), (idx), ((1U << 0) | (1U << 1) | (1U << 2)));
   res_length = idx + 1;
  } else {
   duk_pop_undefined(thr);
  }
  idx++;
  do { } while (0);
 }

 duk_push_uint((thr), (duk_uint_t) (res_length));
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (4)) << 24) + (((duk_uint_t) (87)) << 8) + (duk_uint_t) (((1U << 0)))));

 do { } while (0);
 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_shift(duk_hthread *thr) {
 duk_uint32_t len;
 duk_uint32_t i;

 len = duk__push_this_obj_len_u32(thr);
 if (len == 0) {
  duk_push_int(thr, 0);
  (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (87))));
  return 0;
 }

 duk_get_prop_index(thr, 0, 0);






 for (i = 1; i < len; i++) {
  do { } while (0);
  if (duk_get_prop_index(thr, 0, (duk_uarridx_t) i)) {

   duk_put_prop_index(thr, 0, (duk_uarridx_t) (i - 1));
  } else {

   duk_del_prop_index(thr, 0, (duk_uarridx_t) (i - 1));
   duk_pop_undefined(thr);
  }
 }
 duk_del_prop_index(thr, 0, (duk_uarridx_t) (len - 1));

 duk_push_uint((thr), (duk_uint_t) ((duk_uint32_t) (len - 1)));
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (87))));

 do { } while (0);
 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_unshift(duk_hthread *thr) {
 duk_idx_t nargs;
 duk_uint32_t len;
 duk_uint32_t i;

 nargs = duk_get_top(thr);
 len = duk__push_this_obj_len_u32(thr);






 do { } while (0);






 if (len + (duk_uint32_t) nargs < len) {
  do { } while (0);
  do { do { do { duk_err_range((((thr))), "duk_bi_array.c", (duk_int_t) 1293, ("invalid length")); } while (0); } while (0); return 0; } while (0);
 }

 i = len;
 while (i > 0) {
  do { } while (0);
  i--;


  if (duk_get_prop_index(thr, -2, (duk_uarridx_t) i)) {


   duk_put_prop_index(
       thr,
       -3,
       (duk_uarridx_t) (i + (duk_uint32_t) nargs));
  } else {


   duk_pop_undefined(thr);
   duk_del_prop_index(
       thr,
       -2,
       (duk_uarridx_t) (i + (duk_uint32_t) nargs));
  }
  do { } while (0);
 }

 for (i = 0; i < (duk_uint32_t) nargs; i++) {
  do { } while (0);
  duk_dup(thr, (duk_idx_t) i);
  duk_put_prop_index(thr, -3, (duk_uarridx_t) i);
  do { } while (0);
 }

 do { } while (0);
 duk_push_uint((thr), (duk_uint_t) (len + (duk_uint32_t) nargs));
 duk_dup_top(thr);
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-4)) << 16) + ((duk_uint_t) (87))));
 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_indexof_shared(duk_hthread *thr) {
 duk_idx_t nargs;
 duk_int_t i, len;
 duk_int_t from_idx;
 duk_small_int_t idx_step = duk_get_current_magic(thr);






 nargs = duk_get_top(thr);
 duk_set_top(thr, 2);


 len = (duk_int_t) duk__push_this_obj_len_u32_limited(thr);
 if (len == 0) {
  goto not_found;
 }
# 1374 "duk_bi_array.c"
 if (nargs >= 2) {






  from_idx = duk_to_int_clamped(thr, 1, (idx_step > 0 ? -len : -len - 1), (idx_step > 0 ? len : len - 1));
  if (from_idx < 0) {

   from_idx = len + from_idx;
  }
 } else {



  if (idx_step > 0) {
   from_idx = 0;
  } else {
   from_idx = len - 1;
  }
 }







 for (i = from_idx; i >= 0 && i < len; i += idx_step) {
  do { } while (0);

  if (duk_get_prop_index(thr, 2, (duk_uarridx_t) i)) {
   do { } while (0);
   if (duk_strict_equals(thr, 0, 4)) {
    duk_push_int(thr, i);
    return 1;
   }
  }

  duk_pop_unsafe(thr);
 }

not_found:
 duk_push_int(thr, -1);
 return 1;
}
# 1437 "duk_bi_array.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_iter_shared(duk_hthread *thr) {
 duk_uint32_t len;
 duk_uint32_t i;
 duk_uarridx_t k;
 duk_bool_t bval;
 duk_small_int_t iter_type = duk_get_current_magic(thr);
 duk_uint32_t res_length = 0;


 do { } while (0);

 len = duk__push_this_obj_len_u32(thr);
 duk_require_function((thr), (0));


 if (iter_type == 3 || iter_type == 4) {
  duk_push_array(thr);
 } else {
  duk_push_undefined(thr);
 }
# 1465 "duk_bi_array.c"
 k = 0;
 for (i = 0; i < len; i++) {
  do { } while (0);

  if (!duk_get_prop_index(thr, 2, (duk_uarridx_t) i)) {



   if (iter_type == 3) {
    res_length = i + 1;
   }
   duk_pop_undefined(thr);
   continue;
  }






  duk_dup_0(thr);
  duk_dup_1(thr);
  duk_dup_m3(thr);
  duk_push_uint((thr), (duk_uint_t) (i));
  duk_dup_2(thr);
  duk_call_method(thr, 3);

  switch (iter_type) {
  case 0:
   bval = duk_to_boolean(thr, -1);
   if (!bval) {

    return 1;
   }
   break;
  case 1:
   bval = duk_to_boolean(thr, -1);
   if (bval) {

    return 1;
   }
   break;
  case 2:

   break;
  case 3:
   duk_dup_top(thr);
   duk_xdef_prop_index((thr), (4), ((duk_uarridx_t) i), ((1U << 0) | (1U << 1) | (1U << 2)));
   res_length = i + 1;
   break;
  case 4:
   bval = duk_to_boolean(thr, -1);
   if (bval) {
    duk_dup_m2(thr);
    duk_xdef_prop_index((thr), (4), ((duk_uarridx_t) k), ((1U << 0) | (1U << 1) | (1U << 2)));
    k++;
    res_length = k;
   }
   break;
  default:
   do { __builtin_unreachable(); } while (0);
   break;
  }
  duk_pop_2_unsafe(thr);

  do { } while (0);
 }

 switch (iter_type) {
 case 0:
  duk_push_true(thr);
  break;
 case 1:
  duk_push_false(thr);
  break;
 case 2:
  duk_push_undefined(thr);
  break;
 case 3:
 case 4:
  do { } while (0);
  do { } while (0);
  duk_push_uint((thr), (duk_uint_t) (res_length));
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (87)) << 8) + (duk_uint_t) (((1U << 0)))));
  break;
 default:
  do { __builtin_unreachable(); } while (0);
  break;
 }

 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_array_prototype_reduce_shared(duk_hthread *thr) {
 duk_idx_t nargs;
 duk_bool_t have_acc;
 duk_uint32_t i, len;
 duk_small_int_t idx_step = duk_get_current_magic(thr);




 nargs = duk_get_top(thr);
 do { } while (0);

 duk_set_top(thr, 2);
 len = duk__push_this_obj_len_u32(thr);
 duk_require_function((thr), (0));
# 1585 "duk_bi_array.c"
 have_acc = 0;
 if (nargs >= 2) {
  duk_dup_1(thr);
  have_acc = 1;
 }
 do { } while (0);







 for (i = (idx_step >= 0 ? 0 : len - 1); i < len;
      i += (duk_uint32_t) idx_step) {
  do { } while (0)




                                                          ;

  do { } while (0);

  if (!duk_has_prop_index(thr, 2, (duk_uarridx_t) i)) {
   continue;
  }

  if (!have_acc) {
   do { } while (0);
   duk_get_prop_index(thr, 2, (duk_uarridx_t) i);
   have_acc = 1;
   do { } while (0);
  } else {
   do { } while (0);
   duk_dup_0(thr);
   duk_dup(thr, 4);
   duk_get_prop_index(thr, 2, (duk_uarridx_t) i);
   duk_push_uint((thr), (duk_uint_t) (i));
   duk_dup_2(thr);
   do { } while (0)




                                                            ;
   duk_call(thr, 4);
   do { } while (0);
   duk_replace(thr, 4);
   do { } while (0);
  }
 }

 if (!have_acc) {
  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_array.c", (duk_int_t) 1639); } while (0); return 0; } while (0);
 }

 do { } while (0);
 return 1;
}
# 1 "duk_bi_boolean.c"
# 12 "duk_bi_boolean.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_boolean_prototype_tostring_shared(duk_hthread *thr) {
 duk_tval *tv;
 duk_hobject *h;
 duk_small_int_t coerce_tostring = duk_get_current_magic(thr);






 duk_push_this(thr);
 tv = duk_get_tval(thr, -1);
 do { } while (0);

 if (((tv)->t == 4)) {
  goto type_ok;
 } else if (((tv)->t == 9)) {
  h = ((tv)->v.hobject);
  do { } while (0);

  if ((((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 5) {
   (((void) 0), ((void) 0), duk_xget_owndataprop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (106))));
   do { } while (0);
   goto type_ok;
  }
 }

 do { do { duk_err_type_invalid_args(((thr)), "duk_bi_boolean.c", (duk_int_t) 39); } while (0); return 0; } while (0);


type_ok:
 if (coerce_tostring) {
  duk_to_string(thr, -1);
 }
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_boolean_constructor(duk_hthread *thr) {
 duk_hobject *h_this;

 duk_to_boolean(thr, 0);

 if (duk_is_constructor_call(thr)) {

  duk_push_this(thr);
  h_this = duk_known_hobject(thr, -1);
  do { } while (0);

  do { (&(h_this)->hdr)->h_flags = ((&(h_this)->hdr)->h_flags & (~(((1UL << (5)) - 1UL) << ((7 + (20)))))) | (((5)) << ((7 + (20)))); } while (0);

  duk_dup_0(thr);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (106)) << 8) + (duk_uint_t) (0)));
 }

 return 1;
}
# 1 "duk_bi_buffer.c"
# 15 "duk_bi_buffer.c"
static const duk_uint8_t duk__buffer_proto_from_classnum[] = {
 39, 40, 41,
 42, 43, 44,
 45, 46, 47,
 48, 49
};




static const duk_uint8_t duk__buffer_class_from_elemtype[9] = { 22, 23,
                                                         21, 25,
                                                         24, 27,
                                                         26, 28,
                                                         29 };




static const duk_uint8_t duk__buffer_proto_from_elemtype[9] = {
 42, 43, 41,
 45, 44, 47,
 46, 48, 49
};


static const duk_uint8_t duk__buffer_nbytes_from_fldtype[6] = {
 1,
 2,
 4,
 4,
 8,
 0
};
# 57 "duk_bi_buffer.c"
static duk_uint16_t duk__buffer_elemtype_copy_compatible[9] = {

 (1U << 0) | (1U << 1) | (1U << 2),




 (1U << 0) | (1U << 1),


 (1U << 0) | (1U << 1) | (1U << 2),


 (1U << 3) | (1U << 4),


 (1U << 3) | (1U << 4),


 (1U << 5) | (1U << 6),


 (1U << 5) | (1U << 6),


 (1U << 7),


 (1U << 8)
};


static duk_hbufobj *duk__hbufobj_promote_this(duk_hthread *thr) {
 duk_tval *tv_dst;
 duk_hbufobj *res;

 duk_push_this(thr);
 do { } while (0);
 res = (duk_hbufobj *) duk_to_hobject(thr, -1);
 do { } while (0);
 do { } while (0);

 tv_dst = duk_get_borrowed_this_tval(thr);
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv_dst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 9; duk__tv->v.hobject = (((duk_hobject *) res)); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (((duk_hobject *) res)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
 duk_pop(thr);

 return res;
}
# 113 "duk_bi_buffer.c"
static duk_heaphdr *duk__getrequire_bufobj_this(duk_hthread *thr, duk_small_uint_t flags) {
 duk_tval *tv;
 duk_hbufobj *h_this;

 do { } while (0);

 tv = duk_get_borrowed_this_tval(thr);
 do { } while (0);

 if (((tv)->t == 9)) {
  h_this = (duk_hbufobj *) ((tv)->v.hobject);
  do { } while (0);
  if ((((&((duk_hobject *) h_this)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {
   do { } while (0);
   return (duk_heaphdr *) h_this;
  }
 } else if (((tv)->t == 10)) {
  if (flags & (1 << 1)) {







   h_this = duk__hbufobj_promote_this(thr);
   do { } while (0);
   do { } while (0);
   return (duk_heaphdr *) h_this;
  } else {

   return (duk_heaphdr *) ((tv)->v.hbuffer);
  }
 }

 if (flags & (1 << 0)) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 149; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_bi_buffer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not buffer"))); } while (0); } while (0);
  do { return 
# 150 "duk_bi_buffer.c" 3 4
 ((void *)0)
# 150 "duk_bi_buffer.c"
 ; } while (0);
 }
 return 
# 152 "duk_bi_buffer.c" 3 4
       ((void *)0)
# 152 "duk_bi_buffer.c"
           ;
}


static duk_hbufobj *duk__get_bufobj_this(duk_hthread *thr) {
 return (duk_hbufobj *) duk__getrequire_bufobj_this(thr, (1 << 1));
}




static duk_hbufobj *duk__require_bufobj_this(duk_hthread *thr) {
 return (duk_hbufobj *) duk__getrequire_bufobj_this(thr, (1 << 0) | (1 << 1));
}


static duk_hbufobj *duk__require_bufobj_value(duk_hthread *thr, duk_idx_t idx) {
 duk_tval *tv;
 duk_hbufobj *h_obj;


 do { } while (0);

 tv = duk_require_tval(thr, idx);
 do { } while (0);
 if (((tv)->t == 9)) {
  h_obj = (duk_hbufobj *) ((tv)->v.hobject);
  do { } while (0);
  if ((((&((duk_hobject *) h_obj)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {
   do { } while (0);
   return h_obj;
  }
 } else if (((tv)->t == 10)) {
  h_obj = (duk_hbufobj *) duk_to_hobject(thr, idx);
  do { } while (0);
  do { } while (0);
  return h_obj;
 }

 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 191; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_bi_buffer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not buffer"))); } while (0); } while (0);
 do { return 
# 192 "duk_bi_buffer.c" 3 4
((void *)0)
# 192 "duk_bi_buffer.c"
; } while (0);
}

static void duk__set_bufobj_buffer(duk_hthread *thr, duk_hbufobj *h_bufobj, duk_hbuffer *h_val) {
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);

 h_bufobj->buf = h_val;
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_val))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 h_bufobj->length = (duk_uint_t) (((duk_hbuffer *) (h_val))->size);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);
}


static void duk__resolve_offset_opt_length(duk_hthread *thr,
                                              duk_hbufobj *h_bufarg,
                                              duk_idx_t idx_offset,
                                              duk_idx_t idx_length,
                                              duk_uint_t *out_offset,
                                              duk_uint_t *out_length,
                                              duk_bool_t throw_flag) {
 duk_int_t offset_signed;
 duk_int_t length_signed;
 duk_uint_t offset;
 duk_uint_t length;

 offset_signed = duk_to_int(thr, idx_offset);
 if (offset_signed < 0) {
  goto fail_range;
 }
 offset = (duk_uint_t) offset_signed;
 if (offset > h_bufarg->length) {
  goto fail_range;
 }
 do { } while (0);
 do { } while (0);

 if (duk_is_undefined(thr, idx_length)) {
  do { } while (0);
  length = h_bufarg->length - offset;
 } else {
  length_signed = duk_to_int(thr, idx_length);
  if (length_signed < 0) {
   goto fail_range;
  }
  length = (duk_uint_t) length_signed;
  do { } while (0);
  if (length > h_bufarg->length - offset) {



   if (throw_flag) {
    goto fail_range;
   } else {
    length = h_bufarg->length - offset;
   }
  }
 }
 do { } while (0);
 do { } while (0);

 *out_offset = offset;
 *out_length = length;
 return;

fail_range:
 do { duk_err_range((thr), "duk_bi_buffer.c", (duk_int_t) 266, ("invalid args")); } while (0);
 do { return; } while (0);
}




static void duk__clamp_startend_nonegidx_noshift(duk_hthread *thr,
                                                    duk_int_t buffer_length,
                                                    duk_idx_t idx_start,
                                                    duk_idx_t idx_end,
                                                    duk_int_t *out_start_offset,
                                                    duk_int_t *out_end_offset) {
 duk_int_t start_offset;
 duk_int_t end_offset;

 do { } while (0);
 do { } while (0);


 start_offset = duk_to_int_clamped(thr, idx_start, 0, buffer_length);
 if (duk_is_undefined(thr, idx_end)) {
  end_offset = buffer_length;
 } else {
  end_offset = duk_to_int_clamped(thr, idx_end, start_offset, buffer_length);
 }

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 *out_start_offset = start_offset;
 *out_end_offset = end_offset;
}
# 310 "duk_bi_buffer.c"
static void duk__clamp_startend_negidx_shifted(duk_hthread *thr,
                                                  duk_int_t buffer_length,
                                                  duk_uint8_t buffer_shift,
                                                  duk_idx_t idx_start,
                                                  duk_idx_t idx_end,
                                                  duk_int_t *out_start_offset,
                                                  duk_int_t *out_end_offset) {
 duk_int_t start_offset;
 duk_int_t end_offset;

 do { } while (0);
 do { } while (0);

 buffer_length >>= buffer_shift;






 start_offset = duk_to_int(thr, idx_start);
 if (start_offset < 0) {
  start_offset = buffer_length + start_offset;
 }
 if (duk_is_undefined(thr, idx_end)) {
  end_offset = buffer_length;
 } else {
  end_offset = duk_to_int(thr, idx_end);
  if (end_offset < 0) {
   end_offset = buffer_length + end_offset;
  }
 }


 if (start_offset < 0) {
  start_offset = 0;
 } else if (start_offset > buffer_length) {
  start_offset = buffer_length;
 }
 if (end_offset < start_offset) {
  end_offset = start_offset;
 } else if (end_offset > buffer_length) {
  end_offset = buffer_length;
 }
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 start_offset <<= buffer_shift;
 end_offset <<= buffer_shift;

 *out_start_offset = start_offset;
 *out_end_offset = end_offset;
}

static __attribute__ ((unused)) void duk_hbufobj_promote_plain(duk_hthread *thr, duk_idx_t idx) {
 if (duk_is_buffer(thr, idx)) {
  duk_to_object(thr, idx);
 }
}

static __attribute__ ((unused)) void duk_hbufobj_push_uint8array_from_plain(duk_hthread *thr, duk_hbuffer *h_buf) {





 duk_push_hbuffer(thr, h_buf);
 duk_push_buffer_object(thr, -1, 0, (duk_size_t) (((duk_hbuffer *) (h_buf))->size), 4);
 duk_remove_m2(thr);
# 412 "duk_bi_buffer.c"
}


static __attribute__ ((unused)) void duk_hbufobj_push_validated_read(duk_hthread *thr,
                                                  duk_hbufobj *h_bufobj,
                                                  duk_uint8_t *p,
                                                  duk_small_uint_t elem_size) {
 duk_double_union du;

 do { } while (0);
 do { void *duk__dst = ((void *) du.uc); const void *duk__src = ((const void *) p); duk_size_t duk__len = ((size_t) elem_size); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);

 switch (h_bufobj->elem_type) {
 case 0:
 case 1:
  duk_push_uint(thr, (duk_uint_t) du.uc[0]);
  break;
 case 2:
  duk_push_int(thr, (duk_int_t) (duk_int8_t) du.uc[0]);
  break;
 case 3:
  duk_push_uint(thr, (duk_uint_t) du.us[0]);
  break;
 case 4:
  duk_push_int(thr, (duk_int_t) (duk_int16_t) du.us[0]);
  break;
 case 5:
  duk_push_uint(thr, (duk_uint_t) du.ui[0]);
  break;
 case 6:
  duk_push_int(thr, (duk_int_t) (duk_int32_t) du.ui[0]);
  break;
 case 7:
  duk_push_number(thr, (duk_double_t) du.f[0]);
  break;
 case 8:
  duk_push_number(thr, (duk_double_t) du.d);
  break;
 default:
  do { __builtin_unreachable(); } while (0);
 }
}


static __attribute__ ((unused)) void duk_hbufobj_validated_write(duk_hthread *thr, duk_hbufobj *h_bufobj, duk_uint8_t *p, duk_small_uint_t elem_size) {
 duk_double_union du;
# 467 "duk_bi_buffer.c"
 switch (h_bufobj->elem_type) {
 case 0:
  du.uc[0] = (duk_uint8_t) duk_to_uint32(thr, -1);
  break;
 case 1:
  du.uc[0] = (duk_uint8_t) duk_to_uint8clamped(thr, -1);
  break;
 case 2:
  du.uc[0] = (duk_uint8_t) duk_to_int32(thr, -1);
  break;
 case 3:
  du.us[0] = (duk_uint16_t) duk_to_uint32(thr, -1);
  break;
 case 4:
  du.us[0] = (duk_uint16_t) duk_to_int32(thr, -1);
  break;
 case 5:
  du.ui[0] = (duk_uint32_t) duk_to_uint32(thr, -1);
  break;
 case 6:
  du.ui[0] = (duk_uint32_t) duk_to_int32(thr, -1);
  break;
 case 7:




  du.f[0] = duk_double_to_float_t(duk_to_number_m1(thr));
  break;
 case 8:
  du.d = (duk_double_t) duk_to_number_m1(thr);
  break;
 default:
  do { __builtin_unreachable(); } while (0);
 }

 do { } while (0);
 do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) du.uc); duk_size_t duk__len = ((size_t) elem_size); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
}




static duk_hbuffer *duk__hbufobj_fixed_from_argvalue(duk_hthread *thr) {
 duk_int_t len;
 duk_int_t i;
 duk_size_t buf_size;
 duk_uint8_t *buf;

 switch (duk_get_type(thr, 0)) {
 case 4U: {
  len = duk_to_int_clamped(thr, 0, 0, 0x7fffffff);
  (void) duk_push_fixed_buffer_zero(thr, (duk_size_t) len);
  break;
 }
 case 7U: {
  goto slow_copy;
 }
 case 6U: {
  duk_hobject *h;
  duk_hbufobj *h_bufobj;






  h = duk_known_hobject(thr, 0);
  if ((((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 19) {
   do { } while (0);
   h_bufobj = (duk_hbufobj *) h;
   if (__builtin_expect((h_bufobj->buf == 
# 538 "duk_bi_buffer.c" 3 4
      ((void *)0)
# 538 "duk_bi_buffer.c"
      ), 0)) {
    do { duk_err_type_invalid_args((thr), "duk_bi_buffer.c", (duk_int_t) 539); } while (0);
    do { return 
# 540 "duk_bi_buffer.c" 3 4
   ((void *)0)
# 540 "duk_bi_buffer.c"
   ; } while (0);
   }
   if (__builtin_expect((h_bufobj->offset != 0 || h_bufobj->length != (((duk_hbuffer *) (h_bufobj->buf))->size)), 0)) {



    do { duk_err_type_invalid_args((thr), "duk_bi_buffer.c", (duk_int_t) 546); } while (0);
    do { return 
# 547 "duk_bi_buffer.c" 3 4
   ((void *)0)
# 547 "duk_bi_buffer.c"
   ; } while (0);
   }
   duk_push_hbuffer(thr, h_bufobj->buf);
   return h_bufobj->buf;
  }
  goto slow_copy;
 }
 case 5U: {

  duk_require_hstring_notsymbol(thr, 0);
  duk_dup_0(thr);
  (void) duk_to_buffer_raw((thr), (-1), (&buf_size), 2);
  break;
 }
 default:
  do { duk_err_type_invalid_args((thr), "duk_bi_buffer.c", (duk_int_t) 562); } while (0);
  do { return 
# 563 "duk_bi_buffer.c" 3 4
 ((void *)0)
# 563 "duk_bi_buffer.c"
 ; } while (0);
 }

done:
 do { } while (0);
 return duk_known_hbuffer(thr, -1);

slow_copy:


 (void) (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (87))));
 len = duk_to_int_clamped(thr, -1, 0, 0x7fffffff);
 duk_pop(thr);
 buf = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, (duk_size_t) len);
 for (i = 0; i < len; i++) {

  duk_get_prop_index(thr, 0, (duk_uarridx_t) i);
  buf[i] = (duk_uint8_t) (duk_to_uint32(thr, -1) & 0xffU);
  duk_pop(thr);
 }
 goto done;
}
# 596 "duk_bi_buffer.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_constructor(duk_hthread *thr) {
 duk_hbuffer *h_buf;

 h_buf = duk__hbufobj_fixed_from_argvalue(thr);
 do { } while (0);

 duk_push_buffer_object(thr, -1, 0, (((duk_hbuffer *) ((duk_hbuffer *) ((duk_hbuffer_fixed *) (void *) h_buf)))->size), 4);
 duk_push_hobject_bidx(thr, 50);
 duk_set_prototype(thr, -2);



 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_arraybuffer_constructor(duk_hthread *thr) {
 duk_hbufobj *h_bufobj;
 duk_hbuffer *h_val;
 duk_int_t len;

 do { } while (0);

 duk_require_constructor_call(thr);

 len = duk_to_int(thr, 0);
 if (len < 0) {
  goto fail_length;
 }
 (void) duk_push_fixed_buffer_zero(thr, (duk_size_t) len);
 h_val = (duk_hbuffer *) duk_known_hbuffer(thr, -1);

 h_bufobj = duk_push_bufobj_raw(thr,
                                (1UL << (7 + (0))) | (1UL << (7 + (6))) |
                                    (((duk_uint_t) (19)) << (7 + (20))),
                                39);
 do { } while (0);

 duk__set_bufobj_buffer(thr, h_bufobj, h_val);
 do { } while (0);

 return 1;

fail_length:
 do { do { do { duk_err_range((((thr))), "duk_bi_buffer.c", (duk_int_t) 645, ("invalid length")); } while (0); } while (0); return 0; } while (0);
}
# 657 "duk_bi_buffer.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_typedarray_constructor(duk_hthread *thr) {
 duk_tval *tv;
 duk_hobject *h_obj;
 duk_hbufobj *h_bufobj = 
# 660 "duk_bi_buffer.c" 3 4
                        ((void *)0)
# 660 "duk_bi_buffer.c"
                            ;
 duk_hbufobj *h_bufarg = 
# 661 "duk_bi_buffer.c" 3 4
                        ((void *)0)
# 661 "duk_bi_buffer.c"
                            ;
 duk_hbuffer *h_val;
 duk_small_uint_t magic;
 duk_small_uint_t shift;
 duk_small_uint_t elem_type;
 duk_small_uint_t elem_size;
 duk_small_uint_t class_num;
 duk_small_uint_t proto_bidx;
 duk_uint_t align_mask;
 duk_uint_t elem_length;
 duk_int_t elem_length_signed;
 duk_uint_t byte_length;
 duk_small_uint_t copy_mode;





 duk_require_constructor_call(thr);






 magic = (duk_small_uint_t) duk_get_current_magic(thr);
 shift = magic & 0x03U;
 elem_type = (magic >> 2) & 0x0fU;
 elem_size = 1U << shift;
 align_mask = elem_size - 1;
 do { } while (0);
 proto_bidx = duk__buffer_proto_from_elemtype[elem_type];
 do { } while (0);
 do { } while (0);
 class_num = duk__buffer_class_from_elemtype[elem_type];

 do { } while (0)






                                     ;
# 715 "duk_bi_buffer.c"
 duk_hbufobj_promote_plain(thr, 0);

 tv = duk_get_tval(thr, 0);
 do { } while (0);
 if (((tv)->t == 9)) {
  h_obj = ((tv)->v.hobject);
  do { } while (0);

  if ((((&(h_obj)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 19) {




   duk_int_t byte_offset_signed;
   duk_uint_t byte_offset;

   h_bufarg = (duk_hbufobj *) h_obj;

   byte_offset_signed = duk_to_int(thr, 1);
   if (byte_offset_signed < 0) {
    goto fail_arguments;
   }
   byte_offset = (duk_uint_t) byte_offset_signed;
   if (byte_offset > h_bufarg->length || (byte_offset & align_mask) != 0) {

    goto fail_arguments;
   }
   if (duk_is_undefined(thr, 2)) {
    do { } while (0);
    byte_length = h_bufarg->length - byte_offset;
    if ((byte_length & align_mask) != 0) {



     goto fail_arguments;
    }
    elem_length = (byte_length >> shift);
   } else {
    elem_length_signed = duk_to_int(thr, 2);
    if (elem_length_signed < 0) {
     goto fail_arguments;
    }
    elem_length = (duk_uint_t) elem_length_signed;
    byte_length = elem_length << shift;
    if ((byte_length >> shift) != elem_length) {


     goto fail_arguments;
    }
    do { } while (0);
    if (byte_length > h_bufarg->length - byte_offset) {

     goto fail_arguments;
    }
   }
   do { (void) (elem_length); } while (0);
   do { } while (0);
   do { } while (0);
   do { } while (0);
   do { } while (0);
   do { } while (0);

   h_bufobj = duk_push_bufobj_raw(thr,
                                  (1UL << (7 + (0))) | (1UL << (7 + (6))) |
                                      (((duk_uint_t) (class_num)) << (7 + (20))),
                                  (duk_small_int_t) proto_bidx);
   h_val = h_bufarg->buf;
   if (h_val == 
# 782 "duk_bi_buffer.c" 3 4
               ((void *)0)
# 782 "duk_bi_buffer.c"
                   ) {
    do { do { duk_err_type_invalid_args(((thr)), "duk_bi_buffer.c", (duk_int_t) 783); } while (0); return 0; } while (0);
   }
   h_bufobj->buf = h_val;
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_val))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   h_bufobj->offset = h_bufarg->offset + byte_offset;
   h_bufobj->length = byte_length;
   h_bufobj->shift = (duk_uint8_t) shift;
   h_bufobj->elem_type = (duk_uint8_t) elem_type;
   h_bufobj->is_typedarray = 1;
   do { } while (0);


   do { } while (0);
   h_bufobj->buf_prop = (duk_hobject *) h_bufarg;
   do { } while (0);
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) &(h_bufarg)->obj)); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   return 1;
  } else if ((((&(h_obj)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {





   h_bufarg = (duk_hbufobj *) h_obj;
   do { } while (0);
   elem_length_signed = (duk_int_t) (h_bufarg->length >> h_bufarg->shift);
   if (h_bufarg->buf == 
# 809 "duk_bi_buffer.c" 3 4
                       ((void *)0)
# 809 "duk_bi_buffer.c"
                           ) {
    do { do { duk_err_type_invalid_args(((thr)), "duk_bi_buffer.c", (duk_int_t) 810); } while (0); return 0; } while (0);
   }






   do { } while (0)







                                                              ;

   copy_mode = 2;




   do { } while (0);
   if ((((void) 0), ((void) 0), ((h_bufarg)->offset + (h_bufarg)->length <= (((duk_hbuffer *) ((h_bufarg)->buf))->size)))) {
    if ((duk__buffer_elemtype_copy_compatible[elem_type] & (1 << h_bufarg->elem_type)) != 0) {
     do { } while (0);
     do { } while (0);
     copy_mode = 0;
    } else {
     do { } while (0);
     copy_mode = 1;
    }
   }

  } else {

   elem_length_signed = (duk_int_t) duk_get_length(thr, 0);
   copy_mode = 2;
  }
 } else {




  elem_length_signed = duk_to_int(thr, 0);
  copy_mode = 3;
 }
 if (elem_length_signed < 0) {
  goto fail_arguments;
 }
 elem_length = (duk_uint_t) elem_length_signed;
 byte_length = (duk_uint_t) (elem_length << shift);
 if ((byte_length >> shift) != elem_length) {


  goto fail_arguments;
 }

 do { } while (0);
# 880 "duk_bi_buffer.c"
 (void) duk_push_buffer_raw((thr), (byte_length), 0 );
 h_val = duk_known_hbuffer(thr, -1);
 do { } while (0);

 h_bufobj =
     duk_push_bufobj_raw(thr,
                         (1UL << (7 + (0))) | (1UL << (7 + (6))) | (((duk_uint_t) (class_num)) << (7 + (20))),
                         (duk_small_int_t) proto_bidx);

 h_bufobj->buf = h_val;
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_val))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 do { } while (0);
 h_bufobj->length = byte_length;
 h_bufobj->shift = (duk_uint8_t) shift;
 h_bufobj->elem_type = (duk_uint8_t) elem_type;
 h_bufobj->is_typedarray = 1;
 do { } while (0);







 do { } while (0);
 switch (copy_mode) {




 case 0: {


  duk_uint8_t *p_src;
  duk_uint8_t *p_dst;

  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);

  p_dst = (((void) 0), ((void) 0), (((duk_uint8_t *) ((((&(((h_bufobj)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_bufobj)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_bufobj)->buf))) + 1)))) + (h_bufobj)->offset));
  p_src = (((void) 0), ((void) 0), (((duk_uint8_t *) ((((&(((h_bufarg)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_bufarg)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_bufarg)->buf))) + 1)))) + (h_bufarg)->offset));

  do { } while (0)


                                           ;

  do { void *duk__dst = ((void *) p_dst); const void *duk__src = ((const void *) p_src); duk_size_t duk__len = ((size_t) byte_length); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0);
  break;
 }
 case 1: {


  duk_small_uint_t src_elem_size;
  duk_small_uint_t dst_elem_size;
  duk_uint8_t *p_src;
  duk_uint8_t *p_src_end;
  duk_uint8_t *p_dst;

  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);

  src_elem_size = (duk_small_uint_t) (1U << h_bufarg->shift);
  dst_elem_size = elem_size;

  p_src = (((void) 0), ((void) 0), (((duk_uint8_t *) ((((&(((h_bufarg)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_bufarg)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_bufarg)->buf))) + 1)))) + (h_bufarg)->offset));
  p_dst = (((void) 0), ((void) 0), (((duk_uint8_t *) ((((&(((h_bufobj)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_bufobj)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_bufobj)->buf))) + 1)))) + (h_bufobj)->offset));
  p_src_end = p_src + h_bufarg->length;

  do { } while (0)





                                            ;

  while (p_src != p_src_end) {
   do { } while (0)



                                        ;



   duk_hbufobj_push_validated_read(thr, h_bufarg, p_src, src_elem_size);
   duk_hbufobj_validated_write(thr, h_bufobj, p_dst, dst_elem_size);
   duk_pop(thr);
   p_src += src_elem_size;
   p_dst += dst_elem_size;
  }
  break;
 }

 case 2: {



  duk_uint_t i;

  do { } while (0);

  for (i = 0; i < elem_length; i++) {
   duk_get_prop_index(thr, 0, (duk_uarridx_t) i);
   duk_put_prop_index(thr, -2, (duk_uarridx_t) i);
  }
  break;
 }
 default:
 case 3: {





  do { } while (0);
  break;
 }
 }

 return 1;

fail_arguments:
 do { do { do { duk_err_range((((thr))), "duk_bi_buffer.c", (duk_int_t) 1012, ("invalid args")); } while (0); } while (0); return 0; } while (0);
}
# 1045 "duk_bi_buffer.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_dataview_constructor(duk_hthread *thr) {
 duk_hbufobj *h_bufarg;
 duk_hbufobj *h_bufobj;
 duk_hbuffer *h_val;
 duk_uint_t offset;
 duk_uint_t length;

 duk_require_constructor_call(thr);

 h_bufarg = duk__require_bufobj_value(thr, 0);
 do { } while (0);
 if ((((&((duk_hobject *) h_bufarg)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) != 19) {
  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_buffer.c", (duk_int_t) 1057); } while (0); return 0; } while (0);
 }

 duk__resolve_offset_opt_length(thr, h_bufarg, 1, 2, &offset, &length, 1 );
 do { } while (0);
 do { } while (0);

 h_bufobj = duk_push_bufobj_raw(thr,
                                (1UL << (7 + (0))) | (1UL << (7 + (6))) |
                                    (((duk_uint_t) (20)) << (7 + (20))),
                                40);

 h_val = h_bufarg->buf;
 if (h_val == 
# 1070 "duk_bi_buffer.c" 3 4
             ((void *)0)
# 1070 "duk_bi_buffer.c"
                 ) {
  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_buffer.c", (duk_int_t) 1071); } while (0); return 0; } while (0);
 }
 h_bufobj->buf = h_val;
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_val))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 h_bufobj->offset = h_bufarg->offset + offset;
 h_bufobj->length = length;
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);
 h_bufobj->buf_prop = (duk_hobject *) h_bufarg;
 do { } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) &(h_bufarg)->obj)); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);

 do { } while (0);
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_arraybuffer_isview(duk_hthread *thr) {
 duk_hobject *h_obj;
 duk_bool_t ret = 0;

 if (duk_is_buffer(thr, 0)) {
  ret = 1;
 } else {
  h_obj = duk_get_hobject(thr, 0);
  if (h_obj != 
# 1104 "duk_bi_buffer.c" 3 4
              ((void *)0) 
# 1104 "duk_bi_buffer.c"
                   && (((&(h_obj)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {



   ret = ((duk_hbufobj *) h_obj)->is_typedarray ||
         ((((&(h_obj)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 20);
  }
 }
 duk_push_boolean(thr, ret);
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_uint8array_allocplain(duk_hthread *thr) {
 duk__hbufobj_fixed_from_argvalue(thr);
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_uint8array_plainof(duk_hthread *thr) {
 duk_hbufobj *h_bufobj;



 if (duk_is_buffer(thr, 0)) {
  return 1;
 }






 h_bufobj = duk__require_bufobj_value(thr, 0);
 if (h_bufobj->buf == 
# 1148 "duk_bi_buffer.c" 3 4
                     ((void *)0)
# 1148 "duk_bi_buffer.c"
                         ) {
  duk_push_undefined(thr);
 } else {
  duk_push_hbuffer(thr, h_bufobj->buf);
 }
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_tostring(duk_hthread *thr) {
 duk_hbufobj *h_this;
 duk_int_t start_offset, end_offset;
 duk_uint8_t *buf_slice;
 duk_size_t slice_length;

 h_this = duk__get_bufobj_this(thr);
 if (h_this == 
# 1169 "duk_bi_buffer.c" 3 4
              ((void *)0)
# 1169 "duk_bi_buffer.c"
                  ) {

  duk_push_literal_raw((thr), ("[object Object]"), sizeof(("[object Object]")) - 1U);
  return 1;
 }
 do { } while (0);



 duk__clamp_startend_nonegidx_noshift(thr,
                                      (duk_int_t) h_this->length,
                                      1 ,
                                      2 ,
                                      &start_offset,
                                      &end_offset);

 slice_length = (duk_size_t) (end_offset - start_offset);
 buf_slice = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, slice_length);
 do { } while (0);


 if (h_this->buf == 
# 1190 "duk_bi_buffer.c" 3 4
                   ((void *)0) 
# 1190 "duk_bi_buffer.c"
                        || !(((void) 0), ((void) 0), ((h_this)->offset + ((duk_size_t) start_offset + slice_length) <= (((duk_hbuffer *) ((h_this)->buf))->size)))) {
  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_buffer.c", (duk_int_t) 1191); } while (0); return 0; } while (0);
 }







 do { } while (0);
 do { void *duk__dst = ((void *) buf_slice); const void *duk__src = ((const void *) ((((void) 0), ((void) 0), (((duk_uint8_t *) ((((&(((h_this)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_this)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_this)->buf))) + 1)))) + (h_this)->offset)) + start_offset)); duk_size_t duk__len = ((size_t) slice_length); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0)

                                         ;





 duk_replace(thr, 0);
 duk_set_top(thr, 1);
 return duk_textdecoder_decode_utf8_nodejs(thr);
}







static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_tojson(duk_hthread *thr) {
 duk_hbufobj *h_this;
 duk_uint8_t *buf;
 duk_uint_t i, n;
 duk_tval *tv;

 h_this = duk__require_bufobj_this(thr);
 do { } while (0);

 if (h_this->buf == 
# 1229 "duk_bi_buffer.c" 3 4
                   ((void *)0) 
# 1229 "duk_bi_buffer.c"
                        || !(((void) 0), ((void) 0), ((h_this)->offset + (h_this)->length <= (((duk_hbuffer *) ((h_this)->buf))->size)))) {



  duk_push_null(thr);
  return 1;
 }

 duk_push_object(thr);
 duk_push_hstring_stridx(thr, 30);
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (84))));


 do { } while (0);
 tv = duk_push_harray_with_size_outptr(thr, (duk_uint32_t) h_this->length);
 do { } while (0);

 do { } while (0);
 buf = (((void) 0), ((void) 0), (((duk_uint8_t *) ((((&(((h_this)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_this)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_this)->buf))) + 1)))) + (h_this)->offset));
 for (i = 0, n = h_this->length; i < n; i++) {
  do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((duk_double_t) ((duk_uint32_t) buf[i])); ; duk__tv = ((tv + i)); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0);
 }
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (85))));

 return 1;
}
# 1264 "duk_bi_buffer.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_buffer_compare_shared(duk_hthread *thr) {
 duk_small_uint_t magic;
 duk_hbufobj *h_bufarg1;
 duk_hbufobj *h_bufarg2;
 duk_small_int_t comp_res;



 magic = (duk_small_uint_t) duk_get_current_magic(thr);
 if (magic & 0x02U) {

  h_bufarg1 = duk__require_bufobj_value(thr, 0);
  h_bufarg2 = duk__require_bufobj_value(thr, 1);
 } else {
  h_bufarg1 = duk__require_bufobj_this(thr);
  h_bufarg2 = duk__require_bufobj_value(thr, 0);
 }
 do { } while (0);
 do { } while (0);







 if ((((void) 0), ((void) 0), ((h_bufarg1)->offset + (h_bufarg1)->length <= (((duk_hbuffer *) ((h_bufarg1)->buf))->size))) && (((void) 0), ((void) 0), ((h_bufarg2)->offset + (h_bufarg2)->length <= (((duk_hbuffer *) ((h_bufarg2)->buf))->size)))) {
  comp_res = duk_js_data_compare(
      (const duk_uint8_t *) ((((&((h_bufarg1->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h_bufarg1->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h_bufarg1->buf))) + 1))) + h_bufarg1->offset,
      (const duk_uint8_t *) ((((&((h_bufarg2->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h_bufarg2->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h_bufarg2->buf))) + 1))) + h_bufarg2->offset,
      (duk_size_t) h_bufarg1->length,
      (duk_size_t) h_bufarg2->length);
 } else {
  comp_res = -1;
 }

 if (magic & 0x01U) {

  duk_push_int(thr, comp_res);
 } else {

  duk_push_boolean(thr, (comp_res == 0));
 }

 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_fill(duk_hthread *thr) {
 duk_hbufobj *h_this;
 const duk_uint8_t *fill_str_ptr;
 duk_size_t fill_str_len;
 duk_uint8_t fill_value;
 duk_int_t fill_offset;
 duk_int_t fill_end;
 duk_size_t fill_length;
 duk_uint8_t *p;

 h_this = duk__require_bufobj_this(thr);
 do { } while (0);
 if (h_this->buf == 
# 1329 "duk_bi_buffer.c" 3 4
                   ((void *)0)
# 1329 "duk_bi_buffer.c"
                       ) {
  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_buffer.c", (duk_int_t) 1330); } while (0); return 0; } while (0);
 }



 if (duk_is_string_notsymbol(thr, 0)) {
  fill_str_ptr = (const duk_uint8_t *) duk_get_lstring(thr, 0, &fill_str_len);
  do { } while (0);
 } else {

  fill_value = (duk_uint8_t) duk_to_uint32(thr, 0);
  fill_str_ptr = (const duk_uint8_t *) &fill_value;
  fill_str_len = 1;
 }



 duk__clamp_startend_nonegidx_noshift(thr,
                                      (duk_int_t) h_this->length,
                                      1 ,
                                      2 ,
                                      &fill_offset,
                                      &fill_end);

 do { } while (0)



                                             ;

 do { } while (0);
 do { } while (0);

 p = ((((void) 0), ((void) 0), (((duk_uint8_t *) ((((&(((h_this)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_this)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_this)->buf))) + 1)))) + (h_this)->offset)) + fill_offset);
 fill_length = (duk_size_t) (fill_end - fill_offset);
 if (fill_str_len == 1) {



  do { void *duk__dst = ((void *) p); duk_small_int_t duk__val = ((int) fill_str_ptr[0]); duk_size_t duk__len = ((size_t) fill_length); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); (void) memset(duk__dst, duk__val, (size_t) duk__len); } } while (0);
 } else if (fill_str_len > 1) {
  duk_size_t i, n, t;

  for (i = 0, n = (duk_size_t) (fill_end - fill_offset), t = 0; i < n; i++) {
   p[i] = fill_str_ptr[t++];
   if (t >= fill_str_len) {
    t = 0;
   }
  }
 } else {
  do { } while (0);
 }


 duk_push_this(thr);
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_write(duk_hthread *thr) {
 duk_hbufobj *h_this;
 duk_uint_t offset;
 duk_uint_t length;
 const duk_uint8_t *str_data;
 duk_size_t str_len;


 h_this = duk__require_bufobj_this(thr);
 do { } while (0);


 str_data = (const duk_uint8_t *) duk_require_lstring_notsymbol(thr, 0, &str_len);

 duk__resolve_offset_opt_length(thr, h_this, 1, 2, &offset, &length, 0 );
 do { } while (0);
 do { } while (0);



 if (length > str_len) {
  length = (duk_uint_t) str_len;
 }

 if ((((void) 0), ((void) 0), ((h_this)->offset + (h_this)->length <= (((duk_hbuffer *) ((h_this)->buf))->size)))) {

  do { void *duk__dst = ((void *) ((((void) 0), ((void) 0), (((duk_uint8_t *) ((((&(((h_this)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_this)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_this)->buf))) + 1)))) + (h_this)->offset)) + offset)); const void *duk__src = ((const void *) str_data); duk_size_t duk__len = ((size_t) length); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0)

                                    ;
 } else {
  do { } while (0);
 }

 duk_push_uint(thr, length);
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_copy(duk_hthread *thr) {
 duk_hbufobj *h_this;
 duk_hbufobj *h_bufarg;
 duk_int_t source_length;
 duk_int_t target_length;
 duk_int_t target_start, source_start, source_end;
 duk_uint_t target_ustart, source_ustart, source_uend;
 duk_uint_t copy_size = 0;



 h_this = duk__require_bufobj_this(thr);
 h_bufarg = duk__require_bufobj_value(thr, 0);
 do { } while (0);
 do { } while (0);
 source_length = (duk_int_t) h_this->length;
 target_length = (duk_int_t) h_bufarg->length;

 target_start = duk_to_int(thr, 1);
 source_start = duk_to_int(thr, 2);
 if (duk_is_undefined(thr, 3)) {
  source_end = source_length;
 } else {
  source_end = duk_to_int(thr, 3);
 }

 do { } while (0)





                                            ;



 if (source_start < 0 || source_end < 0 || target_start < 0) {

  goto fail_bounds;
 }
 source_ustart = (duk_uint_t) source_start;
 source_uend = (duk_uint_t) source_end;
 target_ustart = (duk_uint_t) target_start;
 if (source_ustart >= source_uend ||
     source_ustart >= (duk_uint_t) source_length ||
     target_ustart >= (duk_uint_t) target_length) {
  goto silent_ignore;
 }
 if (source_uend >= (duk_uint_t) source_length) {

  source_uend = (duk_uint_t) source_length;
 }
 copy_size = source_uend - source_ustart;
 if (target_ustart + copy_size > (duk_uint_t) target_length) {







  do { } while (0);
  do { } while (0);
  copy_size = (duk_uint_t) target_length - target_ustart;
 }

 do { } while (0)


                                                 ;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 do { } while (0);
 do { } while (0);
 if ((((void) 0), ((void) 0), ((h_bufarg)->offset + (target_ustart + copy_size) <= (((duk_hbuffer *) ((h_bufarg)->buf))->size))) &&
     (((void) 0), ((void) 0), ((h_this)->offset + (source_ustart + copy_size) <= (((duk_hbuffer *) ((h_this)->buf))->size)))) {



  do { void *duk__dst = ((void *) ((((void) 0), ((void) 0), (((duk_uint8_t *) ((((&(((h_bufarg)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_bufarg)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_bufarg)->buf))) + 1)))) + (h_bufarg)->offset)) + target_ustart)); const void *duk__src = ((const void *) ((((void) 0), ((void) 0), (((duk_uint8_t *) ((((&(((h_this)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_this)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_this)->buf))) + 1)))) + (h_this)->offset)) + source_ustart)); duk_size_t duk__len = ((size_t) copy_size); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } } while (0)

                                        ;
 } else {
  do { } while (0);
 }

silent_ignore:




 duk_push_uint(thr, copy_size);
 return 1;

fail_bounds:
 do { do { do { duk_err_range((((thr))), "duk_bi_buffer.c", (duk_int_t) 1538, ("invalid args")); } while (0); } while (0); return 0; } while (0);
}
# 1579 "duk_bi_buffer.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_typedarray_set(duk_hthread *thr) {
 duk_hbufobj *h_this;
 duk_hobject *h_obj;
 duk_uarridx_t i, n;
 duk_int_t offset_signed;
 duk_uint_t offset_elems;
 duk_uint_t offset_bytes;

 h_this = duk__require_bufobj_this(thr);
 do { } while (0);
 do { } while (0);

 if (h_this->buf == 
# 1591 "duk_bi_buffer.c" 3 4
                   ((void *)0)
# 1591 "duk_bi_buffer.c"
                       ) {
  do { } while (0);
  return 0;
 }

 duk_hbufobj_promote_plain(thr, 0);
 h_obj = duk_require_hobject(thr, 0);





 offset_signed = duk_to_int(thr, 1);
 if (offset_signed < 0) {

  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_buffer.c", (duk_int_t) 1606); } while (0); return 0; } while (0);
 }
 offset_elems = (duk_uint_t) offset_signed;
 offset_bytes = offset_elems << h_this->shift;
 if ((offset_bytes >> h_this->shift) != offset_elems) {


  goto fail_args;
 }
 if (offset_bytes > h_this->length) {




  goto fail_args;
 }
 do { } while (0);



 if ((((&(h_obj)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {
  duk_hbufobj *h_bufarg;

  duk_uint16_t comp_mask;

  duk_small_int_t no_overlap = 0;
  duk_uint_t src_length;
  duk_uint_t dst_length;
  duk_uint_t dst_length_elems;
  duk_uint8_t *p_src_base;
  duk_uint8_t *p_src_end;
  duk_uint8_t *p_src;
  duk_uint8_t *p_dst_base;
  duk_uint8_t *p_dst;
  duk_small_uint_t src_elem_size;
  duk_small_uint_t dst_elem_size;

  h_bufarg = (duk_hbufobj *) h_obj;
  do { } while (0);

  if (h_bufarg->buf == 
# 1646 "duk_bi_buffer.c" 3 4
                      ((void *)0)
# 1646 "duk_bi_buffer.c"
                          ) {
   do { } while (0);
   return 0;
  }


  src_length = h_bufarg->length;
  dst_length_elems = (src_length >> h_bufarg->shift);
  dst_length = dst_length_elems << h_this->shift;
  if ((dst_length >> h_this->shift) != dst_length_elems) {


   goto fail_args;
  }
  do { } while (0);
  do { } while (0);
  if (dst_length > h_this->length - offset_bytes) {



   do { } while (0);
   goto fail_args;
  }
  if (!(((void) 0), ((void) 0), ((h_this)->offset + (offset_bytes + dst_length) <= (((duk_hbuffer *) ((h_this)->buf))->size)))) {
   do { } while (0);
   return 0;
  }

  p_src_base = (((void) 0), ((void) 0), (((duk_uint8_t *) ((((&(((h_bufarg)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_bufarg)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_bufarg)->buf))) + 1)))) + (h_bufarg)->offset));
  p_dst_base = (((void) 0), ((void) 0), (((duk_uint8_t *) ((((&(((h_this)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_this)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_this)->buf))) + 1)))) + (h_this)->offset)) + offset_bytes;





  if (!(((void) 0), ((void) 0), ((h_this)->offset + (h_this)->length <= (((duk_hbuffer *) ((h_this)->buf))->size))) || !(((void) 0), ((void) 0), ((h_bufarg)->offset + (h_bufarg)->length <= (((duk_hbuffer *) ((h_bufarg)->buf))->size)))) {




   do { } while (0);
   return 0;
  }
# 1702 "duk_bi_buffer.c"
  do { } while (0);
  comp_mask = duk__buffer_elemtype_copy_compatible[h_this->elem_type];
  if (comp_mask & (1 << h_bufarg->elem_type)) {
   do { } while (0);

   do { } while (0);
   do { void *duk__dst = ((void *) p_dst_base); const void *duk__src = ((const void *) p_src_base); duk_size_t duk__len = ((size_t) dst_length); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } } while (0);
   return 0;
  }
  do { } while (0);
# 1730 "duk_bi_buffer.c"
  do { } while (0)




                                          ;

  if (p_src_base >= p_dst_base + dst_length ||
      p_src_base + src_length <= p_dst_base) {
   no_overlap = 1;
  }

  if (!no_overlap) {





   duk_uint8_t *p_src_copy;

   do { } while (0);
   p_src_copy = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, src_length);
   do { } while (0);
   do { void *duk__dst = ((void *) p_src_copy); const void *duk__src = ((const void *) p_src_base); duk_size_t duk__len = ((size_t) src_length); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0);

   p_src_base = p_src_copy;
  }


  do { } while (0)





                                                ;
# 1775 "duk_bi_buffer.c"
  src_elem_size = (duk_small_uint_t) (1U << h_bufarg->shift);
  dst_elem_size = (duk_small_uint_t) (1U << h_this->shift);
  p_src = p_src_base;
  p_dst = p_dst_base;
  p_src_end = p_src_base + src_length;

  while (p_src != p_src_end) {
   do { } while (0)



                                        ;



   duk_hbufobj_push_validated_read(thr, h_bufarg, p_src, src_elem_size);
   duk_hbufobj_validated_write(thr, h_this, p_dst, dst_elem_size);
   duk_pop(thr);
   p_src += src_elem_size;
   p_dst += dst_elem_size;
  }

  return 0;
 } else {
# 1808 "duk_bi_buffer.c"
  n = (duk_uarridx_t) duk_get_length(thr, 0);
  do { } while (0);
  if ((n << h_this->shift) > h_this->length - offset_bytes) {



   do { } while (0);
   goto fail_args;
  }
# 1825 "duk_bi_buffer.c"
  do { } while (0);
  duk_push_this(thr);

  for (i = 0; i < n; i++) {
   duk_get_prop_index(thr, 0, i);
   duk_put_prop_index(thr, 2, offset_elems + i);
  }
 }

 return 0;

fail_args:
 do { do { do { duk_err_range((((thr))), "duk_bi_buffer.c", (duk_int_t) 1837, ("invalid args")); } while (0); } while (0); return 0; } while (0);
}
# 1862 "duk_bi_buffer.c"
static void duk__arraybuffer_plain_slice(duk_hthread *thr, duk_hbuffer *h_val) {
 duk_int_t start_offset, end_offset;
 duk_uint_t slice_length;
 duk_uint8_t *p_copy;
 duk_size_t copy_length;

 duk__clamp_startend_negidx_shifted(thr,
                                    (duk_int_t) (((duk_hbuffer *) (h_val))->size),
                                    0 ,
                                    0 ,
                                    1 ,
                                    &start_offset,
                                    &end_offset);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 slice_length = (duk_uint_t) (end_offset - start_offset);

 p_copy = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, (duk_size_t) slice_length);
 do { } while (0);
 copy_length = slice_length;

 do { void *duk__dst = ((void *) p_copy); const void *duk__src = ((const void *) ((duk_uint8_t *) ((((&((h_val))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h_val))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h_val))) + 1))) + start_offset)); duk_size_t duk__len = (copy_length); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0)

                               ;
}






static __attribute__ ((unused)) duk_ret_t duk_bi_buffer_slice_shared(duk_hthread *thr) {
 duk_small_int_t magic;
 duk_small_uint_t res_class_num;
 duk_small_int_t res_proto_bidx;
 duk_hbufobj *h_this;
 duk_hbufobj *h_bufobj;
 duk_hbuffer *h_val;
 duk_int_t start_offset, end_offset;
 duk_uint_t slice_length;
 duk_tval *tv;



 magic = duk_get_current_magic(thr);

 tv = duk_get_borrowed_this_tval(thr);
 do { } while (0);

 if (((tv)->t == 10)) {

  h_val = ((tv)->v.hbuffer);
  do { } while (0);

  if (magic & 0x02) {

   duk__arraybuffer_plain_slice(thr, h_val);
   return 1;
  } else {
# 1930 "duk_bi_buffer.c"
   do { } while (0);

  }
 }
 tv = 
# 1934 "duk_bi_buffer.c" 3 4
     ((void *)0)
# 1934 "duk_bi_buffer.c"
         ;

 h_this = duk__require_bufobj_this(thr);
# 1947 "duk_bi_buffer.c"
 duk__clamp_startend_negidx_shifted(thr,
                                    (duk_int_t) h_this->length,
                                    (duk_uint8_t) h_this->shift,
                                    0 ,
                                    1 ,
                                    &start_offset,
                                    &end_offset);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 slice_length = (duk_uint_t) (end_offset - start_offset);
# 1971 "duk_bi_buffer.c"
 res_class_num = (((&((duk_hobject *) h_this)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL));
 do { } while (0);
 do { } while (0);
 res_proto_bidx = duk__buffer_proto_from_classnum[res_class_num - 19];
 if (magic & 0x04) {
  res_proto_bidx = 50;
 }
 h_bufobj =
     duk_push_bufobj_raw(thr,
                         (1UL << (7 + (0))) | (1UL << (7 + (6))) | (((duk_uint_t) (res_class_num)) << (7 + (20))),
                         res_proto_bidx);
 do { } while (0);

 do { } while (0);
 h_bufobj->shift = h_this->shift;
 h_bufobj->elem_type = h_this->elem_type;
 h_bufobj->is_typedarray = magic & 0x01;
 do { } while (0);

 h_val = h_this->buf;
 if (h_val == 
# 1991 "duk_bi_buffer.c" 3 4
             ((void *)0)
# 1991 "duk_bi_buffer.c"
                 ) {
  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_buffer.c", (duk_int_t) 1992); } while (0); return 0; } while (0);
 }

 if (magic & 0x02) {

  duk_uint8_t *p_copy;
  duk_size_t copy_length;

  p_copy = (duk_uint8_t *) duk_push_fixed_buffer_zero(
      thr,
      (duk_size_t) slice_length);
  do { } while (0);




  copy_length = (((void) 0), duk_hbufobj_clamp_bytelength((h_this), (slice_length)));
  do { void *duk__dst = ((void *) p_copy); const void *duk__src = ((const void *) ((((void) 0), ((void) 0), (((duk_uint8_t *) ((((&(((h_this)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_this)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_this)->buf))) + 1)))) + (h_this)->offset)) + start_offset)); duk_size_t duk__len = (copy_length); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0)

                                ;

  h_val = duk_known_hbuffer(thr, -1);

  h_bufobj->buf = h_val;
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_val))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  h_bufobj->length = slice_length;
  do { } while (0);

  duk_pop(thr);
 } else {
  h_bufobj->buf = h_val;
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_val))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  h_bufobj->length = slice_length;
  h_bufobj->offset = h_this->offset + (duk_uint_t) start_offset;






  do { } while (0);
  h_bufobj->buf_prop = h_this->buf_prop;
  do { if (((duk_hobject *) h_bufobj->buf_prop) != 
# 2034 "duk_bi_buffer.c" 3 4
 ((void *)0)
# 2034 "duk_bi_buffer.c"
 ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (((duk_hobject *) h_bufobj->buf_prop)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0);
 }


 do { } while (0);
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_is_encoding(duk_hthread *thr) {
 const char *encoding;



 encoding = duk_to_string(thr, 0);
 do { } while (0);
 duk_push_boolean(thr, strcmp(encoding, "utf8") == 0);
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_is_buffer(duk_hthread *thr) {
 duk_hobject *h;
 duk_hobject *h_proto;
 duk_bool_t ret = 0;

 do { } while (0);
 h = duk_get_hobject(thr, 0);
 if (h != 
# 2072 "duk_bi_buffer.c" 3 4
         ((void *)0)
# 2072 "duk_bi_buffer.c"
             ) {
  h_proto = thr->builtins[50];
  do { } while (0);

  h = ((h)->prototype);
  if (h != 
# 2077 "duk_bi_buffer.c" 3 4
          ((void *)0)
# 2077 "duk_bi_buffer.c"
              ) {
   ret = duk_hobject_prototype_chain_contains(thr, h, h_proto, 0 );
  }
 }

 duk_push_boolean(thr, ret);
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_byte_length(duk_hthread *thr) {
 const char *str;
 duk_size_t len;
# 2111 "duk_bi_buffer.c"
 str = duk_to_lstring(thr, 0, &len);
 do { (void) (str); } while (0);
 duk_push_uint((thr), (duk_uint_t) (len));
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_nodejs_buffer_concat(duk_hthread *thr) {
 duk_hobject *h_arg;
 duk_uint_t total_length;
 duk_hbufobj *h_bufobj;
 duk_hbufobj *h_bufres;
 duk_hbuffer *h_val;
 duk_uint_t i, n;
 duk_uint8_t *p;
 duk_size_t space_left;
 duk_size_t copy_size;


 h_arg = duk_require_hobject(thr, 0);
 if ((((&(h_arg)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) != 2) {
  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_buffer.c", (duk_int_t) 2137); } while (0); return 0; } while (0);
 }


 n = (duk_uint_t) duk_get_length(thr, 0);
 total_length = 0;
 for (i = 0; i < n; i++) {



  do { } while (0);
  duk_get_prop_index(thr, 0, (duk_uarridx_t) i);
  h_bufobj = duk__require_bufobj_value(thr, 2);
  do { } while (0);
  total_length += h_bufobj->length;
  if (__builtin_expect((total_length < h_bufobj->length), 0)) {
   do { do { do { duk_err_range((((thr))), "duk_bi_buffer.c", (duk_int_t) 2153, ("invalid args")); } while (0); } while (0); return 0; } while (0);
  }
  duk_pop(thr);
 }
# 2166 "duk_bi_buffer.c"
 if (!duk_is_undefined(thr, 1) && n > 0) {



  duk_int_t total_length_signed;
  total_length_signed = duk_to_int(thr, 1);
  if (total_length_signed < 0) {
   do { do { do { duk_err_range((((thr))), "duk_bi_buffer.c", (duk_int_t) 2173, ("invalid args")); } while (0); } while (0); return 0; } while (0);
  }
  total_length = (duk_uint_t) total_length_signed;
 }

 h_bufres = duk_push_bufobj_raw(thr,
                                (1UL << (7 + (0))) | (1UL << (7 + (6))) |
                                    (((duk_uint_t) (22)) << (7 + (20))),
                                50);
 do { } while (0);

 p = (duk_uint8_t *) duk_push_fixed_buffer_zero(thr,
                                                total_length);
 do { } while (0);
 space_left = (duk_size_t) total_length;

 for (i = 0; i < n; i++) {
  do { } while (0);

  duk_get_prop_index(thr, 0, (duk_uarridx_t) i);
  h_bufobj = duk__require_bufobj_value(thr, 4);
  do { } while (0);

  copy_size = h_bufobj->length;
  if (copy_size > space_left) {
   copy_size = space_left;
  }

  if (h_bufobj->buf != 
# 2201 "duk_bi_buffer.c" 3 4
                      ((void *)0) 
# 2201 "duk_bi_buffer.c"
                           && (((void) 0), ((void) 0), ((h_bufobj)->offset + (h_bufobj)->length <= (((duk_hbuffer *) ((h_bufobj)->buf))->size)))) {
   do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) (((void) 0), ((void) 0), (((duk_uint8_t *) ((((&(((h_bufobj)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_bufobj)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_bufobj)->buf))) + 1)))) + (h_bufobj)->offset))); duk_size_t duk__len = (copy_size); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0);
  } else {

   ;
  }
  p += copy_size;
  space_left -= copy_size;

  duk_pop(thr);
 }

 h_val = duk_known_hbuffer(thr, -1);

 duk__set_bufobj_buffer(thr, h_bufres, h_val);
 h_bufres->is_typedarray = 1;
 do { } while (0);

 duk_pop(thr);

 return 1;
}
# 2250 "duk_bi_buffer.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_buffer_readfield(duk_hthread *thr) {
 duk_small_uint_t magic = (duk_small_uint_t) duk_get_current_magic(thr);
 duk_small_uint_t magic_ftype;
 duk_small_uint_t magic_bigendian;
 duk_small_uint_t magic_signed;
 duk_small_uint_t magic_typedarray;
 duk_small_uint_t endswap;
 duk_hbufobj *h_this;
 duk_bool_t no_assert;
 duk_int_t offset_signed;
 duk_uint_t offset;
 duk_uint_t buffer_length;
 duk_uint_t check_length;
 duk_uint8_t *buf;
 duk_double_union du;

 magic_ftype = magic & 0x0007U;
 magic_bigendian = magic & 0x0008U;
 magic_signed = magic & 0x0010U;
 magic_typedarray = magic & 0x0020U;

 h_this = duk__require_bufobj_this(thr);
 do { } while (0);
 buffer_length = h_this->length;






 if (magic_typedarray) {
  no_assert = 0;

  endswap = !duk_to_boolean(thr, 1);



 } else {
  no_assert = duk_to_boolean(thr, (magic_ftype == 5) ? 2 : 1);

  endswap = magic_bigendian;



 }





 offset_signed = duk_to_int(thr, 0);
 offset = (duk_uint_t) offset_signed;
 if (offset_signed < 0) {
  goto fail_bounds;
 }

 do { } while (0)
# 2316 "duk_bi_buffer.c"
                                     ;





 check_length = (((void) 0), duk_hbufobj_clamp_bytelength((h_this), (buffer_length)));
 do { } while (0);

 if (h_this->buf) {
  buf = (((void) 0), ((void) 0), (((duk_uint8_t *) ((((&(((h_this)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_this)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_this)->buf))) + 1)))) + (h_this)->offset));
 } else {




  do { } while (0);
  goto fail_neutered;
 }
 do { } while (0);

 switch (magic_ftype) {
 case 0: {
  duk_uint8_t tmp;
  if (offset + 1U > check_length) {
   goto fail_bounds;
  }
  tmp = buf[offset];
  if (magic_signed) {
   duk_push_int(thr, (duk_int_t) ((duk_int8_t) tmp));
  } else {
   duk_push_uint(thr, (duk_uint_t) tmp);
  }
  break;
 }
 case 1: {
  duk_uint16_t tmp;
  if (offset + 2U > check_length) {
   goto fail_bounds;
  }
  do { void *duk__dst = ((void *) du.uc); const void *duk__src = ((const void *) (buf + offset)); duk_size_t duk__len = (2); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
  tmp = du.us[0];
  if (endswap) {
   tmp = ((duk_uint16_t) __builtin_bswap16((duk_uint16_t) (tmp)));
  }
  if (magic_signed) {
   duk_push_int(thr, (duk_int_t) ((duk_int16_t) tmp));
  } else {
   duk_push_uint(thr, (duk_uint_t) tmp);
  }
  break;
 }
 case 2: {
  duk_uint32_t tmp;
  if (offset + 4U > check_length) {
   goto fail_bounds;
  }
  do { void *duk__dst = ((void *) du.uc); const void *duk__src = ((const void *) (buf + offset)); duk_size_t duk__len = (4); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
  tmp = du.ui[0];
  if (endswap) {
   tmp = ((duk_uint32_t) __builtin_bswap32((duk_uint32_t) (tmp)));
  }
  if (magic_signed) {
   duk_push_int(thr, (duk_int_t) ((duk_int32_t) tmp));
  } else {
   duk_push_uint(thr, (duk_uint_t) tmp);
  }
  break;
 }
 case 3: {
  duk_uint32_t tmp;
  if (offset + 4U > check_length) {
   goto fail_bounds;
  }
  do { void *duk__dst = ((void *) du.uc); const void *duk__src = ((const void *) (buf + offset)); duk_size_t duk__len = (4); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
  if (endswap) {
   tmp = du.ui[0];
   tmp = ((duk_uint32_t) __builtin_bswap32((duk_uint32_t) (tmp)));
   du.ui[0] = tmp;
  }
  duk_push_number(thr, (duk_double_t) du.f[0]);
  break;
 }
 case 4: {
  if (offset + 8U > check_length) {
   goto fail_bounds;
  }
  do { void *duk__dst = ((void *) du.uc); const void *duk__src = ((const void *) (buf + offset)); duk_size_t duk__len = (8); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
  if (endswap) {
   do { duk_uint32_t duk__bswaptmp1, duk__bswaptmp2; duk__bswaptmp1 = (&du)->ui[0]; duk__bswaptmp2 = (&du)->ui[1]; duk__bswaptmp1 = ((duk_uint32_t) __builtin_bswap32((duk_uint32_t) (duk__bswaptmp1))); duk__bswaptmp2 = ((duk_uint32_t) __builtin_bswap32((duk_uint32_t) (duk__bswaptmp2))); (&du)->ui[0] = duk__bswaptmp2; (&du)->ui[1] = duk__bswaptmp1; } while (0);
  }
  duk_push_number(thr, (duk_double_t) du.d);
  break;
 }
 case 5: {



  duk_int_t field_bytelen;
  duk_int_t i, i_step, i_end;

  duk_int64_t tmp;
  duk_small_uint_t shift_tmp;




  const duk_uint8_t *p;

  field_bytelen = duk_get_int(thr, 1);
  if (field_bytelen < 1 || field_bytelen > 6) {
   goto fail_field_length;
  }
  if (offset + (duk_uint_t) field_bytelen > check_length) {
   goto fail_bounds;
  }
  p = (const duk_uint8_t *) (buf + offset);






  if (magic_bigendian) {

   i = 0;
   i_step = 1;
   i_end = field_bytelen;
  } else {

   i = field_bytelen - 1;
   i_step = -1;
   i_end = -1;
  }


  tmp = 0;
  do {
   do { } while (0);
   tmp = (tmp << 8) + (duk_int64_t) p[i];
   i += i_step;
  } while (i != i_end);

  if (magic_signed) {




   shift_tmp = (duk_small_uint_t) (64U - (duk_small_uint_t) field_bytelen * 8U);
   tmp = (duk_int64_t) ((duk_uint64_t) tmp << shift_tmp) >> shift_tmp;
  }

  duk_push_number((thr), (duk_double_t) (tmp));
# 2488 "duk_bi_buffer.c"
  break;
 }
 default: {
  goto fail_bounds;
 }
 }

 return 1;

fail_neutered:
fail_field_length:
fail_bounds:
 if (no_assert) {



  duk_push_nan(thr);
  return 1;
 }
 do { do { do { duk_err_range((((thr))), "duk_bi_buffer.c", (duk_int_t) 2507, ("invalid args")); } while (0); } while (0); return 0; } while (0);
}




static __attribute__ ((unused)) duk_ret_t duk_bi_buffer_writefield(duk_hthread *thr) {
 duk_small_uint_t magic = (duk_small_uint_t) duk_get_current_magic(thr);
 duk_small_uint_t magic_ftype;
 duk_small_uint_t magic_bigendian;
 duk_small_uint_t magic_signed;
 duk_small_uint_t magic_typedarray;
 duk_small_uint_t endswap;
 duk_hbufobj *h_this;
 duk_bool_t no_assert;
 duk_int_t offset_signed;
 duk_uint_t offset;
 duk_uint_t buffer_length;
 duk_uint_t check_length;
 duk_uint8_t *buf;
 duk_double_union du;
 duk_int_t nbytes = 0;

 magic_ftype = magic & 0x0007U;
 magic_bigendian = magic & 0x0008U;
 magic_signed = magic & 0x0010U;
 magic_typedarray = magic & 0x0020U;
 do { (void) (magic_signed); } while (0);

 h_this = duk__require_bufobj_this(thr);
 do { } while (0);
 buffer_length = h_this->length;






 if (magic_typedarray) {
  no_assert = 0;

  endswap = !duk_to_boolean(thr, 2);



  duk_swap(thr, 0, 1);
 } else {
  no_assert = duk_to_boolean(thr, (magic_ftype == 5) ? 3 : 2);

  endswap = magic_bigendian;



 }





 offset_signed = duk_to_int(thr, 1);
 offset = (duk_uint_t) offset_signed;




 if (magic_ftype != 5) {
  do { } while (0);
  nbytes = duk__buffer_nbytes_from_fldtype[magic_ftype];
 } else {
  nbytes = duk_get_int(thr, 2);
  if (nbytes < 1 || nbytes > 6) {
   goto fail_field_length;
  }
 }
 do { } while (0);


 if (offset_signed < 0) {
  goto fail_bounds;
 }

 do { } while (0)
# 2599 "duk_bi_buffer.c"
                                     ;





 duk_to_number(thr, 0);





 check_length = (((void) 0), duk_hbufobj_clamp_bytelength((h_this), (buffer_length)));
 do { } while (0);

 if (h_this->buf) {
  buf = (((void) 0), ((void) 0), (((duk_uint8_t *) ((((&(((h_this)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_this)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_this)->buf))) + 1)))) + (h_this)->offset));
 } else {




  do { } while (0);
  goto fail_neutered;
 }
 do { } while (0);

 switch (magic_ftype) {
 case 0: {
  if (offset + 1U > check_length) {
   goto fail_bounds;
  }

  buf[offset] = (duk_uint8_t) duk_to_uint32(thr, 0);
  break;
 }
 case 1: {
  duk_uint16_t tmp;
  if (offset + 2U > check_length) {
   goto fail_bounds;
  }
  tmp = (duk_uint16_t) duk_to_uint32(thr, 0);
  if (endswap) {
   tmp = ((duk_uint16_t) __builtin_bswap16((duk_uint16_t) (tmp)));
  }
  du.us[0] = tmp;

  do { void *duk__dst = ((void *) (buf + offset)); const void *duk__src = ((const void *) du.uc); duk_size_t duk__len = (2); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
  break;
 }
 case 2: {
  duk_uint32_t tmp;
  if (offset + 4U > check_length) {
   goto fail_bounds;
  }
  tmp = (duk_uint32_t) duk_to_uint32(thr, 0);
  if (endswap) {
   tmp = ((duk_uint32_t) __builtin_bswap32((duk_uint32_t) (tmp)));
  }
  du.ui[0] = tmp;

  do { void *duk__dst = ((void *) (buf + offset)); const void *duk__src = ((const void *) du.uc); duk_size_t duk__len = (4); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
  break;
 }
 case 3: {
  duk_uint32_t tmp;
  if (offset + 4U > check_length) {
   goto fail_bounds;
  }
  du.f[0] = (duk_float_t) duk_to_number(thr, 0);
  if (endswap) {
   tmp = du.ui[0];
   tmp = ((duk_uint32_t) __builtin_bswap32((duk_uint32_t) (tmp)));
   du.ui[0] = tmp;
  }

  do { void *duk__dst = ((void *) (buf + offset)); const void *duk__src = ((const void *) du.uc); duk_size_t duk__len = (4); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
  break;
 }
 case 4: {
  if (offset + 8U > check_length) {
   goto fail_bounds;
  }
  du.d = (duk_double_t) duk_to_number(thr, 0);
  if (endswap) {
   do { duk_uint32_t duk__bswaptmp1, duk__bswaptmp2; duk__bswaptmp1 = (&du)->ui[0]; duk__bswaptmp2 = (&du)->ui[1]; duk__bswaptmp1 = ((duk_uint32_t) __builtin_bswap32((duk_uint32_t) (duk__bswaptmp1))); duk__bswaptmp2 = ((duk_uint32_t) __builtin_bswap32((duk_uint32_t) (duk__bswaptmp2))); (&du)->ui[0] = duk__bswaptmp2; (&du)->ui[1] = duk__bswaptmp1; } while (0);
  }

  do { void *duk__dst = ((void *) (buf + offset)); const void *duk__src = ((const void *) du.uc); duk_size_t duk__len = (8); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
  break;
 }
 case 5: {



  duk_int_t field_bytelen;
  duk_int_t i, i_step, i_end;

  duk_int64_t tmp;



  duk_uint8_t *p;

  field_bytelen = (duk_int_t) nbytes;
  if (offset + (duk_uint_t) field_bytelen > check_length) {
   goto fail_bounds;
  }






  if (magic_bigendian) {

   i = field_bytelen;
   i_step = -1;
   i_end = 0;
  } else {

   i = -1;
   i_step = 1;
   i_end = field_bytelen - 1;
  }
# 2732 "duk_bi_buffer.c"
  tmp = (duk_int64_t) duk_to_number(thr, 0);
  p = (duk_uint8_t *) (buf + offset);
  do {
   i += i_step;
   do { } while (0);
   p[i] = (duk_uint8_t) (tmp & 0xff);
   tmp = tmp >> 8;
  } while (i != i_end);
# 2751 "duk_bi_buffer.c"
  break;
 }
 default: {
  goto fail_bounds;
 }
 }




 if (magic_typedarray) {



  return 0;
 }
 duk_push_uint(thr, offset + (duk_uint_t) nbytes);
 return 1;

fail_neutered:
fail_field_length:
fail_bounds:
 if (no_assert) {






  if (magic_typedarray) {
   return 0;
  }
  duk_push_uint(thr, offset + (duk_uint_t) nbytes);
  return 1;
 }
 do { do { do { duk_err_range((((thr))), "duk_bi_buffer.c", (duk_int_t) 2786, ("invalid args")); } while (0); } while (0); return 0; } while (0);
}







static duk_hbufobj *duk__autospawn_arraybuffer(duk_hthread *thr, duk_hbuffer *h_buf) {
 duk_hbufobj *h_res;

 h_res = duk_push_bufobj_raw(thr,
                             (1UL << (7 + (0))) | (1UL << (7 + (6))) |
                                 (((duk_uint_t) (19)) << (7 + (20))),
                             39);
 do { } while (0);
 do { (void) (h_res); } while (0);

 duk__set_bufobj_buffer(thr, h_res, h_buf);
 do { } while (0);
 do { } while (0);
 return h_res;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_typedarray_buffer_getter(duk_hthread *thr) {
 duk_hbufobj *h_bufobj;

 h_bufobj = (duk_hbufobj *) duk__getrequire_bufobj_this(thr, (1 << 0) );
 do { } while (0);
 if ((((((duk_heaphdr *) h_bufobj))->h_flags & 0x00000003UL) == 2)) {
  do { } while (0);
  (void) duk__autospawn_arraybuffer(thr, (duk_hbuffer *) h_bufobj);
  return 1;
 } else {
  if (h_bufobj->buf_prop == 
# 2821 "duk_bi_buffer.c" 3 4
                           ((void *)0) 
# 2821 "duk_bi_buffer.c"
                                &&
      (((&((duk_hobject *) h_bufobj)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) != 19 &&
      h_bufobj->buf != 
# 2823 "duk_bi_buffer.c" 3 4
                      ((void *)0)
# 2823 "duk_bi_buffer.c"
                          ) {
   duk_hbufobj *h_arrbuf;

   do { } while (0);
   h_arrbuf = duk__autospawn_arraybuffer(thr, h_bufobj->buf);

   if (h_bufobj->buf_prop == 
# 2829 "duk_bi_buffer.c" 3 4
                            ((void *)0)
# 2829 "duk_bi_buffer.c"
                                ) {
# 2839 "duk_bi_buffer.c"
    h_arrbuf->offset = 0;
    do { } while (0);
    h_arrbuf->length = h_bufobj->offset + h_bufobj->length;
    do { } while (0);

    do { } while (0);
    h_bufobj->buf_prop = (duk_hobject *) h_arrbuf;
    do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) &(h_arrbuf)->obj)); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   }


  }
  if (h_bufobj->buf_prop) {
   duk_push_hobject(thr, h_bufobj->buf_prop);
   return 1;
  }
 }
 return 0;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_typedarray_byteoffset_getter(duk_hthread *thr) {
 duk_hbufobj *h_bufobj;

 h_bufobj = (duk_hbufobj *) duk__getrequire_bufobj_this(thr, (1 << 0) );
 do { } while (0);
 if ((((((duk_heaphdr *) h_bufobj))->h_flags & 0x00000003UL) == 2)) {
  duk_push_uint(thr, 0);
 } else {



  duk_push_uint(thr, h_bufobj->offset);
 }
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_typedarray_bytelength_getter(duk_hthread *thr) {
 duk_hbufobj *h_bufobj;

 h_bufobj = (duk_hbufobj *) duk__getrequire_bufobj_this(thr, (1 << 0) );
 do { } while (0);
 if ((((((duk_heaphdr *) h_bufobj))->h_flags & 0x00000003UL) == 2)) {
  duk_hbuffer *h_buf;

  h_buf = (duk_hbuffer *) h_bufobj;
  do { } while (0);
  duk_push_uint(thr, (duk_uint_t) (((duk_hbuffer *) (h_buf))->size));
 } else {



  duk_push_uint(thr, h_bufobj->length);
 }
 return 1;
}
# 1 "duk_bi_cbor.c"
# 27 "duk_bi_cbor.c"
typedef struct {
 duk_hthread *thr;
 duk_uint8_t *ptr;
 duk_uint8_t *buf;
 duk_uint8_t *buf_end;
 duk_size_t len;
 duk_idx_t idx_buf;
 duk_uint_t recursion_depth;
 duk_uint_t recursion_limit;
} duk_cbor_encode_context;

typedef struct {
 duk_hthread *thr;
 const duk_uint8_t *buf;
 duk_size_t off;
 duk_size_t len;
 duk_uint_t recursion_depth;
 duk_uint_t recursion_limit;
} duk_cbor_decode_context;

static void duk__cbor_encode_value(duk_cbor_encode_context *enc_ctx);
static void duk__cbor_decode_value(duk_cbor_decode_context *dec_ctx);





static duk_uint32_t duk__cbor_double_to_uint32(double d) {

 do { } while (0);
 return (duk_uint32_t) d;
}





static void duk__cbor_encode_error(duk_cbor_encode_context *enc_ctx) {
 (void) (duk_error_raw((enc_ctx->thr), (duk_errcode_t) 6, (const char *) ("duk_bi_cbor.c"), (duk_int_t) (65), "cbor encode error"), (duk_ret_t) 0);
}

static void duk__cbor_encode_req_stack(duk_cbor_encode_context *enc_ctx) {
 duk_require_stack(enc_ctx->thr, 4);
}

static void duk__cbor_encode_objarr_entry(duk_cbor_encode_context *enc_ctx) {
 duk_hthread *thr = enc_ctx->thr;


 duk_native_stack_check(thr);




 duk__cbor_encode_req_stack(enc_ctx);

 do { } while (0);
 if (enc_ctx->recursion_depth >= enc_ctx->recursion_limit) {
  do { duk_err_range((thr), "duk_bi_cbor.c", (duk_int_t) 85, ("encode recursion limit")); } while (0);
  do { return; } while (0);
 }
 enc_ctx->recursion_depth++;
}

static void duk__cbor_encode_objarr_exit(duk_cbor_encode_context *enc_ctx) {
 do { } while (0);
 enc_ctx->recursion_depth--;
}


static void duk__cbor_encode_sizet_uint32_check(duk_cbor_encode_context *enc_ctx, duk_size_t len) {
 if (__builtin_expect((sizeof(duk_size_t) > sizeof(duk_uint32_t) && len > (duk_size_t) 
# 98 "duk_bi_cbor.c" 3 4
    (4294967295U)
# 98 "duk_bi_cbor.c"
    ), 0)) {
  duk__cbor_encode_error(enc_ctx);
 }
}

static __attribute__((noinline)) void duk__cbor_encode_ensure_slowpath(duk_cbor_encode_context *enc_ctx, duk_size_t len) {
 duk_size_t oldlen;
 duk_size_t minlen;
 duk_size_t newlen;
 duk_uint8_t *p_new;
 duk_size_t old_data_len;

 do { } while (0);
 do { } while (0);
 do { } while (0);





 oldlen = enc_ctx->len;
 minlen = oldlen + len;
 if (__builtin_expect((oldlen > 
# 120 "duk_bi_cbor.c" 3 4
    (18446744073709551615UL) 
# 120 "duk_bi_cbor.c"
    / 2U || minlen < oldlen), 0)) {
  duk__cbor_encode_error(enc_ctx);
 }




 newlen = oldlen * 2U;

 do { } while (0);

 if (minlen > newlen) {
  newlen = minlen;
 }
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);

 p_new = (duk_uint8_t *) duk_resize_buffer(enc_ctx->thr, enc_ctx->idx_buf, newlen);
 do { } while (0);
 old_data_len = (duk_size_t) (enc_ctx->ptr - enc_ctx->buf);
 enc_ctx->buf = p_new;
 enc_ctx->buf_end = p_new + newlen;
 enc_ctx->ptr = p_new + old_data_len;
 enc_ctx->len = newlen;
}

static inline void duk__cbor_encode_ensure(duk_cbor_encode_context *enc_ctx, duk_size_t len) {
 if (__builtin_expect(((duk_size_t) (enc_ctx->buf_end - enc_ctx->ptr) >= len), 1)) {
  return;
 }
 duk__cbor_encode_ensure_slowpath(enc_ctx, len);
}

static duk_size_t duk__cbor_get_reserve(duk_cbor_encode_context *enc_ctx) {
 do { } while (0);
 do { } while (0);
 return (duk_size_t) (enc_ctx->buf_end - enc_ctx->ptr);
}

static void duk__cbor_encode_uint32(duk_cbor_encode_context *enc_ctx, duk_uint32_t u, duk_uint8_t base) {
 duk_uint8_t *p;


 do { } while (0);

 p = enc_ctx->ptr;
 if (__builtin_expect((u <= 23U), 1)) {
  *p++ = (duk_uint8_t) (base + (duk_uint8_t) u);
 } else if (u <= 0xffUL) {
  *p++ = base + 0x18U;
  *p++ = (duk_uint8_t) u;
 } else if (u <= 0xffffUL) {
  *p++ = base + 0x19U;
  duk_raw_writeinc_u16_be(&(p), (duk_uint16_t) ((duk_uint16_t) u));
 } else {
  *p++ = base + 0x1aU;
  duk_raw_writeinc_u32_be(&(p), (duk_uint32_t) (u));
 }
 enc_ctx->ptr = p;
}
# 198 "duk_bi_cbor.c"
static void duk__cbor_encode_double_fp(duk_cbor_encode_context *enc_ctx, double d) {
 duk_double_union u;
 duk_uint16_t u16;
 duk_int16_t expt;
 duk_uint8_t *p;

 do { } while (0);


 do { } while (0);


 u.d = d;
 duk_dblunion_host_to_little(&u);







 u16 = (((duk_uint16_t) u.uc[7]) << 8) | ((duk_uint16_t) u.uc[6]);
 expt = (duk_int16_t) ((u16 & 0x7ff0U) >> 4) - 1023;

 if (expt >= -14 && expt <= 15) {






  duk_bool_t use_half_float;

  use_half_float =
      (u.uc[0] == 0 && u.uc[1] == 0 && u.uc[2] == 0 && u.uc[3] == 0 && u.uc[4] == 0 && (u.uc[5] & 0x03U) == 0);

  if (use_half_float) {
   duk_uint32_t t;

   expt += 15;
   t = (duk_uint32_t) (u.uc[7] & 0x80U) << 8;
   t += (duk_uint32_t) expt << 10;
   t += ((duk_uint32_t) u.uc[6] & 0x0fU) << 6;
   t += ((duk_uint32_t) u.uc[5]) >> 2;


   p = enc_ctx->ptr;
   *p++ = 0xf9U;
   duk_raw_writeinc_u16_be(&(p), (duk_uint16_t) ((duk_uint16_t) t));
   enc_ctx->ptr = p;
   return;
  }
 }


 if (expt >= -126 && expt <= 127) {





  duk_bool_t use_float;
  duk_float_t d_float;
# 271 "duk_bi_cbor.c"
  d_float = (duk_float_t) d;
  use_float = duk_double_equals((duk_double_t) d_float, d);
  if (use_float) {
   p = enc_ctx->ptr;
   *p++ = 0xfaU;
   duk_raw_writeinc_float_be(&(p), (duk_float_t) (d_float));
   enc_ctx->ptr = p;
   return;
  }
 }




 if (expt == 1024) {
  do { } while (0);
  p = enc_ctx->ptr;
  *p++ = 0xf9U;
  if (
# 289 "duk_bi_cbor.c" 3 4
     __builtin_isnan (
# 289 "duk_bi_cbor.c"
     d
# 289 "duk_bi_cbor.c" 3 4
     )
# 289 "duk_bi_cbor.c"
                 ) {






   *p++ = 0x7eU;
  } else {

   if (
# 299 "duk_bi_cbor.c" 3 4
      __builtin_signbit (
# 299 "duk_bi_cbor.c"
      d
# 299 "duk_bi_cbor.c" 3 4
      )
# 299 "duk_bi_cbor.c"
                    ) {
    *p++ = 0xfcU;
   } else {
    *p++ = 0x7cU;
   }
  }
  *p++ = 0x00U;
  enc_ctx->ptr = p;
  return;
 }


 p = enc_ctx->ptr;
 *p++ = 0xfbU;
 duk_raw_writeinc_double_be(&(p), (duk_double_t) (d));
 enc_ctx->ptr = p;
}

static void duk__cbor_encode_double(duk_cbor_encode_context *enc_ctx, double d) {
 duk_uint8_t *p;
 double d_floor;
# 379 "duk_bi_cbor.c"
 do { } while (0);




 d_floor = floor(d);
 if (__builtin_expect((duk_double_equals(d_floor, d) != 0), 1)) {
  do { } while (0);
  if (
# 387 "duk_bi_cbor.c" 3 4
     __builtin_signbit (
# 387 "duk_bi_cbor.c"
     d
# 387 "duk_bi_cbor.c" 3 4
     )
# 387 "duk_bi_cbor.c"
                   ) {
   if (d >= -4294967296.0) {
    d = -1.0 - d;
    if (d >= 0.0) {
     do { } while (0);
     duk__cbor_encode_uint32(enc_ctx, duk__cbor_double_to_uint32(d), 0x20U);
     return;
    }




    p = enc_ctx->ptr;
    *p++ = 0xf9U;
    *p++ = 0x80U;
    *p++ = 0x00U;
    enc_ctx->ptr = p;
    return;
   }
  } else {
   if (d <= 4294967295.0) {

    do { } while (0);
    duk__cbor_encode_uint32(enc_ctx, duk__cbor_double_to_uint32(d), 0x00U);
    return;
   }
  }
 }







 do { } while (0);
 duk__cbor_encode_double_fp(enc_ctx, d);
}


static void duk__cbor_encode_string_top(duk_cbor_encode_context *enc_ctx) {
 const duk_uint8_t *str;
 duk_size_t len;
 duk_uint8_t *p;
# 453 "duk_bi_cbor.c"
 do { } while (0);

 str = (const duk_uint8_t *) duk_require_lstring(enc_ctx->thr, -1, &len);
 if (duk_is_symbol(enc_ctx->thr, -1)) {







  p = enc_ctx->ptr;
  *p++ = 0xa0U;
  enc_ctx->ptr = p;
  return;
 }

 duk__cbor_encode_sizet_uint32_check(enc_ctx, len);





 duk__cbor_encode_uint32(enc_ctx,
                         (duk_uint32_t) len,
                         (__builtin_expect((duk_unicode_is_utf8_compatible(str, len) != 0), 1) ? 0x60U : 0x40U));

 duk__cbor_encode_ensure(enc_ctx, len);
 p = enc_ctx->ptr;
 do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) str); duk_size_t duk__len = (len); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 p += len;
 enc_ctx->ptr = p;
}

static void duk__cbor_encode_object(duk_cbor_encode_context *enc_ctx) {
 duk_uint8_t *buf;
 duk_size_t len;
 duk_uint8_t *p;
 duk_size_t i;
 duk_size_t off_ib;
 duk_uint32_t count;


 do { } while (0);

 duk__cbor_encode_objarr_entry(enc_ctx);


 if (duk_is_array(enc_ctx->thr, -1)) {





  len = duk_get_length(enc_ctx->thr, -1);
  duk__cbor_encode_sizet_uint32_check(enc_ctx, len);
  duk__cbor_encode_uint32(enc_ctx, (duk_uint32_t) len, 0x80U);
  for (i = 0; i < len; i++) {
   duk_get_prop_index(enc_ctx->thr, -1, (duk_uarridx_t) i);
   duk__cbor_encode_value(enc_ctx);
  }
 } else if (duk_is_buffer_data(enc_ctx->thr, -1)) {




  buf = (duk_uint8_t *) duk_require_buffer_data(enc_ctx->thr, -1, &len);
  duk__cbor_encode_sizet_uint32_check(enc_ctx, len);
  duk__cbor_encode_uint32(enc_ctx, (duk_uint32_t) len, 0x40U);
  duk__cbor_encode_ensure(enc_ctx, len);
  p = enc_ctx->ptr;
  do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) buf); duk_size_t duk__len = (len); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0);
  p += len;
  enc_ctx->ptr = p;
 } else {
# 537 "duk_bi_cbor.c"
  off_ib = (duk_size_t) (enc_ctx->ptr - enc_ctx->buf);
  count = 0U;
  p = enc_ctx->ptr;
  *p++ = 0xa0U + 0x1fU;
  enc_ctx->ptr = p;
  duk_enum(enc_ctx->thr, -1, (1U << 4));
  while (duk_next(enc_ctx->thr, -1, 1 )) {
   duk_insert(enc_ctx->thr, -2);
   duk__cbor_encode_value(enc_ctx);
   duk__cbor_encode_value(enc_ctx);
   count++;
   if (count == 0U) {
    duk__cbor_encode_error(enc_ctx);
   }
  }
  duk_pop(enc_ctx->thr);
  if (count <= 0x17U) {
   do { } while (0);
   enc_ctx->buf[off_ib] = 0xa0U + (duk_uint8_t) count;
  } else {
   duk__cbor_encode_ensure(enc_ctx, 1);
   p = enc_ctx->ptr;
   *p++ = 0xffU;
   enc_ctx->ptr = p;
  }
 }

 duk__cbor_encode_objarr_exit(enc_ctx);
}

static void duk__cbor_encode_buffer(duk_cbor_encode_context *enc_ctx) {
 duk_uint8_t *buf;
 duk_size_t len;
 duk_uint8_t *p;


 do { } while (0);


 buf = (duk_uint8_t *) duk_require_buffer(enc_ctx->thr, -1, &len);
 duk__cbor_encode_sizet_uint32_check(enc_ctx, len);
 duk__cbor_encode_uint32(enc_ctx, (duk_uint32_t) len, 0x40U);
 duk__cbor_encode_ensure(enc_ctx, len);
 p = enc_ctx->ptr;
 do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) buf); duk_size_t duk__len = (len); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0);
 p += len;
 enc_ctx->ptr = p;
}

static void duk__cbor_encode_pointer(duk_cbor_encode_context *enc_ctx) {
# 600 "duk_bi_cbor.c"
 const char *ptr;

 ptr = duk_to_string(enc_ctx->thr, -1);
 do { } while (0);
 duk_push_sprintf(enc_ctx->thr, "(%s)", ptr);
 duk_remove(enc_ctx->thr, -2);
 duk__cbor_encode_string_top(enc_ctx);
}

static void duk__cbor_encode_lightfunc(duk_cbor_encode_context *enc_ctx) {
 duk_uint8_t *p;


 do { } while (0);


 p = enc_ctx->ptr;
 *p++ = 0xa0U;
 enc_ctx->ptr = p;
}

static void duk__cbor_encode_value(duk_cbor_encode_context *enc_ctx) {
 duk_uint8_t *p;
# 633 "duk_bi_cbor.c"
 duk__cbor_encode_ensure(enc_ctx, 1 + 8);

 switch (duk_get_type(enc_ctx->thr, -1)) {
 case 1U: {
  p = enc_ctx->ptr;
  *p++ = 0xf7;
  enc_ctx->ptr = p;
  break;
 }
 case 2U: {
  p = enc_ctx->ptr;
  *p++ = 0xf6;
  enc_ctx->ptr = p;
  break;
 }
 case 3U: {
  duk_uint8_t u8 = duk_get_boolean(enc_ctx->thr, -1) ? 0xf5U : 0xf4U;
  p = enc_ctx->ptr;
  *p++ = u8;
  enc_ctx->ptr = p;
  break;
 }
 case 4U: {
  duk__cbor_encode_double(enc_ctx, duk_get_number(enc_ctx->thr, -1));
  break;
 }
 case 5U: {
  duk__cbor_encode_string_top(enc_ctx);
  break;
 }
 case 6U: {
  duk__cbor_encode_object(enc_ctx);
  break;
 }
 case 7U: {
  duk__cbor_encode_buffer(enc_ctx);
  break;
 }
 case 8U: {
  duk__cbor_encode_pointer(enc_ctx);
  break;
 }
 case 9U: {
  duk__cbor_encode_lightfunc(enc_ctx);
  break;
 }
 case 0U:
 default:
  goto fail;
 }

 duk_pop(enc_ctx->thr);
 return;

fail:
 duk__cbor_encode_error(enc_ctx);
}





static void duk__cbor_decode_error(duk_cbor_decode_context *dec_ctx) {
 (void) (duk_error_raw((dec_ctx->thr), (duk_errcode_t) 6, (const char *) ("duk_bi_cbor.c"), (duk_int_t) (696), "cbor decode error"), (duk_ret_t) 0);
}

static void duk__cbor_decode_req_stack(duk_cbor_decode_context *dec_ctx) {
 duk_require_stack(dec_ctx->thr, 4);
}

static void duk__cbor_decode_objarr_entry(duk_cbor_decode_context *dec_ctx) {
 duk_hthread *thr = dec_ctx->thr;


 duk_native_stack_check(thr);

 duk__cbor_decode_req_stack(dec_ctx);

 do { } while (0);
 if (dec_ctx->recursion_depth >= dec_ctx->recursion_limit) {
  do { duk_err_range((thr), "duk_bi_cbor.c", (duk_int_t) 713, ("decode recursion limit")); } while (0);
  do { return; } while (0);
 }
 dec_ctx->recursion_depth++;
}

static void duk__cbor_decode_objarr_exit(duk_cbor_decode_context *dec_ctx) {
 do { } while (0);
 dec_ctx->recursion_depth--;
}

static duk_uint8_t duk__cbor_decode_readbyte(duk_cbor_decode_context *dec_ctx) {
 do { } while (0);
 if (__builtin_expect((dec_ctx->len - dec_ctx->off < 1U), 0)) {
  duk__cbor_decode_error(dec_ctx);
 }
 return dec_ctx->buf[dec_ctx->off++];
}

static duk_uint16_t duk__cbor_decode_read_u16(duk_cbor_decode_context *dec_ctx) {
 duk_uint16_t res;

 do { } while (0);
 if (__builtin_expect((dec_ctx->len - dec_ctx->off < 2U), 0)) {
  duk__cbor_decode_error(dec_ctx);
 }
 res = duk_raw_read_u16_be((dec_ctx->buf + dec_ctx->off));;
 dec_ctx->off += 2;
 return res;
}

static duk_uint32_t duk__cbor_decode_read_u32(duk_cbor_decode_context *dec_ctx) {
 duk_uint32_t res;

 do { } while (0);
 if (__builtin_expect((dec_ctx->len - dec_ctx->off < 4U), 0)) {
  duk__cbor_decode_error(dec_ctx);
 }
 res = duk_raw_read_u32_be((dec_ctx->buf + dec_ctx->off));;
 dec_ctx->off += 4;
 return res;
}

static duk_uint8_t duk__cbor_decode_peekbyte(duk_cbor_decode_context *dec_ctx) {
 if (__builtin_expect((dec_ctx->off >= dec_ctx->len), 0)) {
  duk__cbor_decode_error(dec_ctx);
 }
 return dec_ctx->buf[dec_ctx->off];
}

static void duk__cbor_decode_rewind(duk_cbor_decode_context *dec_ctx, duk_size_t len) {
 do { } while (0);
 dec_ctx->off -= len;
}
# 776 "duk_bi_cbor.c"
static const duk_uint8_t *duk__cbor_decode_consume(duk_cbor_decode_context *dec_ctx, duk_size_t len) {
 do { } while (0);
 if (__builtin_expect((dec_ctx->len - dec_ctx->off >= len), 1)) {
  const duk_uint8_t *res = dec_ctx->buf + dec_ctx->off;
  dec_ctx->off += len;
  return res;
 }

 duk__cbor_decode_error(dec_ctx);
 return 
# 785 "duk_bi_cbor.c" 3 4
       ((void *)0)
# 785 "duk_bi_cbor.c"
           ;
}

static int duk__cbor_decode_checkbreak(duk_cbor_decode_context *dec_ctx) {
 if (duk__cbor_decode_peekbyte(dec_ctx) == 0xffU) {
  do { } while (0);
  dec_ctx->off++;



  return 1;
 }
 return 0;
}

static void duk__cbor_decode_push_aival_int(duk_cbor_decode_context *dec_ctx, duk_uint8_t ib, duk_bool_t negative) {
 duk_uint8_t ai;
 duk_uint32_t t, t1, t2;



 duk_double_t d1, d2;
 duk_double_t d;

 ai = ib & 0x1fU;
 if (ai <= 0x17U) {
  t = ai;
  goto shared_exit;
 }

 switch (ai) {
 case 0x18U:
  t = (duk_uint32_t) duk__cbor_decode_readbyte(dec_ctx);
  goto shared_exit;
 case 0x19U:
  t = (duk_uint32_t) duk__cbor_decode_read_u16(dec_ctx);
  goto shared_exit;
 case 0x1aU:
  t = (duk_uint32_t) duk__cbor_decode_read_u32(dec_ctx);
  goto shared_exit;
 case 0x1bU:




  t = (duk_uint32_t) duk__cbor_decode_read_u32(dec_ctx);
  t2 = t;
  t = (duk_uint32_t) duk__cbor_decode_read_u32(dec_ctx);
  t1 = t;
# 882 "duk_bi_cbor.c"
  d1 = (duk_double_t) t1;
  d2 = (duk_double_t) t2 * 4294967296.0;
  if (negative) {
   d1 += 1.0;
  }
  d = d2 + d1;
  if (negative) {
   d = -d;
  }


  duk_push_number(dec_ctx->thr, d);
  return;
 }

 duk__cbor_decode_error(dec_ctx);
 return;

shared_exit:
 if (negative) {

  if ((duk_uint_t) t <= (duk_uint_t) - (
# 903 "duk_bi_cbor.c" 3 4
                                       (-0x7fffffff - 1) 
# 903 "duk_bi_cbor.c"
                                                   + 1)) {
   duk_push_int(dec_ctx->thr, -1 - ((duk_int_t) t));
  } else {
   duk_push_number(dec_ctx->thr, -1.0 - (duk_double_t) t);
  }
 } else {
  duk_push_uint(dec_ctx->thr, (duk_uint_t) t);
 }
}

static void duk__cbor_decode_skip_aival_int(duk_cbor_decode_context *dec_ctx, duk_uint8_t ib) {
 const duk_int8_t skips[32] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                         0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 4, 8, -1, -1, -1, -1 };
 duk_uint8_t ai;
 duk_int8_t skip;

 ai = ib & 0x1fU;
 skip = skips[ai];
 if (__builtin_expect((skip < 0), 0)) {
  duk__cbor_decode_error(dec_ctx);
 }
 duk__cbor_decode_consume(dec_ctx, (duk_size_t) skip);
 return;
}

static duk_uint32_t duk__cbor_decode_aival_uint32(duk_cbor_decode_context *dec_ctx, duk_uint8_t ib) {
 duk_uint8_t ai;
 duk_uint32_t t;

 ai = ib & 0x1fU;
 if (ai <= 0x17U) {
  return (duk_uint32_t) ai;
 }

 switch (ai) {
 case 0x18U:
  t = (duk_uint32_t) duk__cbor_decode_readbyte(dec_ctx);
  return t;
 case 0x19U:
  t = (duk_uint32_t) duk__cbor_decode_read_u16(dec_ctx);
  return t;
 case 0x1aU:
  t = (duk_uint32_t) duk__cbor_decode_read_u32(dec_ctx);
  return t;
 case 0x1bU:
  t = (duk_uint32_t) duk__cbor_decode_read_u32(dec_ctx);
  if (t != 0U) {
   break;
  }
  t = (duk_uint32_t) duk__cbor_decode_read_u32(dec_ctx);
  return t;
 }

 duk__cbor_decode_error(dec_ctx);
 return 0U;
}

static void duk__cbor_decode_buffer(duk_cbor_decode_context *dec_ctx, duk_uint8_t expected_base) {
 duk_uint32_t len;
 duk_uint8_t *buf;
 const duk_uint8_t *inp;
 duk_uint8_t ib;

 ib = duk__cbor_decode_readbyte(dec_ctx);
 if ((ib & 0xe0U) != expected_base) {
  duk__cbor_decode_error(dec_ctx);
 }

 len = duk__cbor_decode_aival_uint32(dec_ctx, ib);
 inp = duk__cbor_decode_consume(dec_ctx, len);

 buf = (duk_uint8_t *) duk_push_buffer_raw((dec_ctx->thr), ((duk_size_t) len), 0 );
 do { void *duk__dst = ((void *) buf); const void *duk__src = ((const void *) inp); duk_size_t duk__len = ((size_t) len); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
}

static void duk__cbor_decode_join_buffers(duk_cbor_decode_context *dec_ctx, duk_idx_t count) {
 duk_size_t total_size = 0;
 duk_idx_t top = duk_get_top(dec_ctx->thr);
 duk_idx_t base = top - count;
 duk_idx_t idx;
 duk_uint8_t *p = 
# 983 "duk_bi_cbor.c" 3 4
                 ((void *)0)
# 983 "duk_bi_cbor.c"
                     ;

 do { } while (0);
 do { } while (0);

 for (;;) {



  for (idx = base; idx < top; idx++) {
   duk_uint8_t *buf_data;
   duk_size_t buf_size;

   buf_data = (duk_uint8_t *) duk_require_buffer(dec_ctx->thr, idx, &buf_size);
   if (p != 
# 997 "duk_bi_cbor.c" 3 4
           ((void *)0)
# 997 "duk_bi_cbor.c"
               ) {
    do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) buf_data); duk_size_t duk__len = (buf_size); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0);
    p += buf_size;
   } else {
    total_size += buf_size;
    if (__builtin_expect((total_size < buf_size), 0)) {
     duk__cbor_decode_error(dec_ctx);
    }
   }
  }

  if (p != 
# 1008 "duk_bi_cbor.c" 3 4
          ((void *)0)
# 1008 "duk_bi_cbor.c"
              ) {
   break;
  } else {
   p = (duk_uint8_t *) duk_push_buffer_raw((dec_ctx->thr), (total_size), 0 );
   do { } while (0);
  }
 }

 duk_replace(dec_ctx->thr, base);
 duk_pop_n(dec_ctx->thr, count - 1);
}

static void duk__cbor_decode_and_join_strbuf(duk_cbor_decode_context *dec_ctx, duk_uint8_t expected_base) {
 duk_idx_t count = 0;
 for (;;) {
  if (duk__cbor_decode_checkbreak(dec_ctx)) {
   break;
  }
  duk_require_stack(dec_ctx->thr, 1);
  duk__cbor_decode_buffer(dec_ctx, expected_base);
  count++;
  if (__builtin_expect((count <= 0), 0)) {
   duk__cbor_decode_error(dec_ctx);
  }
 }
 if (count == 0) {
  (void) duk_push_buffer_raw((dec_ctx->thr), (0), 0 );
 } else if (count > 1) {
  duk__cbor_decode_join_buffers(dec_ctx, count);
 }
}

static duk_double_t duk__cbor_decode_half_float(duk_cbor_decode_context *dec_ctx) {
 duk_double_union u;
 const duk_uint8_t *inp;
 duk_int_t expt;
 duk_uint_t u16;
 duk_uint_t tmp;
 duk_double_t res;

 inp = duk__cbor_decode_consume(dec_ctx, 2);
 u16 = ((duk_uint_t) inp[0] << 8) + (duk_uint_t) inp[1];
 expt = (duk_int_t) ((u16 >> 10) & 0x1fU) - 15;





 do { void *duk__dst = ((void *) &u); duk_size_t duk__len = (sizeof(u)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);

 if (expt == -15) {



  if ((u16 & 0x03ffU) == 0) {
   u.uc[7] = inp[0] & 0x80U;
  } else {
# 1075 "duk_bi_cbor.c"
   u.uc[7] = 0x3fU;
   u.uc[6] = 0x10U + (duk_uint8_t) ((u16 >> 6) & 0x0fU);
   u.uc[5] = (duk_uint8_t) ((u16 << 2) & 0xffU);

   duk_dblunion_little_to_host(&u);
   res = u.d - 0.00006103515625;
   if (u16 & 0x8000U) {
    res = -res;
   }
   return res;
  }
 } else if (expt == 16) {

  if ((u16 & 0x03ffU) == 0) {
   u.uc[7] = (inp[0] & 0x80U) + 0x7fU;
   u.uc[6] = 0xf0U;
  } else {





   u.uc[7] = (inp[0] & 0x80U) + 0x7fU;
   u.uc[6] = 0xf8U;
  }
 } else {

  tmp = (inp[0] & 0x80U) ? 0x80000000UL : 0UL;
  tmp += (duk_uint_t) (expt + 1023) << 20;
  tmp += (duk_uint_t) (inp[0] & 0x03U) << 18;
  tmp += (duk_uint_t) (inp[1] & 0xffU) << 10;
  u.uc[7] = (tmp >> 24) & 0xffU;
  u.uc[6] = (tmp >> 16) & 0xffU;
  u.uc[5] = (tmp >> 8) & 0xffU;
  u.uc[4] = (tmp >> 0) & 0xffU;
 }

 duk_dblunion_little_to_host(&u);
 return u.d;
}

static void duk__cbor_decode_string(duk_cbor_decode_context *dec_ctx, duk_uint8_t ib, duk_uint8_t ai) {
# 1134 "duk_bi_cbor.c"
 if (ai == 0x1fU) {
  duk_uint8_t *buf_data;
  duk_size_t buf_size;

  duk__cbor_decode_and_join_strbuf(dec_ctx, 0x60U);
  buf_data = (duk_uint8_t *) duk_require_buffer(dec_ctx->thr, -1, &buf_size);
  (void) duk_push_lstring(dec_ctx->thr, (const char *) buf_data, buf_size);
  duk_remove(dec_ctx->thr, -2);
 } else {
  duk_uint32_t len;
  const duk_uint8_t *inp;

  len = duk__cbor_decode_aival_uint32(dec_ctx, ib);
  inp = duk__cbor_decode_consume(dec_ctx, len);
  (void) duk_push_lstring(dec_ctx->thr, (const char *) inp, (duk_size_t) len);
 }
 if (duk_is_symbol(dec_ctx->thr, -1)) {

  duk__cbor_decode_error(dec_ctx);
 }




}

static duk_bool_t duk__cbor_decode_array(duk_cbor_decode_context *dec_ctx, duk_uint8_t ib, duk_uint8_t ai) {
 duk_uint32_t idx, len;

 duk__cbor_decode_objarr_entry(dec_ctx);




 if (ai == 0x1fU) {
  len = 0xffffffffUL;
 } else {
  len = duk__cbor_decode_aival_uint32(dec_ctx, ib);
  if (len == 0xffffffffUL) {
   goto failure;
  }
 }


 duk_push_array(dec_ctx->thr);
 for (idx = 0U;;) {
  if (len == 0xffffffffUL && duk__cbor_decode_checkbreak(dec_ctx)) {
   break;
  }
  if (idx == len) {
   if (ai == 0x1fU) {
    goto failure;
   }
   break;
  }
  duk__cbor_decode_value(dec_ctx);
  duk_put_prop_index(dec_ctx->thr, -2, (duk_uarridx_t) idx);
  idx++;
  if (idx == 0U) {
   goto failure;
  }
 }




 duk__cbor_decode_objarr_exit(dec_ctx);
 return 1;

failure:

 return 0;
}

static duk_bool_t duk__cbor_decode_map(duk_cbor_decode_context *dec_ctx, duk_uint8_t ib, duk_uint8_t ai) {
 duk_uint32_t count;

 duk__cbor_decode_objarr_entry(dec_ctx);

 if (ai == 0x1fU) {
  count = 0xffffffffUL;
 } else {
  count = duk__cbor_decode_aival_uint32(dec_ctx, ib);
  if (count == 0xffffffffUL) {
   goto failure;
  }
 }


 duk_push_object(dec_ctx->thr);
 for (;;) {
  if (count == 0xffffffffUL) {
   if (duk__cbor_decode_checkbreak(dec_ctx)) {
    break;
   }
  } else {
   if (count == 0UL) {
    break;
   }
   count--;
  }
# 1244 "duk_bi_cbor.c"
  duk__cbor_decode_value(dec_ctx);
  duk__cbor_decode_value(dec_ctx);
  duk_put_prop(dec_ctx->thr, -3);
 }




 duk__cbor_decode_objarr_exit(dec_ctx);
 return 1;

failure:

 return 0;
}

static duk_double_t duk__cbor_decode_float(duk_cbor_decode_context *dec_ctx) {
 duk_float_union u;
 const duk_uint8_t *inp;
 inp = duk__cbor_decode_consume(dec_ctx, 4);
 do { void *duk__dst = ((void *) u.uc); const void *duk__src = ((const void *) inp); duk_size_t duk__len = (4); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 duk_fltunion_big_to_host(&u);
 return (duk_double_t) u.f;
}

static duk_double_t duk__cbor_decode_double(duk_cbor_decode_context *dec_ctx) {
 duk_double_union u;
 const duk_uint8_t *inp;
 inp = duk__cbor_decode_consume(dec_ctx, 8);
 do { void *duk__dst = ((void *) u.uc); const void *duk__src = ((const void *) inp); duk_size_t duk__len = (8); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 duk_dblunion_big_to_host(&u);
 return u.d;
}
# 1671 "duk_bi_cbor.c"
static void duk__cbor_decode_value(duk_cbor_decode_context *dec_ctx) {
 duk_uint8_t ib, mt, ai;






reread_initial_byte:
 do { } while (0);

 ib = duk__cbor_decode_readbyte(dec_ctx);
 mt = ib >> 5U;
 ai = ib & 0x1fU;
# 1694 "duk_bi_cbor.c"
 switch (mt) {
 case 0U: {
  duk__cbor_decode_push_aival_int(dec_ctx, ib, 0 );
  break;
 }
 case 1U: {
  duk__cbor_decode_push_aival_int(dec_ctx, ib, 1 );
  break;
 }
 case 2U: {
  if (ai == 0x1fU) {
   duk__cbor_decode_and_join_strbuf(dec_ctx, 0x40U);
  } else {
   duk__cbor_decode_rewind(dec_ctx, 1U);
   duk__cbor_decode_buffer(dec_ctx, 0x40U);
  }
  break;
 }
 case 3U: {
  duk__cbor_decode_string(dec_ctx, ib, ai);
  break;
 }
 case 4U: {
  if (__builtin_expect((duk__cbor_decode_array(dec_ctx, ib, ai) == 0), 0)) {
   goto format_error;
  }
  break;
 }
 case 5U: {
  if (__builtin_expect((duk__cbor_decode_map(dec_ctx, ib, ai) == 0), 0)) {
   goto format_error;
  }
  break;
 }
 case 6U: {




  duk__cbor_decode_skip_aival_int(dec_ctx, ib);
  goto reread_initial_byte;
 }
 case 7U: {
  switch (ai) {
  case 0x14U: {
   duk_push_false(dec_ctx->thr);
   break;
  }
  case 0x15U: {
   duk_push_true(dec_ctx->thr);
   break;
  }
  case 0x16U: {
   duk_push_null(dec_ctx->thr);
   break;
  }
  case 0x17U: {
   duk_push_undefined(dec_ctx->thr);
   break;
  }
  case 0x18U: {
# 1763 "duk_bi_cbor.c"
   goto format_error;
  }
  case 0x19U: {
   duk_double_t d;
   d = duk__cbor_decode_half_float(dec_ctx);
   duk_push_number(dec_ctx->thr, d);
   break;
  }
  case 0x1aU: {
   duk_double_t d;
   d = duk__cbor_decode_float(dec_ctx);
   duk_push_number(dec_ctx->thr, d);
   break;
  }
  case 0x1bU: {
   duk_double_t d;
   d = duk__cbor_decode_double(dec_ctx);
   duk_push_number(dec_ctx->thr, d);
   break;
  }
  case 0xffU:
  default: {
   goto format_error;
  }
  }
  break;
 }
 default: {
  goto format_error;
 }
 }

 return;

format_error:
 duk__cbor_decode_error(dec_ctx);
}


static void duk__cbor_encode(duk_hthread *thr, duk_idx_t idx, duk_uint_t encode_flags) {
 duk_cbor_encode_context enc_ctx;
 duk_uint8_t *buf;

 do { (void) (encode_flags); } while (0);

 idx = duk_require_normalize_index(thr, idx);

 enc_ctx.thr = thr;
 enc_ctx.idx_buf = duk_get_top(thr);

 enc_ctx.len = 64;
 buf = (duk_uint8_t *) duk_push_buffer_raw((thr), (enc_ctx.len), (1 << 0) );
 enc_ctx.ptr = buf;
 enc_ctx.buf = buf;
 enc_ctx.buf_end = buf + enc_ctx.len;

 enc_ctx.recursion_depth = 0;
 enc_ctx.recursion_limit = 1000;

 duk_dup(thr, idx);
 duk__cbor_encode_req_stack(&enc_ctx);
 duk__cbor_encode_value(&enc_ctx);
 do { } while (0);
 duk_resize_buffer(enc_ctx.thr, enc_ctx.idx_buf, (duk_size_t) (enc_ctx.ptr - enc_ctx.buf));
 duk_replace(thr, idx);
}

static void duk__cbor_decode(duk_hthread *thr, duk_idx_t idx, duk_uint_t decode_flags) {
 duk_cbor_decode_context dec_ctx;

 do { (void) (decode_flags); } while (0);




 do { (void) (duk__cbor_get_reserve); } while (0);

 idx = duk_require_normalize_index(thr, idx);

 dec_ctx.thr = thr;
 dec_ctx.buf = (const duk_uint8_t *) duk_require_buffer_data(thr, idx, &dec_ctx.len);
 dec_ctx.off = 0;


 dec_ctx.recursion_depth = 0;
 dec_ctx.recursion_limit = 1000;

 duk__cbor_decode_req_stack(&dec_ctx);
 duk__cbor_decode_value(&dec_ctx);
 do { } while (0);
 if (dec_ctx.off != dec_ctx.len) {
  (void) (duk_error_raw((thr), (duk_errcode_t) 6, (const char *) ("duk_bi_cbor.c"), (duk_int_t) (1854), "trailing garbage"), (duk_ret_t) 0);
 }

 duk_replace(thr, idx);
}
# 1880 "duk_bi_cbor.c"
__attribute__ ((visibility("default"))) void duk_cbor_encode(duk_hthread *thr, duk_idx_t idx, duk_uint_t encode_flags) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 duk__cbor_encode(thr, idx, encode_flags);
}
__attribute__ ((visibility("default"))) void duk_cbor_decode(duk_hthread *thr, duk_idx_t idx, duk_uint_t decode_flags) {
 do { do { } while (0); do { } while (0); do { } while (0); } while (0);
 duk__cbor_decode(thr, idx, decode_flags);
}



static __attribute__ ((unused)) duk_ret_t duk_bi_cbor_encode(duk_hthread *thr) {
 do { } while (0);

 duk__cbor_encode(thr, -1, 0 );





 (void) duk_get_prop_stridx(thr, -1, 86);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_cbor_decode(duk_hthread *thr) {
 do { } while (0);

 duk__cbor_decode(thr, -1, 0 );
 return 1;
}
# 1 "duk_bi_date.c"
# 22 "duk_bi_date.c"
static duk_double_t duk__push_this_get_timeval_tzoffset(duk_hthread *thr, duk_small_uint_t flags, duk_int_t *out_tzoffset);
static duk_double_t duk__push_this_get_timeval(duk_hthread *thr, duk_small_uint_t flags);
static void duk__twodigit_year_fixup(duk_hthread *thr, duk_idx_t idx_val);
static duk_ret_t duk__set_this_timeval_from_dparts(duk_hthread *thr, duk_double_t *dparts, duk_small_uint_t flags);
# 83 "duk_bi_date.c"
static duk_uint8_t duk__date_equivyear[14] = {






 ((duk_uint8_t) ((2023) -1970)),
 ((duk_uint8_t) ((2035) -1970)),
 ((duk_uint8_t) ((2019) -1970)),
 ((duk_uint8_t) ((2031) -1970)),
 ((duk_uint8_t) ((2015) -1970)),
 ((duk_uint8_t) ((2027) -1970)),
 ((duk_uint8_t) ((2011) -1970)),


 ((duk_uint8_t) ((2012) -1970)),
 ((duk_uint8_t) ((2024) -1970)),
 ((duk_uint8_t) ((2008) -1970)),
 ((duk_uint8_t) ((2020) -1970)),
 ((duk_uint8_t) ((2032) -1970)),
 ((duk_uint8_t) ((2016) -1970)),
 ((duk_uint8_t) ((2028) -1970))
# 121 "duk_bi_date.c"
};
# 190 "duk_bi_date.c"
static const duk_uint8_t duk__parse_iso8601_seps[] = {
 0x2b , 0x2d , 0x54 , 0x20 ,
 0x3a , 0x2e , 0x5a , 0x00
};


static const duk_uint32_t duk__parse_iso8601_control[] = {
 ((duk_uint32_t) ((1 << 0)) + (((duk_uint32_t) ((1 << 1))) << 9) + (((duk_uint32_t) (1)) << 17) + (((duk_uint32_t) (0)) << 21)),
 ((duk_uint32_t) ((1 << 1)) + (((duk_uint32_t) ((1 << 1))) << 9) + (((duk_uint32_t) (2)) << 17) + (((duk_uint32_t) (0)) << 21)),
 ((duk_uint32_t) ((1 << 0) | (1 << 1) | (1 << 2)) + (((duk_uint32_t) ((1 << 2) | (1 << 3))) << 9) + (((duk_uint32_t) (3)) << 17) + (((duk_uint32_t) (0)) << 21)),
 ((duk_uint32_t) ((1 << 3)) + (((duk_uint32_t) ((1 << 4))) << 9) + (((duk_uint32_t) (4)) << 17) + (((duk_uint32_t) (0)) << 21)),
 ((duk_uint32_t) ((1 << 4)) + (((duk_uint32_t) ((1 << 4))) << 9) + (((duk_uint32_t) (5)) << 17) + (((duk_uint32_t) (0)) << 21)),
 ((duk_uint32_t) ((1 << 5)) + (((duk_uint32_t) ((1 << 5))) << 9) + (((duk_uint32_t) (6)) << 17) + (((duk_uint32_t) (0)) << 21)),
 ((duk_uint32_t) ((1 << 7)) + (((duk_uint32_t) ((1 << 4))) << 9) + (((duk_uint32_t) (8)) << 17) + (((duk_uint32_t) (0)) << 21)),
 ((duk_uint32_t) ((1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5) | (1 << 6)) + (((duk_uint32_t) ((1 << 0))) << 9) + (((duk_uint32_t) (7)) << 17) + (((duk_uint32_t) (0)) << 21))



                  ,
 ((duk_uint32_t) ((1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5) | (1 << 6)) + (((duk_uint32_t) ((1 << 1))) << 9) + (((duk_uint32_t) (7)) << 17) + (((duk_uint32_t) ((1 << 0))) << 21))



                            ,
 ((duk_uint32_t) ((1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5) | (1 << 6)) + (((duk_uint32_t) ((1 << 6))) << 9) + (((duk_uint32_t) (0)) << 17) + (((duk_uint32_t) ((1 << 2))) << 21))



                                   ,
 ((duk_uint32_t) ((1 << 0) | (1 << 1) | (1 << 2) | (1 << 3) | (1 << 4) | (1 << 5) | (1 << 6) | (1 << 7) | (1 << 8)) + (((duk_uint32_t) ((1 << 7))) << 9) + (((duk_uint32_t) (0)) << 17) + (((duk_uint32_t) ((1 << 1))) << 21))
# 231 "duk_bi_date.c"
};

static duk_bool_t duk__parse_string_iso8601_subset(duk_hthread *thr, const char *str) {
 duk_int_t parts[9];
 duk_double_t dparts[8];
 duk_double_t d;
 const duk_uint8_t *p;
 duk_small_uint_t part_idx = 0;
 duk_int_t accum = 0;
 duk_small_uint_t ndigits = 0;
 duk_bool_t neg_year = 0;
 duk_bool_t neg_tzoffset = 0;
 duk_uint_fast8_t ch;
 duk_small_uint_t i;


 do { void *duk__dst = (parts); duk_size_t duk__len = (sizeof(parts)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 do { } while (0);
 parts[1] = 1;
 parts[2] = 1;


 p = (const duk_uint8_t *) str;
 ch = p[0];
 if (ch == 0x2b) {
  p++;
 } else if (ch == 0x2d) {
  neg_year = 1;
  p++;
 }

 for (;;) {
  ch = *p++;
  do { } while (0)


                                                                                   ;

  if (ch >= 0x30 && ch <= 0x39) {
   if (ndigits >= 9) {
    do { } while (0);
    goto reject;
   }
   if (part_idx == 6 && ndigits >= 3) {

   } else {
    accum = accum * 10 + ((duk_int_t) ch) - ((duk_int_t) 0x30) + 0x00;
    ndigits++;
   }
  } else {
   duk_uint_fast32_t match_val;
   duk_small_uint_t sep_idx;

   if (ndigits <= 0) {
    goto reject;
   }
   if (part_idx == 6) {

    while (ndigits < 3) {
     accum *= 10;
     ndigits++;
    }
   }
   parts[part_idx] = accum;
   do { } while (0);

   accum = 0;
   ndigits = 0;

   for (i = 0; i < (duk_small_uint_t) (sizeof(duk__parse_iso8601_seps) / sizeof(duk_uint8_t)); i++) {
    if (duk__parse_iso8601_seps[i] == ch) {
     break;
    }
   }
   if (i == (duk_small_uint_t) (sizeof(duk__parse_iso8601_seps) / sizeof(duk_uint8_t))) {
    do { } while (0);
    goto reject;
   }

   sep_idx = i;
   match_val = (1UL << part_idx) + (1UL << (sep_idx + 9));

   for (i = 0; i < (duk_small_uint_t) (sizeof(duk__parse_iso8601_control) / sizeof(duk_uint32_t)); i++) {
    duk_uint_fast32_t rule = duk__parse_iso8601_control[i];
    duk_small_uint_t nextpart;
    duk_small_uint_t cflags;

    do { } while (0)



                                               ;

    if ((rule & match_val) != match_val) {
     continue;
    }

    do { (nextpart) = (duk_small_uint_t) (((rule) >> 17) & 0x0f); (cflags) = (duk_small_uint_t) ((rule) >> 21); } while (0);

    do { } while (0)






                                                 ;

    if (cflags & (1 << 0)) {
     neg_tzoffset = 1;
    }

    if (cflags & (1 << 1)) {
     goto accept;
    }

    if (cflags & (1 << 2)) {
     do { } while (0);
     if (*p == 0x00) {
      goto accept;
     }
     goto reject;
    }

    part_idx = nextpart;
    break;
   }

   if (i == (duk_small_uint_t) (sizeof(duk__parse_iso8601_control) / sizeof(duk_uint32_t))) {
    do { } while (0);
    goto reject;
   }

   if (ch == 0) {



    do { } while (0);
    goto reject;
   }
  }
 }


 do { __builtin_unreachable(); } while (0);

reject:
 do { } while (0);
 return 0;

accept:
 do { } while (0);


 if (neg_year) {
  parts[0] = -parts[0];
 }
 if (neg_tzoffset) {
  parts[3] += parts[7];
  parts[4] += parts[8];
 } else {
  parts[3] -= parts[7];
  parts[4] -= parts[8];
 }
 parts[1] -= 1;
 parts[2] -= 1;
# 405 "duk_bi_date.c"
 for (i = 0; i < 8; i++) {
  do { } while (0);
  dparts[i] = parts[i];
 }

 d = duk_bi_date_get_timeval_from_dparts(dparts, 0 );
 duk_push_number(thr, d);
 return 1;
}
# 434 "duk_bi_date.c"
static duk_ret_t duk__parse_string(duk_hthread *thr, const char *str) {





 do { } while (0);
 do { } while (0);

 if (duk__parse_string_iso8601_subset(thr, str) != 0) {
  return 1;
 }







 if (duk_bi_date_parse_string_strptime((thr), (str)) != 0) {
  return 1;
 }




 duk_push_nan(thr);
 return 1;
}
# 473 "duk_bi_date.c"
static duk_uint8_t duk__days_in_month[12] = { (duk_uint8_t) 31, (duk_uint8_t) 28, (duk_uint8_t) 31, (duk_uint8_t) 30,
                                          (duk_uint8_t) 31, (duk_uint8_t) 30, (duk_uint8_t) 31, (duk_uint8_t) 31,
                                          (duk_uint8_t) 30, (duk_uint8_t) 31, (duk_uint8_t) 30, (duk_uint8_t) 31 };
# 490 "duk_bi_date.c"
static __attribute__ ((unused)) duk_bool_t duk_bi_date_is_leap_year(duk_int_t year) {
 if ((year % 4) != 0) {
  return 0;
 }
 if ((year % 100) != 0) {
  return 1;
 }
 if ((year % 400) != 0) {
  return 0;
 }
 return 1;
}

static __attribute__ ((unused)) duk_bool_t duk_bi_date_timeval_in_valid_range(duk_double_t x) {
 return (x >= -(8.64e15) && x <= (8.64e15));
}

static __attribute__ ((unused)) duk_bool_t duk_bi_date_timeval_in_leeway_range(duk_double_t x) {
 return (x >= -(8.64e15 + 24 * 3600e3) && x <= (8.64e15 + 24 * 3600e3));
}

static __attribute__ ((unused)) duk_bool_t duk_bi_date_year_in_valid_range(duk_double_t x) {
 return (x >= (-271821L) && x <= 275760L);
}

static duk_double_t duk__timeclip(duk_double_t x) {
 if (!
# 516 "duk_bi_date.c" 3 4
     __builtin_isfinite (
# 516 "duk_bi_date.c"
     x
# 516 "duk_bi_date.c" 3 4
     )
# 516 "duk_bi_date.c"
                    ) {
  return 
# 517 "duk_bi_date.c" 3 4
        (__builtin_nanf (""))
# 517 "duk_bi_date.c"
                      ;
 }

 if (!duk_bi_date_timeval_in_valid_range(x)) {
  return 
# 521 "duk_bi_date.c" 3 4
        (__builtin_nanf (""))
# 521 "duk_bi_date.c"
                      ;
 }

 x = duk_js_tointeger_number(x);


 return x;
}


static duk_int_t duk__div_floor(duk_int_t a, duk_int_t b) {
 do { } while (0);
 if (a >= 0) {
  return a / b;
 } else {




  return (a - b + 1) / b;
 }
}


static duk_int_t duk__day_from_year(duk_int_t year) {



 return 365 * (year - 1970) + duk__div_floor(year - 1969, 4) - duk__div_floor(year - 1901, 100) +
        duk__div_floor(year - 1601, 400);
}


static duk_int_t duk__year_from_day(duk_int_t day, duk_small_int_t *out_day_within_year) {
 duk_int_t year;
 duk_int_t diff_days;





 if (day >= 0) {
  year = 1970 + day / 365;
 } else {
  year = 1970 + day / 366;
 }

 for (;;) {
  diff_days = duk__day_from_year(year) - day;
  do { } while (0);
  if (diff_days <= 0) {
   do { } while (0);
   *out_day_within_year = -diff_days;
   do { } while (0);
   do { } while (0);
   do { } while (0);
   return year;
  }




  year -= 1 + (diff_days - 1) / 366;
 }
}




static duk_double_t duk__make_day(duk_double_t year, duk_double_t month, duk_double_t day) {
 duk_int_t day_num;
 duk_bool_t is_leap;
 duk_small_int_t i, n;
# 602 "duk_bi_date.c"
 if (!
# 602 "duk_bi_date.c" 3 4
     __builtin_isfinite (
# 602 "duk_bi_date.c"
     year
# 602 "duk_bi_date.c" 3 4
     ) 
# 602 "duk_bi_date.c"
                        || !
# 602 "duk_bi_date.c" 3 4
                            __builtin_isfinite (
# 602 "duk_bi_date.c"
                            month
# 602 "duk_bi_date.c" 3 4
                            )
# 602 "duk_bi_date.c"
                                               ) {
  return 
# 603 "duk_bi_date.c" 3 4
        (__builtin_nanf (""))
# 603 "duk_bi_date.c"
                      ;
 }

 year += floor(month / 12.0);

 month = fmod(month, 12.0);
 if (month < 0.0) {

  month += 12.0;
 }
# 629 "duk_bi_date.c"
 if (!duk_bi_date_year_in_valid_range(year)) {
  do { } while (0);
  return 
# 631 "duk_bi_date.c" 3 4
        (__builtin_nanf (""))
# 631 "duk_bi_date.c"
                      ;
 }
 day_num = duk__day_from_year((duk_int_t) year);
 is_leap = duk_bi_date_is_leap_year((duk_int_t) year);

 n = (duk_small_int_t) month;
 for (i = 0; i < n; i++) {
  day_num += duk__days_in_month[i];
  if (i == 1 && is_leap) {
   day_num++;
  }
 }


 return (duk_double_t) day_num + day;
}





static __attribute__ ((unused)) void duk_bi_date_timeval_to_parts(duk_double_t d, duk_int_t *parts, duk_double_t *dparts, duk_small_uint_t flags) {
 duk_double_t d1, d2;
 duk_int_t t1, t2;
 duk_int_t day_since_epoch;
 duk_int_t year;
 duk_small_int_t day_in_year;
 duk_small_int_t month;
 duk_small_int_t day;
 duk_small_int_t dim;
 duk_int_t jan1_since_epoch;
 duk_small_int_t jan1_weekday;
 duk_int_t equiv_year;
 duk_small_uint_t i;
 duk_bool_t is_leap;
 duk_small_int_t arridx;

 do { } while (0);
 d = floor(d);
 do { } while (0);






 do { (void) (duk_bi_date_timeval_in_leeway_range); } while (0);
 do { } while (0);




 d1 = (duk_double_t) fmod(d, (double) (24L * 60L * 60L * 1000L));
 if (d1 < 0.0) {

  d1 += (duk_double_t) (24L * 60L * 60L * 1000L);
 }
 d2 = floor((double) (d / (duk_double_t) (24L * 60L * 60L * 1000L)));
 do { } while (0);

 t1 = (duk_int_t) d1;
 t2 = (duk_int_t) d2;
 day_since_epoch = t2;
 do { } while (0);
 do { } while (0);





 parts[6] = t1 % 1000;
 t1 /= 1000;
 parts[5] = t1 % 60;
 t1 /= 60;
 parts[4] = t1 % 60;
 t1 /= 60;
 parts[3] = t1;
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0)
# 722 "duk_bi_date.c"
                                                              ;




 do { } while (0);
 parts[7] = (t2 + 4 + (20000000 * 7)) % 7;
 do { } while (0);

 year = duk__year_from_day(t2, &day_in_year);
 day = day_in_year;
 is_leap = duk_bi_date_is_leap_year(year);
 for (month = 0; month < 12; month++) {
  dim = duk__days_in_month[month];
  if (month == 1 && is_leap) {
   dim++;
  }
  do { } while (0);
  if (day < dim) {
   break;
  }
  day -= dim;
 }
 do { } while (0);
 do { } while (0);
 do { } while (0);
# 761 "duk_bi_date.c"
 if ((flags & (1 << 3)) && (year < 1971 || year > 2037)) {
  do { } while (0);

  jan1_since_epoch = day_since_epoch - day_in_year;
  do { } while (0);
  jan1_weekday = (jan1_since_epoch + 4 + (20000000 * 7)) % 7;
  do { } while (0);
  arridx = jan1_weekday;
  if (is_leap) {
   arridx += 7;
  }
  do { } while (0);

  equiv_year = (duk_int_t) duk__date_equivyear[arridx] + 1970;
  year = equiv_year;
  do { } while (0)






                                          ;
 }

 parts[0] = year;
 parts[1] = month;
 parts[2] = day;

 if (flags & (1 << 2)) {
  parts[1]++;
  parts[2]++;
 }

 if (dparts != 
# 795 "duk_bi_date.c" 3 4
              ((void *)0)
# 795 "duk_bi_date.c"
                  ) {
  for (i = 0; i < 8; i++) {
   dparts[i] = (duk_double_t) parts[i];
  }
 }
}







static __attribute__ ((unused)) duk_double_t duk_bi_date_get_timeval_from_dparts(duk_double_t *dparts, duk_small_uint_t flags) {






 duk_double_t tmp_time;
 duk_double_t tmp_day;
 duk_double_t d;

 duk_small_uint_t i;
 duk_int_t tzoff, tzoffprev1, tzoffprev2;
# 832 "duk_bi_date.c"
 for (i = 0; i <= 6; i++) {





  d = dparts[i];
  if (
# 839 "duk_bi_date.c" 3 4
     __builtin_isfinite (
# 839 "duk_bi_date.c"
     d
# 839 "duk_bi_date.c" 3 4
     )
# 839 "duk_bi_date.c"
                    ) {
   dparts[i] = duk_js_tointeger_number(d);
  }
 }
# 860 "duk_bi_date.c"
 tmp_time = 0.0;
 tmp_time += dparts[3] * ((duk_double_t) (60L * 60L * 1000L));
 tmp_time += dparts[4] * ((duk_double_t) (60L * 1000L));
 tmp_time += dparts[5] * ((duk_double_t) 1000L);
 tmp_time += dparts[6];


 tmp_day = duk__make_day(dparts[0], dparts[1], dparts[2]);


 d = tmp_day * ((duk_double_t) (24L * 60L * 60L * 1000L)) + tmp_time;

 do { } while (0);


 if (flags & (1 << 4)) {
# 901 "duk_bi_date.c"
  tzoff = 0;
  tzoffprev1 = 999999999L;
  for (i = 0; i < 4; i++) {
   tzoffprev2 = tzoffprev1;
   tzoffprev1 = tzoff;
   tzoff = duk_bi_date_get_local_tzoffset_gmtime((d - tzoff * 1000L));
   do { } while (0)



                                           ;
   if (tzoff == tzoffprev1) {
    do { } while (0)



                                            ;
    break;
   } else if (tzoff == tzoffprev2) {





    do { } while (0)




                           ;
    if (tzoffprev1 > tzoff) {
     tzoff = tzoffprev1;
    }
    break;
   }
  }
  do { } while (0);
  d -= tzoff * 1000L;
 }


 d = duk__timeclip(d);

 return d;
}
# 955 "duk_bi_date.c"
static duk_double_t duk__push_this_get_timeval_tzoffset(duk_hthread *thr, duk_small_uint_t flags, duk_int_t *out_tzoffset) {
 duk_hobject *h;
 duk_double_t d;
 duk_int_t tzoffset = 0;

 duk_push_this(thr);
 h = duk_get_hobject(thr, -1);
 if (h == 
# 962 "duk_bi_date.c" 3 4
         ((void *)0) 
# 962 "duk_bi_date.c"
              || (((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) != 6) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 963; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_bi_date.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("expected Date"))); } while (0); } while (0);
  do { return 0.0; } while (0);
 }

 (((void) 0), ((void) 0), duk_xget_owndataprop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (106))));
 d = duk_to_number_m1(thr);
 duk_pop(thr);

 if (
# 971 "duk_bi_date.c" 3 4
    __builtin_isnan (
# 971 "duk_bi_date.c"
    d
# 971 "duk_bi_date.c" 3 4
    )
# 971 "duk_bi_date.c"
                ) {
  if (flags & (1 << 0)) {
   d = 0.0;
  }
  if (flags & (1 << 1)) {
   do { duk_err_range((thr), "duk_bi_date.c", (duk_int_t) 976, ("Invalid Date")); } while (0);
   do { return 0.0; } while (0);
  }
 }

 do { } while (0);

 if (flags & (1 << 4)) {



  tzoffset = duk_bi_date_get_local_tzoffset_gmtime((d));
  d += tzoffset * 1000L;
 }
 if (out_tzoffset) {
  *out_tzoffset = tzoffset;
 }


 return d;
}

static duk_double_t duk__push_this_get_timeval(duk_hthread *thr, duk_small_uint_t flags) {
 return duk__push_this_get_timeval_tzoffset(thr, flags, 
# 999 "duk_bi_date.c" 3 4
                                                       ((void *)0)
# 999 "duk_bi_date.c"
                                                           );
}





static duk_ret_t duk__set_this_timeval_from_dparts(duk_hthread *thr, duk_double_t *dparts, duk_small_uint_t flags) {
 duk_double_t d;



 d = duk_bi_date_get_timeval_from_dparts(dparts, flags);
 duk_push_number(thr, d);
 duk_dup_top(thr);




 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-3)) << 24) + (((duk_uint_t) (106)) << 8) + (duk_uint_t) (((1U << 0)))));


 return 1;
}


static void duk__format_parts_iso8601(duk_int_t *parts, duk_int_t tzoffset, duk_small_uint_t flags, duk_uint8_t *out_buf) {
 char yearstr[8];
 char tzstr[8];
 char sep = (flags & (1 << 11)) ? 0x54 : 0x20;

 do { } while (0);
 do { } while (0);
 do { } while (0);




 snprintf(yearstr,
              sizeof(yearstr),
              (parts[0] >= 0 && parts[0] <= 9999) ?
                         "%04ld" :
                         ((parts[0] >= 0) ? "+%06ld" : "%07ld"),
              (long) parts[0]);
 yearstr[sizeof(yearstr) - 1] = (char) 0;

 if (flags & (1 << 4)) {



  const char *fmt;
  duk_small_int_t tmp, arg_hours, arg_minutes;

  if (tzoffset >= 0) {
   tmp = tzoffset;
   fmt = "+%02d:%02d";
  } else {
   tmp = -tzoffset;
   fmt = "-%02d:%02d";
  }
  tmp = tmp / 60;
  arg_hours = tmp / 60;
  arg_minutes = tmp % 60;
  do { } while (0);
  arg_hours = arg_hours & 0x3f;


  snprintf(tzstr, sizeof(tzstr), fmt, (int) arg_hours, (int) arg_minutes);
  tzstr[sizeof(tzstr) - 1] = (char) 0;
 } else {
  tzstr[0] = 0x5a;
  tzstr[1] = (char) 0;
 }




 if ((flags & (1 << 6)) && (flags & (1 << 7))) {
  sprintf((char *) out_buf,
              "%s-%02d-%02d%c%02d:%02d:%02d.%03d%s",
              (const char *) yearstr,
              (int) parts[1],
              (int) parts[2],
              (int) sep,
              (int) parts[3],
              (int) parts[4],
              (int) parts[5],
              (int) parts[6],
              (const char *) tzstr);
 } else if (flags & (1 << 6)) {
  sprintf((char *) out_buf,
              "%s-%02d-%02d",
              (const char *) yearstr,
              (int) parts[1],
              (int) parts[2]);
 } else {
  do { } while (0);
  sprintf((char *) out_buf,
              "%02d:%02d:%02d.%03d%s",
              (int) parts[3],
              (int) parts[4],
              (int) parts[5],
              (int) parts[6],
              (const char *) tzstr);
 }
}





static duk_ret_t duk__to_string_helper(duk_hthread *thr, duk_small_uint_t flags) {
 duk_double_t d;
 duk_int_t parts[8];
 duk_int_t tzoffset;
 duk_bool_t rc;
 duk_uint8_t buf[40];

 do { (void) (rc); } while (0);

 d = duk__push_this_get_timeval_tzoffset(thr, flags, &tzoffset);
 if (
# 1120 "duk_bi_date.c" 3 4
    __builtin_isnan (
# 1120 "duk_bi_date.c"
    d
# 1120 "duk_bi_date.c" 3 4
    )
# 1120 "duk_bi_date.c"
                ) {
  duk_push_hstring_stridx(thr, 66);
  return 1;
 }
 do { } while (0);


 duk_bi_date_timeval_to_parts(d, parts, 
# 1127 "duk_bi_date.c" 3 4
                                       ((void *)0)
# 1127 "duk_bi_date.c"
                                           , (1 << 2));
 do { } while (0);
 do { } while (0);

 if (flags & (1 << 8)) {
# 1142 "duk_bi_date.c"
  rc = duk_bi_date_format_parts_strftime((thr), (parts), (tzoffset), (flags));
  if (rc != 0) {
   return 1;
  }





 }




 duk__format_parts_iso8601(parts, tzoffset, flags, buf);
 duk_push_string(thr, (const char *) buf);
 return 1;
}






static duk_ret_t duk__get_part_helper(duk_hthread *thr, duk_small_uint_t flags_and_idx) {
 duk_double_t d;
 duk_int_t parts[8];
 duk_small_uint_t idx_part = (duk_small_uint_t) (flags_and_idx >> 12);

 do { } while (0);
 do { } while (0);

 d = duk__push_this_get_timeval(thr, flags_and_idx);
 if (
# 1175 "duk_bi_date.c" 3 4
    __builtin_isnan (
# 1175 "duk_bi_date.c"
    d
# 1175 "duk_bi_date.c" 3 4
    )
# 1175 "duk_bi_date.c"
                ) {
  duk_push_nan(thr);
  return 1;
 }
 do { } while (0);

 duk_bi_date_timeval_to_parts(d, parts, 
# 1181 "duk_bi_date.c" 3 4
                                       ((void *)0)
# 1181 "duk_bi_date.c"
                                           , flags_and_idx);





 duk_push_int(thr, (flags_and_idx & (1 << 5)) ? parts[idx_part] - 1900 : parts[idx_part]);
 return 1;
}
# 1198 "duk_bi_date.c"
static duk_ret_t duk__set_part_helper(duk_hthread *thr, duk_small_uint_t flags_and_maxnargs) {
 duk_double_t d;
 duk_int_t parts[8];
 duk_double_t dparts[8];
 duk_idx_t nargs;
 duk_small_uint_t maxnargs = (duk_small_uint_t) (flags_and_maxnargs >> 12);
 duk_small_uint_t idx_first, idx;
 duk_small_uint_t i;

 nargs = duk_get_top(thr);
 d = duk__push_this_get_timeval(thr, flags_and_maxnargs);
 do { } while (0);

 if (
# 1211 "duk_bi_date.c" 3 4
    __builtin_isfinite (
# 1211 "duk_bi_date.c"
    d
# 1211 "duk_bi_date.c" 3 4
    )
# 1211 "duk_bi_date.c"
                   ) {
  duk_bi_date_timeval_to_parts(d, parts, dparts, flags_and_maxnargs);
 } else {





 }
# 1243 "duk_bi_date.c"
 if (flags_and_maxnargs & (1 << 9)) {
  do { } while (0);
  idx_first = 6 - (maxnargs - 1);
 } else {
  do { } while (0);
  idx_first = 2 - (maxnargs - 1);
 }
 do { } while (0);
 do { } while (0);

 for (i = 0; i < maxnargs; i++) {
  if ((duk_idx_t) i >= nargs) {

   break;
  }
  idx = idx_first + i;
  do { } while (0);
  do { } while (0);

  if (idx == 0 && (flags_and_maxnargs & (1 << 10))) {
   duk__twodigit_year_fixup(thr, (duk_idx_t) i);
  }

  dparts[idx] = duk_to_number(thr, (duk_idx_t) i);

  if (idx == 2) {
# 1278 "duk_bi_date.c"
   dparts[idx] -= 1.0;
  }
 }




 if (
# 1285 "duk_bi_date.c" 3 4
    __builtin_isfinite (
# 1285 "duk_bi_date.c"
    d
# 1285 "duk_bi_date.c" 3 4
    )
# 1285 "duk_bi_date.c"
                   ) {
  return duk__set_this_timeval_from_dparts(thr, dparts, flags_and_maxnargs);
 } else {

  duk_push_nan(thr);
  return 1;
 }
}




static void duk__twodigit_year_fixup(duk_hthread *thr, duk_idx_t idx_val) {
 duk_double_t d;






 duk_to_number(thr, idx_val);
 if (duk_is_nan(thr, idx_val)) {
  return;
 }
 duk_dup(thr, idx_val);
 duk_to_int(thr, -1);
 d = duk_get_number(thr, -1);
 if (d >= 0.0 && d <= 99.0) {
  d += 1900.0;
  duk_push_number(thr, d);
  duk_replace(thr, idx_val);
 }
 duk_pop(thr);
}




static void duk__set_parts_from_args(duk_hthread *thr, duk_double_t *dparts, duk_idx_t nargs) {
 duk_double_t d;
 duk_small_uint_t i;
 duk_small_uint_t idx;




 duk__twodigit_year_fixup(thr, 0);





 for (i = 0; i < 8; i++) {

  idx = 0 + i;
  if ((duk_idx_t) i < nargs) {
   d = duk_to_number(thr, (duk_idx_t) i);
   if (idx == 2) {



    d -= 1.0;
   }
  } else {




   d = 0.0;
  }
  dparts[idx] = d;
 }

 do { } while (0)







                                          ;
}
# 1380 "duk_bi_date.c"
static duk_uint16_t duk__date_magics[] = {

 (1 << 6) + (1 << 7) + (1 << 4),


 (1 << 6) + (1 << 4),


 (1 << 7) + (1 << 4),


 (1 << 6) + (1 << 7) + (1 << 8) + (1 << 4),


 (1 << 6) + (1 << 8) + (1 << 4),


 (1 << 7) + (1 << 8) + (1 << 4),


 (1 << 6) + (1 << 7),


 (1 << 6) + (1 << 7) + (1 << 1) + (1 << 11),


 (1 << 4) + (0 << 12),


 0 + (0 << 12),


 (1 << 4) + (1 << 12),


 0 + (1 << 12),


 (1 << 2) + (1 << 4) + (2 << 12),


 (1 << 2) + (2 << 12),


 (1 << 4) + (7 << 12),


 0 + (7 << 12),


 (1 << 4) + (3 << 12),


 0 + (3 << 12),


 (1 << 4) + (4 << 12),


 0 + (4 << 12),


 (1 << 4) + (5 << 12),


 0 + (5 << 12),


 (1 << 4) + (6 << 12),


 0 + (6 << 12),


 (1 << 9) + (1 << 4) + (1 << 12),


 (1 << 9) + (1 << 12),


 (1 << 9) + (1 << 4) + (2 << 12),


 (1 << 9) + (2 << 12),


 (1 << 9) + (1 << 4) + (3 << 12),


 (1 << 9) + (3 << 12),


 (1 << 9) + (1 << 4) + (4 << 12),


 (1 << 9) + (4 << 12),


 (1 << 4) + (1 << 12),


 0 + (1 << 12),


 (1 << 4) + (2 << 12),


 0 + (2 << 12),


 (1 << 0) + (1 << 4) + (3 << 12),


 (1 << 0) + (3 << 12),


 (1 << 4) + (1 << 5) + (0 << 12),


 (1 << 0) + (1 << 10) + (3 << 12),
};

static duk_small_uint_t duk__date_get_indirect_magic(duk_hthread *thr) {
 duk_small_uint_t magicidx = (duk_small_uint_t) duk_get_current_magic(thr);
 do { } while (0);
 return (duk_small_uint_t) duk__date_magics[magicidx];
}






static __attribute__ ((unused)) duk_ret_t duk_bi_date_constructor(duk_hthread *thr) {
 duk_idx_t nargs = duk_get_top(thr);
 duk_bool_t is_cons = duk_is_constructor_call(thr);
 duk_double_t dparts[8];
 duk_double_t d;

 do { } while (0);

 (void) duk_push_object_helper(thr,
                               (1UL << (7 + (0))) | (1UL << (7 + (7))) |
                                   (((duk_uint_t) (6)) << (7 + (20))),
                               16);





 if (nargs == 0 || !is_cons) {
  d = duk__timeclip(duk_time_get_ecmascript_time_nofrac(thr));
  duk_push_number(thr, d);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (106)) << 8) + (duk_uint_t) (((1U << 0)))));
  if (!is_cons) {

   duk_to_string(thr, -1);
  }
  return 1;
 } else if (nargs == 1) {
  const char *str;
  duk_to_primitive(thr, 0, 0);
  str = duk_get_string_notsymbol(thr, 0);
  if (str) {
   duk__parse_string(thr, str);
   duk_replace(thr, 0);
  }
  d = duk__timeclip(duk_to_number(thr, 0));
  duk_push_number(thr, d);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (106)) << 8) + (duk_uint_t) (((1U << 0)))));
  return 1;
 }

 duk__set_parts_from_args(thr, dparts, nargs);



 (void) duk__set_this_timeval_from_dparts(thr, dparts, (1 << 4) );
 duk_pop(thr);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_date_constructor_parse(duk_hthread *thr) {
 return duk__parse_string(thr, duk_to_string(thr, 0));
}

static __attribute__ ((unused)) duk_ret_t duk_bi_date_constructor_utc(duk_hthread *thr) {
 duk_idx_t nargs = duk_get_top(thr);
 duk_double_t dparts[8];
 duk_double_t d;





 if (nargs < 2) {
  duk_push_nan(thr);
 } else {
  duk__set_parts_from_args(thr, dparts, nargs);
  d = duk_bi_date_get_timeval_from_dparts(dparts, 0 );
  duk_push_number(thr, d);
 }
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_date_constructor_now(duk_hthread *thr) {
 duk_double_t d;

 d = duk_time_get_ecmascript_time_nofrac(thr);
 do { } while (0);
 duk_push_number(thr, d);
 return 1;
}
# 1628 "duk_bi_date.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_tostring_shared(duk_hthread *thr) {
 duk_small_uint_t flags = duk__date_get_indirect_magic(thr);
 return duk__to_string_helper(thr, flags);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_value_of(duk_hthread *thr) {




 duk_double_t d = duk__push_this_get_timeval(thr, 0 );
 do { } while (0);
 duk_push_number(thr, d);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_to_json(duk_hthread *thr) {




 duk_push_this(thr);
 duk_to_object(thr, -1);

 duk_dup_top(thr);
 duk_to_primitive(thr, -1, 2);
 if (duk_is_number(thr, -1)) {
  duk_double_t d = duk_get_number(thr, -1);
  if (!
# 1656 "duk_bi_date.c" 3 4
      __builtin_isfinite (
# 1656 "duk_bi_date.c"
      d
# 1656 "duk_bi_date.c" 3 4
      )
# 1656 "duk_bi_date.c"
                     ) {
   duk_push_null(thr);
   return 1;
  }
 }
 duk_pop(thr);

 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (42))));
 duk_dup_m2(thr);
 duk_call_method(thr, 0);
 return 1;
}
# 1710 "duk_bi_date.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_get_shared(duk_hthread *thr) {
 duk_small_uint_t flags_and_idx = duk__date_get_indirect_magic(thr);
 return duk__get_part_helper(thr, flags_and_idx);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_get_timezone_offset(duk_hthread *thr) {
# 1730 "duk_bi_date.c"
 duk_double_t d;
 duk_int_t tzoffset;


 d = duk__push_this_get_timeval(thr, 0 );
 do { } while (0);
 if (
# 1736 "duk_bi_date.c" 3 4
    __builtin_isnan (
# 1736 "duk_bi_date.c"
    d
# 1736 "duk_bi_date.c" 3 4
    )
# 1736 "duk_bi_date.c"
                ) {
  duk_push_nan(thr);
 } else {
  do { } while (0);
  tzoffset = duk_bi_date_get_local_tzoffset_gmtime((d));
  duk_push_int(thr, -tzoffset / 60);
 }
 return 1;
}
# 1795 "duk_bi_date.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_set_shared(duk_hthread *thr) {
 duk_small_uint_t flags_and_maxnargs = duk__date_get_indirect_magic(thr);
 return duk__set_part_helper(thr, flags_and_maxnargs);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_set_time(duk_hthread *thr) {
 duk_double_t d;

 (void) duk__push_this_get_timeval(thr, 0 );
 d = duk__timeclip(duk_to_number(thr, 0));
 duk_push_number(thr, d);
 duk_dup_top(thr);



 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-3)) << 24) + (((duk_uint_t) (106)) << 8) + (duk_uint_t) (((1U << 0)))));


 return 1;
}






static __attribute__ ((unused)) duk_ret_t duk_bi_date_prototype_toprimitive(duk_hthread *thr) {
 duk_size_t hintlen;
 const char *hintstr;
 duk_int_t hint;







 duk_push_this(thr);
 duk_require_object(thr, -1);
 do { } while (0);

 hintstr = duk_require_lstring(thr, 0, &hintlen);
 if ((hintlen == 6 && strcmp(hintstr, "string") == 0) || (hintlen == 7 && strcmp(hintstr, "default") == 0)) {
  hint = 1;
 } else if (hintlen == 6 && strcmp(hintstr, "number") == 0) {
  hint = 2;
 } else {
  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_date.c", (duk_int_t) 1842); } while (0); return 0; } while (0);
 }

 duk_to_primitive_ordinary(thr, -1, hint);
 return 1;
}
# 1 "duk_bi_date_unix.c"
# 19 "duk_bi_date_unix.c"
static __attribute__ ((unused)) duk_double_t duk_bi_date_get_now_gettimeofday(void) {
 struct timeval tv;
 duk_double_t d;

 if (gettimeofday(&tv, 
# 23 "duk_bi_date_unix.c" 3 4
                      ((void *)0)
# 23 "duk_bi_date_unix.c"
                          ) != 0) {
  do { } while (0);
  return 0.0;
 }


 d = ((duk_double_t) tv.tv_sec) * 1000.0 + ((duk_double_t) tv.tv_usec) / 1000.0;

 return d;
}
# 51 "duk_bi_date_unix.c"
static __attribute__ ((unused)) duk_int_t duk_bi_date_get_local_tzoffset_gmtime(duk_double_t d) {
 time_t t, t1, t2;
 duk_int_t parts[8];
 duk_double_t dparts[8];
 struct tm tms[2];





 if (!
# 61 "duk_bi_date_unix.c" 3 4
     __builtin_isfinite (
# 61 "duk_bi_date_unix.c"
     d
# 61 "duk_bi_date_unix.c" 3 4
     )
# 61 "duk_bi_date_unix.c"
                    ) {
  return 0;
 }







 if (!duk_bi_date_timeval_in_leeway_range(d)) {
  do { } while (0);
  return 0;
 }
# 126 "duk_bi_date_unix.c"
 duk_bi_date_timeval_to_parts(d, parts, dparts, (1 << 3) );
 do { } while (0);

 d = duk_bi_date_get_timeval_from_dparts(dparts, 0 );
 do { } while (0);
 t = (time_t) (d / 1000.0);
 do { } while (0);

 do { void *duk__dst = ((void *) tms); duk_size_t duk__len = (sizeof(struct tm) * 2); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);


 (void) gmtime_r(&t, &tms[0]);
 (void) localtime_r(&t, &tms[1]);
# 150 "duk_bi_date_unix.c"
 do { } while (0)
# 160 "duk_bi_date_unix.c"
                                              ;
 do { } while (0)
# 171 "duk_bi_date_unix.c"
                                              ;






 tms[0].tm_isdst = 0;
 tms[1].tm_isdst = 0;
 t1 = mktime(&tms[0]);
 t2 = mktime(&tms[1]);
 if (t1 == (time_t) -1 || t2 == (time_t) -1) {





  goto mktime_error;
 }
 do { } while (0);
# 202 "duk_bi_date_unix.c"
 return (duk_int_t) difftime(t2, t1);

mktime_error:

 do { } while (0);
 return 0;
}



static __attribute__ ((unused)) duk_bool_t duk_bi_date_parse_string_strptime(duk_hthread *thr, const char *str) {
 struct tm tm;
 time_t t;
 char buf[64];


 do { } while (0);
 do { void *duk__dst = (buf); duk_size_t duk__len = (sizeof(buf)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 snprintf(buf, sizeof(buf), "%s", (const char *) str);
 buf[sizeof(buf) - 1] = (char) 0;

 do { } while (0);

 do { void *duk__dst = (&tm); duk_size_t duk__len = (sizeof(tm)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 if (strptime((const char *) buf, "%c", &tm) != 
# 226 "duk_bi_date_unix.c" 3 4
                                               ((void *)0)
# 226 "duk_bi_date_unix.c"
                                                   ) {
  do { } while (0)
# 237 "duk_bi_date_unix.c"
                                           ;
  tm.tm_isdst = -1;

  t = mktime(&tm);
  do { } while (0);
  if (t >= 0) {
   duk_push_number(thr, ((duk_double_t) t) * 1000.0);
   return 1;
  }
 }

 return 0;
}
# 280 "duk_bi_date_unix.c"
static __attribute__ ((unused)) duk_bool_t duk_bi_date_format_parts_strftime(duk_hthread *thr,
                                                          duk_int_t *parts,
                                                          duk_int_t tzoffset,
                                                          duk_small_uint_t flags) {
 char buf[64];
 struct tm tm;
 const char *fmt;

 do { (void) (tzoffset); } while (0);
# 301 "duk_bi_date_unix.c"
 if (sizeof(time_t) < 8 && (parts[0] < 1970 || parts[0] > 2037)) {

  return 0;
 }

 do { void *duk__dst = (&tm); duk_size_t duk__len = (sizeof(tm)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 tm.tm_sec = parts[5];
 tm.tm_min = parts[4];
 tm.tm_hour = parts[3];
 tm.tm_mday = parts[2];
 tm.tm_mon = parts[1] - 1;
 tm.tm_year = parts[0] - 1900;
 tm.tm_wday = parts[7];
 tm.tm_isdst = 0;

 do { void *duk__dst = (buf); duk_size_t duk__len = (sizeof(buf)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 if ((flags & (1 << 6)) && (flags & (1 << 7))) {
  fmt = "%c";
 } else if (flags & (1 << 6)) {
  fmt = "%x";
 } else {
  do { } while (0);
  fmt = "%X";
 }
 (void) strftime(buf, sizeof(buf) - 1, fmt, &tm);
 do { } while (0);

 duk_push_string(thr, buf);
 return 1;
}
# 1 "duk_bi_date_windows.c"
# 1 "duk_bi_duktape.c"
# 16 "duk_bi_duktape.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_info(duk_hthread *thr) {
 duk_inspect_value(thr, -1);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_act(duk_hthread *thr) {
 duk_int_t level;

 level = duk_to_int(thr, 0);
 duk_inspect_callstack_entry(thr, level);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_gc(duk_hthread *thr) {
 duk_small_uint_t flags;

 flags = (duk_small_uint_t) duk_get_uint(thr, 0);
 duk_heap_mark_and_sweep(thr->heap, flags);




 duk_push_true(thr);
 return 1;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_fin(duk_hthread *thr) {
 (void) duk_require_hobject(thr, 0);
 if (duk_get_top(thr) >= 2) {







  duk_set_top(thr, 2);
  duk_set_finalizer(thr, 0);
  return 0;
 } else {

  do { } while (0);
  duk_get_finalizer(thr, 0);
  return 1;
 }
}


static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_enc(duk_hthread *thr) {
 duk_hstring *h_str;






 h_str = duk_require_hstring(thr, 0);
 duk_require_valid_index(thr, 1);

 if (h_str == (((thr))->strs[(112)])) {
  duk_set_top(thr, 2);
  duk_hex_encode(thr, 1);
  do { } while (0);
 } else if (h_str == (((thr))->strs[(113)])) {
  duk_set_top(thr, 2);
  duk_base64_encode(thr, 1);
  do { } while (0);

 } else if (h_str == (((thr))->strs[(114)])) {
  duk_bi_json_stringify_helper(thr,
                               1 ,
                               2 ,
                               3 ,
                               (1U << 2) | (1U << 0) |
                                   (1U << 1) );


 } else if (h_str == (((thr))->strs[(115)])) {
  duk_bi_json_stringify_helper(thr,
                               1 ,
                               2 ,
                               3 ,
                               (1U << 3) | (1U << 0) );

 } else {
  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_duktape.c", (duk_int_t) 102); } while (0); return 0; } while (0);
 }
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_dec(duk_hthread *thr) {
 duk_hstring *h_str;






 h_str = duk_require_hstring(thr, 0);
 duk_require_valid_index(thr, 1);

 if (h_str == (((thr))->strs[(112)])) {
  duk_set_top(thr, 2);
  duk_hex_decode(thr, 1);
  do { } while (0);
 } else if (h_str == (((thr))->strs[(113)])) {
  duk_set_top(thr, 2);
  duk_base64_decode(thr, 1);
  do { } while (0);

 } else if (h_str == (((thr))->strs[(114)])) {
  duk_bi_json_parse_helper(thr, 1 , 2 , (1U << 2) );


 } else if (h_str == (((thr))->strs[(115)])) {
  duk_bi_json_parse_helper(thr, 1 , 2 , (1U << 3) );

 } else {
  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_duktape.c", (duk_int_t) 135); } while (0); return 0; } while (0);
 }
 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_duktape_object_compact(duk_hthread *thr) {
 do { } while (0);
 duk_compact(thr, 0);
 return 1;
}
# 1 "duk_bi_encoding.c"
# 14 "duk_bi_encoding.c"
typedef struct {
 duk_uint8_t *out;
 duk_codepoint_t lead;
} duk__encode_context;

typedef struct {

 duk_codepoint_t codepoint;
 duk_uint8_t upper;
 duk_uint8_t lower;
 duk_uint8_t needed;
 duk_uint8_t bom_handled;


 duk_uint8_t fatal;
 duk_uint8_t ignore_bom;
} duk__decode_context;
# 44 "duk_bi_encoding.c"
static duk_uint8_t *duk__utf8_emit_repl(duk_uint8_t *ptr) {
 *ptr++ = 0xef;
 *ptr++ = 0xbf;
 *ptr++ = 0xbd;
 return ptr;
}

static void duk__utf8_decode_init(duk__decode_context *dec_ctx) {



 dec_ctx->codepoint = 0x0000L;
 dec_ctx->upper = 0xbf;
 dec_ctx->lower = 0x80;
 dec_ctx->needed = 0;
 dec_ctx->bom_handled = 0;
}

static duk_codepoint_t duk__utf8_decode_next(duk__decode_context *dec_ctx, duk_uint8_t x) {
# 72 "duk_bi_encoding.c"
 if (dec_ctx->needed == 0) {

  if (x <= 0x7f) {

   return (duk_codepoint_t) x;
  } else if (x >= 0xc2 && x <= 0xdf) {

   dec_ctx->needed = 1;
   dec_ctx->codepoint = x & 0x1f;
   do { } while (0);
   do { } while (0);
   return (-1);
  } else if (x >= 0xe0 && x <= 0xef) {

   if (x == 0xe0) {
    dec_ctx->lower = 0xa0;
    do { } while (0);
   } else if (x == 0xed) {
    do { } while (0);
    dec_ctx->upper = 0x9f;
   }
   dec_ctx->needed = 2;
   dec_ctx->codepoint = x & 0x0f;
   return (-1);
  } else if (x >= 0xf0 && x <= 0xf4) {

   if (x == 0xf0) {
    dec_ctx->lower = 0x90;
    do { } while (0);
   } else if (x == 0xf4) {
    do { } while (0);
    dec_ctx->upper = 0x8f;
   }
   dec_ctx->needed = 3;
   dec_ctx->codepoint = x & 0x07;
   return (-1);
  } else {

   return (-2);
  }
 } else {

  if (x >= dec_ctx->lower && x <= dec_ctx->upper) {
   dec_ctx->lower = 0x80;
   dec_ctx->upper = 0xbf;
   dec_ctx->codepoint = (dec_ctx->codepoint << 6) | (x & 0x3f);
   if (--dec_ctx->needed > 0) {

    return (-1);
   } else {

    duk_codepoint_t ret;
    do { } while (0);
    ret = dec_ctx->codepoint;
    dec_ctx->codepoint = 0x0000L;
    dec_ctx->needed = 0;
    return ret;
   }
  } else {






   dec_ctx->codepoint = 0x0000L;
   dec_ctx->needed = 0;
   dec_ctx->lower = 0x80;
   dec_ctx->upper = 0xbf;
   return (-3);
  }
 }
}


static void duk__utf8_encode_char(void *udata, duk_codepoint_t codepoint) {
 duk__encode_context *enc_ctx;

 do { } while (0);
 enc_ctx = (duk__encode_context *) udata;
 do { } while (0);


 if (codepoint <= 0x7f && enc_ctx->lead == 0x0000L) {

  *enc_ctx->out++ = (duk_uint8_t) codepoint;
  return;
 }


 if (__builtin_expect((codepoint > 0x10ffffL), 0)) {

  codepoint = 0xfffdL;
 } else if (codepoint >= 0xd800L && codepoint <= 0xdfffL) {
  if (codepoint <= 0xdbffL) {

   duk_codepoint_t prev_lead = enc_ctx->lead;
   enc_ctx->lead = codepoint;
   if (prev_lead == 0x0000L) {

    return;
   } else {

    codepoint = 0xfffdL;
   }
  } else {

   if (enc_ctx->lead != 0x0000L) {
    codepoint =
        (duk_codepoint_t) (0x010000L + ((enc_ctx->lead - 0xd800L) << 10) + (codepoint - 0xdc00L));
    enc_ctx->lead = 0x0000L;
   } else {

    do { } while (0);
    codepoint = 0xfffdL;
   }
  }
 } else {
  if (enc_ctx->lead != 0x0000L) {

   enc_ctx->lead = 0x0000L;
   enc_ctx->out = duk__utf8_emit_repl(enc_ctx->out);
  }
 }




 enc_ctx->out += duk_unicode_encode_xutf8((duk_ucodepoint_t) codepoint, enc_ctx->out);
}





static duk_ret_t duk__decode_helper(duk_hthread *thr, duk__decode_context *dec_ctx) {
 const duk_uint8_t *input;
 duk_size_t len = 0;
 duk_size_t len_tmp;
 duk_bool_t stream = 0;
 duk_codepoint_t codepoint;
 duk_uint8_t *output;
 const duk_uint8_t *in;
 duk_uint8_t *out;

 do { } while (0);
# 227 "duk_bi_encoding.c"
 if (duk_is_undefined(thr, 0)) {
  duk_push_fixed_buffer_nozero(thr, 0);
  duk_replace(thr, 0);
 }
 (void) duk_require_buffer_data(thr, 0, &len);

 if (duk_check_type_mask(thr, 1, (1U << 1U) | (1U << 2U) | (1U << 0U))) {

 } else {
  ((void) duk_check_type_mask((thr), (1), ((1U << 1U) | (1U << 2U) | (1U << 9U) | (1U << 7U) | (1U << 6U)) | (1U << 10)))


                                                                        ;
  if (duk_get_prop_literal_raw((thr), (1), ("stream"), sizeof(("stream")) - 1U)) {
   stream = duk_to_boolean(thr, -1);
  }
 }
# 253 "duk_bi_encoding.c"
 if (len >= ((0x7ffffffeUL) / 3) - 3) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 254; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_bi_encoding.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("result too long"))); } while (0); } while (0);
  do { return 0; } while (0);
 }
 output =
     (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, 3 + (3 * len));

 input = (const duk_uint8_t *) duk_get_buffer_data(thr, 0, &len_tmp);
 do { } while (0);
 if (__builtin_expect((len != len_tmp), 0)) {





  do { } while (0);
  goto fail_type;
 }







 in = input;
 out = output;
 while (in < input + len) {
  codepoint = duk__utf8_decode_next(dec_ctx, *in++);
  if (codepoint < 0) {
   if (codepoint == (-1)) {
    continue;
   }


   do { } while (0);
   if (codepoint == (-3)) {
    --in;
   }

   codepoint = 0xfffdL;
   if (dec_ctx->fatal) {

    goto fail_type;
   }

  }
  do { } while (0);

  if (!dec_ctx->bom_handled) {
   dec_ctx->bom_handled = 1;
   if (codepoint == 0xfeffL && !dec_ctx->ignore_bom) {
    continue;
   }
  }

  out += duk_unicode_encode_cesu8((duk_ucodepoint_t) codepoint, out);
  do { } while (0);
 }

 if (!stream) {
  if (dec_ctx->needed != 0) {

   if (dec_ctx->fatal) {
    goto fail_type;
   } else {
    out += duk_unicode_encode_cesu8(0xfffdL, out);
    do { } while (0);
   }
  }
  duk__utf8_decode_init(dec_ctx);
 }




 duk_push_lstring(thr, (const char *) output, (duk_size_t) (out - output));
 return 1;

fail_type:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 333; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_bi_encoding.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("utf-8 decode failed"))); } while (0); } while (0);
 do { return 0; } while (0);
}






static __attribute__ ((unused)) duk_ret_t duk_bi_textencoder_constructor(duk_hthread *thr) {




 duk_require_constructor_call(thr);
 return 0;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_textencoder_prototype_encoding_getter(duk_hthread *thr) {
 duk_push_literal_raw((thr), ("utf-8"), sizeof(("utf-8")) - 1U);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_textencoder_prototype_encode(duk_hthread *thr) {
 duk__encode_context enc_ctx;
 duk_size_t len;
 duk_size_t final_len;
 duk_uint8_t *output;

 do { } while (0);
 if (duk_is_undefined(thr, 0)) {
  len = 0;
 } else {
  duk_hstring *h_input;

  h_input = duk_to_hstring(thr, 0);
  do { } while (0);

  len = (duk_size_t) duk_hstring_get_charlen((h_input));
  if (len >= (0x7ffffffeUL) / 3) {
   do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 373; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_bi_encoding.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("result too long"))); } while (0); } while (0);
   do { return 0; } while (0);
  }
 }
# 387 "duk_bi_encoding.c"
 do { } while (0);
 output = (duk_uint8_t *) duk_push_buffer_raw((thr), (3 * len), (1 << 0) );

 if (len > 0) {
  do { } while (0);
# 405 "duk_bi_encoding.c"
  enc_ctx.lead = 0x0000L;
  enc_ctx.out = output;
  duk_decode_string(thr, 0, duk__utf8_encode_char, (void *) &enc_ctx);
  if (enc_ctx.lead != 0x0000L) {

   enc_ctx.out = duk__utf8_emit_repl(enc_ctx.out);
   do { } while (0);
  }




  do { } while (0);
  do { } while (0);

  final_len = (duk_size_t) (enc_ctx.out - output);
  duk_resize_buffer(thr, -1, final_len);

 } else {
  final_len = 0;
 }
# 434 "duk_bi_encoding.c"
 duk_push_buffer_object(thr, -1, 0, final_len, 4);

 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_textdecoder_constructor(duk_hthread *thr) {
 duk__decode_context *dec_ctx;
 duk_bool_t fatal = 0;
 duk_bool_t ignore_bom = 0;

 do { } while (0);
 duk_require_constructor_call(thr);
 if (!duk_is_undefined(thr, 0)) {

  duk_to_string(thr, 0);
 }
 if (!((duk_get_type_mask((thr), (1)) & ((1U << 2U) | (1U << 1U))) ? 1 : 0)) {
  if (duk_get_prop_literal_raw((thr), (1), ("fatal"), sizeof(("fatal")) - 1U)) {
   fatal = duk_to_boolean(thr, -1);
  }
  if (duk_get_prop_literal_raw((thr), (1), ("ignoreBOM"), sizeof(("ignoreBOM")) - 1U)) {
   ignore_bom = duk_to_boolean(thr, -1);
  }
 }

 duk_push_this(thr);




 dec_ctx = (duk__decode_context *) duk_push_buffer_raw((thr), (sizeof(duk__decode_context)), 0 );
 dec_ctx->fatal = (duk_uint8_t) fatal;
 dec_ctx->ignore_bom = (duk_uint8_t) ignore_bom;
 duk__utf8_decode_init(dec_ctx);

 duk_put_prop_literal_raw((thr), (-2), (("\x82" "Context")), sizeof((("\x82" "Context"))) - 1U);
 return 0;
}


static duk__decode_context *duk__get_textdecoder_context(duk_hthread *thr) {
 duk__decode_context *dec_ctx;
 duk_push_this(thr);
 duk_get_prop_literal_raw((thr), (-1), (("\x82" "Context")), sizeof((("\x82" "Context"))) - 1U);
 dec_ctx = (duk__decode_context *) duk_require_buffer(thr, -1, 
# 478 "duk_bi_encoding.c" 3 4
                                                              ((void *)0)
# 478 "duk_bi_encoding.c"
                                                                  );
 do { } while (0);
 return dec_ctx;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_textdecoder_prototype_shared_getter(duk_hthread *thr) {
 duk__decode_context *dec_ctx;
 duk_int_t magic;

 dec_ctx = duk__get_textdecoder_context(thr);
 magic = duk_get_current_magic(thr);
 switch (magic) {
 case 0:



  duk_push_literal_raw((thr), ("utf-8"), sizeof(("utf-8")) - 1U);
  break;
 case 1:
  duk_push_boolean(thr, dec_ctx->fatal);
  break;
 default:
  duk_push_boolean(thr, dec_ctx->ignore_bom);
  break;
 }

 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_textdecoder_prototype_decode(duk_hthread *thr) {
 duk__decode_context *dec_ctx;

 dec_ctx = duk__get_textdecoder_context(thr);
 return duk__decode_helper(thr, dec_ctx);
}
# 524 "duk_bi_encoding.c"
static __attribute__ ((unused)) duk_ret_t duk_textdecoder_decode_utf8_nodejs(duk_hthread *thr) {
 duk__decode_context dec_ctx;

 dec_ctx.fatal = 0;
 dec_ctx.ignore_bom = 1;
 duk__utf8_decode_init(&dec_ctx);

 return duk__decode_helper(thr, &dec_ctx);
}
# 1 "duk_bi_error.c"






static __attribute__ ((unused)) duk_ret_t duk_bi_error_constructor_shared(duk_hthread *thr) {







 duk_small_int_t bidx_prototype = duk_get_current_magic(thr);


 duk_uint_t flags_and_class =
     (1UL << (7 + (0))) | (1UL << (7 + (7))) | (((duk_uint_t) (7)) << (7 + (20)));

 (void) duk_push_object_helper(thr, flags_and_class, bidx_prototype);




 if (!duk_is_undefined(thr, 0)) {
  duk_to_string(thr, 0);
  duk_dup_0(thr);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (52)) << 8) + (duk_uint_t) (((1U << 0) | (1U << 2)))));
 }






 if (!duk_is_constructor_call(thr)) {
  duk_err_augment_error_create(thr, thr, 
# 38 "duk_bi_error.c" 3 4
                                        ((void *)0)
# 38 "duk_bi_error.c"
                                            , 0, (1U << 0));
 }


 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_to_string(duk_hthread *thr) {


 duk_push_this(thr);
 (void) duk_require_hobject_promote_mask(thr, -1, (1U << 9U) | (1U << 7U));



 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (93))));
 if (duk_is_undefined(thr, -1)) {
  duk_pop(thr);
  duk_push_literal_raw((thr), ("Error"), sizeof(("Error")) - 1U);
 } else {
  duk_to_string(thr, -1);
 }







 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (52))));
 if (duk_is_undefined(thr, -1)) {
  duk_pop(thr);
  duk_push_hstring_empty(thr);
 } else {
  duk_to_string(thr, -1);
 }



 if (duk_get_length(thr, -2) == 0) {

  return 1;
 }
 if (duk_get_length(thr, -1) == 0) {

  duk_pop(thr);
  return 1;
 }
 duk_push_literal_raw((thr), (": "), sizeof((": ")) - 1U);
 duk_insert(thr, -2);
 duk_concat(thr, 3);

 return 1;
}
# 114 "duk_bi_error.c"
static duk_ret_t duk__error_getter_helper(duk_hthread *thr, duk_small_int_t output_type) {
 duk_idx_t idx_td;
 duk_small_int_t i;
 duk_small_int_t t;
 duk_small_int_t count_func = 0;
 const char *str_tailcall = " tailcall";
 const char *str_strict = " strict";
 const char *str_construct = " construct";
 const char *str_prevyield = " preventsyield";
 const char *str_directeval = " directeval";
 const char *str_empty = "";

 do { } while (0);

 duk_push_this(thr);
 (((void) 0), ((void) 0), duk_xget_owndataprop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (92))));
 idx_td = duk_get_top_index(thr);

 duk_push_hstring_stridx(thr, 64);
 duk_push_this(thr);





 if (duk_check_type(thr, idx_td, 6U)) {

  for (i = 0;; i += 2) {
   duk_int_t pc;
   duk_uint_t line;
   duk_uint_t flags;
   duk_double_t d;
   const char *funcname;
   const char *filename;
   duk_hobject *h_func;
   duk_hstring *h_name;

   duk_require_stack(thr, 5);
   duk_get_prop_index(thr, idx_td, (duk_uarridx_t) i);
   duk_get_prop_index(thr, idx_td, (duk_uarridx_t) (i + 1));
   d = duk_to_number_m1(thr);
   pc = duk_double_to_int_t(fmod(d, 4294967296.0));
   flags = duk_double_to_uint_t(floor(d / 4294967296.0));
   t = (duk_small_int_t) duk_get_type(thr, -2);

   if (t == 6U || t == 9U) {




    count_func++;







    (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (93))));
    (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-3)) << 16) + ((duk_uint_t) (94))));


    line = (duk_uint_t) duk_hobject_pc2line_query(thr, -4, (duk_uint_fast32_t) pc);
# 186 "duk_bi_error.c"
    if (duk_is_string_notsymbol(thr, -1)) {
     if (output_type == 0) {
      return 1;
     } else if (output_type == 1) {
      duk_push_uint(thr, line);
      return 1;
     }
    }



    h_name = duk_get_hstring_notsymbol(thr, -2);
    funcname = (h_name == 
# 198 "duk_bi_error.c" 3 4
                         ((void *)0) 
# 198 "duk_bi_error.c"
                              || h_name == (((thr))->strs[(15)])) ?
                                               "[anon]" :
                                               (const char *) ((const duk_uint8_t *) ((h_name) + 1));
    filename = duk_get_string_notsymbol(thr, -1);
    filename = filename ? filename : "";
    do { } while (0);
    do { } while (0);

    h_func = duk_get_hobject(thr, -4);

    if (h_func == 
# 208 "duk_bi_error.c" 3 4
                 ((void *)0)
# 208 "duk_bi_error.c"
                     ) {
     duk_push_sprintf(
         thr,
         "at %s light%s%s%s%s%s",
         (const char *) funcname,
         (const char *) ((flags & (1U << 0)) ? str_strict : str_empty),
         (const char *) ((flags & (1U << 1)) ? str_tailcall : str_empty),
         (const char *) ((flags & (1U << 2)) ? str_construct : str_empty),
         (const char *) ((flags & (1U << 4)) ? str_directeval : str_empty),
         (const char *) ((flags & (1U << 3)) ? str_prevyield : str_empty));
    } else if ((((&(h_func)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)) {
     duk_push_sprintf(
         thr,
         "at %s (%s) native%s%s%s%s%s",
         (const char *) funcname,
         (const char *) filename,
         (const char *) ((flags & (1U << 0)) ? str_strict : str_empty),
         (const char *) ((flags & (1U << 1)) ? str_tailcall : str_empty),
         (const char *) ((flags & (1U << 2)) ? str_construct : str_empty),
         (const char *) ((flags & (1U << 4)) ? str_directeval : str_empty),
         (const char *) ((flags & (1U << 3)) ? str_prevyield : str_empty));
    } else {
     duk_push_sprintf(
         thr,
         "at %s (%s:%lu)%s%s%s%s%s",
         (const char *) funcname,
         (const char *) filename,
         (unsigned long) line,
         (const char *) ((flags & (1U << 0)) ? str_strict : str_empty),
         (const char *) ((flags & (1U << 1)) ? str_tailcall : str_empty),
         (const char *) ((flags & (1U << 2)) ? str_construct : str_empty),
         (const char *) ((flags & (1U << 4)) ? str_directeval : str_empty),
         (const char *) ((flags & (1U << 3)) ? str_prevyield : str_empty));
    }
    duk_replace(thr, -5);
    duk_pop_3(thr);
   } else if (t == 5U) {
    const char *str_file;
# 258 "duk_bi_error.c"
    if (!(flags & (1U << 0))) {
     if (output_type == 0) {
      duk_pop(thr);
      return 1;
     } else if (output_type == 1) {
      duk_push_int(thr, pc);
      return 1;
     }
    }






    str_file = (const char *) duk_get_string(thr, -2);
    duk_push_sprintf(thr,
                     "at [anon] (%s:%ld) internal",
                     (const char *) (str_file ? str_file : "null"),
                     (long) pc);
    duk_replace(thr, -3);
    duk_pop(thr);
   } else {

    duk_pop_2(thr);
    break;
   }
  }

  if (count_func >= 10) {




   duk_push_hstring_stridx(thr, 65);
  }
 }



 if (output_type != (-1)) {
  return 0;
 } else {




  duk_join(thr, duk_get_top(thr) - (idx_td + 2) );
  return 1;
 }
}





static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_stack_getter(duk_hthread *thr) {
 return duk__error_getter_helper(thr, (-1));
}

static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_filename_getter(duk_hthread *thr) {
 return duk__error_getter_helper(thr, 0);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_linenumber_getter(duk_hthread *thr) {
 return duk__error_getter_helper(thr, 1);
}
# 359 "duk_bi_error.c"
static duk_ret_t duk__error_setter_helper(duk_hthread *thr, duk_small_uint_t stridx_key) {







 do { } while (0);

 duk_push_this(thr);
 duk_push_hstring_stridx(thr, stridx_key);
 duk_dup_0(thr);



 do { } while (0);

 duk_def_prop(thr,
              -3,
              (1U << 6) | (1U << 3) | (1U << 0) |
                  (1U << 4) |
                  (1U << 5) | (1U << 2));
 return 0;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_stack_setter(duk_hthread *thr) {
 return duk__error_setter_helper(thr, 89);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_filename_setter(duk_hthread *thr) {
 return duk__error_setter_helper(thr, 94);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_error_prototype_linenumber_setter(duk_hthread *thr) {
 return duk__error_setter_helper(thr, 91);
}
# 1 "duk_bi_function.c"







static __attribute__ ((unused)) duk_ret_t duk_bi_function_prototype(duk_hthread *thr) {

 do { (void) (thr); } while (0);
 return 0;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_function_constructor(duk_hthread *thr) {
 duk_hstring *h_sourcecode;
 duk_idx_t nargs;
 duk_idx_t i;
 duk_small_uint_t comp_flags;
 duk_hcompfunc *func;
 duk_hobject *outer_lex_env;
 duk_hobject *outer_var_env;



 nargs = duk_get_top(thr);
 for (i = 0; i < nargs; i++) {
  duk_to_string(thr, i);
 }

 if (nargs == 0) {
  duk_push_hstring_empty(thr);
  duk_push_hstring_empty(thr);
 } else if (nargs == 1) {

  duk_push_hstring_empty(thr);
 } else {
  duk_insert(thr, 0);
  duk_push_literal_raw((thr), (","), sizeof((",")) - 1U);
  duk_insert(thr, 1);
  duk_join(thr, nargs - 1);
 }



 do { } while (0);




 duk_push_literal_raw((thr), ("function("), sizeof(("function(")) - 1U);
 duk_dup_1(thr);
 duk_push_literal_raw((thr), ("){"), sizeof(("){")) - 1U);
 duk_dup_0(thr);
 duk_push_literal_raw((thr), ("\n}"), sizeof(("\n}")) - 1U);
 duk_concat(thr, 5);



 do { } while (0);


 comp_flags = (1U << 12);

 duk_push_hstring_stridx(thr, 107);
 h_sourcecode = duk_require_hstring(thr, -2);
 duk_js_compile(thr,
                (const duk_uint8_t *) ((const duk_uint8_t *) ((h_sourcecode) + 1)),
                (duk_size_t) ((h_sourcecode)->blen),
                comp_flags);


 duk_push_literal_raw((thr), ("anonymous"), sizeof(("anonymous")) - 1U);
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (93)) << 8) + (duk_uint_t) (((1U << 2)))));

 func = (duk_hcompfunc *) duk_known_hobject(thr, -1);
 do { } while (0);
 do { } while (0);







 outer_lex_env = thr->builtins[1];
 outer_var_env = thr->builtins[1];

 duk_js_push_closure(thr, func, outer_var_env, outer_lex_env, 1 );



 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_function_prototype_to_string(duk_hthread *thr) {
 duk_tval *tv;
# 121 "duk_bi_function.c"
 duk_push_this(thr);
 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));
 do { } while (0);

 if (((tv)->t == 9)) {
  duk_hobject *obj = ((tv)->v.hobject);
  const char *func_name;
# 136 "duk_bi_function.c"
  (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (93))));
  if (duk_is_undefined(thr, -1)) {
   func_name = "";
  } else {
   func_name = duk_to_string(thr, -1);
   do { } while (0);
  }

  if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
   duk_push_sprintf(thr, "function %s() { [ecmascript code] }", (const char *) func_name);
  } else if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)) {
   duk_push_sprintf(thr, "function %s() { [native code] }", (const char *) func_name);
  } else if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0)) {
   duk_push_sprintf(thr, "function %s() { [bound code] }", (const char *) func_name);
  } else {
   goto type_error;
  }
 } else if (((tv)->t == 6)) {
  duk_push_lightfunc_tostring(thr, tv);
 } else {
  goto type_error;
 }

 return 1;

type_error:
 do { do { duk_err_type_invalid_args(((thr)), "duk_bi_function.c", (duk_int_t) 162); } while (0); return 0; } while (0);
}





static __attribute__ ((unused)) duk_ret_t duk_bi_function_prototype_call(duk_hthread *thr) {



 do { (void) (thr); } while (0);
 return (-6);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_function_prototype_apply(duk_hthread *thr) {

 do { (void) (thr); } while (0);
 return (-6);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_reflect_apply(duk_hthread *thr) {

 do { (void) (thr); } while (0);
 return (-6);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_reflect_construct(duk_hthread *thr) {

 do { (void) (thr); } while (0);
 return (-6);
}







static __attribute__ ((unused)) duk_ret_t duk_bi_function_prototype_bind(duk_hthread *thr) {
 duk_hboundfunc *h_bound;
 duk_idx_t nargs;
 duk_idx_t bound_nargs;
 duk_int_t bound_len;
 duk_tval *tv_prevbound;
 duk_idx_t n_prevbound;
 duk_tval *tv_res;
 duk_tval *tv_tmp;






 nargs = duk_get_top(thr) - 1;
 if (nargs < 0) {
  nargs++;
  duk_push_undefined(thr);
 }
 do { } while (0);




 if (nargs > (duk_idx_t) 0x20000000UL) {
  do { do { do { duk_err_range((((thr))), "duk_bi_function.c", (duk_int_t) 227, ("invalid count")); } while (0); } while (0); return 0; } while (0);
 }

 duk_push_this(thr);
 duk_require_function((thr), (-1));


 do { } while (0);


 h_bound = duk_push_hboundfunc(thr);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
# 251 "duk_bi_function.c"
 tv_prevbound = 
# 251 "duk_bi_function.c" 3 4
               ((void *)0)
# 251 "duk_bi_function.c"
                   ;
 n_prevbound = 0;
 tv_tmp = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (0));
 do { *(&h_bound->this_binding) = *(tv_tmp); } while (0);
 tv_tmp = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-2));
 do { *(&h_bound->target) = *(tv_tmp); } while (0);

 if (((tv_tmp)->t == 9)) {
  duk_hobject *h_target;
  duk_hobject *bound_proto;

  h_target = ((tv_tmp)->v.hobject);
  do { } while (0);





  bound_proto = ((h_target)->prototype);
  do { duk_hthread *duk__thr = (thr); duk_hobject *duk__obj = ((duk_hobject *) h_bound); duk_hobject *duk__proto = (bound_proto); do { (void) (duk__thr); } while (0); do { } while (0); do { (duk__obj)->prototype = (duk__proto); } while (0); do { if ((duk__proto) != 
# 270 "duk_bi_function.c" 3 4
 ((void *)0)
# 270 "duk_bi_function.c"
 ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk__proto)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0); } while (0);







  if ((((&(h_target)->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)) {
   do { do { } while (0); (&((duk_hobject *) h_bound)->hdr)->h_flags |= ((1UL << (7 + (9)))); } while (0);
  }

  if ((((&(h_target)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0)) {
   duk_hboundfunc *h_boundtarget;

   h_boundtarget = (duk_hboundfunc *) (void *) h_target;




   do { } while (0)


                                                                                       ;

   do { *(&h_bound->target) = *(&h_boundtarget->target); } while (0);
   do { *(&h_bound->this_binding) = *(&h_boundtarget->this_binding); } while (0);

   tv_prevbound = h_boundtarget->args;
   n_prevbound = h_boundtarget->nargs;
  }
 } else {

  duk_hobject *bound_proto;

  do { } while (0);
  do { do { } while (0); (&((duk_hobject *) h_bound)->hdr)->h_flags |= ((1UL << (7 + (9)))); } while (0);
  bound_proto = thr->builtins[5];
  do { duk_hthread *duk__thr = (thr); duk_hobject *duk__obj = ((duk_hobject *) h_bound); duk_hobject *duk__proto = (bound_proto); do { (void) (duk__thr); } while (0); do { } while (0); do { (duk__obj)->prototype = (duk__proto); } while (0); do { if ((duk__proto) != 
# 308 "duk_bi_function.c" 3 4
 ((void *)0)
# 308 "duk_bi_function.c"
 ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk__proto)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0); } while (0);
 }

 do { duk_tval *duk__tv = ((&h_bound->target)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 do { duk_tval *duk__tv = ((&h_bound->this_binding)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);

 bound_nargs = n_prevbound + nargs;
 if (bound_nargs > (duk_idx_t) 0x20000000UL) {
  do { do { do { duk_err_range((((thr))), "duk_bi_function.c", (duk_int_t) 316, ("invalid count")); } while (0); } while (0); return 0; } while (0);
 }
 tv_res = (duk_tval *) duk_heap_mem_alloc_checked((thr), (((duk_size_t) bound_nargs) * sizeof(duk_tval)));
 do { } while (0);
 do { } while (0);
 do { } while (0);
 h_bound->args = tv_res;
 h_bound->nargs = bound_nargs;

 do { } while (0);
 duk_copy_tvals_incref(thr, tv_res, tv_prevbound, (duk_size_t) n_prevbound);
 do { } while (0);
 duk_copy_tvals_incref(thr, tv_res + n_prevbound, ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (1)), (duk_size_t) nargs);






 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (87))));
 bound_len = duk_get_int(thr, -1);
 if (bound_len < nargs) {
  bound_len = 0;
 } else {
  bound_len -= nargs;
 }
 if (sizeof(duk_int_t) > 4 && bound_len > (duk_int_t) 
# 342 "duk_bi_function.c" 3 4
                                                     (4294967295U)
# 342 "duk_bi_function.c"
                                                                   ) {
  bound_len = (duk_int_t) 
# 343 "duk_bi_function.c" 3 4
                         (4294967295U)
# 343 "duk_bi_function.c"
                                       ;
 }
 duk_pop(thr);
 do { } while (0);
 tv_tmp = thr->valstack_top++;
 do { } while (0);
 do { } while (0);
 do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((duk_double_t) ((duk_uint32_t) bound_len)); ; duk__tv = ((tv_tmp)); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0);
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (87)) << 8) + (duk_uint_t) (((1U << 2)))));



 duk_xdef_prop_stridx_thrower(thr, -1, 69);
 duk_xdef_prop_stridx_thrower(thr, -1, 67);


 duk_push_literal_raw((thr), ("bound "), sizeof(("bound ")) - 1U);
 duk_get_prop_stridx(thr, -3, 93);
 if (!duk_is_string_notsymbol(thr, -1)) {




  duk_pop(thr);
  duk_push_hstring_empty(thr);
 }
 duk_concat(thr, 2);
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (93)) << 8) + (duk_uint_t) (((1U << 2)))));

 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (94))));
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (94)) << 8) + (duk_uint_t) (((1U << 2)))));


 do { } while (0);

 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_native_function_length(duk_hthread *thr) {
 duk_tval *tv;
 duk_hnatfunc *h;
 duk_int16_t func_nargs;

 tv = duk_get_borrowed_this_tval(thr);
 do { } while (0);

 if (((tv)->t == 9)) {
  h = (duk_hnatfunc *) ((tv)->v.hobject);
  do { } while (0);
  if (!(((&((duk_hobject *) h)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)) {
   goto fail_type;
  }
  func_nargs = h->nargs;
  duk_push_int(thr, func_nargs == ((duk_int16_t) -1) ? 0 : func_nargs);
 } else if (((tv)->t == 6)) {
  duk_small_uint_t lf_flags;
  duk_small_uint_t lf_len;

  lf_flags = ((duk_small_uint_t) ((tv)->v_extra));
  lf_len = (((lf_flags) >> 4) & 0x0fU);
  duk_push_uint(thr, lf_len);
 } else {
  goto fail_type;
 }
 return 1;

fail_type:
 do { do { duk_err_type_invalid_args(((thr)), "duk_bi_function.c", (duk_int_t) 412); } while (0); return 0; } while (0);
}


static __attribute__ ((unused)) duk_ret_t duk_bi_native_function_name(duk_hthread *thr) {
 duk_tval *tv;
 duk_hnatfunc *h;

 tv = duk_get_borrowed_this_tval(thr);
 do { } while (0);

 if (((tv)->t == 9)) {
  h = (duk_hnatfunc *) ((tv)->v.hobject);
  do { } while (0);
  if (!(((&((duk_hobject *) h)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)) {
   goto fail_type;
  }



  duk_push_hstring_empty(thr);
 } else if (((tv)->t == 6)) {
  duk_push_lightfunc_name(thr, tv);
 } else {
  goto fail_type;
 }
 return 1;

fail_type:
 do { do { duk_err_type_invalid_args(((thr)), "duk_bi_function.c", (duk_int_t) 441); } while (0); return 0; } while (0);
}


static __attribute__ ((unused)) duk_ret_t duk_bi_function_prototype_hasinstance(duk_hthread *thr) {

 duk_bool_t ret;

 ret = duk_js_instanceof_ordinary(thr, ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (0)), (((void) 0), (thr)->valstack_bottom - 1));
 duk_push_boolean(thr, ret);
 return 1;
}
# 1 "duk_bi_global.c"
# 24 "duk_bi_global.c"
static const duk_uint8_t duk__encode_uriunescaped_table[16] = {
 ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))), ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))),
 ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))), ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))),
 ((duk_uint8_t) (((0) << 0) | ((1) << 1) | ((0) << 2) | ((1) << 3) | ((1) << 4) | ((0) << 5) | ((1) << 6) | ((1) << 7))), ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7))),
 ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7))), ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((0) << 4) | ((1) << 5) | ((0) << 6) | ((1) << 7))),
 ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7))), ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7))),
 ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7))), ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((1) << 7))),
 ((duk_uint8_t) (((0) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7))), ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7))),
 ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7))), ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((1) << 6) | ((0) << 7))),
};


static const duk_uint8_t duk__encode_uricomponent_unescaped_table[16] = {
 ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))), ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))),
 ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))), ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))),
 ((duk_uint8_t) (((0) << 0) | ((1) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((1) << 7))), ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((0) << 3) | ((0) << 4) | ((1) << 5) | ((1) << 6) | ((0) << 7))),
 ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7))), ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))),
 ((duk_uint8_t) (((0) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7))), ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7))),
 ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7))), ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((1) << 7))),
 ((duk_uint8_t) (((0) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7))), ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7))),
 ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7))), ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((1) << 6) | ((0) << 7))),
};


static const duk_uint8_t duk__decode_uri_reserved_table[16] = {
 ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))), ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))),
 ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))), ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))),
 ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((1) << 3) | ((1) << 4) | ((0) << 5) | ((1) << 6) | ((0) << 7))), ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((1) << 3) | ((1) << 4) | ((0) << 5) | ((0) << 6) | ((1) << 7))),
 ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))), ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((1) << 2) | ((1) << 3) | ((0) << 4) | ((1) << 5) | ((0) << 6) | ((1) << 7))),
 ((duk_uint8_t) (((1) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))), ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))),
 ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))), ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))),
 ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))), ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))),
 ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))), ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))),
};


static const duk_uint8_t duk__decode_uri_component_reserved_table[16] = {
 ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))), ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))),
 ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))), ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))),
 ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))), ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))),
 ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))), ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))),
 ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))), ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))),
 ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))), ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))),
 ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))), ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))),
 ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))), ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))),
};



static const duk_uint8_t duk__escape_unescaped_table[16] = {
 ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))), ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))),
 ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))), ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))),
 ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))), ((duk_uint8_t) (((0) << 0) | ((0) << 1) | ((1) << 2) | ((1) << 3) | ((0) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7))),
 ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7))), ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((0) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7))),
 ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7))), ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7))),
 ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7))), ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((1) << 7))),
 ((duk_uint8_t) (((0) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7))), ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7))),
 ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((1) << 3) | ((1) << 4) | ((1) << 5) | ((1) << 6) | ((1) << 7))), ((duk_uint8_t) (((1) << 0) | ((1) << 1) | ((1) << 2) | ((0) << 3) | ((0) << 4) | ((0) << 5) | ((0) << 6) | ((0) << 7)))
};


typedef struct {
 duk_hthread *thr;
 duk_hstring *h_str;
 duk_bufwriter_ctx bw;
 const duk_uint8_t *p;
 const duk_uint8_t *p_start;
 const duk_uint8_t *p_end;
} duk__transform_context;

typedef void (*duk__transform_callback)(duk__transform_context *tfm_ctx, const void *udata, duk_codepoint_t cp);


static duk_small_int_t duk__decode_hex_escape(const duk_uint8_t *p, duk_small_int_t n) {
 duk_small_int_t ch;
 duk_small_int_t t = 0;

 while (n > 0) {
  t = t * 16;
  ch = (duk_small_int_t) duk_hex_dectab[*p++];
  if (__builtin_expect((ch >= 0), 1)) {
   t += ch;
  } else {
   return -1;
  }
  n--;
 }
 return t;
}

static int duk__transform_helper(duk_hthread *thr, duk__transform_callback callback, const void *udata) {
 duk__transform_context tfm_ctx_alloc;
 duk__transform_context *tfm_ctx = &tfm_ctx_alloc;
 duk_codepoint_t cp;

 tfm_ctx->thr = thr;

 tfm_ctx->h_str = duk_to_hstring(thr, 0);
 do { } while (0);

 do { duk_bw_init_pushbuf((thr), (&tfm_ctx->bw), (((tfm_ctx->h_str)->blen))); } while (0);

 tfm_ctx->p_start = ((const duk_uint8_t *) ((tfm_ctx->h_str) + 1));
 tfm_ctx->p_end = tfm_ctx->p_start + ((tfm_ctx->h_str)->blen);
 tfm_ctx->p = tfm_ctx->p_start;

 while (tfm_ctx->p < tfm_ctx->p_end) {
  cp = (duk_codepoint_t) duk_unicode_decode_xutf8_checked(thr, &tfm_ctx->p, tfm_ctx->p_start, tfm_ctx->p_end);
  callback(tfm_ctx, udata, cp);
 }

 do { duk_bw_compact((thr), (&tfm_ctx->bw)); } while (0);

 (void) duk_buffer_to_string(thr, -1);
 return 1;
}

static void duk__transform_callback_encode_uri(duk__transform_context *tfm_ctx, const void *udata, duk_codepoint_t cp) {
 duk_uint8_t xutf8_buf[7];
 duk_small_int_t len;
 duk_codepoint_t cp1, cp2;
 duk_small_int_t i, t;
 const duk_uint8_t *unescaped_table = (const duk_uint8_t *) udata;





 do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (3 * 7); duk__space = (duk_size_t) ((&tfm_ctx->bw)->p_limit - (&tfm_ctx->bw)->p); if (duk__space < duk__sz) { (void) duk_bw_resize((tfm_ctx->thr), (&tfm_ctx->bw), duk__sz); } } while (0);

 if (cp < 0) {
  goto uri_error;
 } else if ((cp < 0x80L) && ((unescaped_table)[(cp) >> 3] & (1 << ((cp) &0x07)))) {
  do { do { (((void) 0), ((void) 0)); } while (0); *(&tfm_ctx->bw)->p++ = (duk_uint8_t) ((duk_uint8_t) cp); } while (0);
  return;
 } else if (cp >= 0xdc00L && cp <= 0xdfffL) {
  goto uri_error;
 } else if (cp >= 0xd800L && cp <= 0xdbffL) {

  if (duk_unicode_decode_xutf8(tfm_ctx->thr,
                               &tfm_ctx->p,
                               tfm_ctx->p_start,
                               tfm_ctx->p_end,
                               (duk_ucodepoint_t *) &cp2) == 0) {
   goto uri_error;
  }
  if (!(cp2 >= 0xdc00L && cp2 <= 0xdfffL)) {
   goto uri_error;
  }
  cp1 = cp;
  cp = (duk_codepoint_t) (((cp1 - 0xd800L) << 10) + (cp2 - 0xdc00L) + 0x10000L);
 } else if (cp > 0x10ffffL) {






  goto uri_error;
 } else {




  ;
 }

 len = duk_unicode_encode_xutf8((duk_ucodepoint_t) cp, xutf8_buf);
 for (i = 0; i < len; i++) {
  t = (duk_small_int_t) xutf8_buf[i];
  do { duk_uint8_t *duk__p; do { (((void) 0), ((void) 0)); } while (0); duk__p = (&tfm_ctx->bw)->p; *duk__p++ = (duk_uint8_t) (0x25); *duk__p++ = (duk_uint8_t) ((duk_uint8_t) duk_uc_nybbles[t >> 4]); *duk__p++ = (duk_uint8_t) ((duk_uint8_t) duk_uc_nybbles[t & 0x0f]); (&tfm_ctx->bw)->p = duk__p; } while (0)



                                                               ;
 }

 return;

uri_error:
 do { do { duk_errcode_t duk__err = (7); duk_int_t duk__line = (duk_int_t) 204; do { } while (0); do { } while (0); duk_err_handle_error(((tfm_ctx->thr)), "duk_bi_global.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid input"))); } while (0); } while (0);
 do { return; } while (0);
}

static void duk__transform_callback_decode_uri(duk__transform_context *tfm_ctx, const void *udata, duk_codepoint_t cp) {
 const duk_uint8_t *reserved_table = (const duk_uint8_t *) udata;
 duk_small_uint_t utf8_blen;
 duk_codepoint_t min_cp;
 duk_small_int_t t;
 duk_small_uint_t i;




 do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = ((7 >= 2 * 3 ? 7 : 3)); duk__space = (duk_size_t) ((&tfm_ctx->bw)->p_limit - (&tfm_ctx->bw)->p); if (duk__space < duk__sz) { (void) duk_bw_resize((tfm_ctx->thr), (&tfm_ctx->bw), duk__sz); } } while (0)


                                                                                                                                ;

 if (cp == (duk_codepoint_t) '%') {
  const duk_uint8_t *p = tfm_ctx->p;
  duk_size_t left = (duk_size_t) (tfm_ctx->p_end - p);

  do { } while (0);

  if (left < 2) {
   goto uri_error;
  }

  t = duk__decode_hex_escape(p, 2);
  do { } while (0);
  if (t < 0) {
   goto uri_error;
  }

  if (t < 0x80) {
   if (((reserved_table)[(t) >> 3] & (1 << ((t) &0x07)))) {

    do { } while (0);
    do { duk_uint8_t *duk__p; do { (((void) 0), ((void) 0)); } while (0); duk__p = (&tfm_ctx->bw)->p; *duk__p++ = (duk_uint8_t) (0x25); *duk__p++ = (duk_uint8_t) (p[0]); *duk__p++ = (duk_uint8_t) (p[1]); (&tfm_ctx->bw)->p = duk__p; } while (0);
   } else {
    do { do { (((void) 0), ((void) 0)); } while (0); *(&tfm_ctx->bw)->p++ = (duk_uint8_t) ((duk_uint8_t) t); } while (0);
   }
   tfm_ctx->p += 2;
   return;
  }
# 260 "duk_bi_global.c"
  do { } while (0);
  if (t < 0xc0) {

   goto uri_error;
  } else if (t < 0xe0) {

   utf8_blen = 2;
   min_cp = 0x80L;
   cp = t & 0x1f;
  } else if (t < 0xf0) {

   utf8_blen = 3;
   min_cp = 0x800L;
   cp = t & 0x0f;
  } else if (t < 0xf8) {

   utf8_blen = 4;
   min_cp = 0x10000L;
   cp = t & 0x07;
  } else {

   goto uri_error;
  }

  if (left < utf8_blen * 3 - 1) {

   goto uri_error;
  }

  p += 3;
  for (i = 1; i < utf8_blen; i++) {

   t = duk__decode_hex_escape(p, 2);
   do { } while (0)



                                           ;
   if (t < 0) {
    goto uri_error;
   }
   if ((t & 0xc0) != 0x80) {
    goto uri_error;
   }
   cp = (cp << 6) + (t & 0x3f);
   p += 3;
  }
  p--;
  tfm_ctx->p = p;

  do { } while (0);

  if (cp < min_cp || cp > 0x10ffffL || (cp >= 0xd800L && cp <= 0xdfffL)) {
   goto uri_error;
  }
# 325 "duk_bi_global.c"
  do { } while (0);

  if (cp >= 0x10000L) {
   cp -= 0x10000L;
   do { } while (0);

   do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) (((cp >> 10) + 0xd800L)); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_xutf8(duk__cp, (&tfm_ctx->bw)->p); (&tfm_ctx->bw)->p += duk__enc_len; } while (0);
   do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) (((cp & 0x03ffL) + 0xdc00L)); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_xutf8(duk__cp, (&tfm_ctx->bw)->p); (&tfm_ctx->bw)->p += duk__enc_len; } while (0);
  } else {
   do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) (cp); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_xutf8(duk__cp, (&tfm_ctx->bw)->p); (&tfm_ctx->bw)->p += duk__enc_len; } while (0);
  }
 } else {
  do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) (cp); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_xutf8(duk__cp, (&tfm_ctx->bw)->p); (&tfm_ctx->bw)->p += duk__enc_len; } while (0);
 }
 return;

uri_error:
 do { do { duk_errcode_t duk__err = (7); duk_int_t duk__line = (duk_int_t) 342; do { } while (0); do { } while (0); duk_err_handle_error(((tfm_ctx->thr)), "duk_bi_global.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid input"))); } while (0); } while (0);
 do { return; } while (0);
}


static void duk__transform_callback_escape(duk__transform_context *tfm_ctx, const void *udata, duk_codepoint_t cp) {
 do { (void) (udata); } while (0);

 do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (6); duk__space = (duk_size_t) ((&tfm_ctx->bw)->p_limit - (&tfm_ctx->bw)->p); if (duk__space < duk__sz) { (void) duk_bw_resize((tfm_ctx->thr), (&tfm_ctx->bw), duk__sz); } } while (0);

 if (cp < 0) {
  goto esc_error;
 } else if ((cp < 0x80L) && ((duk__escape_unescaped_table)[(cp) >> 3] & (1 << ((cp) &0x07)))) {
  do { do { (((void) 0), ((void) 0)); } while (0); *(&tfm_ctx->bw)->p++ = (duk_uint8_t) ((duk_uint8_t) cp); } while (0);
 } else if (cp < 0x100L) {
  do { duk_uint8_t *duk__p; do { (((void) 0), ((void) 0)); } while (0); duk__p = (&tfm_ctx->bw)->p; *duk__p++ = (duk_uint8_t) ((duk_uint8_t) 0x25); *duk__p++ = (duk_uint8_t) ((duk_uint8_t) duk_uc_nybbles[cp >> 4]); *duk__p++ = (duk_uint8_t) ((duk_uint8_t) duk_uc_nybbles[cp & 0x0f]); (&tfm_ctx->bw)->p = duk__p; } while (0)



                                                                ;
 } else if (cp < 0x10000L) {
  do { duk_uint8_t *duk__p; do { (((void) 0), ((void) 0)); } while (0); duk__p = (&tfm_ctx->bw)->p; *duk__p++ = (duk_uint8_t) ((duk_uint8_t) 0x25); *duk__p++ = (duk_uint8_t) ((duk_uint8_t) 0x75); *duk__p++ = (duk_uint8_t) ((duk_uint8_t) duk_uc_nybbles[cp >> 12]); *duk__p++ = (duk_uint8_t) ((duk_uint8_t) duk_uc_nybbles[(cp >> 8) & 0x0f]); *duk__p++ = (duk_uint8_t) ((duk_uint8_t) duk_uc_nybbles[(cp >> 4) & 0x0f]); *duk__p++ = (duk_uint8_t) ((duk_uint8_t) duk_uc_nybbles[cp & 0x0f]); (&tfm_ctx->bw)->p = duk__p; } while (0)






                                                                ;
 } else {





  goto esc_error;
 }

 return;

esc_error:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 383; do { } while (0); do { } while (0); duk_err_handle_error(((tfm_ctx->thr)), "duk_bi_global.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid input"))); } while (0); } while (0);
 do { return; } while (0);
}

static void duk__transform_callback_unescape(duk__transform_context *tfm_ctx, const void *udata, duk_codepoint_t cp) {
 duk_small_int_t t;

 do { (void) (udata); } while (0);

 if (cp == (duk_codepoint_t) '%') {
  const duk_uint8_t *p = tfm_ctx->p;
  duk_size_t left = (duk_size_t) (tfm_ctx->p_end - p);

  if (left >= 5 && p[0] == 'u' && ((t = duk__decode_hex_escape(p + 1, 4)) >= 0)) {
   cp = (duk_codepoint_t) t;
   tfm_ctx->p += 5;
  } else if (left >= 2 && ((t = duk__decode_hex_escape(p, 2)) >= 0)) {
   cp = (duk_codepoint_t) t;
   tfm_ctx->p += 2;
  }
 }

 do { do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (7); duk__space = (duk_size_t) (((&tfm_ctx->bw))->p_limit - ((&tfm_ctx->bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((tfm_ctx->thr)), ((&tfm_ctx->bw)), duk__sz); } } while (0); do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) ((cp)); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_xutf8(duk__cp, ((&tfm_ctx->bw))->p); ((&tfm_ctx->bw))->p += duk__enc_len; } while (0); } while (0);
}
# 420 "duk_bi_global.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_eval(duk_hthread *thr) {
 duk_hstring *h;
 duk_activation *act_caller;
 duk_activation *act_eval;
 duk_hcompfunc *func;
 duk_hobject *outer_lex_env;
 duk_hobject *outer_var_env;
 duk_bool_t this_to_global = 1;
 duk_small_uint_t comp_flags;
 duk_int_t level = -2;
 duk_small_uint_t call_flags;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0)
                                      ;
# 446 "duk_bi_global.c"
 h = duk_get_hstring_notsymbol(thr, 0);
 if (!h) {

  return 1;
 }
# 465 "duk_bi_global.c"
 comp_flags = (1U << 3);
 act_eval = thr->callstack_curr;
 do { } while (0);
 act_caller = duk_hthread_get_activation_for_level(thr, level);
 if (act_caller != 
# 469 "duk_bi_global.c" 3 4
                  ((void *)0)
# 469 "duk_bi_global.c"
                      ) {



  if ((act_caller->flags & (1U << 0)) && (act_eval->flags & (1U << 4))) {



   comp_flags |= (1U << 5);
  }
 } else {
  do { } while (0);
 }

 duk_push_hstring_stridx(thr, 108);
 duk_js_compile(thr, (const duk_uint8_t *) ((const duk_uint8_t *) ((h) + 1)), (duk_size_t) ((h)->blen), comp_flags);
 func = (duk_hcompfunc *) duk_known_hobject(thr, -1);
 do { } while (0);





 if (act_eval->flags & (1U << 4)) {
  do { } while (0);
  do { } while (0);
  if (act_caller->lex_env == 
# 495 "duk_bi_global.c" 3 4
                            ((void *)0)
# 495 "duk_bi_global.c"
                                ) {
   do { } while (0);
   do { } while (0);


   duk_js_init_activation_environment_records_delayed(thr, act_caller);
  }
  do { } while (0);
  do { } while (0);

  this_to_global = 0;

  if ((((&((duk_hobject *) func)->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)) {
   duk_hdecenv *new_env;
   duk_hobject *act_lex_env;

   do { } while (0)

                                                                 ;

   act_lex_env = act_caller->lex_env;

   new_env =
       duk_hdecenv_alloc(thr,
                         (1UL << (7 + (0))) | (((duk_uint_t) (16)) << (7 + (20))));
   do { } while (0);
   duk_push_hobject(thr, (duk_hobject *) new_env);

   do { } while (0);
   do { ((duk_hobject *) new_env)->prototype = (act_lex_env); } while (0);
   do { if ((act_lex_env) != 
# 525 "duk_bi_global.c" 3 4
  ((void *)0)
# 525 "duk_bi_global.c"
  ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((act_lex_env)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0);
   do { } while (0);

   outer_lex_env = (duk_hobject *) new_env;
   outer_var_env = (duk_hobject *) new_env;

   duk_insert(thr, 0);


   do { } while (0);
  } else {
   do { } while (0)

                                                                 ;

   outer_lex_env = act_caller->lex_env;
   outer_var_env = act_caller->var_env;


   do { } while (0);
  }
 } else {
  do { } while (0)
                                                                       ;

  this_to_global = 1;
  outer_lex_env = thr->builtins[1];
  outer_var_env = thr->builtins[1];
 }


 duk_js_push_closure(thr, func, outer_var_env, outer_lex_env, 0 );



 if (this_to_global) {
  do { } while (0);
  duk_push_hobject_bidx(thr, 0);
 } else {
  duk_tval *tv;
  do { } while (0);
  do { } while (0);
  tv = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + act_caller->bottom_byteoff -
                              sizeof(duk_tval));
  do { } while (0);
  duk_push_tval(thr, tv);
 }

 do { } while (0)


                                             ;



 call_flags = 0;
 if (act_eval->flags & (1U << 4)) {






  call_flags |= (1U << 4);
 }
 duk_handle_call_unprotected_nargs(thr, 0, call_flags);



 return 1;
}






static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_parse_int(duk_hthread *thr) {
 duk_int32_t radix;
 duk_small_uint_t s2n_flags;

 do { } while (0);
 duk_to_string(thr, 0);

 radix = duk_to_int32(thr, 1);




 s2n_flags = (1U << 0) | (1U << 2) | (1U << 3) | (1U << 4) |
             (1U << 10) | (1U << 11);
# 624 "duk_bi_global.c"
 if (radix != 0) {
  if (radix < 2 || radix > 36) {
   goto ret_nan;
  }
  if (radix != 16) {
   s2n_flags &= ~(1U << 11);
  }
 } else {
  radix = 10;
 }

 duk_dup_0(thr);
 duk_numconv_parse(thr, (duk_small_int_t) radix, s2n_flags);
 return 1;

ret_nan:
 duk_push_nan(thr);
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_parse_float(duk_hthread *thr) {
 duk_small_uint_t s2n_flags;

 do { } while (0);
 duk_to_string(thr, 0);


 s2n_flags = (1U << 0) | (1U << 1) | (1U << 2) | (1U << 3) |
             (1U << 4) | (1U << 5) | (1U << 6) | (1U << 7) |
             (1U << 8) | (1U << 10);

 duk_numconv_parse(thr, 10 , s2n_flags);
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_is_nan(duk_hthread *thr) {
 duk_double_t d = duk_to_number(thr, 0);
 duk_push_boolean(thr, (duk_bool_t) 
# 669 "duk_bi_global.c" 3 4
                                   __builtin_isnan (
# 669 "duk_bi_global.c"
                                   d
# 669 "duk_bi_global.c" 3 4
                                   )
# 669 "duk_bi_global.c"
                                               );
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_is_finite(duk_hthread *thr) {
 duk_double_t d = duk_to_number(thr, 0);
 duk_push_boolean(thr, (duk_bool_t) 
# 677 "duk_bi_global.c" 3 4
                                   __builtin_isfinite (
# 677 "duk_bi_global.c"
                                   d
# 677 "duk_bi_global.c" 3 4
                                   )
# 677 "duk_bi_global.c"
                                                  );
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_decode_uri(duk_hthread *thr) {
 return duk__transform_helper(thr, duk__transform_callback_decode_uri, (const void *) duk__decode_uri_reserved_table);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_decode_uri_component(duk_hthread *thr) {
 return duk__transform_helper(thr,
                              duk__transform_callback_decode_uri,
                              (const void *) duk__decode_uri_component_reserved_table);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_encode_uri(duk_hthread *thr) {
 return duk__transform_helper(thr, duk__transform_callback_encode_uri, (const void *) duk__encode_uriunescaped_table);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_encode_uri_component(duk_hthread *thr) {
 return duk__transform_helper(thr,
                              duk__transform_callback_encode_uri,
                              (const void *) duk__encode_uricomponent_unescaped_table);
}


static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_escape(duk_hthread *thr) {
 return duk__transform_helper(thr, duk__transform_callback_escape, (const void *) 
# 709 "duk_bi_global.c" 3 4
                                                                                 ((void *)0)
# 709 "duk_bi_global.c"
                                                                                     );
}

static __attribute__ ((unused)) duk_ret_t duk_bi_global_object_unescape(duk_hthread *thr) {
 return duk__transform_helper(thr, duk__transform_callback_unescape, (const void *) 
# 713 "duk_bi_global.c" 3 4
                                                                                   ((void *)0)
# 713 "duk_bi_global.c"
                                                                                       );
}
# 1 "duk_bi_json.c"
# 31 "duk_bi_json.c"
static void duk__json_dec_syntax_error(duk_json_dec_ctx *js_ctx);
static void duk__json_dec_eat_white(duk_json_dec_ctx *js_ctx);

static duk_uint8_t duk__json_dec_peek(duk_json_dec_ctx *js_ctx);

static duk_uint8_t duk__json_dec_get(duk_json_dec_ctx *js_ctx);
static duk_uint8_t duk__json_dec_get_nonwhite(duk_json_dec_ctx *js_ctx);
static duk_uint_fast32_t duk__json_dec_decode_hex_escape(duk_json_dec_ctx *js_ctx, duk_small_uint_t n);
static void duk__json_dec_req_stridx(duk_json_dec_ctx *js_ctx, duk_small_uint_t stridx);
static void duk__json_dec_string(duk_json_dec_ctx *js_ctx);

static void duk__json_dec_plain_string(duk_json_dec_ctx *js_ctx);
static void duk__json_dec_pointer(duk_json_dec_ctx *js_ctx);
static void duk__json_dec_buffer(duk_json_dec_ctx *js_ctx);

static void duk__json_dec_number(duk_json_dec_ctx *js_ctx);
static void duk__json_dec_objarr_entry(duk_json_dec_ctx *js_ctx);
static void duk__json_dec_objarr_exit(duk_json_dec_ctx *js_ctx);
static void duk__json_dec_object(duk_json_dec_ctx *js_ctx);
static void duk__json_dec_array(duk_json_dec_ctx *js_ctx);
static void duk__json_dec_value(duk_json_dec_ctx *js_ctx);
static void duk__json_dec_reviver_walk(duk_json_dec_ctx *js_ctx);

static void duk__emit_1(duk_json_enc_ctx *js_ctx, duk_uint_fast8_t ch);
static void duk__emit_2(duk_json_enc_ctx *js_ctx, duk_uint_fast8_t ch1, duk_uint_fast8_t ch2);
static void duk__unemit_1(duk_json_enc_ctx *js_ctx);
static void duk__emit_hstring(duk_json_enc_ctx *js_ctx, duk_hstring *h);



static void duk__emit_stridx(duk_json_enc_ctx *js_ctx, duk_small_uint_t stridx);
static duk_uint8_t *duk__emit_esc_auto_fast(duk_json_enc_ctx *js_ctx, duk_uint_fast32_t cp, duk_uint8_t *q);
static void duk__json_enc_key_autoquote(duk_json_enc_ctx *js_ctx, duk_hstring *k);
static void duk__json_enc_quote_string(duk_json_enc_ctx *js_ctx, duk_hstring *h_str);
static void duk__json_enc_objarr_entry(duk_json_enc_ctx *js_ctx, duk_idx_t *entry_top);
static void duk__json_enc_objarr_exit(duk_json_enc_ctx *js_ctx, duk_idx_t *entry_top);
static void duk__json_enc_object(duk_json_enc_ctx *js_ctx);
static void duk__json_enc_array(duk_json_enc_ctx *js_ctx);
static duk_bool_t duk__json_enc_value(duk_json_enc_ctx *js_ctx, duk_idx_t idx_holder);
static duk_bool_t duk__json_enc_allow_into_proplist(duk_tval *tv);
static void duk__json_enc_double(duk_json_enc_ctx *js_ctx);




static void duk__json_enc_buffer_jx_jc(duk_json_enc_ctx *js_ctx, duk_hbuffer *h);
static void duk__json_enc_pointer(duk_json_enc_ctx *js_ctx, void *ptr);

static void duk__json_enc_bufobj(duk_json_enc_ctx *js_ctx, duk_hbufobj *h_bufobj);





static void duk__json_enc_newline_indent(duk_json_enc_ctx *js_ctx, duk_uint_t depth);






static const duk_uint8_t duk__json_quotestr_lookup[256] = {






 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xe2, 0xf4, 0xee, 0x80, 0xe6, 0xf2, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x20, 0x21, 0xa2, 0x23, 0x24, 0x25, 0x26, 0x27,
 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,
 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0xdc, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,
 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81,
 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81
};







static const duk_uint8_t duk__json_decstr_lookup[256] = {



 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x21, 0x00, 0x23, 0x24, 0x25, 0x26, 0x27,
 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,
 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x00, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63,
 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b,
 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,
 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7,
 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb,
 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
};



static const duk_uint8_t duk__json_eatwhite_lookup[256] = {



 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};



static const duk_uint8_t duk__json_decnumber_lookup[256] = {



 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
# 195 "duk_bi_json.c"
static void duk__json_dec_syntax_error(duk_json_dec_ctx *js_ctx) {




 do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 200; do { } while (0); do { } while (0); duk_err_handle_error_fmt((js_ctx->thr), "duk_bi_json.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("invalid json (at offset %ld)"), ((long) (js_ctx->p - js_ctx->p_start))); } while (0);
 do { return; } while (0);
}

static void duk__json_dec_eat_white(duk_json_dec_ctx *js_ctx) {
 const duk_uint8_t *p;
 duk_uint8_t t;

 p = js_ctx->p;
 for (;;) {
  do { } while (0);
  t = *p;





  do { } while (0);
  if (duk__json_eatwhite_lookup[t] == 0) {
   break;
  }
# 229 "duk_bi_json.c"
  p++;
 }
 js_ctx->p = p;
}


static duk_uint8_t duk__json_dec_peek(duk_json_dec_ctx *js_ctx) {
 do { } while (0);
 return *js_ctx->p;
}


static duk_uint8_t duk__json_dec_get(duk_json_dec_ctx *js_ctx) {
 do { } while (0);
 return *js_ctx->p++;
}

static duk_uint8_t duk__json_dec_get_nonwhite(duk_json_dec_ctx *js_ctx) {
 duk__json_dec_eat_white(js_ctx);
 return duk__json_dec_get(js_ctx);
}


static duk_uint_fast32_t duk__json_dec_decode_hex_escape(duk_json_dec_ctx *js_ctx, duk_small_uint_t n) {
 duk_small_uint_t i;
 duk_uint_fast32_t res = 0;
 duk_uint8_t x;
 duk_small_int_t t;

 for (i = 0; i < n; i++) {


  x = duk__json_dec_get(js_ctx);
  do { } while (0);


  do { } while (0);
  t = duk_hex_dectab[x & 0xff];
  if (__builtin_expect((t >= 0), 1)) {
   res = (res * 16) + (duk_uint_fast32_t) t;
  } else {

   goto syntax_error;
  }
 }

 do { } while (0);
 return res;

syntax_error:
 duk__json_dec_syntax_error(js_ctx);
 do { __builtin_unreachable(); } while (0);
 return 0;
}

static void duk__json_dec_req_stridx(duk_json_dec_ctx *js_ctx, duk_small_uint_t stridx) {
 duk_hstring *h;
 const duk_uint8_t *p;
 duk_uint8_t x, y;






 do { } while (0);
 h = ((js_ctx->thr)->strs[(stridx)]);
 do { } while (0);

 p = (const duk_uint8_t *) ((const duk_uint8_t *) ((h) + 1)) + 1;
 do { } while (0);

 for (;;) {
  x = *p;
  if (x == 0) {
   break;
  }
  y = duk__json_dec_get(js_ctx);
  if (x != y) {

   goto syntax_error;
  }
  p++;
 }

 return;

syntax_error:
 duk__json_dec_syntax_error(js_ctx);
 do { __builtin_unreachable(); } while (0);
}

static duk_small_int_t duk__json_dec_string_escape(duk_json_dec_ctx *js_ctx, duk_uint8_t **ext_p) {
 duk_uint_fast32_t cp;





 cp = (duk_uint_fast32_t) duk__json_dec_get(js_ctx);
 switch (cp) {
 case 0x5c:
  break;
 case 0x22:
  break;
 case 0x2f:
  break;
 case 0x74:
  cp = 0x09;
  break;
 case 0x6e:
  cp = 0x0a;
  break;
 case 0x72:
  cp = 0x0d;
  break;
 case 0x66:
  cp = 0x0c;
  break;
 case 0x62:
  cp = 0x08;
  break;
 case 0x75: {
  cp = duk__json_dec_decode_hex_escape(js_ctx, 4);
  break;
 }

 case 0x55: {
  if (js_ctx->flag_ext_custom) {
   cp = duk__json_dec_decode_hex_escape(js_ctx, 8);
  } else {
   return 1;
  }
  break;
 }
 case 0x78: {
  if (js_ctx->flag_ext_custom) {
   cp = duk__json_dec_decode_hex_escape(js_ctx, 2);
  } else {
   return 1;
  }
  break;
 }

 default:

  return 1;
 }

 duk_raw_writeinc_xutf8(&(*ext_p), (duk_ucodepoint_t) (cp));

 return 0;
}

static void duk__json_dec_string(duk_json_dec_ctx *js_ctx) {
 duk_hthread *thr = js_ctx->thr;
 duk_bufwriter_ctx bw_alloc;
 duk_bufwriter_ctx *bw;
 duk_uint8_t *q;
# 396 "duk_bi_json.c"
 bw = &bw_alloc;
 do { duk_bw_init_pushbuf((js_ctx->thr), (bw), (128)); } while (0);
 q = ((bw)->p);


 for (;;) {
  duk_small_uint_t safe;
  duk_uint8_t b, x;
  const duk_uint8_t *p;







  safe = 64;


  q = (((duk_size_t) ((bw)->p_limit - (q)) >= (safe + 7)) ? (q) : ((bw)->p = (q), duk_bw_resize((js_ctx->thr), (bw), (safe + 7))));

  p = js_ctx->p;
  for (;;) {
   if (safe == 0) {
    js_ctx->p = p;
    break;
   }
   safe--;


   do { } while (0);

   b = *p++;
   x = (duk_small_int_t) duk__json_decstr_lookup[b];
   if (__builtin_expect((x != 0), 1)) {

    *q++ = b;
   } else if (b == 0x22) {
    js_ctx->p = p;
    goto found_quote;
   } else if (b == 0x5c) {




    js_ctx->p = p;
    if (duk__json_dec_string_escape(js_ctx, &q) != 0) {
     goto syntax_error;
    }
    break;
   } else {
    js_ctx->p = p;
    goto syntax_error;
   }
  }
 }
found_quote:
# 476 "duk_bi_json.c"
 do { (bw)->p = (q); duk_bw_compact((js_ctx->thr), (bw)); } while (0);
 (void) duk_buffer_to_string(thr, -1);



 return;

syntax_error:
 duk__json_dec_syntax_error(js_ctx);
 do { __builtin_unreachable(); } while (0);
}





static void duk__json_dec_plain_string(duk_json_dec_ctx *js_ctx) {
 duk_hthread *thr = js_ctx->thr;
 const duk_uint8_t *p;
 duk_small_int_t x;



 js_ctx->p--;
 p = js_ctx->p;
# 511 "duk_bi_json.c"
 for (;;) {
  x = *p;







  if (!duk_unicode_is_identifier_part((duk_codepoint_t) x)) {
   break;
  }
  p++;
 }

 duk_push_lstring(thr, (const char *) js_ctx->p, (duk_size_t) (p - js_ctx->p));
 js_ctx->p = p;


}



static void duk__json_dec_pointer(duk_json_dec_ctx *js_ctx) {
 duk_hthread *thr = js_ctx->thr;
 const duk_uint8_t *p;
 duk_small_int_t x;
 void *voidptr;



 p = js_ctx->p;

 for (;;) {
  x = *p;





  if (x == 0x29) {
   break;
  } else if (x <= 0) {

   goto syntax_error;
  }
  p++;
 }
# 571 "duk_bi_json.c"
 voidptr = 
# 571 "duk_bi_json.c" 3 4
          ((void *)0)
# 571 "duk_bi_json.c"
              ;
 (void) sscanf((const char *) js_ctx->p, "%p", &voidptr);
 duk_push_pointer(thr, voidptr);
 js_ctx->p = p + 1;



 return;

syntax_error:
 duk__json_dec_syntax_error(js_ctx);
 do { __builtin_unreachable(); } while (0);
}



static void duk__json_dec_buffer(duk_json_dec_ctx *js_ctx) {
 duk_hthread *thr = js_ctx->thr;
 const duk_uint8_t *p;
 duk_uint8_t *buf;
 duk_size_t src_len;
 duk_small_int_t x;



 p = js_ctx->p;
# 610 "duk_bi_json.c"
 for (;;) {
  x = *p;




  if (x == 0x7c) {
   break;
  } else if (x <= 0) {

   goto syntax_error;
  }
  p++;
 }


 src_len = (duk_size_t) (p - js_ctx->p);
 buf = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, src_len);
 do { } while (0);
 do { void *duk__dst = ((void *) buf); const void *duk__src = ((const void *) js_ctx->p); duk_size_t duk__len = (src_len); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 duk_hex_decode(thr, -1);

 js_ctx->p = p + 1;



 return;

syntax_error:
 duk__json_dec_syntax_error(js_ctx);
 do { __builtin_unreachable(); } while (0);
}



static void duk__json_dec_number(duk_json_dec_ctx *js_ctx) {
 duk_hthread *thr = js_ctx->thr;
 const duk_uint8_t *p_start;
 const duk_uint8_t *p;
 duk_uint8_t x;
 duk_small_uint_t s2n_flags;

 do { } while (0);

 p_start = js_ctx->p;





 p = js_ctx->p;
 for (;;) {
  x = *p;

  do { } while (0)



                                 ;





  do { } while (0);
  if (duk__json_decnumber_lookup[x] == 0) {
   break;
  }
# 687 "duk_bi_json.c"
  p++;
 }
 js_ctx->p = p;

 do { } while (0);
 duk_push_lstring(thr, (const char *) p_start, (duk_size_t) (p - p_start));

 s2n_flags = (1U << 1) | (1U << 4) |
             (1U << 6);

 do { } while (0);
 duk_numconv_parse(thr, 10 , s2n_flags);
 if (duk_is_nan(thr, -1)) {
  duk__json_dec_syntax_error(js_ctx);
 }
 do { } while (0);
 do { } while (0);


}

static void duk__json_dec_objarr_entry(duk_json_dec_ctx *js_ctx) {
 duk_hthread *thr = js_ctx->thr;
 duk_require_stack(thr, 32);



 duk_native_stack_check(thr);

 do { } while (0);
 do { } while (0);
 if (js_ctx->recursion_depth >= js_ctx->recursion_limit) {
  do { duk_err_range((thr), "duk_bi_json.c", (duk_int_t) 719, ("decode recursion limit")); } while (0);
  do { return; } while (0);
 }
 js_ctx->recursion_depth++;
}

static void duk__json_dec_objarr_exit(duk_json_dec_ctx *js_ctx) {


 do { } while (0);
 do { } while (0);
 js_ctx->recursion_depth--;
}

static void duk__json_dec_object(duk_json_dec_ctx *js_ctx) {
 duk_hthread *thr = js_ctx->thr;
 duk_int_t key_count;
 duk_uint8_t x;

 do { } while (0);

 duk__json_dec_objarr_entry(js_ctx);

 duk_push_object(thr);



 key_count = 0;
 for (;;) {
  x = duk__json_dec_get_nonwhite(js_ctx);

  do { } while (0)


                                         ;



  if (x == 0x2c && key_count > 0) {

   x = duk__json_dec_get_nonwhite(js_ctx);
  } else if (x == 0x7d) {

   break;
  } else if (key_count == 0) {



   ;
  } else {

   goto syntax_error;
  }



  if (x == 0x22) {
   duk__json_dec_string(js_ctx);

  } else if (js_ctx->flag_ext_custom && duk_unicode_is_identifier_start((duk_codepoint_t) x)) {
   duk__json_dec_plain_string(js_ctx);

  } else {
   goto syntax_error;
  }



  x = duk__json_dec_get_nonwhite(js_ctx);
  if (x != 0x3a) {
   goto syntax_error;
  }

  duk__json_dec_value(js_ctx);



  duk_xdef_prop((thr), (-3), ((1U << 0) | (1U << 1) | (1U << 2)));



  key_count++;
 }



 do { } while (0);

 duk__json_dec_objarr_exit(js_ctx);
 return;

syntax_error:
 duk__json_dec_syntax_error(js_ctx);
 do { __builtin_unreachable(); } while (0);
}

static void duk__json_dec_array(duk_json_dec_ctx *js_ctx) {
 duk_hthread *thr = js_ctx->thr;
 duk_uarridx_t arr_idx;
 duk_uint8_t x;

 do { } while (0);

 duk__json_dec_objarr_entry(js_ctx);

 duk_push_array(thr);



 arr_idx = 0;
 for (;;) {
  x = duk__json_dec_get_nonwhite(js_ctx);

  do { } while (0)


                                       ;



  if ((x == 0x2c) && (arr_idx != 0)) {

   ;
  } else if (x == 0x5d) {

   break;
  } else if (arr_idx == 0) {



   js_ctx->p--;
  } else {

   goto syntax_error;
  }



  duk__json_dec_value(js_ctx);



  duk_xdef_prop_index((thr), (-2), (arr_idx), ((1U << 0) | (1U << 1) | (1U << 2)));
  arr_idx++;
 }





 duk_set_length(thr, -1, arr_idx);



 do { } while (0);

 duk__json_dec_objarr_exit(js_ctx);
 return;

syntax_error:
 duk__json_dec_syntax_error(js_ctx);
 do { __builtin_unreachable(); } while (0);
}

static void duk__json_dec_value(duk_json_dec_ctx *js_ctx) {
 duk_hthread *thr = js_ctx->thr;
 duk_uint8_t x;

 x = duk__json_dec_get_nonwhite(js_ctx);

 do { } while (0);



 if (x == 0x22) {
  duk__json_dec_string(js_ctx);
 } else if ((x >= 0x30 && x <= 0x39) || (x == 0x2d)) {

  if (js_ctx->flag_ext_custom && x == 0x2d && duk__json_dec_peek(js_ctx) == 0x49) {
   duk__json_dec_req_stridx(js_ctx, 61);
   duk_push_number(thr, -((double) 
# 899 "duk_bi_json.c" 3 4
                        (__builtin_inff ())
# 899 "duk_bi_json.c"
                        ));
  } else {




   js_ctx->p--;
   duk__json_dec_number(js_ctx);
  }
 } else if (x == 0x74) {
  duk__json_dec_req_stridx(js_ctx, 156);
  duk_push_true(thr);
 } else if (x == 0x66) {
  duk__json_dec_req_stridx(js_ctx, 157);
  duk_push_false(thr);
 } else if (x == 0x6e) {
  duk__json_dec_req_stridx(js_ctx, 155);
  duk_push_null(thr);

 } else if (js_ctx->flag_ext_custom && x == 0x75) {
  duk__json_dec_req_stridx(js_ctx, 58);
  duk_push_undefined(thr);
 } else if (js_ctx->flag_ext_custom && x == 0x4e) {
  duk__json_dec_req_stridx(js_ctx, 59);
  duk_push_nan(thr);
 } else if (js_ctx->flag_ext_custom && x == 0x49) {
  duk__json_dec_req_stridx(js_ctx, 60);
  duk_push_number(thr, ((double) 
# 926 "duk_bi_json.c" 3 4
                      (__builtin_inff ())
# 926 "duk_bi_json.c"
                      ));
 } else if (js_ctx->flag_ext_custom && x == 0x28) {
  duk__json_dec_pointer(js_ctx);
 } else if (js_ctx->flag_ext_custom && x == 0x7c) {
  duk__json_dec_buffer(js_ctx);

 } else if (x == 0x7b) {
  duk__json_dec_object(js_ctx);
 } else if (x == 0x5b) {
  duk__json_dec_array(js_ctx);
 } else {

  goto syntax_error;
 }

 duk__json_dec_eat_white(js_ctx);


 return;

syntax_error:
 duk__json_dec_syntax_error(js_ctx);
 do { __builtin_unreachable(); } while (0);
}






static void duk__json_dec_reviver_walk(duk_json_dec_ctx *js_ctx) {
 duk_hthread *thr = js_ctx->thr;
 duk_hobject *h;
 duk_uarridx_t i, arr_len;

 duk__json_dec_objarr_entry(js_ctx);

 do { } while (0)


                                                          ;

 duk_dup_top(thr);
 duk_get_prop(thr, -3);

 h = duk_get_hobject(thr, -1);
 if (h != 
# 972 "duk_bi_json.c" 3 4
         ((void *)0)
# 972 "duk_bi_json.c"
             ) {
  if (duk_js_isarray_hobject(h)) {
   arr_len = (duk_uarridx_t) duk_get_length(thr, -1);
   for (i = 0; i < arr_len; i++) {


    do { } while (0)





                                                             ;

    duk_dup_top(thr);
    (void) duk_push_uint_to_hstring(thr,
                                    (duk_uint_t) i);
    duk__json_dec_reviver_walk(js_ctx);

    if (duk_is_undefined(thr, -1)) {
     duk_pop(thr);
     duk_del_prop_index(thr, -1, i);
    } else {




     duk_put_prop_index(thr, -2, i);
    }
   }
  } else {

   duk_enum(thr, -1, (1U << 4) );
   while (duk_next(thr, -1 , 0 )) {
    do { } while (0)





                                                             ;


    duk_dup_m3(thr);
    duk_dup_m2(thr);


    duk__json_dec_reviver_walk(js_ctx);


    if (duk_is_undefined(thr, -1)) {
     duk_pop(thr);
     duk_del_prop(thr, -3);
    } else {
# 1035 "duk_bi_json.c"
     duk_put_prop(thr, -4);
    }
   }
   duk_pop(thr);
  }
 }



 duk_dup(thr, js_ctx->idx_reviver);
 duk_insert(thr, -4);
 duk_call_method(thr, 2);

 duk__json_dec_objarr_exit(js_ctx);

 do { } while (0);
}
# 1066 "duk_bi_json.c"
static void duk__emit_1(duk_json_enc_ctx *js_ctx, duk_uint_fast8_t ch) {
 do { do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (1); duk__space = (duk_size_t) (((&js_ctx->bw))->p_limit - ((&js_ctx->bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((js_ctx->thr)), ((&js_ctx->bw)), duk__sz); } } while (0); do { do { (((void) 0), ((void) 0)); } while (0); *((&js_ctx->bw))->p++ = (duk_uint8_t) ((ch)); } while (0); } while (0);
}

static void duk__emit_2(duk_json_enc_ctx *js_ctx, duk_uint_fast8_t ch1, duk_uint_fast8_t ch2) {
 do { do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (2); duk__space = (duk_size_t) (((&js_ctx->bw))->p_limit - ((&js_ctx->bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((js_ctx->thr)), ((&js_ctx->bw)), duk__sz); } } while (0); do { duk_uint8_t *duk__p; do { (((void) 0), ((void) 0)); } while (0); duk__p = ((&js_ctx->bw))->p; *duk__p++ = (duk_uint8_t) ((ch1)); *duk__p++ = (duk_uint8_t) ((ch2)); ((&js_ctx->bw))->p = duk__p; } while (0); } while (0);
}

static void duk__emit_hstring(duk_json_enc_ctx *js_ctx, duk_hstring *h) {
 do { duk_size_t duk__val_len; duk__val_len = (((h))->blen); do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (duk__val_len); duk__space = (duk_size_t) (((&js_ctx->bw))->p_limit - ((&js_ctx->bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((js_ctx->thr)), ((&js_ctx->bw)), duk__sz); } } while (0); do { void *duk__dst = ((void *) ((&js_ctx->bw)->p)); const void *duk__src = ((const void *) ((const duk_uint8_t *) (((h)) + 1))); duk_size_t duk__len = (duk__val_len); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0); (&js_ctx->bw)->p += duk__val_len; } while (0);
}


static void duk__emit_cstring(duk_json_enc_ctx *js_ctx, const char *str) {
 do { const duk_uint8_t *duk__val; duk_size_t duk__val_len; duk__val = (const duk_uint8_t *) (str); duk__val_len = strlen((const char *) duk__val); do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (duk__val_len); duk__space = (duk_size_t) (((&js_ctx->bw))->p_limit - ((&js_ctx->bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((js_ctx->thr)), ((&js_ctx->bw)), duk__sz); } } while (0); do { void *duk__dst = ((void *) ((&js_ctx->bw)->p)); const void *duk__src = ((const void *) duk__val); duk_size_t duk__len = (duk__val_len); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0); (&js_ctx->bw)->p += duk__val_len; } while (0);
}


static void duk__emit_stridx(duk_json_enc_ctx *js_ctx, duk_small_uint_t stridx) {
 duk_hstring *h;

 do { } while (0);
 h = ((js_ctx->thr)->strs[(stridx)]);
 do { } while (0);

 do { duk_size_t duk__val_len; duk__val_len = (((h))->blen); do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (duk__val_len); duk__space = (duk_size_t) (((&js_ctx->bw))->p_limit - ((&js_ctx->bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((js_ctx->thr)), ((&js_ctx->bw)), duk__sz); } } while (0); do { void *duk__dst = ((void *) ((&js_ctx->bw)->p)); const void *duk__src = ((const void *) ((const duk_uint8_t *) (((h)) + 1))); duk_size_t duk__len = (duk__val_len); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0); (&js_ctx->bw)->p += duk__val_len; } while (0);
}

static void duk__unemit_1(duk_json_enc_ctx *js_ctx) {
 do { } while (0);
 do { (&js_ctx->bw)->p += (-1); } while (0);
}




static duk_uint8_t *duk__emit_esc_auto_fast(duk_json_enc_ctx *js_ctx, duk_uint_fast32_t cp, duk_uint8_t *q) {
 duk_uint_fast32_t tmp;
 duk_small_uint_t dig;

 do { (void) (js_ctx); } while (0);
# 1117 "duk_bi_json.c"
 if (__builtin_expect((cp < 0x100UL), 1)) {
  if (__builtin_expect((js_ctx->flag_ext_custom != 0U), 0)) {
   tmp = (((duk_uint_fast32_t) (2)) << 16) | (((duk_uint_fast32_t) (0x5c)) << 8) | ((duk_uint_fast32_t) (0x78));
  } else {
   tmp = (((duk_uint_fast32_t) (4)) << 16) | (((duk_uint_fast32_t) (0x5c)) << 8) | ((duk_uint_fast32_t) (0x75));
  }
 } else

     if (__builtin_expect((cp < 0x10000UL), 1)) {
  tmp = (((duk_uint_fast32_t) (4)) << 16) | (((duk_uint_fast32_t) (0x5c)) << 8) | ((duk_uint_fast32_t) (0x75));
 } else {

  if (__builtin_expect((js_ctx->flag_ext_custom != 0U), 1)) {
   tmp = (((duk_uint_fast32_t) (8)) << 16) | (((duk_uint_fast32_t) (0x5c)) << 8) | ((duk_uint_fast32_t) (0x55));
  } else

  {





   tmp = (((duk_uint_fast32_t) (8)) << 16) | (((duk_uint_fast32_t) (0x55)) << 8) | ((duk_uint_fast32_t) (0x2b));
  }
 }

 *q++ = (duk_uint8_t) ((tmp >> 8) & 0xff);
 *q++ = (duk_uint8_t) (tmp & 0xff);

 tmp = tmp >> 16;
 while (tmp > 0) {
  tmp--;
  dig = (duk_small_uint_t) ((cp >> (4 * tmp)) & 0x0f);
  *q++ = duk_lc_digits[dig];
 }

 return q;
}

static void duk__json_enc_key_autoquote(duk_json_enc_ctx *js_ctx, duk_hstring *k) {
 const duk_int8_t *p, *p_start, *p_end;
 duk_size_t k_len;
 duk_codepoint_t cp;

 do { } while (0);
# 1170 "duk_bi_json.c"
 if (js_ctx->flag_avoid_key_quotes) {
  k_len = ((k)->blen);
  p_start = (const duk_int8_t *) ((const duk_uint8_t *) ((k) + 1));
  p_end = p_start + k_len;
  p = p_start;

  if (p == p_end) {

   goto quote_normally;
  }
  cp = (duk_codepoint_t) (*p++);
  if (__builtin_expect((!duk_unicode_is_identifier_start(cp)), 0)) {
   goto quote_normally;
  }
  while (p < p_end) {
   cp = (duk_codepoint_t) (*p++);
   if (__builtin_expect((!duk_unicode_is_identifier_part(cp)), 0)) {
    goto quote_normally;
   }
  }




  duk__emit_hstring((js_ctx), (k));
  return;
 }

quote_normally:
 duk__json_enc_quote_string(js_ctx, k);
}






static void duk__json_enc_quote_string(duk_json_enc_ctx *js_ctx, duk_hstring *h_str) {
 duk_hthread *thr = js_ctx->thr;
 const duk_uint8_t *p, *p_start, *p_end, *p_now, *p_tmp;
 duk_uint8_t *q;
 duk_ucodepoint_t cp;

 do { } while (0);

 do { } while (0);
 p_start = ((const duk_uint8_t *) ((h_str) + 1));
 p_end = p_start + ((h_str)->blen);
 p = p_start;

 duk__emit_1((js_ctx), (duk_uint_fast8_t) (0x22));





 while (p < p_end) {
  duk_size_t left, now, space;

  left = (duk_size_t) (p_end - p);
  now = (left > 64 ? 64 : left);






  space = now * 6;
  q = (((duk_size_t) (((&js_ctx->bw))->p_limit - ((&js_ctx->bw)->p)) >= ((space))) ? ((&js_ctx->bw)->p) : (((&js_ctx->bw))->p = ((&js_ctx->bw)->p), duk_bw_resize(((thr)), ((&js_ctx->bw)), ((space)))));

  p_now = p + now;

  while (p < p_now) {

   duk_uint8_t b;

   b = duk__json_quotestr_lookup[*p++];
   if (__builtin_expect((b < 0x80), 1)) {

    *q++ = b;
   } else if (b >= 0xa0) {
    *q++ = 0x5c;
    *q++ = (duk_uint8_t) (b - 0x80);
   } else if (b == 0x80) {
    cp = (duk_ucodepoint_t) (*(p - 1));
    q = duk__emit_esc_auto_fast(js_ctx, cp, q);
   } else if (b == 0x7f && js_ctx->flag_ascii_only) {

    do { } while (0);
    cp = (duk_ucodepoint_t) 0x7f;
    q = duk__emit_esc_auto_fast(js_ctx, cp, q);
   } else {
    do { } while (0);
    p--;
# 1314 "duk_bi_json.c"
    p_tmp = p;
    if (!duk_unicode_decode_xutf8(thr, &p, p_start, p_end, &cp)) {

     cp = *p_tmp;
     p = p_tmp + 1;
    }


    if (js_ctx->flag_ascii_only || cp == 0x2028 || cp == 0x2029) {



     q = duk__emit_esc_auto_fast(js_ctx, cp, q);
    } else {

     duk_raw_writeinc_xutf8(&(q), (duk_ucodepoint_t) (cp));
    }
   }
  }

  do { (&js_ctx->bw)->p = (q); } while (0);
 }

 duk__emit_1((js_ctx), (duk_uint_fast8_t) (0x22));
}




static void duk__json_enc_double(duk_json_enc_ctx *js_ctx) {
 duk_hthread *thr;
 duk_tval *tv;
 duk_double_t d;
 duk_small_int_t c;
 duk_small_int_t s;
 duk_small_uint_t stridx;
 duk_small_uint_t n2s_flags;
 duk_hstring *h_str;

 do { } while (0);
 thr = js_ctx->thr;
 do { } while (0);


 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));
 do { } while (0);
 d = ((tv)->v.d);

 c = (duk_small_int_t) 
# 1362 "duk_bi_json.c" 3 4
                      __builtin_fpclassify (0, 1, 4, 3, 2, 
# 1362 "duk_bi_json.c"
                      d
# 1362 "duk_bi_json.c" 3 4
                      )
# 1362 "duk_bi_json.c"
                                       ;
 s = (duk_small_int_t) 
# 1363 "duk_bi_json.c" 3 4
                      __builtin_signbit (
# 1363 "duk_bi_json.c"
                      d
# 1363 "duk_bi_json.c" 3 4
                      )
# 1363 "duk_bi_json.c"
                                    ;
 do { (void) (s); } while (0);

 if (__builtin_expect((!(c == 
# 1366 "duk_bi_json.c" 3 4
    1 
# 1366 "duk_bi_json.c"
    || c == 
# 1366 "duk_bi_json.c" 3 4
    0
# 1366 "duk_bi_json.c"
    )), 1)) {
  do { } while (0);





  if (__builtin_expect((c == 
# 1373 "duk_bi_json.c" 3 4
     2 
# 1373 "duk_bi_json.c"
     && s != 0 && (js_ctx->flag_ext_custom_or_compatible)), 0)) {
   duk_push_hstring_stridx(thr, 62);
  } else

  {
   n2s_flags = 0;

   duk_numconv_stringify(thr, 10 , 0 , n2s_flags);
  }
  h_str = duk_known_hstring(thr, -1);
  duk__emit_hstring((js_ctx), (h_str));
  return;
 }


 if (!(js_ctx->flags & ((1U << 2) | (1U << 3)))) {
  stridx = 155;
 } else if (c == 
# 1390 "duk_bi_json.c" 3 4
                0
# 1390 "duk_bi_json.c"
                          ) {
  stridx = js_ctx->stridx_custom_nan;
 } else if (s == 0) {
  stridx = js_ctx->stridx_custom_posinf;
 } else {
  stridx = js_ctx->stridx_custom_neginf;
 }



 duk__emit_stridx((js_ctx), (stridx));
}
# 1430 "duk_bi_json.c"
static duk_uint8_t *duk__json_enc_buffer_data_hex(const duk_uint8_t *src, duk_size_t src_len, duk_uint8_t *dst) {
 duk_uint8_t *q;
 duk_uint16_t *q16;
 duk_small_uint_t x;
 duk_size_t i, len_safe;

 duk_bool_t shift_dst;
# 1450 "duk_bi_json.c"
 shift_dst = (duk_bool_t) (((duk_size_t) dst) & 0x01U);
 if (shift_dst) {
  do { } while (0);
  q16 = (duk_uint16_t *) (void *) (dst + 1);
 } else {
  do { } while (0);
  q16 = (duk_uint16_t *) (void *) dst;
 }
 do { } while (0);


 len_safe = src_len & ~0x03U;
 for (i = 0; i < len_safe; i += 4) {
  q16[0] = duk_hex_enctab[src[i]];
  q16[1] = duk_hex_enctab[src[i + 1]];
  q16[2] = duk_hex_enctab[src[i + 2]];
  q16[3] = duk_hex_enctab[src[i + 3]];
  q16 += 4;
 }
 q = (duk_uint8_t *) q16;


 if (shift_dst) {
  q--;
  do { void *duk__dst = ((void *) dst); const void *duk__src = ((const void *) (dst + 1)); duk_size_t duk__len = (2 * len_safe); do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } while (0);
  do { } while (0);
 }


 for (; i < src_len; i++) {
  x = src[i];
  *q++ = duk_lc_digits[x >> 4];
  *q++ = duk_lc_digits[x & 0x0f];
 }

 return q;
}
# 1507 "duk_bi_json.c"
static void duk__json_enc_buffer_data(duk_json_enc_ctx *js_ctx, duk_uint8_t *buf_data, duk_size_t buf_len) {
 duk_hthread *thr;
 duk_uint8_t *q;
 duk_size_t space;

 thr = js_ctx->thr;

 do { } while (0);
 do { } while (0);
# 1528 "duk_bi_json.c"
 space = 9 + buf_len * 2 + 2;
 do { } while (0);
 do { } while (0);
 q = (((duk_size_t) (((&js_ctx->bw))->p_limit - ((&js_ctx->bw)->p)) >= ((space))) ? ((&js_ctx->bw)->p) : (((&js_ctx->bw))->p = ((&js_ctx->bw)->p), duk_bw_resize(((thr)), ((&js_ctx->bw)), ((space)))));


 if (js_ctx->flag_ext_custom)


 {
  *q++ = 0x7c;
  q = duk__json_enc_buffer_data_hex(buf_data, buf_len, q);
  *q++ = 0x7c;

 }


 else


 {
  do { } while (0);
  do { void *duk__dst = ((void *) q); const void *duk__src = ((const void *) "{\"_buf\":\""); duk_size_t duk__len = (9); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
  q += 9;
  q = duk__json_enc_buffer_data_hex(buf_data, buf_len, q);
  *q++ = 0x22;
  *q++ = 0x7d;
 }


 do { (&js_ctx->bw)->p = (q); } while (0);
}

static void duk__json_enc_buffer_jx_jc(duk_json_enc_ctx *js_ctx, duk_hbuffer *h) {
 duk__json_enc_buffer_data(js_ctx,
                           (duk_uint8_t *) ((((&((h))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h))) + 1))),
                           (duk_size_t) (((duk_hbuffer *) (h))->size));
}
# 1616 "duk_bi_json.c"
static void duk__json_enc_pointer(duk_json_enc_ctx *js_ctx, void *ptr) {
 char buf[64];
 const char *fmt;

 do { } while (0);
 do { } while (0);

 do { void *duk__dst = (buf); duk_size_t duk__len = (sizeof(buf)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);





 if (js_ctx->flag_ext_custom)


 {
  fmt = ptr ? "(%p)" : "(null)";
 }


 else


 {
  do { } while (0);
  fmt = ptr ? "{\"_ptr\":\"%p\"}" : "{\"_ptr\":\"null\"}";
 }



 snprintf(buf, sizeof(buf) - 1, fmt, ptr);
 duk__emit_cstring((js_ctx), (buf));
}




static void duk__json_enc_bufobj(duk_json_enc_ctx *js_ctx, duk_hbufobj *h_bufobj) {
 do { } while (0);

 if (h_bufobj->buf == 
# 1657 "duk_bi_json.c" 3 4
                     ((void *)0) 
# 1657 "duk_bi_json.c"
                          || !(((void) 0), ((void) 0), ((h_bufobj)->offset + (h_bufobj)->length <= (((duk_hbuffer *) ((h_bufobj)->buf))->size)))) {
  duk__emit_stridx((js_ctx), (155));
 } else {

  duk__json_enc_buffer_data(js_ctx,
                            (duk_uint8_t *) (((void) 0), ((void) 0), (((duk_uint8_t *) ((((&(((h_bufobj)->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) ((h_bufobj)->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) ((h_bufobj)->buf))) + 1)))) + (h_bufobj)->offset)),
                            (duk_size_t) h_bufobj->length);
 }
}
# 1683 "duk_bi_json.c"
static void duk__json_enc_newline_indent(duk_json_enc_ctx *js_ctx, duk_uint_t depth) {
 const duk_uint8_t *gap_data;
 duk_size_t gap_len;
 duk_size_t avail_bytes;
 duk_size_t need_bytes;
 duk_uint8_t *p_start;
 duk_uint8_t *p;

 do { } while (0);
 do { } while (0);

 duk__emit_1((js_ctx), (duk_uint_fast8_t) (0x0a));
 if (__builtin_expect((depth == 0), 0)) {
  return;
 }







 gap_data = (const duk_uint8_t *) ((const duk_uint8_t *) ((js_ctx->h_gap) + 1));
 gap_len = (duk_size_t) ((js_ctx->h_gap)->blen);
 do { } while (0);

 need_bytes = gap_len * depth;
 p = (((duk_size_t) (((&js_ctx->bw))->p_limit - ((&js_ctx->bw)->p)) >= ((need_bytes))) ? ((&js_ctx->bw)->p) : (((&js_ctx->bw))->p = ((&js_ctx->bw)->p), duk_bw_resize(((js_ctx->thr)), ((&js_ctx->bw)), ((need_bytes)))));
 p_start = p;

 do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) gap_data); duk_size_t duk__len = ((size_t) gap_len); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 p += gap_len;
 avail_bytes = gap_len;
 do { } while (0);
 need_bytes -= gap_len;

 while (need_bytes >= avail_bytes) {
  do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) p_start); duk_size_t duk__len = ((size_t) avail_bytes); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
  p += avail_bytes;
  need_bytes -= avail_bytes;
  avail_bytes <<= 1;
 }

 do { } while (0);
 do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) p_start); duk_size_t duk__len = ((size_t) need_bytes); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 p += need_bytes;


 do { (&js_ctx->bw)->p = (p); } while (0);
}



static void duk__json_enc_objarr_entry(duk_json_enc_ctx *js_ctx, duk_idx_t *entry_top) {
 duk_hthread *thr = js_ctx->thr;
 duk_hobject *h_target;
 duk_uint_fast32_t i, n;

 *entry_top = duk_get_top(thr);

 duk_native_stack_check(thr);
 duk_require_stack(thr, 32);





 h_target = duk_known_hobject(thr, -1);

 n = js_ctx->recursion_depth;
 if (__builtin_expect((n > 64), 0)) {
  n = 64;
 }
 for (i = 0; i < n; i++) {
  if (__builtin_expect((js_ctx->visiting[i] == h_target), 0)) {
   do { } while (0);
   do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 1759; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_bi_json.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("cyclic input"))); } while (0); } while (0);
   do { return; } while (0);
  }
 }
 if (js_ctx->recursion_depth < 64) {
  js_ctx->visiting[js_ctx->recursion_depth] = h_target;
 } else {
  duk_push_sprintf(thr, "%p", (void *) h_target);
  duk_dup_top(thr);
  if (duk_has_prop(thr, js_ctx->idx_loop)) {
   do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 1769; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_bi_json.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("cyclic input"))); } while (0); } while (0);
   do { return; } while (0);
  }
  duk_push_true(thr);
  duk_put_prop(thr, js_ctx->idx_loop);
 }



 do { } while (0);
 do { } while (0);
 if (js_ctx->recursion_depth >= js_ctx->recursion_limit) {
  do { duk_err_range((thr), "duk_bi_json.c", (duk_int_t) 1781, ("encode recursion limit")); } while (0);
  do { return; } while (0);
 }
 js_ctx->recursion_depth++;

 do { } while (0)

                                                                        ;
}


static void duk__json_enc_objarr_exit(duk_json_enc_ctx *js_ctx, duk_idx_t *entry_top) {
 duk_hthread *thr = js_ctx->thr;
 duk_hobject *h_target;



 do { } while (0);
 do { } while (0);
 js_ctx->recursion_depth--;



 h_target = duk_known_hobject(thr, *entry_top - 1);

 if (js_ctx->recursion_depth < 64) {

 } else {
  duk_push_sprintf(thr, "%p", (void *) h_target);
  duk_del_prop(thr, js_ctx->idx_loop);
 }


 duk_set_top(thr, *entry_top);

 do { } while (0)

                                                                        ;
}





static void duk__json_enc_object(duk_json_enc_ctx *js_ctx) {
 duk_hthread *thr = js_ctx->thr;
 duk_hstring *h_key;
 duk_idx_t entry_top;
 duk_idx_t idx_obj;
 duk_idx_t idx_keys;
 duk_bool_t emitted;
 duk_uarridx_t arr_len, i;
 duk_size_t prev_size;

 do { } while (0);

 duk__json_enc_objarr_entry(js_ctx, &entry_top);

 idx_obj = entry_top - 1;

 if (js_ctx->idx_proplist >= 0) {
  idx_keys = js_ctx->idx_proplist;
 } else {

  duk_dup(thr, idx_obj);
  (void) duk_hobject_get_enumerated_keys(
      thr,
      (1U << 4) );
  idx_keys = duk_require_normalize_index(thr, -1);

 }

 do { } while (0);



 duk__emit_1((js_ctx), (duk_uint_fast8_t) (0x7b));







 arr_len = (duk_uarridx_t) duk_get_length(thr, idx_keys);
 emitted = 0;
 for (i = 0; i < arr_len; i++) {
  duk_get_prop_index(thr, idx_keys, i);

  do { } while (0)

                                                           ;

  h_key = duk_known_hstring(thr, -1);
  do { } while (0);
  do { } while (0);

  prev_size = ((duk_size_t) ((&js_ctx->bw)->p - (&js_ctx->bw)->p_base));
  if (__builtin_expect((js_ctx->h_gap != 
# 1879 "duk_bi_json.c" 3 4
     ((void *)0)
# 1879 "duk_bi_json.c"
     ), 0)) {
   duk__json_enc_newline_indent(js_ctx, js_ctx->recursion_depth);
   duk__json_enc_key_autoquote(js_ctx, h_key);
   duk__emit_2((js_ctx), (duk_uint_fast8_t) (0x3a), (duk_uint_fast8_t) (0x20));
  } else {
   duk__json_enc_key_autoquote(js_ctx, h_key);
   duk__emit_1((js_ctx), (duk_uint_fast8_t) (0x3a));
  }



  if (__builtin_expect((duk__json_enc_value(js_ctx, idx_obj) == 0), 0)) {



   do { do { } while (0); (&js_ctx->bw)->p = (&js_ctx->bw)->p_base + (prev_size); } while (0);
  } else {
   duk__emit_1((js_ctx), (duk_uint_fast8_t) (0x2c));
   emitted = 1;
  }


 }

 if (emitted) {
  do { } while (0);
  duk__unemit_1((js_ctx));
  if (__builtin_expect((js_ctx->h_gap != 
# 1906 "duk_bi_json.c" 3 4
     ((void *)0)
# 1906 "duk_bi_json.c"
     ), 0)) {
   do { } while (0);
   duk__json_enc_newline_indent(js_ctx, js_ctx->recursion_depth - 1U);
  }
 }
 duk__emit_1((js_ctx), (duk_uint_fast8_t) (0x7d));

 duk__json_enc_objarr_exit(js_ctx, &entry_top);

 do { } while (0);
}





static void duk__json_enc_array(duk_json_enc_ctx *js_ctx) {
 duk_hthread *thr = js_ctx->thr;
 duk_idx_t entry_top;
 duk_idx_t idx_arr;
 duk_bool_t emitted;
 duk_uarridx_t i, arr_len;

 do { } while (0);

 duk__json_enc_objarr_entry(js_ctx, &entry_top);

 idx_arr = entry_top - 1;



 duk__emit_1((js_ctx), (duk_uint_fast8_t) (0x5b));

 arr_len = (duk_uarridx_t) duk_get_length(thr, idx_arr);
 emitted = 0;
 for (i = 0; i < arr_len; i++) {
  do { } while (0)


                                       ;

  if (__builtin_expect((js_ctx->h_gap != 
# 1947 "duk_bi_json.c" 3 4
     ((void *)0)
# 1947 "duk_bi_json.c"
     ), 0)) {
   do { } while (0);
   duk__json_enc_newline_indent(js_ctx, js_ctx->recursion_depth);
  }

  (void) duk_push_uint_to_hstring(thr, (duk_uint_t) i);



  if (__builtin_expect((duk__json_enc_value(js_ctx, idx_arr) == 0), 0)) {

   duk__emit_stridx((js_ctx), (155));
  } else {
   ;
  }



  duk__emit_1((js_ctx), (duk_uint_fast8_t) (0x2c));
  emitted = 1;
 }

 if (emitted) {
  do { } while (0);
  duk__unemit_1((js_ctx));
  if (__builtin_expect((js_ctx->h_gap != 
# 1972 "duk_bi_json.c" 3 4
     ((void *)0)
# 1972 "duk_bi_json.c"
     ), 0)) {
   do { } while (0);
   duk__json_enc_newline_indent(js_ctx, js_ctx->recursion_depth - 1U);
  }
 }
 duk__emit_1((js_ctx), (duk_uint_fast8_t) (0x5d));

 duk__json_enc_objarr_exit(js_ctx, &entry_top);

 do { } while (0);
}





static duk_bool_t duk__json_enc_value(duk_json_enc_ctx *js_ctx, duk_idx_t idx_holder) {
 duk_hthread *thr = js_ctx->thr;
 duk_tval *tv;
 duk_tval *tv_holder;
 duk_tval *tv_key;
 duk_small_int_t c;

 do { } while (0)


                                                          ;

 tv_holder = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (idx_holder));
 do { } while (0);
 tv_key = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));
 do { } while (0);
 do { } while (0);
 (void) duk_hobject_getprop(thr, tv_holder, tv_key);



 do { } while (0);






 if (duk_check_type_mask(thr, -1, (1U << 6U) | (1U << 9U) | (1U << 7U))) {
  (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (83))));
  if (duk_is_function((thr), (-1))) {
   do { } while (0);

   duk_dup_m2(thr);
   duk_dup_m4(thr);
   duk_call_method(thr, 1);
   duk_remove_m2(thr);
  } else {
   duk_pop(thr);
  }
 }



 do { } while (0);

 if (js_ctx->h_replacer) {

  do { } while (0);
  duk_push_hobject(thr, js_ctx->h_replacer);
  duk_dup(thr, idx_holder);
  duk_dup_m4(thr);
  duk_dup_m4(thr);
  duk_call_method(thr, 2);
  duk_remove_m2(thr);
 }



 do { } while (0);

 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));
 if (((tv)->t == 9)) {
  duk_hobject *h;

  h = ((tv)->v.hobject);
  do { } while (0);



  if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0) && js_ctx->flags & ((1U << 2) | (1U << 3))) {

   duk_hbufobj *h_bufobj;
   h_bufobj = (duk_hbufobj *) h;
   do { } while (0);
   duk__json_enc_bufobj(js_ctx, h_bufobj);
   goto pop2_emitted;
  }



  c = (duk_small_int_t) (((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL));
  switch (c) {
  case 10: {
   do { } while (0);
   duk_to_number_m1(thr);




   do { } while (0);
   break;
  }
  case 12: {
   do { } while (0);
   duk_to_string(thr, -1);

   do { } while (0);
   break;
  }

  case 17:

  case 5: {
   do { } while (0);
   (((void) 0), ((void) 0), duk_xget_owndataprop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (106))));
   duk_remove_m2(thr);
   break;
  }
  default: {







   do { } while (0);
   if ((((&((h))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)) {

    if (js_ctx->flags & ((1U << 2) | (1U << 3))) {

     do { } while (0);
     do { } while (0);
     duk__emit_stridx((js_ctx), (js_ctx->stridx_custom_function));
     goto pop2_emitted;
    } else {
     do { } while (0);
     goto pop2_undef;
    }




   }
  }
  }
 }



 do { } while (0);

 if (duk_check_type_mask(thr, -1, js_ctx->mask_for_undefined)) {

  do { } while (0);
  goto pop2_undef;
 }
 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));

 switch (((tv)->t)) {


 case 2: {
  duk__emit_stridx((js_ctx), (js_ctx->stridx_custom_undefined));
  break;
 }

 case 3: {
  duk__emit_stridx((js_ctx), (155));
  break;
 }
 case 4: {
  duk__emit_stridx((js_ctx), (((duk_small_uint_t) (tv)->v.i) ? 156 : 157));
  break;
 }


 case 5: {
  duk__json_enc_pointer(js_ctx, ((tv)->v.voidptr));
  break;
 }

 case 8: {
  duk_hstring *h = ((tv)->v.hstring);
  do { } while (0);
  if (__builtin_expect(((((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
   goto pop2_undef;
  }
  duk__json_enc_quote_string(js_ctx, h);
  break;
 }
 case 9: {
  duk_hobject *h = ((tv)->v.hobject);
  do { } while (0);




  do { } while (0);

  if (duk_js_isarray_hobject(h)) {
   duk__json_enc_array(js_ctx);
  } else {
   duk__json_enc_object(js_ctx);
  }
  break;
 }






 case 10: {

  if (js_ctx->flag_ext_custom_or_compatible) {
   duk__json_enc_buffer_jx_jc(js_ctx, ((tv)->v.hbuffer));
   break;
  }





  duk_to_object(thr, -1);
  duk__json_enc_object(js_ctx);
  break;
 }
 case 6: {


  do { } while (0);
  duk__emit_stridx((js_ctx), (js_ctx->stridx_custom_function));




  break;
 }
# 2226 "duk_bi_json.c"
 default: {

  do { } while (0);
  do { } while (0);



  duk__json_enc_double(js_ctx);
  break;
 }
 }


pop2_emitted:

 duk_pop_2(thr);
 return 1;

pop2_undef:
 duk_pop_2(thr);
 return 0;
}


static duk_bool_t duk__json_enc_allow_into_proplist(duk_tval *tv) {
 duk_small_int_t c;




 do { } while (0);
 if (((tv)->t == 8)) {
  duk_hstring *h;
  h = ((tv)->v.hstring);
  do { } while (0);
  if (__builtin_expect(((((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
   return 0;
  }
  return 1;
 } else if (((tv)->t == 0)) {
  return 1;
 } else if (((tv)->t == 9)) {
  duk_hobject *h;
  h = ((tv)->v.hobject);
  do { } while (0);
  c = (duk_small_int_t) (((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL));
  if (c == 12 || c == 10) {
   return 1;
  }
 }

 return 0;
}
# 2785 "duk_bi_json.c"
static __attribute__ ((unused))
void duk_bi_json_parse_helper(duk_hthread *thr, duk_idx_t idx_value, duk_idx_t idx_reviver, duk_small_uint_t flags) {
 duk_json_dec_ctx js_ctx_alloc;
 duk_json_dec_ctx *js_ctx = &js_ctx_alloc;
 duk_hstring *h_text;





 do { } while (0);
 do { } while (0);

 do { } while (0)



                                               ;

 do { void *duk__dst = (&js_ctx_alloc); duk_size_t duk__len = (sizeof(js_ctx_alloc)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 js_ctx->thr = thr;



 js_ctx->recursion_limit = 1000;
 do { } while (0);





 js_ctx->flags = flags;

 js_ctx->flag_ext_custom = flags & (1U << 2);


 js_ctx->flag_ext_compatible = flags & (1U << 3);


 js_ctx->flag_ext_custom_or_compatible = flags & ((1U << 2) | (1U << 3));


 h_text = duk_to_hstring(thr, idx_value);
 do { } while (0);





 js_ctx->p_start = (const duk_uint8_t *) ((const duk_uint8_t *) ((h_text) + 1));
 js_ctx->p = js_ctx->p_start;
 js_ctx->p_end = ((const duk_uint8_t *) ((const duk_uint8_t *) ((h_text) + 1))) + ((h_text)->blen);
 do { } while (0);

 duk__json_dec_value(js_ctx);
 do { } while (0);





 if (js_ctx->p != js_ctx->p_end) {
  duk__json_dec_syntax_error(js_ctx);
 }

 if (duk_is_function((thr), (idx_reviver))) {
  do { } while (0);

  js_ctx->idx_reviver = idx_reviver;

  duk_push_object(thr);
  duk_dup_m2(thr);
  (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (15))));
  duk_push_hstring_stridx(thr, 15);

  do { } while (0)

                                                           ;

  do { } while (0);
  duk__json_dec_reviver_walk(js_ctx);
  do { } while (0);
  duk_remove_m2(thr);
 } else {
  do { } while (0)
                                                                                                                  ;
 }



 do { } while (0)




                                               ;

 do { } while (0);
}

static __attribute__ ((unused))
void duk_bi_json_stringify_helper(duk_hthread *thr,
                                  duk_idx_t idx_value,
                                  duk_idx_t idx_replacer,
                                  duk_idx_t idx_space,
                                  duk_small_uint_t flags) {
 duk_json_enc_ctx js_ctx_alloc;
 duk_json_enc_ctx *js_ctx = &js_ctx_alloc;
 duk_hobject *h;
 duk_idx_t idx_holder;
 duk_idx_t entry_top;


 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0)




                                               ;

 entry_top = duk_get_top(thr);





 do { void *duk__dst = (&js_ctx_alloc); duk_size_t duk__len = (sizeof(js_ctx_alloc)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 js_ctx->thr = thr;




 js_ctx->idx_proplist = -1;





 js_ctx->flags = flags;
 js_ctx->flag_ascii_only = flags & (1U << 0);
 js_ctx->flag_avoid_key_quotes = flags & (1U << 1);

 js_ctx->flag_ext_custom = flags & (1U << 2);


 js_ctx->flag_ext_compatible = flags & (1U << 3);


 js_ctx->flag_ext_custom_or_compatible = flags & ((1U << 2) | (1U << 3));






 js_ctx->stridx_custom_undefined = 155;

 if (flags & (1U << 2)) {
  js_ctx->stridx_custom_undefined = 58;
  js_ctx->stridx_custom_nan = 59;
  js_ctx->stridx_custom_neginf = 61;
  js_ctx->stridx_custom_posinf = 60;
  js_ctx->stridx_custom_function =
      (flags & (1U << 1)) ? 121 : 120;
 }


 else


     if (js_ctx->flags & (1U << 3)) {
  js_ctx->stridx_custom_undefined = 116;
  js_ctx->stridx_custom_nan = 117;
  js_ctx->stridx_custom_neginf = 119;
  js_ctx->stridx_custom_posinf = 118;
  js_ctx->stridx_custom_function = 120;
 }




 if (js_ctx->flags & ((1U << 2) | (1U << 3))) {
  do { } while (0);
 } else

 {





  js_ctx->mask_for_undefined = (1U << 1U) | (1U << 8U) | (1U << 9U);
 }

 do { duk_bw_init_pushbuf((thr), (&js_ctx->bw), (128)); } while (0);

 js_ctx->idx_loop = duk_push_bare_object(thr);
 do { } while (0);







 h = duk_get_hobject(thr, idx_replacer);
 if (h != 
# 2995 "duk_bi_json.c" 3 4
         ((void *)0)
# 2995 "duk_bi_json.c"
             ) {
  if ((((&((h))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)) {
   js_ctx->h_replacer = h;
  } else if (duk_js_isarray_hobject(h)) {






   duk_uarridx_t plist_idx = 0;
   duk_small_uint_t enum_flags;

   js_ctx->idx_proplist = duk_push_bare_array(thr);

   enum_flags = (1U << 5) | (1U << 6);
   duk_enum(thr, idx_replacer, enum_flags);
   while (duk_next(thr, -1 , 1 )) {

    if (duk__json_enc_allow_into_proplist(duk_get_tval(thr, -1))) {

     do { } while (0)

                                                              ;
     duk_to_string(thr, -1);
     duk_put_prop_index(thr, -4, plist_idx);
     plist_idx++;
     duk_pop(thr);
    } else {
     do { } while (0)

                                                              ;
     duk_pop_2(thr);
    }
   }
   duk_pop(thr);


  }
 }







 h = duk_get_hobject(thr, idx_space);
 if (h != 
# 3043 "duk_bi_json.c" 3 4
         ((void *)0)
# 3043 "duk_bi_json.c"
             ) {
  duk_small_uint_t c = (((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL));
  if (c == 10) {
   duk_to_number(thr, idx_space);
  } else if (c == 12) {
   duk_to_string(thr, idx_space);
  }
 }

 if (duk_is_number(thr, idx_space)) {
  duk_small_int_t nspace;

  static const char spaces[10] = {
   0x20, 0x20, 0x20, 0x20, 0x20,
   0x20, 0x20, 0x20, 0x20, 0x20
  };


  nspace = (duk_small_int_t) duk_to_int_clamped(thr, idx_space, 0 , 10 );
  do { } while (0);

  duk_push_lstring(thr, spaces, (duk_size_t) nspace);
  js_ctx->h_gap = duk_known_hstring(thr, -1);
  do { } while (0);
 } else if (duk_is_string_notsymbol(thr, idx_space)) {
  duk_dup(thr, idx_space);
  duk_substring(thr, -1, 0, 10);
  js_ctx->h_gap = duk_known_hstring(thr, -1);
 } else {

 }

 if (js_ctx->h_gap != 
# 3075 "duk_bi_json.c" 3 4
                     ((void *)0)
# 3075 "duk_bi_json.c"
                         ) {




  if (((js_ctx->h_gap)->blen) == 0) {
   js_ctx->h_gap = 
# 3081 "duk_bi_json.c" 3 4
                  ((void *)0)
# 3081 "duk_bi_json.c"
                      ;
  }
 }
# 3150 "duk_bi_json.c"
 idx_holder = duk_push_object(thr);
 duk_dup(thr, idx_value);
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (15))));

 do { } while (0)






                                                          ;



 duk_push_hstring_empty(thr);



 js_ctx->recursion_limit = 1000;
 do { } while (0);

 if (__builtin_expect((duk__json_enc_value(js_ctx, idx_holder) == 0), 0)) {

  duk_push_undefined(thr);
 } else {

  do { duk_push_lstring((thr), (const char *) (&js_ctx->bw)->p_base, (duk_size_t) ((&js_ctx->bw)->p - (&js_ctx->bw)->p_base)); } while (0);
 }

 do { } while (0)






                                                                  ;
# 3196 "duk_bi_json.c"
 duk_replace(thr, entry_top);
 duk_set_top(thr, entry_top + 1);

 do { } while (0)






                                               ;

 do { } while (0);
}







static __attribute__ ((unused)) duk_ret_t duk_bi_json_object_parse(duk_hthread *thr) {
 duk_bi_json_parse_helper(thr, 0 , 1 , 0 );
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_json_object_stringify(duk_hthread *thr) {
 duk_bi_json_stringify_helper(thr, 0 , 1 , 2 , 0 );
 return 1;
}
# 1 "duk_bi_math.c"
# 18 "duk_bi_math.c"
typedef double (*duk__one_arg_func)(double);
typedef double (*duk__two_arg_func)(double, double);

static duk_ret_t duk__math_minmax(duk_hthread *thr, duk_double_t initial, duk__two_arg_func min_max) {
 duk_idx_t n = duk_get_top(thr);
 duk_idx_t i;
 duk_double_t res = initial;
 duk_double_t t;
# 38 "duk_bi_math.c"
 for (i = 0; i < n; i++) {
  t = duk_to_number(thr, i);
  if (
# 40 "duk_bi_math.c" 3 4
     __builtin_fpclassify (0, 1, 4, 3, 2, 
# 40 "duk_bi_math.c"
     t
# 40 "duk_bi_math.c" 3 4
     ) 
# 40 "duk_bi_math.c"
                       == 
# 40 "duk_bi_math.c" 3 4
                          0 
# 40 "duk_bi_math.c"
                                     || 
# 40 "duk_bi_math.c" 3 4
                                        __builtin_fpclassify (0, 1, 4, 3, 2, 
# 40 "duk_bi_math.c"
                                        res
# 40 "duk_bi_math.c" 3 4
                                        ) 
# 40 "duk_bi_math.c"
                                                            == 
# 40 "duk_bi_math.c" 3 4
                                                               0
# 40 "duk_bi_math.c"
                                                                         ) {

   res = (duk_double_t) 
# 42 "duk_bi_math.c" 3 4
                       (__builtin_nanf (""))
# 42 "duk_bi_math.c"
                                     ;
  } else {
   res = (duk_double_t) min_max(res, (double) t);
  }
 }

 duk_push_number(thr, res);
 return 1;
}

static double duk__fmin_fixed(double x, double y) {



 if (duk_double_equals(x, 0.0) && duk_double_equals(y, 0.0)) {
  duk_double_union du1, du2;
  du1.d = x;
  du2.d = y;





  do { } while (0);
  do { } while (0);


  if ((du1.ui[1] | du2.ui[1]) != 0) {

   return -0.0;
  } else {
   return +0.0;
  }
 }
 return duk_double_fmin(x, y);
}

static double duk__fmax_fixed(double x, double y) {



 if (duk_double_equals(x, 0.0) && duk_double_equals(y, 0.0)) {
  if (
# 84 "duk_bi_math.c" 3 4
     __builtin_signbit (
# 84 "duk_bi_math.c"
     x
# 84 "duk_bi_math.c" 3 4
     ) 
# 84 "duk_bi_math.c"
                    == 0 || 
# 84 "duk_bi_math.c" 3 4
                            __builtin_signbit (
# 84 "duk_bi_math.c"
                            y
# 84 "duk_bi_math.c" 3 4
                            ) 
# 84 "duk_bi_math.c"
                                           == 0) {
   return +0.0;
  } else {
   return -0.0;
  }
 }
 return duk_double_fmax(x, y);
}


static double duk__cbrt(double x) {







 return cbrt(x);
# 116 "duk_bi_math.c"
}

static double duk__log2(double x) {

 return log2(x);



}

static double duk__log10(double x) {

 return log10(x);



}

static double duk__trunc(double x) {

 return trunc(x);






}


static double duk__round_fixed(double x) {
# 155 "duk_bi_math.c"
 duk_small_int_t c = (duk_small_int_t) 
# 155 "duk_bi_math.c" 3 4
                                      __builtin_fpclassify (0, 1, 4, 3, 2, 
# 155 "duk_bi_math.c"
                                      x
# 155 "duk_bi_math.c" 3 4
                                      )
# 155 "duk_bi_math.c"
                                                       ;
 if (c == 
# 156 "duk_bi_math.c" 3 4
         0 
# 156 "duk_bi_math.c"
                    || c == 
# 156 "duk_bi_math.c" 3 4
                            1 
# 156 "duk_bi_math.c"
                                            || c == 
# 156 "duk_bi_math.c" 3 4
                                                    2
# 156 "duk_bi_math.c"
                                                               ) {
  return x;
 }
# 175 "duk_bi_math.c"
 if (x >= -0.5 && x < 0.5) {

  if (x < 0.0) {
   return -0.0;
  } else {
   return +0.0;
  }
 }

 return floor(x + 0.5);
}






static double duk__fabs(double x) {
 return fabs(x);
}
static double duk__acos(double x) {
 return acos(x);
}
static double duk__asin(double x) {
 return asin(x);
}
static double duk__atan(double x) {
 return atan(x);
}
static double duk__ceil(double x) {
 return ceil(x);
}
static double duk__cos(double x) {
 return cos(x);
}
static double duk__exp(double x) {
 return exp(x);
}
static double duk__floor(double x) {
 return floor(x);
}
static double duk__log(double x) {
 return log(x);
}
static double duk__sin(double x) {
 return sin(x);
}
static double duk__sqrt(double x) {
 return sqrt(x);
}
static double duk__tan(double x) {
 return tan(x);
}
static double duk__atan2_fixed(double x, double y) {
# 251 "duk_bi_math.c"
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 return atan2(x, y);
}



static const duk__one_arg_func duk__one_arg_funcs[] = {

 duk__fabs, duk__acos, duk__asin, duk__atan, duk__ceil, duk__cos, duk__exp,
 duk__floor, duk__log, duk__round_fixed, duk__sin, duk__sqrt, duk__tan,

 duk__cbrt, duk__log2, duk__log10, duk__trunc
# 276 "duk_bi_math.c"
};


static const duk__two_arg_func duk__two_arg_funcs[] = {

 duk__atan2_fixed,
 duk_js_arith_pow




};

static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_onearg_shared(duk_hthread *thr) {
 duk_small_int_t fun_idx = duk_get_current_magic(thr);
 duk__one_arg_func fun;
 duk_double_t arg1;

 do { } while (0);
 do { } while (0);
 arg1 = duk_to_number(thr, 0);
 fun = duk__one_arg_funcs[fun_idx];
 duk_push_number(thr, (duk_double_t) fun((double) arg1));
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_twoarg_shared(duk_hthread *thr) {
 duk_small_int_t fun_idx = duk_get_current_magic(thr);
 duk__two_arg_func fun;
 duk_double_t arg1;
 duk_double_t arg2;

 do { } while (0);
 do { } while (0);
 arg1 = duk_to_number(thr, 0);
 arg2 = duk_to_number(thr, 1);
 fun = duk__two_arg_funcs[fun_idx];
 duk_push_number(thr, (duk_double_t) fun((double) arg1, (double) arg2));
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_max(duk_hthread *thr) {
 return duk__math_minmax(thr, -((double) 
# 318 "duk_bi_math.c" 3 4
                              (__builtin_inff ())
# 318 "duk_bi_math.c"
                              ), duk__fmax_fixed);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_min(duk_hthread *thr) {
 return duk__math_minmax(thr, ((double) 
# 322 "duk_bi_math.c" 3 4
                             (__builtin_inff ())
# 322 "duk_bi_math.c"
                             ), duk__fmin_fixed);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_random(duk_hthread *thr) {
 duk_push_number(thr, (duk_double_t) duk_util_get_random_double(thr));
 return 1;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_hypot(duk_hthread *thr) {
# 343 "duk_bi_math.c"
 duk_idx_t nargs;
 duk_idx_t i;
 duk_bool_t found_nan;
 duk_double_t max;
 duk_double_t sum, summand;
 duk_double_t comp, prelim;
 duk_double_t t;

 nargs = duk_get_top(thr);


 max = 0.0;
 found_nan = 0;
 for (i = 0; i < nargs; i++) {
  t = fabs(duk_to_number(thr, i));
  if (
# 358 "duk_bi_math.c" 3 4
     __builtin_fpclassify (0, 1, 4, 3, 2, 
# 358 "duk_bi_math.c"
     t
# 358 "duk_bi_math.c" 3 4
     ) 
# 358 "duk_bi_math.c"
                       == 
# 358 "duk_bi_math.c" 3 4
                          0
# 358 "duk_bi_math.c"
                                    ) {
   found_nan = 1;
  } else {
   max = duk_double_fmax(max, t);
  }
 }


 if (duk_double_equals(max, ((double) 
# 366 "duk_bi_math.c" 3 4
                           (__builtin_inff ())
# 366 "duk_bi_math.c"
                           ))) {
  duk_push_number(thr, ((double) 
# 367 "duk_bi_math.c" 3 4
                      (__builtin_inff ())
# 367 "duk_bi_math.c"
                      ));
  return 1;
 } else if (found_nan) {
  duk_push_number(thr, 
# 370 "duk_bi_math.c" 3 4
                      (__builtin_nanf (""))
# 370 "duk_bi_math.c"
                                    );
  return 1;
 } else if (duk_double_equals(max, 0.0)) {
  duk_push_number(thr, 0.0);

  return 1;
 }






 sum = 0.0;
 comp = 0.0;
 for (i = 0; i < nargs; i++) {
  t = fabs(duk_get_number(thr, i)) / max;
  summand = (t * t) - comp;
  prelim = sum + summand;
  comp = (prelim - sum) - summand;
  sum = prelim;
 }

 duk_push_number(thr, (duk_double_t) sqrt(sum) * max);
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_sign(duk_hthread *thr) {
 duk_double_t d;

 d = duk_to_number(thr, 0);
 if (duk_double_is_nan(d)) {
  do { } while (0);
  return 1;
 }
 if (duk_double_equals(d, 0.0)) {

  return 1;
 }
 duk_push_int(thr, (d > 0.0 ? 1 : -1));
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_clz32(duk_hthread *thr) {
 duk_uint32_t x;
 duk_small_uint_t i;
# 435 "duk_bi_math.c"
 i = 0;
 x = duk_to_uint32(thr, 0);
 if (x & 0xffff0000UL) {
  x >>= 16;
 } else {
  i += 16;
 }
 if (x & 0x0000ff00UL) {
  x >>= 8;
 } else {
  i += 8;
 }
 if (x & 0x000000f0UL) {
  x >>= 4;
 } else {
  i += 4;
 }
 if (x & 0x0000000cUL) {
  x >>= 2;
 } else {
  i += 2;
 }
 if (x & 0x00000002UL) {
  x >>= 1;
 } else {
  i += 1;
 }
 if (x & 0x00000001UL) {
  ;
 } else {
  i += 1;
 }
 do { } while (0);
 duk_push_uint(thr, i);
 return 1;

}



static __attribute__ ((unused)) duk_ret_t duk_bi_math_object_imul(duk_hthread *thr) {
 duk_uint32_t x, y, z;

 x = duk_to_uint32(thr, 0);
 y = duk_to_uint32(thr, 1);
 z = x * y;





 duk_push_int((thr), (duk_int_t) ((duk_int32_t) z));
 return 1;
}
# 1 "duk_bi_number.c"
# 9 "duk_bi_number.c"
static duk_double_t duk__push_this_number_plain(duk_hthread *thr) {
 duk_hobject *h;





 duk_push_this(thr);
 if (duk_is_number(thr, -1)) {
  do { } while (0);
  goto done;
 }
 h = duk_get_hobject(thr, -1);
 if (!h || ((((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) != 10)) {
  do { } while (0);
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 24; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_bi_number.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("number expected"))); } while (0); } while (0);
  do { return 0.0; } while (0);
 }
 (((void) 0), ((void) 0), duk_xget_owndataprop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (106))));
 do { } while (0);
 do { } while (0)

                                                          ;
 duk_remove_m2(thr);

done:
 return duk_get_number(thr, -1);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_number_constructor(duk_hthread *thr) {
 duk_idx_t nargs;
 duk_hobject *h_this;
# 49 "duk_bi_number.c"
 nargs = duk_get_top(thr);
 if (nargs == 0) {
  duk_push_int(thr, 0);
 }
 duk_to_number(thr, 0);
 duk_set_top(thr, 1);
 do { } while (0);

 if (!duk_is_constructor_call(thr)) {
  return 1;
 }
# 75 "duk_bi_number.c"
 duk_push_this(thr);
 h_this = duk_known_hobject(thr, -1);
 do { (&(h_this)->hdr)->h_flags = ((&(h_this)->hdr)->h_flags & (~(((1UL << (5)) - 1UL) << ((7 + (20)))))) | (((10)) << ((7 + (20)))); } while (0);

 do { } while (0);
 do { } while (0);
 do { } while (0);

 duk_dup_0(thr);
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (106)) << 8) + (duk_uint_t) (0)));
 return 0;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_number_prototype_value_of(duk_hthread *thr) {
 (void) duk__push_this_number_plain(thr);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_number_prototype_to_string(duk_hthread *thr) {
 duk_small_int_t radix;
 duk_small_uint_t n2s_flags;

 (void) duk__push_this_number_plain(thr);
 if (duk_is_undefined(thr, 0)) {
  radix = 10;
 } else {
  radix = (duk_small_int_t) duk_to_int_check_range(thr, 0, 2, 36);
 }
 do { } while (0);

 n2s_flags = 0;

 duk_numconv_stringify(thr, radix , 0 , n2s_flags );
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_number_prototype_to_locale_string(duk_hthread *thr) {



 return duk_bi_number_prototype_to_string(thr);
}







static __attribute__ ((unused)) duk_ret_t duk_bi_number_prototype_to_fixed(duk_hthread *thr) {
 duk_small_int_t frac_digits;
 duk_double_t d;
 duk_small_int_t c;
 duk_small_uint_t n2s_flags;




 d = duk__push_this_number_plain(thr);
 frac_digits = (duk_small_int_t) duk_to_int_check_range(thr, 0, 0, 20);

 c = (duk_small_int_t) 
# 136 "duk_bi_number.c" 3 4
                      __builtin_fpclassify (0, 1, 4, 3, 2, 
# 136 "duk_bi_number.c"
                      d
# 136 "duk_bi_number.c" 3 4
                      )
# 136 "duk_bi_number.c"
                                       ;
 if (c == 
# 137 "duk_bi_number.c" 3 4
         0 
# 137 "duk_bi_number.c"
                    || c == 
# 137 "duk_bi_number.c" 3 4
                            1
# 137 "duk_bi_number.c"
                                           ) {
  goto use_to_string;
 }

 if (d >= 1.0e21 || d <= -1.0e21) {
  goto use_to_string;
 }

 n2s_flags = (1U << 0) | (1U << 3);

 duk_numconv_stringify(thr, 10 , frac_digits , n2s_flags );
 return 1;

use_to_string:
 do { } while (0);
 duk_to_string(thr, -1);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_number_prototype_to_exponential(duk_hthread *thr) {
 duk_bool_t frac_undefined;
 duk_small_int_t frac_digits;
 duk_double_t d;
 duk_small_int_t c;
 duk_small_uint_t n2s_flags;

 d = duk__push_this_number_plain(thr);

 frac_undefined = duk_is_undefined(thr, 0);
 duk_to_int(thr, 0);

 c = (duk_small_int_t) 
# 168 "duk_bi_number.c" 3 4
                      __builtin_fpclassify (0, 1, 4, 3, 2, 
# 168 "duk_bi_number.c"
                      d
# 168 "duk_bi_number.c" 3 4
                      )
# 168 "duk_bi_number.c"
                                       ;
 if (c == 
# 169 "duk_bi_number.c" 3 4
         0 
# 169 "duk_bi_number.c"
                    || c == 
# 169 "duk_bi_number.c" 3 4
                            1
# 169 "duk_bi_number.c"
                                           ) {
  goto use_to_string;
 }

 frac_digits = (duk_small_int_t) duk_to_int_check_range(thr, 0, 0, 20);

 n2s_flags = (1U << 1) | (frac_undefined ? 0 : (1U << 0));

 duk_numconv_stringify(thr, 10 , frac_digits + 1 , n2s_flags );
 return 1;

use_to_string:
 do { } while (0);
 duk_to_string(thr, -1);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_number_prototype_to_precision(duk_hthread *thr) {





 duk_double_t d;
 duk_small_int_t prec;
 duk_small_int_t c;
 duk_small_uint_t n2s_flags;

 do { } while (0);

 d = duk__push_this_number_plain(thr);
 if (duk_is_undefined(thr, 0)) {
  goto use_to_string;
 }
 do { } while (0);

 duk_to_int(thr, 0);

 c = (duk_small_int_t) 
# 207 "duk_bi_number.c" 3 4
                      __builtin_fpclassify (0, 1, 4, 3, 2, 
# 207 "duk_bi_number.c"
                      d
# 207 "duk_bi_number.c" 3 4
                      )
# 207 "duk_bi_number.c"
                                       ;
 if (c == 
# 208 "duk_bi_number.c" 3 4
         0 
# 208 "duk_bi_number.c"
                    || c == 
# 208 "duk_bi_number.c" 3 4
                            1
# 208 "duk_bi_number.c"
                                           ) {
  goto use_to_string;
 }

 prec = (duk_small_int_t) duk_to_int_check_range(thr, 0, 1, 21);

 n2s_flags = (1U << 0) | (1U << 2);

 duk_numconv_stringify(thr, 10 , prec , n2s_flags );
 return 1;

use_to_string:




 do { } while (0);
 duk_to_string(thr, -1);
 return 1;
}






static __attribute__ ((unused)) duk_ret_t duk_bi_number_check_shared(duk_hthread *thr) {
 duk_int_t magic;
 duk_bool_t ret = 0;

 if (duk_is_number(thr, 0)) {
  duk_double_t d;

  magic = duk_get_current_magic(thr);
  d = duk_get_number(thr, 0);

  switch (magic) {
  case 0:
   ret = duk_double_is_finite(d);
   break;
  case 1:
   ret = duk_double_is_integer(d);
   break;
  case 2:
   ret = duk_double_is_nan(d);
   break;
  default:
   do { } while (0);
   ret = duk_double_is_safe_integer(d);
  }
 }

 duk_push_boolean(thr, ret);
 return 1;
}
# 1 "duk_bi_object.c"







static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_to_string(duk_hthread *thr) {
 duk_tval *tv;

 tv = (((void) 0), ((void) 0), (thr)->valstack_bottom - 1);
 duk_push_class_string_tval(thr, tv, 0 );
 return 1;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor(duk_hthread *thr) {
 duk_uint_t arg_mask;

 arg_mask = duk_get_type_mask(thr, 0);

 if (!duk_is_constructor_call(thr) &&
     ((arg_mask & ((1U << 2U) | (1U << 1U))) == 0)) {
  duk_to_object(thr, 0);
  return 1;
 }






 if (arg_mask & ((1U << 6U) | (1U << 5U) | (1U << 3U) | (1U << 4U) |
                 (1U << 8U) | (1U << 7U) | (1U << 9U))) {




  duk_to_object(thr, 0);
  return 1;
 }

 (void) duk_push_object_helper(thr,
                               (1UL << (7 + (0))) | (1UL << (7 + (7))) |
                                   (((duk_uint_t) (1)) << (7 + (20))),
                               3);
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_assign(duk_hthread *thr) {
 duk_idx_t nargs;
 duk_int_t idx;

 nargs = duk_get_top_require_min(thr, 1 );

 duk_to_object(thr, 0);
 for (idx = 1; idx < nargs; idx++) {

  if (((duk_get_type_mask((thr), (idx)) & ((1U << 2U) | (1U << 1U))) ? 1 : 0)) {
   continue;
  }




  duk_to_object(thr, idx);
  duk_enum(thr, idx, (1U << 4));
  while (duk_next(thr, -1, 1 )) {

   duk_put_prop(thr, 0);

  }



 }

 duk_set_top(thr, 1);
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_is(duk_hthread *thr) {
 do { } while (0);
 duk_push_boolean(thr, duk_samevalue(thr, 0, 1));
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_create(duk_hthread *thr) {
 duk_hobject *proto;

 do { } while (0);


 duk_hbufobj_promote_plain(thr, 0);

 proto = duk_require_hobject_accept_mask(thr, 0, (1U << 2U));
 do { } while (0);

 (void) duk_push_object_helper_proto(thr,
                                     (1UL << (7 + (0))) | (1UL << (7 + (7))) |
                                         (((duk_uint_t) (1)) << (7 + (20))),
                                     proto);

 if (!duk_is_undefined(thr, 1)) {


  duk_replace(thr, 0);







  return duk_bi_object_constructor_define_properties(thr);
 }



 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_define_properties(duk_hthread *thr) {
 duk_small_uint_t pass;
 duk_uint_t defprop_flags;
 duk_hobject *obj;
 duk_idx_t idx_value;
 duk_hobject *get;
 duk_hobject *set;


 obj = duk_require_hobject_promote_mask(thr, 0, (1U << 9U) | (1U << 7U));
 do { } while (0);

 duk_to_object(thr, 1);

 do { } while (0);
# 157 "duk_bi_object.c"
 for (pass = 0; pass < 2; pass++) {
  duk_set_top(thr, 2);
  duk_enum(thr, 1, (1U << 4) | (1U << 2) );

  for (;;) {
   duk_hstring *key;



   duk_set_top(thr, 3);

   if (!duk_next(thr, 2, 1 )) {
    break;
   }

   do { } while (0)

                                                            ;



   duk_hobject_prepare_property_descriptor(thr, 4 , &defprop_flags, &idx_value, &get, &set);



   if (pass == 0) {
    continue;
   }


   key = duk_known_hstring(thr, 3);
   do { } while (0);

   duk_hobject_define_property_helper(thr, defprop_flags, obj, key, idx_value, get, set, 1 );
  }
 }





 duk_dup_0(thr);
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_seal_freeze_shared(duk_hthread *thr) {
 do { } while (0);

 duk_seal_freeze_raw(thr, 0, (duk_bool_t) duk_get_current_magic(thr) );
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_is_sealed_frozen_shared(duk_hthread *thr) {
 duk_hobject *h;
 duk_bool_t is_frozen;
 duk_uint_t mask;

 is_frozen = (duk_bool_t) duk_get_current_magic(thr);
 mask = duk_get_type_mask(thr, 0);
 if (mask & ((1U << 9U) | (1U << 7U))) {
  do { } while (0);
  duk_push_boolean(thr,
                   (mask & (1U << 9U)) ? 1 :
                                     (is_frozen ^ 1));
 } else {



  h = duk_get_hobject(thr, 0);
  duk_push_boolean(thr, (h == 
# 230 "duk_bi_object.c" 3 4
                             ((void *)0)
# 230 "duk_bi_object.c"
                                 ) || duk_hobject_object_is_sealed_frozen_helper(thr, h, is_frozen ));
 }
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_to_locale_string(duk_hthread *thr) {
 do { } while (0);
 (void) duk_push_this_coercible_to_object(thr);
 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (82))));



 duk_dup_0(thr);
 duk_call_method(thr, 0);
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_value_of(duk_hthread *thr) {

 (void) duk_push_this_coercible_to_object(thr);
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_is_prototype_of(duk_hthread *thr) {
 duk_hobject *h_v;
 duk_hobject *h_obj;

 do { } while (0);

 h_v = duk_get_hobject(thr, 0);
 if (!h_v) {
  duk_push_false(thr);
  return 1;
 }

 h_obj = duk_push_this_coercible_to_object(thr);
 do { } while (0);




 duk_push_boolean(
     thr,
     duk_hobject_prototype_chain_contains(thr, ((h_v)->prototype), h_obj, 0 ));
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_has_own_property(duk_hthread *thr) {
 return (duk_ret_t) duk_hobject_object_ownprop_helper(thr, 0 );
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_property_is_enumerable(duk_hthread *thr) {
 return (duk_ret_t) duk_hobject_object_ownprop_helper(thr, (1U << 1) );
}
# 302 "duk_bi_object.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_object_getprototype_shared(duk_hthread *thr) {






 duk_hobject *h;
 duk_hobject *proto;
 duk_tval *tv;
 duk_int_t magic;

 magic = duk_get_current_magic(thr);

 if (magic == 0) {
  do { } while (0);
  duk_push_this_coercible_to_object(thr);
 }
 do { } while (0);
 if (magic < 2) {

  duk_to_object(thr, 0);
 }
 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (0));

 switch (((tv)->t)) {
 case 10:
  proto = thr->builtins[42];
  break;
 case 6:
  proto = thr->builtins[5];
  break;
 case 9:
  h = ((tv)->v.hobject);
  proto = ((h)->prototype);
  break;
 default:



  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_object.c", (duk_int_t) 342); } while (0); return 0; } while (0);
 }
 if (proto != 
# 344 "duk_bi_object.c" 3 4
             ((void *)0)
# 344 "duk_bi_object.c"
                 ) {
  duk_push_hobject(thr, proto);
 } else {
  duk_push_null(thr);
 }
 return 1;
}
# 360 "duk_bi_object.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_object_setprototype_shared(duk_hthread *thr) {






 duk_hobject *h_obj;
 duk_hobject *h_new_proto;
 duk_hobject *h_curr;
 duk_ret_t ret_success = 1;
 duk_uint_t mask;
 duk_int_t magic;


 magic = duk_get_current_magic(thr);
 if (magic == 0) {
  duk_push_this_check_object_coercible(thr);
  duk_insert(thr, 0);
  if (!duk_check_type_mask(thr, 1, (1U << 2U) | (1U << 6U))) {
   return 0;
  }




  ret_success = 0;
 } else {
  if (magic == 1) {
   ((void) duk_check_type_mask((thr), (0), (1U << 3U) | (1U << 4U) | (1U << 5U) | (1U << 6U) | (1U << 7U) | (1U << 8U) | (1U << 9U) | (1U << 10)));
  } else {
   duk_require_hobject_accept_mask(thr, 0, (1U << 9U) | (1U << 7U));
  }
  ((void) duk_check_type_mask((thr), (1), ((1U << 2U) | (1U << 6U)) | (1U << 10)));
 }

 h_new_proto = duk_get_hobject(thr, 1);


 mask = duk_get_type_mask(thr, 0);
 if (mask & ((1U << 9U) | (1U << 7U))) {
  duk_hobject *curr_proto;
  curr_proto =
      thr->builtins[(mask & (1U << 9U)) ? 5 : 42];
  if (h_new_proto == curr_proto) {
   goto skip;
  }
  goto fail_nonextensible;
 }
 h_obj = duk_get_hobject(thr, 0);
 if (h_obj == 
# 410 "duk_bi_object.c" 3 4
             ((void *)0)
# 410 "duk_bi_object.c"
                 ) {
  goto skip;
 }
 do { } while (0);




 if (h_new_proto == ((h_obj)->prototype)) {
  goto skip;
 }
 if (!(((&(h_obj)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0)) {
  goto fail_nonextensible;
 }
 for (h_curr = h_new_proto; h_curr != 
# 424 "duk_bi_object.c" 3 4
                                     ((void *)0)
# 424 "duk_bi_object.c"
                                         ; h_curr = ((h_curr)->prototype)) {

  if (h_curr == h_obj) {
   goto fail_loop;
  }
 }
 duk_hobject_set_prototype_updref((thr), (h_obj), (h_new_proto));


skip:
 duk_set_top(thr, 1);
 if (magic == 2) {
  duk_push_true(thr);
 }
 return ret_success;

fail_nonextensible:
fail_loop:
 if (magic != 2) {
  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_object.c", (duk_int_t) 443); } while (0); return 0; } while (0);
 } else {
  duk_push_false(thr);
  return 1;
 }
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_define_property(duk_hthread *thr) {





 duk_hobject *obj;
 duk_hstring *key;
 duk_hobject *get;
 duk_hobject *set;
 duk_idx_t idx_value;
 duk_uint_t defprop_flags;
 duk_small_uint_t magic;
 duk_bool_t throw_flag;
 duk_bool_t ret;

 do { } while (0);

 do { } while (0)



                                                         ;



 magic = (duk_small_uint_t) duk_get_current_magic(thr);





 obj = duk_require_hobject_promote_mask(thr, 0, (1U << 9U) | (1U << 7U));
 do { } while (0);
 key = duk_to_property_key_hstring(thr, 1);
 (void) duk_require_hobject(thr, 2);

 do { } while (0);
 do { } while (0);
 do { } while (0);
# 501 "duk_bi_object.c"
 duk_hobject_prepare_property_descriptor(thr, 2 , &defprop_flags, &idx_value, &get, &set);





 do { } while (0);
 throw_flag = magic ^ 1U;
 ret = duk_hobject_define_property_helper(thr, defprop_flags, obj, key, idx_value, get, set, throw_flag);





 if (magic == 0U) {

  duk_push_hobject(thr, obj);
 } else {

  duk_push_boolean(thr, ret);
 }
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_get_own_property_descriptor(duk_hthread *thr) {
 do { } while (0);


 if (duk_get_current_magic(thr) == 0) {
  duk_to_object(thr, 0);
 }



 duk_hobject_object_get_own_property_descriptor(thr, -2);
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_is_extensible(duk_hthread *thr) {





 duk_hobject *h;

 if (duk_get_current_magic(thr) == 0) {
  h = duk_get_hobject(thr, 0);
 } else {



  h = duk_require_hobject_accept_mask(thr, 0, (1U << 9U) | (1U << 7U));
 }

 duk_push_boolean(thr, (h != 
# 560 "duk_bi_object.c" 3 4
                            ((void *)0)
# 560 "duk_bi_object.c"
                                ) && (((&(h)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0));
 return 1;
}
# 572 "duk_bi_object.c"
static const duk_small_uint_t duk__object_keys_enum_flags[4] = {

 (1U << 4) | (1U << 7),


 (1U << 0) | (1U << 4) | (1U << 7),


 (1U << 2) | (1U << 4) | (1U << 3) | (1U << 0) |
     (1U << 7),


 (1U << 2) | (1U << 4) | (1U << 0) | (1U << 7)
};

static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_keys_shared(duk_hthread *thr) {
 duk_hobject *obj;

 duk_hobject *h_proxy_target;
 duk_hobject *h_proxy_handler;
 duk_hobject *h_trap_result;

 duk_small_uint_t enum_flags;
 duk_int_t magic;

 do { } while (0);

 magic = duk_get_current_magic(thr);
 if (magic == 3) {



  obj = duk_require_hobject_promote_mask(thr, 0, (1U << 9U) | (1U << 7U));
 } else {

  obj = duk_to_hobject(thr, 0);
 }
 do { } while (0);
 do { (void) (obj); } while (0);





 if (__builtin_expect((!duk_hobject_proxy_check(obj, &h_proxy_target, &h_proxy_handler)), 1)) {
  goto skip_proxy;
 }

 duk_push_hobject(thr, h_proxy_handler);
 if (!(((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (75))))) {



  do { } while (0);
  duk_pop_2(thr);
  duk_push_hobject(thr, h_proxy_target);
  duk_replace(thr, 0);
  do { } while (0);
  goto skip_proxy;
 }


 duk_insert(thr, -2);
 duk_push_hobject(thr, h_proxy_target);
 duk_call_method(thr, 1 );
 h_trap_result = duk_require_hobject(thr, -1);
 do { (void) (h_trap_result); } while (0);

 magic = duk_get_current_magic(thr);
 do { } while (0);
 enum_flags = duk__object_keys_enum_flags[magic];

 duk_proxy_ownkeys_postprocess(thr, h_proxy_target, enum_flags);
 return 1;

skip_proxy:


 do { } while (0);
 magic = duk_get_current_magic(thr);
 do { } while (0);
 enum_flags = duk__object_keys_enum_flags[magic];
 return duk_hobject_get_enumerated_keys(thr, enum_flags);
}



static __attribute__ ((unused)) duk_ret_t duk_bi_object_constructor_prevent_extensions(duk_hthread *thr) {





 duk_hobject *h;
 duk_uint_t mask;
 duk_int_t magic;

 magic = duk_get_current_magic(thr);


 mask = (1U << 9U) | (1U << 7U);


 if (magic == 0) {
  mask |= (1U << 1U) | (1U << 2U) | (1U << 3U) | (1U << 4U) |
          (1U << 5U) | (1U << 8U);
 }

 if (duk_check_type_mask(thr, 0, mask)) {

  goto done;
 }
 h = duk_require_hobject(thr, 0);
 do { } while (0);

 do { do { } while (0); (&(h)->hdr)->h_flags &= ~(((1UL << (7 + (0))))); } while (0);




 duk_hobject_compact_props(thr, h);

done:
 if (magic == 1) {
  duk_push_true(thr);
 }
 return 1;
}







static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_defineaccessor(duk_hthread *thr) {
 duk_push_this(thr);
 duk_insert(thr, 0);
 duk_to_object(thr, 0);
 duk_require_function((thr), (2));




 duk_def_prop(thr,
              0,
              ((1U << 4) | (1U << 1)) | ((1U << 5) | (1U << 2)) |
                  (duk_get_current_magic(thr) ? (1U << 8) : (1U << 7)));
 return 0;
}
static __attribute__ ((unused)) duk_ret_t duk_bi_object_prototype_lookupaccessor(duk_hthread *thr) {
 duk_uint_t sanity;

 duk_push_this(thr);
 duk_to_object(thr, -1);






 sanity = 10000L;
 while (!duk_is_undefined(thr, -1)) {

  duk_dup(thr, 0);
  duk_get_prop_desc(thr, 1, 0 );
  if (!duk_is_undefined(thr, -1)) {
   duk_get_prop_stridx(thr, -1, (duk_get_current_magic(thr) != 0 ? 88 : 73));
   return 1;
  }
  duk_pop(thr);

  if (__builtin_expect((sanity-- == 0), 0)) {
   do { duk_err_range((thr), "duk_bi_object.c", (duk_int_t) 745, ("prototype chain limit")); } while (0);
   do { return 0; } while (0);
  }

  duk_get_prototype(thr, -1);
  duk_remove(thr, -2);
 }
 return 1;
}
# 1 "duk_bi_performance.c"
# 10 "duk_bi_performance.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_performance_now(duk_hthread *thr) {






 duk_push_number(thr, duk_time_get_monotonic_time(thr));
 return 1;
}
# 1 "duk_bi_pointer.c"
# 11 "duk_bi_pointer.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_pointer_constructor(duk_hthread *thr) {




 if (duk_get_top(thr) == 0) {
  duk_push_pointer(thr, 
# 17 "duk_bi_pointer.c" 3 4
                       ((void *)0)
# 17 "duk_bi_pointer.c"
                           );
 } else {
  duk_to_pointer(thr, 0);
 }
 do { } while (0);
 duk_set_top(thr, 1);

 if (duk_is_constructor_call(thr)) {
  (void) duk_push_object_helper(thr,
                                (1UL << (7 + (0))) | (1UL << (7 + (7))) |
                                    (((duk_uint_t) (17)) << (7 + (20))),
                                36);


  duk_dup_0(thr);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (106)) << 8) + (duk_uint_t) (0)));
 }


 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_pointer_prototype_tostring_shared(duk_hthread *thr) {
 duk_tval *tv;
 duk_small_int_t to_string = duk_get_current_magic(thr);

 duk_push_this(thr);
 tv = duk_require_tval(thr, -1);
 do { } while (0);

 if (((tv)->t == 5)) {

 } else if (((tv)->t == 9)) {
  duk_hobject *h = ((tv)->v.hobject);
  do { } while (0);


  if ((((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) != 17) {
   goto type_error;
  }

  (((void) 0), ((void) 0), duk_xget_owndataprop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (106))));
 } else {
  goto type_error;
 }

 if (to_string) {
  duk_to_string(thr, -1);
 }
 return 1;

type_error:
 do { do { duk_err_type_invalid_args(((thr)), "duk_bi_pointer.c", (duk_int_t) 73); } while (0); return 0; } while (0);
}
# 1 "duk_bi_promise.c"
# 1 "duk_bi_proxy.c"
# 12 "duk_bi_proxy.c"
static __attribute__ ((unused)) void duk_proxy_ownkeys_postprocess(duk_hthread *thr, duk_hobject *h_proxy_target, duk_uint_t flags) {
 duk_uarridx_t i, len, idx;
 duk_propdesc desc;

 do { } while (0);
 do { } while (0);

 len = (duk_uarridx_t) duk_get_length(thr, -1);
 idx = 0;
 duk_push_array(thr);

 for (i = 0; i < len; i++) {
  duk_hstring *h;


  (void) duk_get_prop_index(thr, -2, i);
  h = duk_get_hstring(thr, -1);
  if (h == 
# 29 "duk_bi_proxy.c" 3 4
          ((void *)0)
# 29 "duk_bi_proxy.c"
              ) {
   do { duk_err_type_invalid_trap_result((thr), "duk_bi_proxy.c", (duk_int_t) 30); } while (0);
   do { return; } while (0);
  }

  if (!(flags & (1U << 0))) {




   if (duk_hobject_get_own_propdesc(thr, h_proxy_target, duk_known_hstring(thr, -1), &desc, 0 )) {
    if ((desc.flags & (1U << 1)) == 0) {
     do { } while (0);
     goto skip_key;
    }
   } else {
    do { } while (0);
    goto skip_key;
   }
  }
  if (__builtin_expect(((((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
   if (!(flags & (1U << 2))) {
    do { } while (0);
    goto skip_key;
   }
   if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0) && !(flags & (1U << 1))) {
    do { } while (0);
    goto skip_key;
   }
  } else {
   if (flags & (1U << 3)) {
    do { } while (0);
    goto skip_key;
   }
  }


  duk_push_uint((thr), (duk_uint_t) (idx++));
  duk_insert(thr, -2);
  duk_def_prop(thr, -3, (1U << 6) | (((1U << 3) | (1U << 0)) | ((1U << 4) | (1U << 1)) | ((1U << 5) | (1U << 2))));
  continue;

 skip_key:
  duk_pop(thr);
  continue;
 }
# 87 "duk_bi_proxy.c"
}



static __attribute__ ((unused)) duk_ret_t duk_bi_proxy_constructor(duk_hthread *thr) {
 do { } while (0);

 duk_require_constructor_call(thr);
 duk_push_proxy(thr, 0 );
 return 1;
}
# 1 "duk_bi_reflect.c"
# 12 "duk_bi_reflect.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_reflect_object_delete_property(duk_hthread *thr) {
 duk_tval *tv_obj;
 duk_tval *tv_key;
 duk_bool_t ret;

 do { } while (0);
 (void) duk_require_hobject(thr, 0);
 (void) duk_to_string(thr, 1);



 do { } while (0);
 tv_obj = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (0));
 tv_key = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (1));
 ret = duk_hobject_delprop(thr, tv_obj, tv_key, 0 );
 duk_push_boolean(thr, ret);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_reflect_object_get(duk_hthread *thr) {
 duk_tval *tv_obj;
 duk_tval *tv_key;
 duk_idx_t nargs;

 do { } while (0);
 nargs = duk_get_top_require_min(thr, 2 );
 (void) duk_require_hobject(thr, 0);
 (void) duk_to_string(thr, 1);
 if (nargs >= 3 && !duk_strict_equals(thr, 0, 2)) {

  do { do { duk_errcode_t duk__err = (1); duk_int_t duk__line = (duk_int_t) 42; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_bi_reflect.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("unsupported")); } while (0); } while (0);
  do { return 0; } while (0);
 }



 tv_obj = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (0));
 tv_key = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (1));
 (void) duk_hobject_getprop(thr, tv_obj, tv_key);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_reflect_object_has(duk_hthread *thr) {
 duk_tval *tv_obj;
 duk_tval *tv_key;
 duk_bool_t ret;

 do { } while (0);
 do { } while (0);
 (void) duk_require_hobject(thr, 0);
 (void) duk_to_string(thr, 1);



 tv_obj = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (0));
 tv_key = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (1));
 ret = duk_hobject_hasprop(thr, tv_obj, tv_key);
 duk_push_boolean(thr, ret);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_reflect_object_set(duk_hthread *thr) {
 duk_tval *tv_obj;
 duk_tval *tv_key;
 duk_tval *tv_val;
 duk_idx_t nargs;
 duk_bool_t ret;

 do { } while (0);
 nargs = duk_get_top_require_min(thr, 3 );
 (void) duk_require_hobject(thr, 0);
 (void) duk_to_string(thr, 1);
 if (nargs >= 4 && !duk_strict_equals(thr, 0, 3)) {

  do { do { duk_errcode_t duk__err = (1); duk_int_t duk__line = (duk_int_t) 86; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_bi_reflect.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("unsupported")); } while (0); } while (0);
  do { return 0; } while (0);
 }



 tv_obj = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (0));
 tv_key = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (1));
 tv_val = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (2));
 ret = duk_hobject_putprop(thr, tv_obj, tv_key, tv_val, 0 );
 duk_push_boolean(thr, ret);
 return 1;
}
# 1 "duk_bi_regexp.c"
# 9 "duk_bi_regexp.c"
static void duk__get_this_regexp(duk_hthread *thr) {
 duk_hobject *h;

 duk_push_this(thr);
 h = duk_require_hobject_with_class(thr, -1, 11);
 do { } while (0);
 do { (void) (h); } while (0);
 duk_insert(thr, 0);
}


static __attribute__ ((unused)) duk_ret_t duk_bi_regexp_constructor(duk_hthread *thr) {
 duk_hobject *h_pattern;

 do { } while (0);
 h_pattern = duk_get_hobject(thr, 0);

 if (!duk_is_constructor_call(thr) && h_pattern != 
# 26 "duk_bi_regexp.c" 3 4
                                                  ((void *)0) 
# 26 "duk_bi_regexp.c"
                                                       &&
     (((&(h_pattern)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 11 && duk_is_undefined(thr, 1)) {






  duk_dup_0(thr);
  return 1;
 }





 if (h_pattern != 
# 42 "duk_bi_regexp.c" 3 4
                 ((void *)0) 
# 42 "duk_bi_regexp.c"
                      && (((&(h_pattern)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 11) {
  (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (44))));
  if (duk_is_undefined(thr, 1)) {



   duk_get_prop_stridx(thr, 0, 48);
  } else {

   duk_dup_1(thr);
  }
 } else {
  if (duk_is_undefined(thr, 0)) {
   duk_push_hstring_empty(thr);
  } else {
   duk_dup_0(thr);
   duk_to_string(thr, -1);
  }
  if (duk_is_undefined(thr, 1)) {
   duk_push_hstring_empty(thr);
  } else {
   duk_dup_1(thr);
   duk_to_string(thr, -1);
  }


 }

 do { } while (0)

                                                          ;



 duk_to_string(thr, -2);
 duk_to_string(thr, -1);
 duk_regexp_compile(thr);



 duk_regexp_create_instance(thr);



 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_regexp_prototype_exec(duk_hthread *thr) {
 duk__get_this_regexp(thr);



 duk_regexp_match(thr);



 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_regexp_prototype_test(duk_hthread *thr) {
 duk__get_this_regexp(thr);




 duk_regexp_match(thr);



 duk_push_boolean(thr, (duk_is_null(thr, -1) ? 0 : 1));

 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_regexp_prototype_tostring(duk_hthread *thr) {

 do { } while (0);
 duk_push_this(thr);
 duk_push_literal_raw((thr), ("/"), sizeof(("/")) - 1U);
 duk_get_prop_stridx(thr, 0, 44);
 duk_dup_m2(thr);
 duk_get_prop_stridx(thr, 0, 48);
 duk_concat(thr, 4);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_regexp_prototype_flags(duk_hthread *thr) {



 duk_uint8_t buf[8];
 duk_uint8_t *p = buf;


 duk_push_this(thr);
 (void) duk_require_hobject(thr, -1);
 if (duk_get_prop_stridx_boolean(thr, 0, 27, 
# 138 "duk_bi_regexp.c" 3 4
                                                           ((void *)0)
# 138 "duk_bi_regexp.c"
                                                               )) {
  *p++ = 0x67;
 }
 if (duk_get_prop_stridx_boolean(thr, 0, 45, 
# 141 "duk_bi_regexp.c" 3 4
                                                                ((void *)0)
# 141 "duk_bi_regexp.c"
                                                                    )) {
  *p++ = 0x69;
 }
 if (duk_get_prop_stridx_boolean(thr, 0, 46, 
# 144 "duk_bi_regexp.c" 3 4
                                                              ((void *)0)
# 144 "duk_bi_regexp.c"
                                                                  )) {
  *p++ = 0x6d;
 }


 *p++ = 0x00;
 do { } while (0);

 duk_push_string(thr, (const char *) buf);
 return 1;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_regexp_prototype_shared_getter(duk_hthread *thr) {
 duk_hstring *h_bc;
 duk_small_uint_t re_flags;
 duk_hobject *h;
 duk_int_t magic;

 do { } while (0);

 duk_push_this(thr);
 h = duk_require_hobject(thr, -1);
 magic = duk_get_current_magic(thr);

 if ((((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 11) {
  (((void) 0), ((void) 0), duk_xget_owndataprop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (101))));
  (((void) 0), ((void) 0), duk_xget_owndataprop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (98))));
  h_bc = duk_require_hstring(thr, -1);
  re_flags = (duk_small_uint_t) ((const duk_uint8_t *) ((h_bc) + 1))[0];
  duk_pop(thr);
 } else if (h == thr->builtins[18]) {





  if (magic != 16 ) {
   return 0;
  }
  duk_push_literal_raw((thr), ("(?:)"), sizeof(("(?:)")) - 1U);
  re_flags = 0;
 } else {
  do { do { duk_err_type_invalid_args(((thr)), "duk_bi_regexp.c", (duk_int_t) 187); } while (0); return 0; } while (0);
 }



 switch (magic) {
 case 0: {
  duk_push_boolean(thr, (re_flags & (1U << 0)));
  break;
 }
 case 1: {
  duk_push_boolean(thr, (re_flags & (1U << 1)));
  break;
 }
 case 2: {
  duk_push_boolean(thr, (re_flags & (1U << 2)));
  break;
 }
# 215 "duk_bi_regexp.c"
 default: {

  break;
 }
 }

 return 1;
}
# 1 "duk_bi_string.c"
# 26 "duk_bi_string.c"
static duk_hstring *duk__str_tostring_notregexp(duk_hthread *thr, duk_idx_t idx) {
 duk_hstring *h;

 if (duk_get_class_number(thr, idx) == 11) {
  do { duk_err_type_invalid_args((thr), "duk_bi_string.c", (duk_int_t) 30); } while (0);
  do { return 
# 31 "duk_bi_string.c" 3 4
 ((void *)0)
# 31 "duk_bi_string.c"
 ; } while (0);
 }
 h = duk_to_hstring(thr, idx);
 do { } while (0);

 return h;
}

static duk_int_t
duk__str_search_shared(duk_hthread *thr, duk_hstring *h_this, duk_hstring *h_search, duk_int_t start_cpos, duk_bool_t backwards) {
 duk_int_t cpos;
 duk_int_t bpos;
 const duk_uint8_t *p_start, *p_end, *p;
 const duk_uint8_t *q_start;
 duk_int_t q_blen;
 duk_uint8_t firstbyte;
 duk_uint8_t t;

 cpos = start_cpos;





 q_start = ((const duk_uint8_t *) ((h_search) + 1));
 q_blen = (duk_int_t) ((h_search)->blen);
 if (q_blen <= 0) {
  return cpos;
 }
 do { } while (0);

 bpos = (duk_int_t) duk_heap_strcache_offset_char2byte(thr, h_this, (duk_uint32_t) cpos);

 p_start = ((const duk_uint8_t *) ((h_this) + 1));
 p_end = p_start + ((h_this)->blen);
 p = p_start + bpos;
# 75 "duk_bi_string.c"
 firstbyte = q_start[0];
 while (p <= p_end && p >= p_start) {
  t = *p;






  if ((t == firstbyte) && ((duk_size_t) (p_end - p) >= (duk_size_t) q_blen)) {
   do { } while (0);
   if (duk_memcmp((const void *) p, (const void *) q_start, (size_t) q_blen) == 0) {
    return cpos;
   }
  }


  if (backwards) {





   if ((t & 0xc0) != 0x80) {
    cpos--;
   }
   p--;
  } else {
   if ((t & 0xc0) != 0x80) {
    cpos++;
   }
   p++;
  }
 }


 return -1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_string_constructor(duk_hthread *thr) {
 duk_hstring *h;
 duk_uint_t flags;
# 132 "duk_bi_string.c"
 if (duk_get_top(thr) == 0) {
  duk_push_hstring_empty(thr);
 } else {
  h = duk_to_hstring_acceptsymbol(thr, 0);
  if (__builtin_expect(((((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0) && !duk_is_constructor_call(thr)), 0)) {
   duk_push_symbol_descriptive_string(thr, h);
   duk_replace(thr, 0);
  }
 }
 duk_to_string(thr, 0);
 do { } while (0);
 duk_set_top(thr, 1);

 if (duk_is_constructor_call(thr)) {

  flags = (1UL << (7 + (0))) | (1UL << (7 + (7))) | (1UL << (7 + (16))) |
          (((duk_uint_t) (12)) << (7 + (20)));
  duk_push_object_helper(thr, flags, 10);
  duk_dup_0(thr);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (106)) << 8) + (duk_uint_t) (0)));
 }


 return 1;
}

static duk_ret_t duk__construct_from_codepoints(duk_hthread *thr, duk_bool_t nonbmp) {
 duk_bufwriter_ctx bw_alloc;
 duk_bufwriter_ctx *bw;
 duk_idx_t i, n;
 duk_ucodepoint_t cp;







 n = duk_get_top(thr);

 bw = &bw_alloc;
 do { duk_bw_init_pushbuf((thr), (bw), ((duk_size_t) n)); } while (0);

 for (i = 0; i < n; i++) {




  if (nonbmp) {





   duk_int32_t i32 = 0;
   if (!duk_is_whole_get_int32(duk_to_number(thr, i), &i32) || i32 < 0 || i32 > 0x10ffffL) {
    do { do { do { duk_err_range((((thr))), "duk_bi_string.c", (duk_int_t) 188, ("invalid args")); } while (0); } while (0); return 0; } while (0);
   }
   do { } while (0);
   cp = (duk_ucodepoint_t) i32;
   do { do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (6); duk__space = (duk_size_t) (((bw))->p_limit - ((bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((thr)), ((bw)), duk__sz); } } while (0); do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) ((cp)); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_cesu8(duk__cp, ((bw))->p); ((bw))->p += duk__enc_len; } while (0); } while (0);
  } else {






   cp = (duk_ucodepoint_t) duk_to_uint32(thr, i);
   do { do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (7); duk__space = (duk_size_t) (((bw))->p_limit - ((bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((thr)), ((bw)), duk__sz); } } while (0); do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) ((cp)); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_xutf8(duk__cp, ((bw))->p); ((bw))->p += duk__enc_len; } while (0); } while (0);





  }
 }

 do { duk_bw_compact((thr), (bw)); } while (0);
 (void) duk_buffer_to_string(thr, -1);
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_string_constructor_from_char_code(duk_hthread *thr) {
 return duk__construct_from_codepoints(thr, 0 );
}


static __attribute__ ((unused)) duk_ret_t duk_bi_string_constructor_from_code_point(duk_hthread *thr) {
 return duk__construct_from_codepoints(thr, 1 );
}






static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_to_string(duk_hthread *thr) {
 duk_tval *tv;

 duk_push_this(thr);
 tv = duk_require_tval(thr, -1);
 do { } while (0);

 if (((tv)->t == 8)) {

 } else if (((tv)->t == 9)) {
  duk_hobject *h = ((tv)->v.hobject);
  do { } while (0);


  if ((((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) != 12) {
   goto type_error;
  }

  (((void) 0), ((void) 0), duk_xget_owndataprop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (106))));
  do { } while (0);
 } else {
  goto type_error;
 }

 (void) duk_require_hstring_notsymbol(thr, -1);
 return 1;

type_error:
 do { do { duk_err_type_invalid_args(((thr)), "duk_bi_string.c", (duk_int_t) 257); } while (0); return 0; } while (0);
}





static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_char_at(duk_hthread *thr) {
 duk_hstring *h;
 duk_int_t pos;



 h = duk_push_this_coercible_to_string(thr);
 do { } while (0);

 pos = duk_to_int(thr, 0);

 if (sizeof(duk_size_t) >= sizeof(duk_uint_t)) {






  do { } while (0);
  do { } while (0);
  duk_substring(thr, -1, (duk_size_t) pos, (duk_size_t) pos + 1U);
 } else {



  if (__builtin_expect((pos < 0 || (duk_uint_t) pos >= (duk_uint_t) duk_hstring_get_charlen((h))), 0)) {
   duk_push_hstring_empty(thr);
  } else {
   duk_substring(thr, -1, (duk_size_t) pos, (duk_size_t) pos + 1U);
  }
 }

 return 1;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_char_code_at(duk_hthread *thr) {
 duk_int_t pos;
 duk_hstring *h;
 duk_bool_t clamped;
 duk_uint32_t cp;
 duk_int_t magic;



 do { } while (0);

 h = duk_push_this_coercible_to_string(thr);
 do { } while (0);

 pos = duk_to_int_clamped_raw(thr,
                              0 ,
                              0 ,
                              (duk_int_t) duk_hstring_get_charlen((h)) - 1 ,
                              &clamped );

 magic = duk_get_current_magic(thr);




 if (clamped) {



  if (magic != 0) {
   return 0;
  }
  duk_push_nan(thr);
 } else {
  do { } while (0);
  cp = (duk_uint32_t) duk_hstring_char_code_at_raw(thr, h, (duk_uint_t) pos, (duk_bool_t) magic );
  duk_push_uint((thr), (duk_uint_t) (cp));
 }
 return 1;
}
# 349 "duk_bi_string.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_substring(duk_hthread *thr) {
 duk_hstring *h;
 duk_int_t start_pos, end_pos;
 duk_int_t len;

 h = duk_push_this_coercible_to_string(thr);
 do { } while (0);
 len = (duk_int_t) duk_hstring_get_charlen((h));



 start_pos = duk_to_int_clamped(thr, 0, 0, len);
 if (duk_is_undefined(thr, 1)) {
  end_pos = len;
 } else {
  end_pos = duk_to_int_clamped(thr, 1, 0, len);
 }
 do { } while (0);
 do { } while (0);

 if (start_pos > end_pos) {
  duk_int_t tmp = start_pos;
  start_pos = end_pos;
  end_pos = tmp;
 }

 do { } while (0);

 duk_substring(thr, -1, (duk_size_t) start_pos, (duk_size_t) end_pos);
 return 1;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_substr(duk_hthread *thr) {
 duk_hstring *h;
 duk_int_t start_pos, end_pos;
 duk_int_t len;





 duk_push_this(thr);
 h = duk_to_hstring_m1(thr);
 do { } while (0);
 len = (duk_int_t) duk_hstring_get_charlen((h));
# 404 "duk_bi_string.c"
 start_pos = duk_to_int_clamped(thr, 0, -len, len);
 if (start_pos < 0) {
  start_pos = len + start_pos;
 }
 do { } while (0);


 if (duk_is_undefined(thr, 1)) {
  end_pos = len;
 } else {
  do { } while (0);
  end_pos = start_pos + duk_to_int_clamped(thr, 1, 0, len - start_pos);
 }
 do { } while (0);
 do { } while (0);
 do { } while (0);

 duk_substring(thr, -1, (duk_size_t) start_pos, (duk_size_t) end_pos);
 return 1;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_slice(duk_hthread *thr) {
 duk_hstring *h;
 duk_int_t start_pos, end_pos;
 duk_int_t len;

 h = duk_push_this_coercible_to_string(thr);
 do { } while (0);
 len = (duk_int_t) duk_hstring_get_charlen((h));



 start_pos = duk_to_int_clamped(thr, 0, -len, len);
 if (start_pos < 0) {
  start_pos = len + start_pos;
 }
 if (duk_is_undefined(thr, 1)) {
  end_pos = len;
 } else {
  end_pos = duk_to_int_clamped(thr, 1, -len, len);
  if (end_pos < 0) {
   end_pos = len + end_pos;
  }
 }
 do { } while (0);
 do { } while (0);

 if (end_pos < start_pos) {
  end_pos = start_pos;
 }

 do { } while (0);

 duk_substring(thr, -1, (duk_size_t) start_pos, (duk_size_t) end_pos);
 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_caseconv_shared(duk_hthread *thr) {
 duk_small_int_t uppercase = duk_get_current_magic(thr);

 (void) duk_push_this_coercible_to_string(thr);
 duk_unicode_case_convert_string(thr, (duk_bool_t) uppercase);
 return 1;
}





static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_indexof_shared(duk_hthread *thr) {
 duk_hstring *h_this;
 duk_hstring *h_search;
 duk_int_t clen_this;
 duk_int_t cpos;
 duk_small_uint_t is_lastindexof = (duk_small_uint_t) duk_get_current_magic(thr);

 h_this = duk_push_this_coercible_to_string(thr);
 do { } while (0);
 clen_this = (duk_int_t) duk_hstring_get_charlen((h_this));

 h_search = duk_to_hstring(thr, 0);
 do { } while (0);

 duk_to_number(thr, 1);
 if (duk_is_nan(thr, 1) && is_lastindexof) {




  cpos = clen_this;
 } else {
  cpos = duk_to_int_clamped(thr, 1, 0, clen_this);
 }

 cpos = duk__str_search_shared(thr, h_this, h_search, cpos, is_lastindexof );
 duk_push_int(thr, cpos);
 return 1;
}
# 523 "duk_bi_string.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_replace(duk_hthread *thr) {
 duk_hstring *h_input;
 duk_hstring *h_match;
 duk_hstring *h_search;
 duk_hobject *h_re;
 duk_bufwriter_ctx bw_alloc;
 duk_bufwriter_ctx *bw;

 duk_bool_t is_regexp;
 duk_bool_t is_global;

 duk_bool_t is_repl_func;
 duk_uint32_t match_start_coff, match_start_boff;

 duk_int_t match_caps;

 duk_uint32_t prev_match_end_boff;
 const duk_uint8_t *r_start, *r_end, *r;
 duk_size_t tmp_sz;

 do { } while (0);
 h_input = duk_push_this_coercible_to_string(thr);
 do { } while (0);

 bw = &bw_alloc;
 do { duk_bw_init_pushbuf((thr), (bw), (((h_input)->blen))); } while (0);

 do { } while (0);







 h_re = duk_get_hobject_with_class(thr, 0, 11);
 if (h_re) {

  is_regexp = 1;
  is_global = duk_get_prop_stridx_boolean(thr, 0, 27, 
# 562 "duk_bi_string.c" 3 4
                                                                    ((void *)0)
# 562 "duk_bi_string.c"
                                                                        );

  if (is_global) {

   duk_push_int(thr, 0);
   (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (47))));
  }



 } else {
  duk_to_string(thr, 0);

  is_regexp = 0;
  is_global = 0;

 }

 if (duk_is_function(thr, 1)) {
  is_repl_func = 1;
  r_start = 
# 582 "duk_bi_string.c" 3 4
           ((void *)0)
# 582 "duk_bi_string.c"
               ;
  r_end = 
# 583 "duk_bi_string.c" 3 4
         ((void *)0)
# 583 "duk_bi_string.c"
             ;
 } else {
  duk_hstring *h_repl;

  is_repl_func = 0;
  h_repl = duk_to_hstring(thr, 1);
  do { } while (0);
  r_start = ((const duk_uint8_t *) ((h_repl) + 1));
  r_end = r_start + ((h_repl)->blen);
 }

 prev_match_end_boff = 0;

 for (;;) {
# 620 "duk_bi_string.c"
  do { } while (0);


  if (is_regexp) {
   duk_dup_0(thr);
   duk_dup_2(thr);
   duk_regexp_match(thr);
   if (!duk_is_object(thr, -1)) {
    duk_pop(thr);
    break;
   }

   (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (49))));
   do { } while (0);
   match_start_coff = duk_get_uint(thr, -1);
   duk_pop(thr);

   duk_get_prop_index(thr, -1, 0);
   do { } while (0);
   h_match = duk_known_hstring(thr, -1);
   duk_pop(thr);

   if (((h_match)->blen) == 0) {



    duk_uint32_t last_index;

    (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (47))));
    last_index = (duk_uint32_t) duk_get_uint(thr, -1);
    do { } while (0)

                                                  ;
    duk_pop(thr);
    duk_push_uint(thr, (duk_uint_t) (last_index + 1));
    (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (47))));
   }

   do { } while (0);
   match_caps = (duk_int_t) duk_get_length(thr, -1);
  } else {



   const duk_uint8_t *p_start, *p_end, *p;
   const duk_uint8_t *q_start;
   duk_size_t p_blen;
   duk_size_t q_blen;


   do { } while (0);


   p_start = ((const duk_uint8_t *) ((h_input) + 1));
   p_end = p_start + ((h_input)->blen);
   p_blen = (duk_size_t) ((h_input)->blen);
   p = p_start;

   h_search = duk_known_hstring(thr, 0);
   q_start = ((const duk_uint8_t *) ((h_search) + 1));
   q_blen = (duk_size_t) ((h_search)->blen);

   if (q_blen > p_blen) {
    break;
   }

   p_end -= q_blen;
   do { } while (0);

   match_start_coff = 0;

   while (p <= p_end) {
    do { } while (0);
    if (duk_memcmp((const void *) p, (const void *) q_start, (size_t) q_blen) == 0) {
     duk_dup_0(thr);
     h_match = duk_known_hstring(thr, -1);

     match_caps = 0;

     goto found;
    }


    if ((p[0] & 0xc0) != 0x80) {
     match_start_coff++;
    }
    p++;
   }


   break;
  }
 found:
# 721 "duk_bi_string.c"
  match_start_boff = (duk_uint32_t) duk_heap_strcache_offset_char2byte(thr, h_input, match_start_coff);

  tmp_sz = (duk_size_t) (match_start_boff - prev_match_end_boff);
  do { const void *duk__valptr; duk_size_t duk__valsz; duk__valptr = (const void *) (((const duk_uint8_t *) ((h_input) + 1)) + prev_match_end_boff); duk__valsz = (duk_size_t) (tmp_sz); do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (duk__valsz); duk__space = (duk_size_t) (((bw))->p_limit - ((bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((thr)), ((bw)), duk__sz); } } while (0); do { void *duk__dst = ((void *) ((bw)->p)); const void *duk__src = (duk__valptr); duk_size_t duk__len = (duk__valsz); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0); (bw)->p += duk__valsz; } while (0);

  prev_match_end_boff = match_start_boff + ((h_match)->blen);

  if (is_repl_func) {
   duk_idx_t idx_args;
   duk_hstring *h_repl;



   duk_dup_1(thr);
   idx_args = duk_get_top(thr);


   if (is_regexp) {
    duk_int_t idx;
    duk_require_stack(thr, match_caps + 2);
    for (idx = 0; idx < match_caps; idx++) {

     duk_get_prop_index(thr, 4, (duk_uarridx_t) idx);
    }
   } else {




    duk_dup_0(thr);
   }
   duk_push_uint(thr, (duk_uint_t) match_start_coff);
   duk_dup_2(thr);



   duk_call(thr, duk_get_top(thr) - idx_args);
   h_repl = duk_to_hstring_m1(thr);
   do { } while (0);

   do { duk_size_t duk__val_len; duk__val_len = (((h_repl))->blen); do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (duk__val_len); duk__space = (duk_size_t) (((bw))->p_limit - ((bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((thr)), ((bw)), duk__sz); } } while (0); do { void *duk__dst = ((void *) ((bw)->p)); const void *duk__src = ((const void *) ((const duk_uint8_t *) (((h_repl)) + 1))); duk_size_t duk__len = (duk__val_len); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0); (bw)->p += duk__val_len; } while (0);

   duk_pop(thr);
  } else {
   r = r_start;

   while (r < r_end) {
    duk_int_t ch1;
    duk_int_t ch2;

    duk_int_t ch3;

    duk_size_t left;

    ch1 = *r++;
    if (ch1 != 0x24) {
     goto repl_write;
    }
    do { } while (0);
    left = (duk_size_t) (r_end - r);

    if (left <= 0) {
     goto repl_write;
    }

    ch2 = r[0];
    switch (ch2) {
    case 0x24: {
     ch1 = (1 << 8) + 0x24;
     goto repl_write;
    }
    case 0x26: {
     do { duk_size_t duk__val_len; duk__val_len = (((h_match))->blen); do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (duk__val_len); duk__space = (duk_size_t) (((bw))->p_limit - ((bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((thr)), ((bw)), duk__sz); } } while (0); do { void *duk__dst = ((void *) ((bw)->p)); const void *duk__src = ((const void *) ((const duk_uint8_t *) (((h_match)) + 1))); duk_size_t duk__len = (duk__val_len); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0); (bw)->p += duk__val_len; } while (0);
     r++;
     continue;
    }
    case 0x60: {
     tmp_sz = (duk_size_t) match_start_boff;
     do { const void *duk__valptr; duk_size_t duk__valsz; duk__valptr = (const void *) (((const duk_uint8_t *) ((h_input) + 1))); duk__valsz = (duk_size_t) (tmp_sz); do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (duk__valsz); duk__space = (duk_size_t) (((bw))->p_limit - ((bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((thr)), ((bw)), duk__sz); } } while (0); do { void *duk__dst = ((void *) ((bw)->p)); const void *duk__src = (duk__valptr); duk_size_t duk__len = (duk__valsz); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0); (bw)->p += duk__valsz; } while (0);
     r++;
     continue;
    }
    case 0x27: {
     duk_uint32_t match_end_boff;





     match_end_boff = (duk_uint32_t) duk_heap_strcache_offset_char2byte(
         thr,
         h_input,
         match_start_coff + (duk_uint_fast32_t) duk_hstring_get_charlen((h_match)));

     tmp_sz = (duk_size_t) (((h_input)->blen) - match_end_boff);
     do { const void *duk__valptr; duk_size_t duk__valsz; duk__valptr = (const void *) (((const duk_uint8_t *) ((h_input) + 1)) + match_end_boff); duk__valsz = (duk_size_t) (tmp_sz); do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (duk__valsz); duk__space = (duk_size_t) (((bw))->p_limit - ((bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((thr)), ((bw)), duk__sz); } } while (0); do { void *duk__dst = ((void *) ((bw)->p)); const void *duk__src = (duk__valptr); duk_size_t duk__len = (duk__valsz); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0); (bw)->p += duk__valsz; } while (0);
     r++;
     continue;
    }
    default: {

     duk_int_t capnum, captmp, capadv;




     if (!is_regexp) {
      goto repl_write;
     }

     if (!(ch2 >= 0x30 && ch2 <= 0x39)) {
      goto repl_write;
     }
     capnum = ch2 - 0x30;
     capadv = 1;

     if (left >= 2) {
      ch3 = r[1];
      if (ch3 >= 0x30 && ch3 <= 0x39) {
       captmp = capnum * 10 + (ch3 - 0x30);
       if (captmp < match_caps) {
        capnum = captmp;
        capadv = 2;
       }
      }
     }

     if (capnum > 0 && capnum < match_caps) {
      do { } while (0);


      duk_get_prop_index(thr, 4, (duk_uarridx_t) capnum);
      if (duk_is_string(thr, -1)) {
       duk_hstring *h_tmp_str;

       h_tmp_str = duk_known_hstring(thr, -1);

       do { duk_size_t duk__val_len; duk__val_len = (((h_tmp_str))->blen); do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (duk__val_len); duk__space = (duk_size_t) (((bw))->p_limit - ((bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((thr)), ((bw)), duk__sz); } } while (0); do { void *duk__dst = ((void *) ((bw)->p)); const void *duk__src = ((const void *) ((const duk_uint8_t *) (((h_tmp_str)) + 1))); duk_size_t duk__len = (duk__val_len); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0); (bw)->p += duk__val_len; } while (0);
      } else {

      }
      duk_pop(thr);
      r += capadv;
      continue;
     } else {
      goto repl_write;
     }



    }
    }

   repl_write:


    do { do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (1); duk__space = (duk_size_t) (((bw))->p_limit - ((bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((thr)), ((bw)), duk__sz); } } while (0); do { do { (((void) 0), ((void) 0)); } while (0); *((bw))->p++ = (duk_uint8_t) (((duk_uint8_t) (ch1 & 0xff))); } while (0); } while (0);
    r += ch1 >> 8;
   }
  }

  duk_pop(thr);


  if (!is_global) {



   break;
  }
 }


 tmp_sz = (duk_size_t) (((h_input)->blen) - prev_match_end_boff);
 do { const void *duk__valptr; duk_size_t duk__valsz; duk__valptr = (const void *) (((const duk_uint8_t *) ((h_input) + 1)) + prev_match_end_boff); duk__valsz = (duk_size_t) (tmp_sz); do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (duk__valsz); duk__space = (duk_size_t) (((bw))->p_limit - ((bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((thr)), ((bw)), duk__sz); } } while (0); do { void *duk__dst = ((void *) ((bw)->p)); const void *duk__src = (duk__valptr); duk_size_t duk__len = (duk__valsz); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0); (bw)->p += duk__valsz; } while (0);

 do { } while (0);
 do { duk_bw_compact((thr), (bw)); } while (0);
 (void) duk_buffer_to_string(thr, -1);
 return 1;
}
# 911 "duk_bi_string.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_split(duk_hthread *thr) {
 duk_hstring *h_input;
 duk_hstring *h_sep;
 duk_uint32_t limit;
 duk_uint32_t arr_idx;

 duk_bool_t is_regexp;

 duk_bool_t matched;
 duk_uint32_t prev_match_end_coff, prev_match_end_boff;
 duk_uint32_t match_start_boff, match_start_coff;
 duk_uint32_t match_end_boff, match_end_coff;

 h_input = duk_push_this_coercible_to_string(thr);
 do { } while (0);

 duk_push_array(thr);

 if (duk_is_undefined(thr, 1)) {
  limit = 0xffffffffUL;
 } else {
  limit = duk_to_uint32(thr, 1);
 }

 if (limit == 0) {
  return 1;
 }







 if (duk_is_undefined(thr, 0)) {




  duk_dup_2(thr);
  duk_put_prop_index(thr, 3, 0);
  return 1;
 } else if (duk_get_hobject_with_class(thr, 0, 11) != 
# 953 "duk_bi_string.c" 3 4
                                                                           ((void *)0)
# 953 "duk_bi_string.c"
                                                                               ) {

  duk_push_hobject_bidx(thr, 17);
  duk_dup_0(thr);
  duk_new(thr, 1);
  duk_replace(thr, 0);

  is_regexp = 1;



 } else {
  duk_to_string(thr, 0);

  is_regexp = 0;

 }







 prev_match_end_boff = 0;
 prev_match_end_coff = 0;
 arr_idx = 0;
 matched = 0;

 for (;;) {







  do { } while (0);


  if (is_regexp) {
   duk_dup_0(thr);
   duk_dup_2(thr);
   duk_regexp_match_force_global(thr);
   if (!duk_is_object(thr, -1)) {
    duk_pop(thr);
    break;
   }
   matched = 1;

   (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (49))));
   do { } while (0);
   match_start_coff = duk_get_uint(thr, -1);
   match_start_boff = (duk_uint32_t) duk_heap_strcache_offset_char2byte(thr, h_input, match_start_coff);
   duk_pop(thr);

   if (match_start_coff == duk_hstring_get_charlen((h_input))) {

    duk_pop(thr);
    break;
   }

   (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (47))));
   do { } while (0);
   match_end_coff = duk_get_uint(thr, -1);
   match_end_boff = (duk_uint32_t) duk_heap_strcache_offset_char2byte(thr, h_input, match_end_coff);
   duk_pop(thr);


   if (prev_match_end_boff == match_end_boff) {
    duk_push_uint(thr, (duk_uint_t) (match_end_coff + 1));
    (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (47))));
    duk_pop(thr);
    continue;
   }
  } else {



   const duk_uint8_t *p_start, *p_end, *p;
   const duk_uint8_t *q_start;
   duk_size_t q_blen, q_clen;

   p_start = ((const duk_uint8_t *) ((h_input) + 1));
   p_end = p_start + ((h_input)->blen);
   p = p_start + prev_match_end_boff;

   h_sep = duk_known_hstring(thr, 0);
   q_start = ((const duk_uint8_t *) ((h_sep) + 1));
   q_blen = (duk_size_t) ((h_sep)->blen);
   q_clen = (duk_size_t) duk_hstring_get_charlen((h_sep));

   p_end -= q_blen;

   match_start_coff = prev_match_end_coff;

   if (q_blen == 0) {
# 1058 "duk_bi_string.c"
    matched = 1;

    match_start_coff++;
    p++;
    while (p < p_end) {
     if ((p[0] & 0xc0) != 0x80) {
      goto found;
     }
     p++;
    }
    goto not_found;
   }

   do { } while (0);
   while (p <= p_end) {
    do { } while (0);
    do { } while (0);
    if (duk_memcmp((const void *) p, (const void *) q_start, (size_t) q_blen) == 0) {

     goto found;
    }


    if ((p[0] & 0xc0) != 0x80) {
     match_start_coff++;
    }
    p++;
   }

  not_found:

   break;

  found:
   matched = 1;
   match_start_boff = (duk_uint32_t) (p - p_start);
   match_end_coff = (duk_uint32_t) (match_start_coff + q_clen);
   match_end_boff = (duk_uint32_t) (match_start_boff + q_blen);


   if (prev_match_end_boff == match_end_boff) {
    prev_match_end_boff++;
    prev_match_end_coff++;
    continue;
   }
  }
# 1112 "duk_bi_string.c"
  do { } while (0)





                                                   ;

  duk_push_lstring(thr,
                   (const char *) (((const duk_uint8_t *) ((h_input) + 1)) + prev_match_end_boff),
                   (duk_size_t) (match_start_boff - prev_match_end_boff));
  duk_put_prop_index(thr, 3, arr_idx);
  arr_idx++;
  if (arr_idx >= limit) {
   goto hit_limit;
  }


  if (is_regexp) {
   duk_size_t i, len;

   len = duk_get_length(thr, 4);
   for (i = 1; i < len; i++) {
    do { } while (0);
    duk_get_prop_index(thr, 4, (duk_uarridx_t) i);
    duk_put_prop_index(thr, 3, arr_idx);
    arr_idx++;
    if (arr_idx >= limit) {
     goto hit_limit;
    }
   }

   duk_pop(thr);

  } else {





  }

  prev_match_end_boff = match_end_boff;
  prev_match_end_coff = match_end_coff;
  continue;
 }



 do { } while (0);

 if (((h_input)->blen) > 0 || !matched) {





  duk_push_lstring(thr,
                   (const char *) ((const duk_uint8_t *) ((h_input) + 1)) + prev_match_end_boff,
                   (duk_size_t) (((h_input)->blen) - prev_match_end_boff));
  duk_put_prop_index(thr, 3, arr_idx);

 }

 return 1;

hit_limit:

 if (is_regexp) {
  duk_pop(thr);
 }


 return 1;
}






static void duk__to_regexp_helper(duk_hthread *thr, duk_idx_t idx, duk_bool_t force_new) {
 duk_hobject *h;



 do { } while (0);

 if (force_new) {
  goto do_new;
 }

 h = duk_get_hobject_with_class(thr, idx, 11);
 if (!h) {
  goto do_new;
 }
 return;

do_new:
 duk_push_hobject_bidx(thr, 17);
 duk_dup(thr, idx);
 duk_new(thr, 1);
 duk_replace(thr, idx);
}



static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_search(duk_hthread *thr) {
# 1230 "duk_bi_string.c"
 do { } while (0);
 (void) duk_push_this_coercible_to_string(thr);
 duk__to_regexp_helper(thr, 0 , 1 );
# 1242 "duk_bi_string.c"
 duk_dup_0(thr);
 duk_dup_1(thr);
 duk_regexp_match(thr);

 if (!duk_is_object(thr, -1)) {
  duk_push_int(thr, -1);
  return 1;
 }

 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (49))));
 do { } while (0);
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_match(duk_hthread *thr) {
 duk_bool_t global;
 duk_int_t prev_last_index;
 duk_int_t this_index;
 duk_int_t arr_idx;

 do { } while (0);
 (void) duk_push_this_coercible_to_string(thr);
 duk__to_regexp_helper(thr, 0 , 0 );
 global = duk_get_prop_stridx_boolean(thr, 0, 27, 
# 1267 "duk_bi_string.c" 3 4
                                                                ((void *)0)
# 1267 "duk_bi_string.c"
                                                                    );
 do { } while (0);





 if (!global) {
  duk_regexp_match(thr);
  return 1;
 }





 duk_push_int(thr, 0);
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (47))));
 duk_push_array(thr);



 prev_last_index = 0;
 arr_idx = 0;

 for (;;) {
  do { } while (0);

  duk_dup_0(thr);
  duk_dup_1(thr);
  duk_regexp_match(thr);

  if (!duk_is_object(thr, -1)) {
   duk_pop(thr);
   break;
  }

  (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (47))));
  do { } while (0);
  this_index = duk_get_int(thr, -1);
  duk_pop(thr);

  if (this_index == prev_last_index) {
   this_index++;
   duk_push_int(thr, this_index);
   (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (0)) << 16) + ((duk_uint_t) (47))));
  }
  prev_last_index = this_index;

  duk_get_prop_index(thr, -1, 0);
  duk_put_prop_index(thr, 2, (duk_uarridx_t) arr_idx);
  arr_idx++;
  duk_pop(thr);
 }

 if (arr_idx == 0) {
  duk_push_null(thr);
 }

 return 1;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_concat(duk_hthread *thr) {

 (void) duk_push_this_coercible_to_string(thr);
 duk_insert(thr, 0);
 duk_concat(thr, duk_get_top(thr));
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_trim(duk_hthread *thr) {
 do { } while (0);
 (void) duk_push_this_coercible_to_string(thr);
 duk_trim(thr, 0);
 do { } while (0);
 return 1;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_repeat(duk_hthread *thr) {
 duk_hstring *h_input;
 duk_size_t input_blen;
 duk_size_t result_len;
 duk_int_t count_signed;
 duk_uint_t count;
 const duk_uint8_t *src;
 duk_uint8_t *buf;
 duk_uint8_t *p;
 duk_double_t d;

 duk_size_t copy_size;
 duk_uint8_t *p_end;


 do { } while (0);
 h_input = duk_push_this_coercible_to_string(thr);
 do { } while (0);
 input_blen = ((h_input)->blen);







 d = duk_to_number(thr, 0);
 if (duk_double_is_posinf(d)) {
  goto fail_range;
 }
 count_signed = duk_get_int(thr, 0);
 if (count_signed < 0) {
  goto fail_range;
 }
 count = (duk_uint_t) count_signed;


 result_len = count * input_blen;
 if (count != 0 && result_len / count != input_blen) {
  goto fail_range;
 }


 buf = (duk_uint8_t *) duk_push_fixed_buffer_nozero(thr, result_len);
 do { } while (0);
 src = (const duk_uint8_t *) ((const duk_uint8_t *) ((h_input) + 1));
 do { } while (0);
# 1405 "duk_bi_string.c"
 p = buf;
 p_end = p + result_len;
 copy_size = input_blen;
 for (;;) {
  duk_size_t remain = (duk_size_t) (p_end - p);
  do { } while (0)



                                          ;
  if (remain <= copy_size) {



   do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) src); duk_size_t duk__len = (remain); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
   break;
  } else {
   do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) src); duk_size_t duk__len = (copy_size); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
   p += copy_size;
  }

  src = (const duk_uint8_t *) buf;
  copy_size = (duk_size_t) (p - buf);
 }
# 1440 "duk_bi_string.c"
 duk_buffer_to_string(thr, -1);
 return 1;

fail_range:
 do { do { do { duk_err_range((((thr))), "duk_bi_string.c", (duk_int_t) 1444, ("invalid args")); } while (0); } while (0); return 0; } while (0);
}


static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_locale_compare(duk_hthread *thr) {
 duk_hstring *h1;
 duk_hstring *h2;
 duk_size_t h1_len, h2_len, prefix_len;
 duk_small_int_t ret = 0;
 duk_small_int_t rc;
# 1467 "duk_bi_string.c"
 h1 = duk_push_this_coercible_to_string(thr);
 do { } while (0);

 h2 = duk_to_hstring(thr, 0);
 do { } while (0);

 h1_len = (duk_size_t) ((h1)->blen);
 h2_len = (duk_size_t) ((h2)->blen);
 prefix_len = (h1_len <= h2_len ? h1_len : h2_len);

 rc = (duk_small_int_t) duk_memcmp((const void *) ((const duk_uint8_t *) ((h1) + 1)),
                                   (const void *) ((const duk_uint8_t *) ((h2) + 1)),
                                   (size_t) prefix_len);

 if (rc < 0) {
  ret = -1;
  goto done;
 } else if (rc > 0) {
  ret = 1;
  goto done;
 }


 if (h1_len > h2_len) {
  ret = 1;
  goto done;
 } else if (h1_len == h2_len) {
  do { } while (0);
  goto done;
 }
 ret = -1;
 goto done;

done:
 duk_push_int(thr, (duk_int_t) ret);
 return 1;
}


static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_startswith_endswith(duk_hthread *thr) {
 duk_int_t magic;
 duk_hstring *h_target;
 duk_size_t blen_target;
 duk_hstring *h_search;
 duk_size_t blen_search;
 duk_int_t off;
 duk_bool_t result = 0;
 duk_size_t blen_left;




 do { } while (0);

 h_target = duk_push_this_coercible_to_string(thr);
 do { } while (0);

 h_search = duk__str_tostring_notregexp(thr, 0);
 do { } while (0);

 magic = duk_get_current_magic(thr);



 blen_target = ((h_target)->blen);
 blen_search = ((h_search)->blen);
# 1544 "duk_bi_string.c"
 off = 0;
 if (duk_is_undefined(thr, 1)) {
  if (magic) {
   off = (duk_int_t) blen_target - (duk_int_t) blen_search;
  } else {
   do { } while (0);
  }
 } else {
  duk_int_t len;
  duk_int_t pos;

  do { } while (0);
  len = (duk_int_t) duk_hstring_get_charlen((h_target));
  pos = duk_to_int_clamped(thr, 1, 0, len);
  do { } while (0);

  off = (duk_int_t) duk_heap_strcache_offset_char2byte(thr, h_target, (duk_uint_fast32_t) pos);
  if (magic) {
   off -= (duk_int_t) blen_search;
  }
 }
 if (off < 0 || off > (duk_int_t) blen_target) {
  goto finish;
 }
# 1576 "duk_bi_string.c"
 do { } while (0);
 do { } while (0);
 blen_left = blen_target - (duk_size_t) off;
 if (blen_left >= blen_search) {
  const duk_uint8_t *p_cmp_start = (const duk_uint8_t *) ((const duk_uint8_t *) ((h_target) + 1)) + off;
  const duk_uint8_t *p_search = (const duk_uint8_t *) ((const duk_uint8_t *) ((h_search) + 1));
  if (duk_memcmp_unsafe((const void *) p_cmp_start, (const void *) p_search, (size_t) blen_search) == 0) {
   result = 1;
  }
 }

finish:
 duk_push_boolean(thr, result);
 return 1;
}



static __attribute__ ((unused)) duk_ret_t duk_bi_string_prototype_includes(duk_hthread *thr) {
 duk_hstring *h;
 duk_hstring *h_search;
 duk_int_t len;
 duk_int_t pos;

 h = duk_push_this_coercible_to_string(thr);
 do { } while (0);

 h_search = duk__str_tostring_notregexp(thr, 0);
 do { } while (0);

 len = (duk_int_t) duk_hstring_get_charlen((h));
 pos = duk_to_int_clamped(thr, 1, 0, len);
 do { } while (0);

 pos = duk__str_search_shared(thr, h, h_search, pos, 0 );
 duk_push_boolean(thr, pos >= 0);
 return 1;
}
# 1 "duk_bi_symbol.c"
# 13 "duk_bi_symbol.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_symbol_constructor_shared(duk_hthread *thr) {
 const duk_uint8_t *desc;
 duk_size_t len;
 duk_uint8_t *buf;
 duk_uint8_t *p;
 duk_int_t magic;

 magic = duk_get_current_magic(thr);
 if (duk_is_undefined(thr, 0) && (magic == 0)) {



  desc = 
# 25 "duk_bi_symbol.c" 3 4
        ((void *)0)
# 25 "duk_bi_symbol.c"
            ;
  len = 0;
 } else {

  desc = (const duk_uint8_t *) duk_to_lstring(thr, 0, &len);
 }
# 39 "duk_bi_symbol.c"
 buf = (duk_uint8_t *) duk_push_buffer_raw((thr), (1 + len + 1 + 17 + 1), 0 );
 do { } while (0);
 p = buf + 1;
 do { } while (0);
 do { void *duk__dst = ((void *) p); const void *duk__src = ((const void *) desc); duk_size_t duk__len = (len); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0);
 p += len;
 if (magic == 0) {




  if (++thr->heap->sym_counter[0] == 0) {
   thr->heap->sym_counter[1]++;
  }
  p += sprintf((char *) p,
                   "\xFF"
                   "%lx-%lx",
                   (unsigned long) thr->heap->sym_counter[1],
                   (unsigned long) thr->heap->sym_counter[0]);
  if (desc == 
# 58 "duk_bi_symbol.c" 3 4
             ((void *)0)
# 58 "duk_bi_symbol.c"
                 ) {




   *p++ = 0xff;
  }
  buf[0] = 0x81;
 } else {

  buf[0] = 0x80;
 }

 duk_push_lstring(thr, (const char *) buf, (duk_size_t) (p - buf));
 do { } while (0);
 return 1;
}

static duk_hstring *duk__auto_unbox_symbol(duk_hthread *thr, duk_tval *tv_arg) {
 duk_tval *tv;
 duk_hobject *h_obj;
 duk_hstring *h_str;

 do { } while (0);




 tv = tv_arg;
 if (((tv)->t == 9)) {
  h_obj = ((tv)->v.hobject);
  do { } while (0);
  if ((((&(h_obj)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 14) {
   tv = duk_hobject_get_internal_value_tval_ptr(thr->heap, h_obj);
   if (tv == 
# 92 "duk_bi_symbol.c" 3 4
            ((void *)0)
# 92 "duk_bi_symbol.c"
                ) {
    return 
# 93 "duk_bi_symbol.c" 3 4
          ((void *)0)
# 93 "duk_bi_symbol.c"
              ;
   }
  } else {
   return 
# 96 "duk_bi_symbol.c" 3 4
         ((void *)0)
# 96 "duk_bi_symbol.c"
             ;
  }
 }

 if (!((tv)->t == 8)) {
  return 
# 101 "duk_bi_symbol.c" 3 4
        ((void *)0)
# 101 "duk_bi_symbol.c"
            ;
 }
 h_str = ((tv)->v.hstring);
 do { } while (0);


 if (__builtin_expect((!(((&(h_str)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
  return 
# 108 "duk_bi_symbol.c" 3 4
        ((void *)0)
# 108 "duk_bi_symbol.c"
            ;
 }

 return h_str;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_symbol_tostring_shared(duk_hthread *thr) {
 duk_hstring *h_str;

 h_str = duk__auto_unbox_symbol(thr, (((void) 0), ((void) 0), (thr)->valstack_bottom - 1));
 if (h_str == 
# 118 "duk_bi_symbol.c" 3 4
             ((void *)0)
# 118 "duk_bi_symbol.c"
                 ) {
  return (-6);
 }

 if (duk_get_current_magic(thr) == 0) {

  duk_push_symbol_descriptive_string(thr, h_str);
 } else {

  duk_push_hstring(thr, h_str);
 }
 return 1;
}

static __attribute__ ((unused)) duk_ret_t duk_bi_symbol_key_for(duk_hthread *thr) {
 duk_hstring *h;
 const duk_uint8_t *p;




 h = duk_require_hstring(thr, 0);
 do { } while (0);

 p = (const duk_uint8_t *) ((const duk_uint8_t *) ((h) + 1));
 do { } while (0);




 if (p[0] == 0x80) {

  duk_push_lstring(thr, (const char *) (p + 1), (duk_size_t) (((h)->blen) - 1));
  return 1;
 } else if (p[0] == 0x81 || p[0] == 0x82 || p[0] == 0xff) {

  return 0;
 }


 return (-6);
}

static __attribute__ ((unused)) duk_ret_t duk_bi_symbol_toprimitive(duk_hthread *thr) {
 duk_hstring *h_str;

 h_str = duk__auto_unbox_symbol(thr, (((void) 0), ((void) 0), (thr)->valstack_bottom - 1));
 if (h_str == 
# 165 "duk_bi_symbol.c" 3 4
             ((void *)0)
# 165 "duk_bi_symbol.c"
                 ) {
  return (-6);
 }
 duk_push_hstring(thr, h_str);
 return 1;
}
# 1 "duk_bi_thread.c"
# 12 "duk_bi_thread.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_thread_constructor(duk_hthread *thr) {
 duk_hthread *new_thr;
 duk_hobject *func;






 func = duk_require_hobject_promote_mask((thr), (0), (1U << 9U));
 do { } while (0);
 duk_require_function((thr), (0));

 duk_push_thread_raw((thr), 0 );
 new_thr = (duk_hthread *) duk_known_hobject(thr, -1);
 new_thr->state = 1;




 duk_push_hobject(new_thr, func);

 return 1;
}
# 54 "duk_bi_thread.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_thread_resume(duk_hthread *ctx) {
 duk_hthread *thr = (duk_hthread *) ctx;
 duk_hthread *thr_resume;
 duk_hobject *caller_func;
 duk_small_uint_t is_error;

 do { } while (0)


                                                         ;

 do { } while (0);
 do { } while (0);

 thr_resume = duk_require_hthread(thr, 0);
 do { } while (0);
 is_error = (duk_small_uint_t) duk_to_boolean_top_pop(thr);
 do { } while (0);







 if (thr->callstack_top < 2) {
  do { } while (0)
                                                                                                              ;
  goto state_error;
 }
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 caller_func = ((thr->callstack_curr->parent)->func);
 if (!(((&(caller_func)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
  do { } while (0);
  goto state_error;
 }





 if (thr_resume->state != 1 && thr_resume->state != 4) {
  do { } while (0);
  goto state_error;
 }

 do { } while (0);



 if (thr_resume->state == 4) {



 } else {
  duk_hobject *h_fun;

  do { } while (0);






  if ((thr_resume->callstack_top != 0) || (thr_resume->valstack_top - thr_resume->valstack != 1)) {
   goto state_error;
  }

  duk_push_tval(thr, ((((void) 0), ((void) 0)), ((duk_hthread *) (thr_resume))->valstack_top + (-1)));
  duk_resolve_nonbound_function(thr);
  h_fun = duk_require_hobject(thr, -1);
  if (!(((&((h_fun))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0) || !(((&(h_fun)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
   goto state_error;
  }
  duk_pop(thr);
 }
# 157 "duk_bi_thread.c"
 if (is_error) {
  do { } while (0);
  duk_err_augment_error_throw(thr);
 }
# 179 "duk_bi_thread.c"
 thr->heap->lj.type = 3;


 do { } while (0);
 do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (&thr->heap->lj.value2); tv__src = (&thr->valstack_bottom[0]); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((tv__dst))->t & 0x08)) { h__obj = ((tv__dst)->v.heaphdr); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);


 do { } while (0);
 do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (&thr->heap->lj.value1); tv__src = (&thr->valstack_bottom[1]); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((tv__dst))->t & 0x08)) { h__obj = ((tv__dst)->v.heaphdr); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);
 do { } while (0);

 thr->heap->lj.iserror = is_error;

 do { } while (0);
 duk_err_longjmp(thr);
 do { __builtin_unreachable(); } while (0);


state_error:
 do { do { duk_err_type_invalid_state(((thr)), "duk_bi_thread.c", (duk_int_t) 198); } while (0); return 0; } while (0);
}
# 218 "duk_bi_thread.c"
static __attribute__ ((unused)) duk_ret_t duk_bi_thread_yield(duk_hthread *thr) {
 duk_hobject *caller_func;
 duk_small_uint_t is_error;

 do { } while (0)

                                                         ;

 do { } while (0);
 do { } while (0);

 do { } while (0);
 is_error = (duk_small_uint_t) duk_to_boolean_top_pop(thr);
 do { } while (0);







 if (!thr->resumer) {
  do { } while (0);
  goto state_error;
 }
 do { } while (0);

 if (thr->callstack_top < 2) {
  do { } while (0)
                                                                                                            ;
  goto state_error;
 }
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 caller_func = ((thr->callstack_curr->parent)->func);
 if (!(((&(caller_func)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
  do { } while (0);
  goto state_error;
 }

 do { } while (0);
 if (thr->callstack_preventcount != 1) {

  do { } while (0)

                                                         ;
  goto state_error;
 }
# 279 "duk_bi_thread.c"
 if (is_error) {
  do { } while (0);
  duk_err_augment_error_throw(thr);
 }
# 300 "duk_bi_thread.c"
 thr->heap->lj.type = 2;


 do { } while (0);
 do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (&thr->heap->lj.value1); tv__src = (&thr->valstack_bottom[0]); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((tv__dst))->t & 0x08)) { h__obj = ((tv__dst)->v.heaphdr); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);
 do { } while (0);

 thr->heap->lj.iserror = is_error;

 do { } while (0);
 duk_err_longjmp(thr);
 do { __builtin_unreachable(); } while (0);


state_error:
 do { do { duk_err_type_invalid_state(((thr)), "duk_bi_thread.c", (duk_int_t) 315); } while (0); return 0; } while (0);
}



static __attribute__ ((unused)) duk_ret_t duk_bi_thread_current(duk_hthread *thr) {
 duk_push_current_thread(thr);
 return 1;
}
# 1 "duk_bi_thrower.c"






static __attribute__ ((unused)) duk_ret_t duk_bi_type_error_thrower(duk_hthread *thr) {
 do { do { duk_err_type_invalid_args(((thr)), "duk_bi_thrower.c", (duk_int_t) 8); } while (0); return 0; } while (0);
}
# 1 "duk_debug_fixedbuffer.c"
# 1 "duk_debug_vsnprintf.c"
# 1 "duk_debugger.c"
# 1 "duk_error_augment.c"
# 62 "duk_error_augment.c"
static void duk__err_augment_user(duk_hthread *thr, duk_small_uint_t stridx_cb) {
 duk_tval *tv_hnd;
 duk_int_t rc;

 do { } while (0);
 do { } while (0);
 do { } while (0);

 if (thr->heap->augmenting_error) {
  do { } while (0);
  return;
 }
# 85 "duk_error_augment.c"
 ;



 if (thr->builtins[34] == 
# 89 "duk_error_augment.c" 3 4
                                       ((void *)0)
# 89 "duk_error_augment.c"
                                           ) {



  do { } while (0);
  return;
 }
 tv_hnd = duk_hobject_find_entry_tval_ptr_stridx(thr->heap, thr->builtins[34], stridx_cb);
 if (tv_hnd == 
# 97 "duk_error_augment.c" 3 4
              ((void *)0)
# 97 "duk_error_augment.c"
                  ) {
  do { } while (0);
  return;
 }
 do { } while (0);
 duk_push_tval(thr, tv_hnd);



 duk_insert(thr, -2);
 duk_push_undefined(thr);
 duk_insert(thr, -2);
# 121 "duk_error_augment.c"
 do { } while (0);
 thr->heap->augmenting_error = 1;

 rc = duk_pcall_method(thr, 1);
 do { (void) (rc); } while (0);

 do { } while (0);
 thr->heap->augmenting_error = 0;


}







static void duk__add_traceback(duk_hthread *thr,
                                  duk_hthread *thr_callstack,
                                  const char *c_filename,
                                  duk_int_t c_line,
                                  duk_small_uint_t flags) {
 duk_activation *act;
 duk_int_t depth;
 duk_int_t arr_size;
 duk_tval *tv;
 duk_hstring *s;
 duk_uint32_t u32;
 duk_double_t d;

 do { } while (0);
 do { } while (0);
# 165 "duk_error_augment.c"
 do { } while (0);




 act = thr->callstack_curr;
 depth = 10;
 do { } while (0);
 if (depth > (duk_int_t) thr_callstack->callstack_top) {
  depth = (duk_int_t) thr_callstack->callstack_top;
 }
 if (depth > 0) {
  if (flags & (1U << 1)) {
   do { } while (0);
   act = act->parent;
   depth--;
  }
 }
 arr_size = depth * 2;
 if (thr->compile_ctx != 
# 184 "duk_error_augment.c" 3 4
                        ((void *)0) 
# 184 "duk_error_augment.c"
                             && thr->compile_ctx->h_filename != 
# 184 "duk_error_augment.c" 3 4
                                                                ((void *)0)
# 184 "duk_error_augment.c"
                                                                    ) {
  arr_size += 2;
 }
 if (c_filename) {




  duk_push_string(thr, c_filename);
  arr_size += 2;
 }




 do { } while (0);
 tv = duk_push_harray_with_size_outptr(thr, (duk_uint32_t) arr_size);
 duk_clear_prototype(thr, -1);
 do { } while (0);
 do { } while (0);




 if (thr->compile_ctx != 
# 208 "duk_error_augment.c" 3 4
                        ((void *)0) 
# 208 "duk_error_augment.c"
                             && thr->compile_ctx->h_filename != 
# 208 "duk_error_augment.c" 3 4
                                                                ((void *)0)
# 208 "duk_error_augment.c"
                                                                    ) {
  s = thr->compile_ctx->h_filename;
  do { duk_tval *duk__tv; duk__tv = (tv); duk__tv->t = 8; duk__tv->v.hstring = (s); } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (s))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  tv++;

  u32 = (duk_uint32_t) thr->compile_ctx->curr_token.start_line;
  do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((duk_double_t) (u32)); ; duk__tv = ((tv)); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0);
  tv++;
 }
# 226 "duk_error_augment.c"
 if (c_filename) {
  do { } while (0);
  s = ((thr->valstack_top - 2)->v.hstring);
  do { } while (0);
  do { duk_tval *duk__tv; duk__tv = (tv); duk__tv->t = 8; duk__tv->v.hstring = (s); } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (s))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  tv++;

  d = ((flags & (1U << 0)) ?
                         ((duk_double_t) (1U << 0)) * 4294967296.0 :
                         0.0) +
      (duk_double_t) c_line;
  do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((d)); ; duk__tv = ((tv)); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0);
  tv++;
 }




 for (; depth-- > 0; act = act->parent) {
  duk_uint32_t pc;
  duk_tval *tv_src;



  do { } while (0);
  do { } while (0);


  tv_src = &act->tv_func;
  do { } while (0);
  do { *(tv) = *(tv_src); } while (0);
  do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  tv++;






  pc = (duk_uint32_t) duk_hthread_get_act_prev_pc(thr_callstack, act);
  do { } while (0);
  do { } while (0);
  d = ((duk_double_t) act->flags) * 4294967296.0 + (duk_double_t) pc;
  do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((d)); ; duk__tv = ((tv)); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0);
  tv++;
 }
# 287 "duk_error_augment.c"
 if (c_filename) {
  duk_remove_m2(thr);
 }



 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw(((thr)), (((duk_uint_t) ((-2))) << 24) + (((duk_uint_t) ((92))) << 8) + (duk_uint_t) (((1U << 0) | (1U << 1) | (1U << 2)))));
}
# 423 "duk_error_augment.c"
static void duk__add_compiler_error_line(duk_hthread *thr) {
# 432 "duk_error_augment.c"
 do { } while (0);

 if (!(thr->compile_ctx != 
# 434 "duk_error_augment.c" 3 4
                          ((void *)0) 
# 434 "duk_error_augment.c"
                               && thr->compile_ctx->h_filename != 
# 434 "duk_error_augment.c" 3 4
                                                                  ((void *)0)
# 434 "duk_error_augment.c"
                                                                      )) {
  return;
 }

 do { } while (0);

 if ((((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (52))))) {
  duk_bool_t at_end;
# 450 "duk_error_augment.c"
  at_end = (thr->compile_ctx->lex.window[0].codepoint < 0);

  do { } while (0)





                                                                     ;

  duk_push_sprintf(thr,
                   " (line %ld%s)",
                   (long) thr->compile_ctx->curr_token.start_line,
                   at_end ? ", end of input" : "");
  duk_concat(thr, 2);
  (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (52))));
 } else {
  duk_pop(thr);
 }

 do { } while (0);
}
# 480 "duk_error_augment.c"
static void duk__err_augment_builtin_create(duk_hthread *thr,
                                               duk_hthread *thr_callstack,
                                               const char *c_filename,
                                               duk_int_t c_line,
                                               duk_hobject *obj,
                                               duk_small_uint_t flags) {







 do { } while (0);

 do { (void) (obj); } while (0);

 duk__add_compiler_error_line(thr);






 if (duk_hobject_find_entry_tval_ptr_stridx(thr->heap, obj, 92) != 
# 504 "duk_error_augment.c" 3 4
                                                                                        ((void *)0)
# 504 "duk_error_augment.c"
                                                                                            ) {
  do { } while (0);
 } else {
  duk__add_traceback(thr, thr_callstack, c_filename, c_line, flags);
 }
# 519 "duk_error_augment.c"
}
# 538 "duk_error_augment.c"
static __attribute__ ((unused)) void duk_err_augment_error_create(duk_hthread *thr,
                                               duk_hthread *thr_callstack,
                                               const char *c_filename,
                                               duk_int_t c_line,
                                               duk_small_uint_t flags) {
 duk_hobject *obj;

 do { } while (0);
 do { } while (0);
# 562 "duk_error_augment.c"
 obj = duk_get_hobject(thr, -1);
 if (!obj) {
  do { } while (0);
  return;
 }
 if (!duk_hobject_prototype_chain_contains(thr, obj, thr->builtins[20], 1 )) {




  do { } while (0);
  return;
 }
 if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0)) {
  do { } while (0);
  duk__err_augment_builtin_create(thr, thr_callstack, c_filename, c_line, obj, flags);
 } else {
  do { } while (0);
 }




 duk__err_augment_user(thr, 109);

}
# 597 "duk_error_augment.c"
static __attribute__ ((unused)) void duk_err_augment_error_throw(duk_hthread *thr) {

 duk__err_augment_user(thr, 110);

}
# 1 "duk_error_longjmp.c"
# 31 "duk_error_longjmp.c"
static void duk__uncaught_error_aware(duk_hthread *thr);
static void duk__uncaught_error_aware(duk_hthread *thr) {
 const char *summary;
 char buf[128];

 summary = duk_push_string_tval_readable_error(thr, &thr->heap->lj.value1);
 do { } while (0);
 snprintf(buf, sizeof(buf), "uncaught: %s", summary);
 buf[sizeof(buf) - 1] = (char) 0;
 (void) (duk_fatal_raw((thr), ((const char *) buf)), (duk_ret_t) 0);
 do { return; } while (0);
}


static __attribute__ ((unused)) void duk_err_longjmp(duk_hthread *thr) {
 do { } while (0);
 do { } while (0);

 do { } while (0)



                                           ;
# 68 "duk_error_longjmp.c"
 do { do { } while (0); do { } while (0); } while (0);

 thr->heap->pf_prevent_count++;
 do { } while (0);







 do { } while (0);





 if (!thr->heap->lj.jmpbuf_ptr) {
  do { } while (0)



                                          ;




  duk__uncaught_error_aware(thr);

  do { __builtin_unreachable(); } while (0);
 }




 longjmp((thr->heap->lj.jmpbuf_ptr->jb), 1);


 do { __builtin_unreachable(); } while (0);
}
# 1 "duk_error_misc.c"
# 42 "duk_error_misc.c"
static __attribute__ ((unused)) duk_hobject *duk_error_prototype_from_code(duk_hthread *thr, duk_errcode_t code) {
 switch (code) {
 case 2:
  return thr->builtins[22];
 case 3:
  return thr->builtins[24];
 case 4:
  return thr->builtins[26];
 case 5:
  return thr->builtins[28];
 case 6:
  return thr->builtins[30];
 case 7:
  return thr->builtins[32];
 case 1:
 default:
  return thr->builtins[20];
 }
}
# 158 "duk_error_misc.c"
static __attribute__ ((unused)) void duk_err_setup_ljstate1(duk_hthread *thr, duk_small_uint_t lj_type, duk_tval *tv_val) {
 duk_heap *heap;

 do { } while (0);
 heap = thr->heap;
 do { } while (0);
 do { } while (0);

 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);

 heap->lj.type = lj_type;
 do { *(&heap->lj.value1) = *(tv_val); } while (0);
 do { duk_tval *duk__tv = ((tv_val)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);

 do { do { } while (0); do { } while (0); } while (0);
}
# 1 "duk_error_throw.c"
# 24 "duk_error_throw.c"
static __attribute__ ((unused)) void duk_err_create_and_throw(duk_hthread *thr,
                                           duk_errcode_t code,
                                           const char *msg,
                                           const char *filename,
                                           duk_int_t line) {




 do { } while (0)



                                 ;




 do { } while (0);





 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);





 duk_hthread_sync_and_null_currpc(thr);
# 64 "duk_error_throw.c"
 if (thr->heap->creating_error) {
  duk_tval tv_val;
  duk_hobject *h_err;

  thr->heap->creating_error = 0;

  h_err = thr->builtins[37];
  if (h_err != 
# 71 "duk_error_throw.c" 3 4
              ((void *)0)
# 71 "duk_error_throw.c"
                  ) {
   do { } while (0);
   do { duk_tval *duk__tv; duk__tv = (&tv_val); duk__tv->t = 9; duk__tv->v.hobject = (h_err); } while (0);
  } else {
   do { } while (0)
                                                         ;
   do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((duk_double_t) ((duk_int32_t) code)); ; duk__tv = ((&tv_val)); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0);
  }

  duk_err_setup_ljstate1(thr, 1, &tv_val);


 } else {





  thr->heap->creating_error = 1;

  duk_require_stack(thr, 1);





  duk_push_error_object_raw(thr, code | (1L << 24), filename, line, "%s", (const char *) msg);
# 109 "duk_error_throw.c"
  do { } while (0);
  duk_err_augment_error_throw(thr);


  duk_err_setup_ljstate1(thr, 1, ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)));
  thr->heap->creating_error = 0;
# 125 "duk_error_throw.c"
 }





 do { } while (0)

                                                          ;

 duk_err_longjmp(thr);
 do { __builtin_unreachable(); } while (0);
}





static __attribute__ ((unused)) void duk_error_throw_from_negative_rc(duk_hthread *thr, duk_ret_t rc) {
 do { } while (0);
 do { } while (0);
# 157 "duk_error_throw.c"
 duk_error_raw(thr, -rc, 
# 157 "duk_error_throw.c" 3 4
                        ((void *)0)
# 157 "duk_error_throw.c"
                            , 0, "error (rc %ld)", (long) rc);
 do { return; } while (0);
}
# 1 "duk_hbuffer_alloc.c"
# 11 "duk_hbuffer_alloc.c"
static __attribute__ ((unused)) duk_hbuffer *duk_hbuffer_alloc(duk_heap *heap, duk_size_t size, duk_small_uint_t flags, void **out_bufdata) {
 duk_hbuffer *res = 
# 12 "duk_hbuffer_alloc.c" 3 4
                   ((void *)0)
# 12 "duk_hbuffer_alloc.c"
                       ;
 duk_size_t header_size;
 duk_size_t alloc_size;

 do { } while (0);
 do { } while (0);

 do { } while (0);






 if (size > (0x7ffffffeUL)) {
  do { } while (0);
  return 
# 28 "duk_hbuffer_alloc.c" 3 4
        ((void *)0)
# 28 "duk_hbuffer_alloc.c"
            ;
 }

 if (flags & (1 << 1)) {
  header_size = sizeof(duk_hbuffer_external);
  alloc_size = sizeof(duk_hbuffer_external);
 } else if (flags & (1 << 0)) {
  header_size = sizeof(duk_hbuffer_dynamic);
  alloc_size = sizeof(duk_hbuffer_dynamic);
 } else {
  header_size = sizeof(duk_hbuffer_fixed);
  alloc_size = sizeof(duk_hbuffer_fixed) + size;
  do { } while (0);
 }

 res = (duk_hbuffer *) duk_heap_mem_alloc((heap), (alloc_size));
 if (__builtin_expect((res == 
# 44 "duk_hbuffer_alloc.c" 3 4
    ((void *)0)
# 44 "duk_hbuffer_alloc.c"
    ), 0)) {
  goto alloc_error;
 }



 do { void *duk__dst = ((void *) res); duk_size_t duk__len = ((flags & (1 << 2)) ? header_size : alloc_size); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);




 if (flags & (1 << 1)) {
  duk_hbuffer_external *h;
  h = (duk_hbuffer_external *) res;
  do { (void) (h); } while (0);
  *out_bufdata = 
# 59 "duk_hbuffer_alloc.c" 3 4
                ((void *)0)
# 59 "duk_hbuffer_alloc.c"
                    ;







  do { } while (0);
 } else if (flags & (1 << 0)) {
  duk_hbuffer_dynamic *h = (duk_hbuffer_dynamic *) res;
  void *ptr;

  if (size > 0) {
   do { } while (0);
   do { } while (0);

   ptr = duk_heap_mem_alloc_zeroed((heap), (size));



   if (__builtin_expect((ptr == 
# 80 "duk_hbuffer_alloc.c" 3 4
      ((void *)0)
# 80 "duk_hbuffer_alloc.c"
      ), 0)) {

    goto alloc_error;
   }
   *out_bufdata = ptr;

   do { (h)->curr_alloc = (void *) (ptr); } while (0);
  } else {
   *out_bufdata = 
# 88 "duk_hbuffer_alloc.c" 3 4
                 ((void *)0)
# 88 "duk_hbuffer_alloc.c"
                     ;







   do { } while (0);
  }
 } else {
  *out_bufdata = (void *) ((duk_hbuffer_fixed *) (void *) res + 1);
 }

 do { ((duk_hbuffer *) (res))->size = (size); } while (0);

 do { (&res->hdr)->h_flags = ((&res->hdr)->h_flags & ~(0x00000003UL)) | (2); } while (0);
 if (flags & (1 << 0)) {
  do { do { } while (0); (&(res)->hdr)->h_flags |= ((1UL << (7 + (0)))); } while (0);
  if (flags & (1 << 1)) {
   do { do { } while (0); (&(res)->hdr)->h_flags |= ((1UL << (7 + (1)))); } while (0);
  }
 } else {
  do { } while (0);
 }
 duk_heap_insert_into_heap_allocated((heap), (&res->hdr));

 do { } while (0);
 return res;

alloc_error:
 do { } while (0);

 duk_heap_mem_free((heap), (res));
 return 
# 122 "duk_hbuffer_alloc.c" 3 4
       ((void *)0)
# 122 "duk_hbuffer_alloc.c"
           ;
}



static __attribute__ ((unused)) void *duk_hbuffer_get_dynalloc_ptr(duk_heap *heap, void *ud) {
 duk_hbuffer_dynamic *buf = (duk_hbuffer_dynamic *) ud;
 do { (void) (heap); } while (0);
 return (void *) ((buf)->curr_alloc);
}
# 1 "duk_hbuffer_assert.c"
# 1 "duk_hbuffer_ops.c"
# 12 "duk_hbuffer_ops.c"
static __attribute__ ((unused)) void duk_hbuffer_resize(duk_hthread *thr, duk_hbuffer_dynamic *buf, duk_size_t new_size) {
 void *res;
 duk_size_t prev_size;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);





 if (new_size > (0x7ffffffeUL)) {
  do { duk_err_range((thr), "duk_hbuffer_ops.c", (duk_int_t) 26, ("buffer too long")); } while (0);
  do { return; } while (0);
 }







 res = duk_heap_mem_realloc_indirect((thr->heap), (duk_hbuffer_get_dynalloc_ptr), ((void *) buf), (new_size));
 if (__builtin_expect((res != 
# 37 "duk_hbuffer_ops.c" 3 4
    ((void *)0) 
# 37 "duk_hbuffer_ops.c"
    || new_size == 0), 1)) {


  do { } while (0)



                                        ;







  prev_size = (((duk_hbuffer *) ((duk_hbuffer *) (buf)))->size);
  if (new_size > prev_size) {
   do { } while (0);

   do { void *duk__dst = ((void *) ((char *) res + prev_size)); duk_size_t duk__len = ((duk_size_t) (new_size - prev_size)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);

  }

  do { ((duk_hbuffer *) ((duk_hbuffer *) (buf)))->size = ((new_size)); } while (0);
  do { (buf)->curr_alloc = (void *) (res); } while (0);
 } else {
  do { duk_err_error_alloc_failed((thr), "duk_hbuffer_ops.c", (duk_int_t) 63); } while (0);
  do { return; } while (0);
 }

 do { } while (0);
}

static __attribute__ ((unused)) void duk_hbuffer_reset(duk_hthread *thr, duk_hbuffer_dynamic *buf) {
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 duk_hbuffer_resize(thr, buf, 0);
}
# 2 "duk_hbufobj_misc.c"


static __attribute__ ((unused)) duk_uint_t duk_hbufobj_clamp_bytelength(duk_hbufobj *h_bufobj, duk_uint_t len) {
 duk_uint_t buf_size;
 duk_uint_t buf_avail;

 do { } while (0);
 do { } while (0);

 buf_size = (duk_uint_t) (((duk_hbuffer *) (h_bufobj->buf))->size);
 if (h_bufobj->offset > buf_size) {

  return 0;
 }
 buf_avail = buf_size - h_bufobj->offset;

 return buf_avail >= len ? len : buf_avail;
}
# 1 "duk_heap_alloc.c"
# 21 "duk_heap_alloc.c"
static __attribute__ ((unused)) void duk_free_hobject(duk_heap *heap, duk_hobject *h) {
 do { } while (0);
 do { } while (0);

 duk_heap_mem_free((heap), (((h)->props)));

 if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
  duk_hcompfunc *f = (duk_hcompfunc *) h;
  do { (void) (f); } while (0);

 } else if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)) {
  duk_hnatfunc *f = (duk_hnatfunc *) h;
  do { (void) (f); } while (0);

 } else if (((((&((h))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 18)) {
  duk_hthread *t = (duk_hthread *) h;
  duk_activation *act;

  duk_heap_mem_free((heap), (t->valstack));







  for (act = t->callstack_curr; act != 
# 47 "duk_heap_alloc.c" 3 4
                                      ((void *)0)
# 47 "duk_heap_alloc.c"
                                          ;) {
   duk_activation *act_next;
   duk_catcher *cat;

   for (cat = act->cat; cat != 
# 51 "duk_heap_alloc.c" 3 4
                              ((void *)0)
# 51 "duk_heap_alloc.c"
                                  ;) {
    duk_catcher *cat_next;

    cat_next = cat->parent;
    duk_heap_mem_free((heap), ((void *) cat));
    cat = cat_next;
   }

   act_next = act->parent;
   duk_heap_mem_free((heap), ((void *) act));
   act = act_next;
  }





 } else if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0)) {
  duk_hboundfunc *f = (duk_hboundfunc *) (void *) h;

  duk_heap_mem_free((heap), (f->args));
 }

 duk_heap_mem_free((heap), ((void *) h));
}

static __attribute__ ((unused)) void duk_free_hbuffer(duk_heap *heap, duk_hbuffer *h) {
 do { } while (0);
 do { } while (0);

 if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) && !(((&(h)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0)) {
  duk_hbuffer_dynamic *g = (duk_hbuffer_dynamic *) h;
  do { } while (0);
  duk_heap_mem_free((heap), (((g)->curr_alloc)));
 }
 duk_heap_mem_free((heap), ((void *) h));
}

static __attribute__ ((unused)) void duk_free_hstring(duk_heap *heap, duk_hstring *h) {
 do { } while (0);
 do { } while (0);

 do { (void) (heap); } while (0);
 do { (void) (h); } while (0);
# 103 "duk_heap_alloc.c"
 duk_heap_mem_free((heap), ((void *) h));
}

static __attribute__ ((unused)) void duk_heap_free_heaphdr_raw(duk_heap *heap, duk_heaphdr *hdr) {
 do { } while (0);
 do { } while (0);

 do { } while (0);

 switch (((hdr)->h_flags & 0x00000003UL)) {
 case 0:
  duk_free_hstring(heap, (duk_hstring *) hdr);
  break;
 case 1:
  duk_free_hobject(heap, (duk_hobject *) hdr);
  break;
 default:
  do { } while (0);
  duk_free_hbuffer(heap, (duk_hbuffer *) hdr);
 }
}
# 139 "duk_heap_alloc.c"
static duk_size_t duk__heap_free_activation_freelist(duk_heap *heap) {
 duk_activation *act;
 duk_activation *act_next;
 duk_size_t count_act = 0;

 for (act = heap->activation_free; act != 
# 144 "duk_heap_alloc.c" 3 4
                                         ((void *)0)
# 144 "duk_heap_alloc.c"
                                             ;) {
  act_next = act->parent;
  duk_heap_mem_free((heap), ((void *) act));
  act = act_next;



 }
 heap->activation_free = 
# 152 "duk_heap_alloc.c" 3 4
                        ((void *)0)
# 152 "duk_heap_alloc.c"
                            ;
 return count_act;
}



static duk_size_t duk__heap_free_catcher_freelist(duk_heap *heap) {
 duk_catcher *cat;
 duk_catcher *cat_next;
 duk_size_t count_cat = 0;

 for (cat = heap->catcher_free; cat != 
# 163 "duk_heap_alloc.c" 3 4
                                      ((void *)0)
# 163 "duk_heap_alloc.c"
                                          ;) {
  cat_next = cat->parent;
  duk_heap_mem_free((heap), ((void *) cat));
  cat = cat_next;



 }
 heap->catcher_free = 
# 171 "duk_heap_alloc.c" 3 4
                     ((void *)0)
# 171 "duk_heap_alloc.c"
                         ;

 return count_cat;
}


static __attribute__ ((unused)) void duk_heap_free_freelists(duk_heap *heap) {
 duk_size_t count_act = 0;
 duk_size_t count_cat = 0;


 count_act = duk__heap_free_activation_freelist(heap);


 count_cat = duk__heap_free_catcher_freelist(heap);

 do { (void) (heap); } while (0);
 do { (void) (count_act); } while (0);
 do { (void) (count_cat); } while (0);

 do { } while (0)
                                                                                                                           ;
}

static void duk__free_allocated(duk_heap *heap) {
 duk_heaphdr *curr;
 duk_heaphdr *next;

 curr = heap->heap_allocated;
 while (curr) {




  do { } while (0);
  next = ((curr)->h_next);
  duk_heap_free_heaphdr_raw(heap, curr);
  curr = next;
 }
}


static void duk__free_finalize_list(duk_heap *heap) {
 duk_heaphdr *curr;
 duk_heaphdr *next;

 curr = heap->finalize_list;
 while (curr) {
  do { } while (0);
  next = ((curr)->h_next);
  duk_heap_free_heaphdr_raw(heap, curr);
  curr = next;
 }
}


static void duk__free_stringtable(duk_heap *heap) {

 duk_heap_strtable_free(heap);
}


static void duk__free_run_finalizers(duk_heap *heap) {
 duk_heaphdr *curr;
 duk_uint_t round_no;
 duk_size_t count_all;
 duk_size_t count_finalized;
 duk_size_t curr_limit;

 do { } while (0);


 do { } while (0);

 do { } while (0);

 if (heap->heap_thread == 
# 247 "duk_heap_alloc.c" 3 4
                         ((void *)0)
# 247 "duk_heap_alloc.c"
                             ) {



  do { } while (0);
  return;
 }
# 264 "duk_heap_alloc.c"
 do { } while (0);
 do { } while (0);
 do { } while (0);
 heap->pf_prevent_count = 1;
 heap->ms_running = 2;
 heap->ms_prevent_count = 1;

 curr_limit = 0;
 for (round_no = 0;; round_no++) {
  curr = heap->heap_allocated;
  count_all = 0;
  count_finalized = 0;
  while (curr) {
   count_all++;
   if (((curr)->h_flags & 0x01UL)) {




    do { } while (0);

    if (duk_hobject_has_finalizer_fast_raw(((duk_hobject *) curr))) {
     if (!(((((duk_heaphdr *) curr))->h_flags & ((1UL << (2 + (3))))) != 0)) {
      do { } while (0)
                                                ;
      duk_heap_run_finalizer(heap, (duk_hobject *) curr);
      count_finalized++;
     }
    }
   }
   curr = ((curr)->h_next);
  }
# 309 "duk_heap_alloc.c"
  if (round_no == 0) {



   curr_limit = count_all * 2;
  } else {
   curr_limit = (curr_limit * 3) / 4;
  }
  do { } while (0)



                                      ;

  if (count_finalized == 0) {
   do { } while (0);
   break;
  }
  if (count_finalized >= curr_limit) {
   do { } while (0);
   break;
  }
 }

 do { } while (0);
 do { } while (0);
 heap->ms_running = 0;
 heap->pf_prevent_count = 0;
}


static __attribute__ ((unused)) void duk_heap_free(duk_heap *heap) {
 do { } while (0);
# 373 "duk_heap_alloc.c"
 do { } while (0);
 do { } while (0);
 do { } while (0);
 duk_heap_mark_and_sweep(heap, 0);
 do { } while (0);
 duk_heap_mark_and_sweep(heap, 0);
 do { } while (0);
 heap->pf_skip_finalizers = 1;
 duk_heap_mark_and_sweep(heap, 0);
# 390 "duk_heap_alloc.c"
 do { } while (0);


 do { } while (0);



 do { } while (0);
 do { ((heap))->flags |= ((1U << 2)); } while (0);
 duk__free_run_finalizers(heap);






 do { } while (0);
 duk_heap_free_freelists(heap);

 do { } while (0);
 duk__free_allocated(heap);


 do { } while (0);



 do { } while (0);
 duk__free_finalize_list(heap);


 do { } while (0);
 duk__free_stringtable(heap);

 do { } while (0);
 heap->free_func(heap->heap_udata, heap);
}
# 469 "duk_heap_alloc.c"
static duk_bool_t duk__init_heap_strings(duk_heap *heap) {
 duk_bitdecoder_ctx bd_ctx;
 duk_bitdecoder_ctx *bd = &bd_ctx;
 duk_small_uint_t i;

 do { void *duk__dst = (&bd_ctx); duk_size_t duk__len = (sizeof(bd_ctx)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 bd->data = (const duk_uint8_t *) duk_strings_data;
 bd->length = (duk_size_t) 972;

 for (i = 0; i < 167; i++) {
  duk_uint8_t tmp[27];
  duk_small_uint_t len;
  duk_hstring *h;

  len = duk_bd_decode_bitpacked_string(bd, tmp);




  do { } while (0);
  do { } while (0);
  h = duk_heap_strtable_intern(heap, tmp, len);
  if (!h) {
   goto failed;
  }
  do { } while (0);






  if (i == 33 || i == 67) {
   do { do { } while (0); (&(h)->hdr)->h_flags |= ((1UL << (7 + (6)))); } while (0);
  }
  if (i >= 122 && i < 167) {
   do { do { } while (0); (&(h)->hdr)->h_flags |= ((1UL << (7 + (4)))); } while (0);
   if (i >= 158) {
    do { do { } while (0); (&(h)->hdr)->h_flags |= ((1UL << (7 + (5)))); } while (0);
   }
  }

  do { } while (0);




  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);




  heap->strs[i] = h;

 }

 return 1;

failed:
 return 0;
}


static duk_bool_t duk__init_heap_thread(duk_heap *heap) {
 duk_hthread *thr;

 do { } while (0);
 thr = duk_hthread_alloc_unchecked(heap, (1UL << (7 + (0))) | (((duk_uint_t) (18)) << (7 + (20))));
 if (thr == 
# 537 "duk_heap_alloc.c" 3 4
           ((void *)0)
# 537 "duk_heap_alloc.c"
               ) {
  do { } while (0);
  return 0;
 }
 thr->state = 1;






 thr->strs = heap->strs;



 heap->heap_thread = thr;
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) &(thr)->obj)); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);



 do { } while (0);
 if (!duk_hthread_init_stacks(heap, thr)) {
  return 0;
 }


 duk_hthread_create_builtin_objects(thr);


 do { duk_hthread *duk__thr = (thr); duk_hobject *duk__obj = ((duk_hobject *) thr); duk_hobject *duk__proto = (thr->builtins[35]); do { (void) (duk__thr); } while (0); do { } while (0); do { (duk__obj)->prototype = (duk__proto); } while (0); do { if ((duk__proto) != 
# 566 "duk_heap_alloc.c" 3 4
((void *)0)
# 566 "duk_heap_alloc.c"
) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk__proto)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0); } while (0);

 return 1;
}
# 794 "duk_heap_alloc.c"
static __attribute__ ((unused))
duk_heap *duk_heap_alloc(duk_alloc_function alloc_func,
                         duk_realloc_function realloc_func,
                         duk_free_function free_func,
                         void *heap_udata,
                         duk_fatal_function fatal_func) {
 duk_heap *res = 
# 800 "duk_heap_alloc.c" 3 4
                ((void *)0)
# 800 "duk_heap_alloc.c"
                    ;
 duk_uint32_t st_initsize;

 do { } while (0);





 do { } while (0);

 do { } while (0);
 do { } while (0);
 do { } while (0);
# 850 "duk_heap_alloc.c"
 if (sizeof(duk_tval) != 16) {

  fatal_func(heap_udata, "sizeof(duk_tval) not 8 or 16, cannot use DUK_USE_EXEC_REGCONST_OPTIMIZE option");
 }
# 894 "duk_heap_alloc.c"
 do { } while (0);
 res = (duk_heap *) alloc_func(heap_udata, sizeof(duk_heap));
 if (!res) {
  goto failed;
 }





 do { void *duk__dst = (res); duk_size_t duk__len = (sizeof(*res)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
# 962 "duk_heap_alloc.c"
 res->alloc_func = alloc_func;
 res->realloc_func = realloc_func;
 res->free_func = free_func;
 res->heap_udata = heap_udata;
 res->fatal_func = fatal_func;
# 978 "duk_heap_alloc.c"
 do { } while (0);
 do { } while (0);
 res->ms_prevent_count = 1;
 res->pf_prevent_count = 1;
 do { } while (0);

 res->call_recursion_depth = 0;
 res->call_recursion_limit = 1000;
# 1000 "duk_heap_alloc.c"
 res->hash_seed = (duk_uint32_t) (duk_uintptr_t) res;

 res->hash_seed ^= 5381;






 do { } while (0);
 do { } while (0);
 do { duk_tval *duk__tv; duk__tv = (&res->lj.value1); duk__tv->t = 2; } while (0);
 do { duk_tval *duk__tv; duk__tv = (&res->lj.value2); duk__tv->t = 2; } while (0);

 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);





 st_initsize = 1024;






 res->strtable = (duk_hstring **) alloc_func(heap_udata, sizeof(duk_hstring *) * st_initsize);
 if (res->strtable == 
# 1028 "duk_heap_alloc.c" 3 4
                     ((void *)0)
# 1028 "duk_heap_alloc.c"
                         ) {
  goto failed;
 }

 res->st_size = st_initsize;
 res->st_mask = st_initsize - 1;

 do { } while (0);
# 1050 "duk_heap_alloc.c"
 do { void *duk__dst = (res->strtable); duk_size_t duk__len = (sizeof(duk_hstring *) * st_initsize); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
# 1071 "duk_heap_alloc.c"
 do { } while (0);
 do { } while (0);
# 1097 "duk_heap_alloc.c"
 do { } while (0);
 if (!duk__init_heap_strings(res)) {
  goto failed;
 }
# 1109 "duk_heap_alloc.c"
 do { } while (0);
 if (!duk__init_heap_thread(res)) {
  goto failed;
 }
# 1121 "duk_heap_alloc.c"
 do { } while (0);
 do { } while (0);
 res->heap_object = duk_hobject_alloc_unchecked(res,
                                                (1UL << (7 + (0))) | (1UL << (7 + (7))) |
                                                    (((duk_uint_t) (1)) << (7 + (20))));
 if (res->heap_object == 
# 1126 "duk_heap_alloc.c" 3 4
                        ((void *)0)
# 1126 "duk_heap_alloc.c"
                            ) {
  goto failed;
 }
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (res->heap_object))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
# 1140 "duk_heap_alloc.c"
 res->rnd_state[0] = (duk_uint64_t) duk_time_get_ecmascript_time(res->heap_thread);
 do { } while (0);




 duk_util_tinyrandom_prepare_seed(res->heap_thread);





 {
  duk_uint64_t tmp_u64;
  tmp_u64 = 0;
  do { void *duk__dst = ((void *) &tmp_u64); const void *duk__src = ((const void *) &res); duk_size_t duk__len = ((size_t) (sizeof(void *) >= sizeof(duk_uint64_t) ? sizeof(duk_uint64_t) : sizeof(void *))); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0)

                                                                                                       ;
  res->rnd_state[1] ^= tmp_u64;
 }
 do {
  duk_small_uint_t i;
  for (i = 0; i < 10; i++) {




   (void) duk_util_tinyrandom_get_double(res->heap_thread);
  }
 } while (0);







 do { } while (0);
 do { } while (0);
 do { } while (0);
 res->ms_prevent_count = 0;
 res->pf_prevent_count = 0;
 do { } while (0);
# 1191 "duk_heap_alloc.c"
 do { } while (0);
 return res;

failed:
 do { } while (0);

 if (res != 
# 1197 "duk_heap_alloc.c" 3 4
           ((void *)0)
# 1197 "duk_heap_alloc.c"
               ) {



  do { } while (0);
  do { } while (0);
  do { } while (0);
  if (res->heap_thread != 
# 1204 "duk_heap_alloc.c" 3 4
                         ((void *)0)
# 1204 "duk_heap_alloc.c"
                             ) {
   res->ms_prevent_count = 0;
   res->pf_prevent_count = 0;
  }




  do { } while (0);
  do { } while (0);
  do { } while (0);
  duk_heap_free(res);
 }

 return 
# 1218 "duk_heap_alloc.c" 3 4
       ((void *)0)
# 1218 "duk_heap_alloc.c"
           ;
}
# 1 "duk_heap_finalize.c"
# 129 "duk_heap_finalize.c"
static __attribute__ ((unused)) void duk_heap_process_finalize_list(duk_heap *heap) {
 duk_heaphdr *curr;




 do { } while (0);

 if (heap->pf_prevent_count != 0) {
  do { } while (0);
  return;
 }


 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);


 do { } while (0);
 heap->pf_prevent_count = 1;
# 171 "duk_heap_finalize.c"
 while ((curr = heap->finalize_list) != 
# 171 "duk_heap_finalize.c" 3 4
                                       ((void *)0)
# 171 "duk_heap_finalize.c"
                                           ) {

  duk_bool_t queue_back;


  do { } while (0);

  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0)
            ;
  do { } while (0);
  do { } while (0);
# 194 "duk_heap_finalize.c"
  do { do { } while (0); ((curr))->h_flags &= ~(((1UL << (2 + (2))))); } while (0);

  if (__builtin_expect((!heap->pf_skip_finalizers), 1)) {







   duk_bool_t had_zero_refcount;






   do { } while (0);
   had_zero_refcount = (((curr)->h_refcount) == 1);


   do { } while (0);
   duk_heap_run_finalizer(heap, (duk_hobject *) curr);
   do { } while (0);





   do { } while (0);
   if (((curr)->h_refcount) == 1) {
# 234 "duk_heap_finalize.c"
    queue_back = 0;
   } else

   {

    queue_back = 1;
    if (had_zero_refcount) {






     do { do { } while (0); ((curr))->h_flags &= ~(((1UL << (2 + (3))))); } while (0);
    }

   }
  } else {




   do { } while (0);
   do { } while (0);

   queue_back = 1;

  }







  duk_heap_remove_from_finalize_list((heap), (curr));



  if (queue_back) {






   do { } while (0);
   (--(curr)->h_refcount);
   do { do { } while (0); ((curr))->h_flags &= ~(((1UL << (2 + (2))))); } while (0);
   duk_heap_insert_into_heap_allocated((heap), (curr));
  } else {

   do { } while (0);
   do { } while (0);
   duk_hobject_refcount_finalize_norz(heap, (duk_hobject *) curr);
   duk_free_hobject(heap, (duk_hobject *) curr);
   do { } while (0);
  }
# 305 "duk_heap_finalize.c"
 }


 do { } while (0);
# 321 "duk_heap_finalize.c"
 do { } while (0);
 heap->pf_prevent_count = 0;




}
# 343 "duk_heap_finalize.c"
static duk_ret_t duk__finalize_helper(duk_hthread *thr, void *udata) {
 do { } while (0);
 do { (void) (udata); } while (0);

 do { } while (0);
# 361 "duk_heap_finalize.c"
 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (105))));
 duk_dup_m2(thr);
 duk_push_boolean(thr, (((thr->heap))->flags & ((1U << 2))));
 do { } while (0);
 duk_call(thr, 2);
 do { } while (0);
 return 0;





}

static __attribute__ ((unused)) void duk_heap_run_finalizer(duk_heap *heap, duk_hobject *obj) {
 duk_hthread *thr;
 duk_ret_t rc;




 do { } while (0);

 do { } while (0);
 do { } while (0);
 thr = heap->heap_thread;
 do { } while (0);
 ;
# 402 "duk_heap_finalize.c"
 do { } while (0);




 do { } while (0);






 do { do { } while (0); (((duk_heaphdr *) obj))->h_flags |= ((1UL << (2 + (3)))); } while (0);


 if ((((&((obj))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)) {





  do { } while (0);
  return;
 }


 duk_push_hobject(thr, obj);
 rc = duk_safe_call(thr, duk__finalize_helper, 
# 429 "duk_heap_finalize.c" 3 4
                                              ((void *)0) 
# 429 "duk_heap_finalize.c"
                                                            , 0 , 1 );
 do { } while (0);

 if (rc != 0) {



  do { } while (0)

                                                       ;
 }
 duk_pop_2(thr);

 do { } while (0);
}
# 1 "duk_heap_hashstring.c"
# 84 "duk_heap_hashstring.c"
static __attribute__ ((unused)) duk_uint32_t duk_heap_hashstring(duk_heap *heap, const duk_uint8_t *str, duk_size_t len) {
 duk_uint32_t hash;
 duk_size_t step;
 duk_size_t off;
# 101 "duk_heap_hashstring.c"
 hash = heap->hash_seed ^ ((duk_uint32_t) len);
 step = (len >> 5) + 1;
 for (off = len; off >= step; off -= step) {
  do { } while (0);
  hash = (hash * 33) + str[off - 1];
 }







 return hash;
}
# 1 "duk_heap_markandsweep.c"






static void duk__mark_heaphdr(duk_heap *heap, duk_heaphdr *h);
static void duk__mark_heaphdr_nonnull(duk_heap *heap, duk_heaphdr *h);
static void duk__mark_tval(duk_heap *heap, duk_tval *tv);
static void duk__mark_tvals(duk_heap *heap, duk_tval *tv, duk_idx_t count);





static void duk__mark_hstring(duk_heap *heap, duk_hstring *h) {
 do { (void) (heap); } while (0);
 do { (void) (h); } while (0);

 do { } while (0);
 do { } while (0);
 do { } while (0);


}

static void duk__mark_hobject(duk_heap *heap, duk_hobject *h) {
 duk_uint_fast32_t i;

 do { } while (0);

 do { } while (0);
 do { } while (0);



 for (i = 0; i < (duk_uint_fast32_t) ((h)->e_next); i++) {
  duk_hstring *key = (((duk_hstring **) (void *) (((((h)))->props) + ((((h)))->e_size) * sizeof(duk_propvalue)))[(i)]);
  if (key == 
# 39 "duk_heap_markandsweep.c" 3 4
            ((void *)0)
# 39 "duk_heap_markandsweep.c"
                ) {
   continue;
  }
  duk__mark_heaphdr_nonnull(heap, (duk_heaphdr *) key);
  if ((((((duk_uint8_t *) (void *) ((((((h))))->props) + (((((h))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))[((i))]) & (1U << 3)) != 0)) {
   duk__mark_heaphdr(heap, (duk_heaphdr *) (&((duk_propvalue *) (void *) (((((h)))->props)))[(i)])->a.get);
   duk__mark_heaphdr(heap, (duk_heaphdr *) (&((duk_propvalue *) (void *) (((((h)))->props)))[(i)])->a.set);
  } else {
   duk__mark_tval(heap, &(&((duk_propvalue *) (void *) (((((h)))->props)))[(i)])->v);
  }
 }

 for (i = 0; i < (duk_uint_fast32_t) ((h)->a_size); i++) {
  duk__mark_tval(heap, (&((duk_tval *) (void *) (((((h)))->props) + ((((h)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((h)))->e_size))) & 0x07)))[(i)]));
 }



 duk__mark_heaphdr(heap, (duk_heaphdr *) ((h)->prototype));




 if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (7))))) != 0)) {
  do { } while (0);
  return;
 }
 do { } while (0);


 if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
  duk_hcompfunc *f = (duk_hcompfunc *) h;
  duk_tval *tv, *tv_end;
  duk_hobject **fn, **fn_end;

  do { } while (0);





  duk__mark_heaphdr(heap, (duk_heaphdr *) ((duk_hbuffer_fixed *) (void *) (f)->data));
  duk__mark_heaphdr(heap, (duk_heaphdr *) ((f)->lex_env));
  duk__mark_heaphdr(heap, (duk_heaphdr *) ((f)->var_env));

  if (((duk_hbuffer_fixed *) (void *) (f)->data) != 
# 84 "duk_heap_markandsweep.c" 3 4
                                        ((void *)0)
# 84 "duk_heap_markandsweep.c"
                                            ) {
   tv = ((duk_tval *) (void *) ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) (((duk_hbuffer_fixed *) (void *) (((f)))->data))) + 1)));
   tv_end = ((duk_tval *) (void *) (((f))->funcs));
   while (tv < tv_end) {
    duk__mark_tval(heap, tv);
    tv++;
   }

   fn = (((f))->funcs);
   fn_end = ((duk_hobject **) (void *) (((f))->bytecode));
   while (fn < fn_end) {
    duk__mark_heaphdr_nonnull(heap, (duk_heaphdr *) *fn);
    fn++;
   }
  } else {

   do { } while (0);
  }
 } else if (((((&((h))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 16)) {
  duk_hdecenv *e = (duk_hdecenv *) h;
  do { } while (0);
  duk__mark_heaphdr(heap, (duk_heaphdr *) e->thread);
  duk__mark_heaphdr(heap, (duk_heaphdr *) e->varmap);
 } else if (((((&((h))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 15)) {
  duk_hobjenv *e = (duk_hobjenv *) h;
  do { } while (0);
  duk__mark_heaphdr_nonnull(heap, (duk_heaphdr *) e->target);

 } else if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {
  duk_hbufobj *b = (duk_hbufobj *) h;
  do { } while (0);
  duk__mark_heaphdr(heap, (duk_heaphdr *) b->buf);
  duk__mark_heaphdr(heap, (duk_heaphdr *) b->buf_prop);

 } else if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0)) {
  duk_hboundfunc *f = (duk_hboundfunc *) (void *) h;
  do { } while (0);
  duk__mark_tval(heap, &f->target);
  duk__mark_tval(heap, &f->this_binding);
  duk__mark_tvals(heap, f->args, f->nargs);

 } else if ((((&((h))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)) {
  duk_hproxy *p = (duk_hproxy *) h;
  do { } while (0);
  duk__mark_heaphdr_nonnull(heap, (duk_heaphdr *) p->target);
  duk__mark_heaphdr_nonnull(heap, (duk_heaphdr *) p->handler);

 } else if (((((&((h))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 18)) {
  duk_hthread *t = (duk_hthread *) h;
  duk_activation *act;
  duk_tval *tv;

  do { } while (0);

  tv = t->valstack;
  while (tv < t->valstack_top) {
   duk__mark_tval(heap, tv);
   tv++;
  }

  for (act = t->callstack_curr; act != 
# 144 "duk_heap_markandsweep.c" 3 4
                                      ((void *)0)
# 144 "duk_heap_markandsweep.c"
                                          ; act = act->parent) {
   duk__mark_heaphdr(heap, (duk_heaphdr *) ((act)->func));
   duk__mark_heaphdr(heap, (duk_heaphdr *) act->var_env);
   duk__mark_heaphdr(heap, (duk_heaphdr *) act->lex_env);







  }

  duk__mark_heaphdr(heap, (duk_heaphdr *) t->resumer);

  for (i = 0; i < 51; i++) {
   duk__mark_heaphdr(heap, (duk_heaphdr *) t->builtins[i]);
  }
 } else {




  do { } while (0);
  do { } while (0);
 }
}


static void duk__mark_heaphdr(duk_heap *heap, duk_heaphdr *h) {
 do { } while (0)
                                                                                                                          ;


 if (h == 
# 178 "duk_heap_markandsweep.c" 3 4
         ((void *)0)
# 178 "duk_heap_markandsweep.c"
             ) {
  return;
 }

 do { } while (0);
 do { } while (0);






 if (((((h))->h_flags & ((1UL << (2 + (0))))) != 0)) {
  do { } while (0);
  return;
 }







 do { do { } while (0); ((h))->h_flags |= ((1UL << (2 + (0)))); } while (0);

 if (heap->ms_recursion_depth >= 256) {
  do { } while (0);
  do { ((heap))->flags |= ((1U << 0)); } while (0);
  do { do { } while (0); ((h))->h_flags |= ((1UL << (2 + (1)))); } while (0);
  return;
 }

 heap->ms_recursion_depth++;
 do { } while (0);

 switch (((h)->h_flags & 0x00000003UL)) {
 case 0:
  duk__mark_hstring(heap, (duk_hstring *) h);
  break;
 case 1:
  duk__mark_hobject(heap, (duk_hobject *) h);
  break;
 case 2:

  break;
 default:
  do { } while (0);
  do { __builtin_unreachable(); } while (0);
 }

 do { } while (0);
 heap->ms_recursion_depth--;
}

static void duk__mark_tval(duk_heap *heap, duk_tval *tv) {
 do { } while (0);
 if (tv == 
# 234 "duk_heap_markandsweep.c" 3 4
          ((void *)0)
# 234 "duk_heap_markandsweep.c"
              ) {
  return;
 }
 do { } while (0);
 if (((tv)->t & 0x08)) {
  duk_heaphdr *h;
  h = ((tv)->v.heaphdr);
  do { } while (0);
  duk__mark_heaphdr_nonnull(heap, h);
 }
}

static void duk__mark_tvals(duk_heap *heap, duk_tval *tv, duk_idx_t count) {
 do { } while (0);

 while (count-- > 0) {
  do { } while (0);
  if (((tv)->t & 0x08)) {
   duk_heaphdr *h;
   h = ((tv)->v.heaphdr);
   do { } while (0);
   duk__mark_heaphdr_nonnull(heap, h);
  }
  tv++;
 }
}


static void duk__mark_heaphdr_nonnull(duk_heap *heap, duk_heaphdr *h) {



 duk__mark_heaphdr(heap, h);
}





static void duk__mark_roots_heap(duk_heap *heap) {
 duk_small_uint_t i;

 do { } while (0);

 duk__mark_heaphdr(heap, (duk_heaphdr *) heap->heap_thread);
 duk__mark_heaphdr(heap, (duk_heaphdr *) heap->heap_object);

 for (i = 0; i < 167; i++) {
  duk_hstring *h = ((heap)->strs[(i)]);
  duk__mark_heaphdr(heap, (duk_heaphdr *) h);
 }

 duk__mark_tval(heap, &heap->lj.value1);
 duk__mark_tval(heap, &heap->lj.value2);






}
# 309 "duk_heap_markandsweep.c"
static void duk__mark_finalizable(duk_heap *heap) {
 duk_heaphdr *hdr;
 duk_size_t count_finalizable = 0;

 do { } while (0);

 do { } while (0);

 hdr = heap->heap_allocated;
 while (hdr != 
# 318 "duk_heap_markandsweep.c" 3 4
              ((void *)0)
# 318 "duk_heap_markandsweep.c"
                  ) {







  if (!((((hdr))->h_flags & ((1UL << (2 + (0))))) != 0) && ((hdr)->h_flags & 0x01UL) && !((((hdr))->h_flags & ((1UL << (2 + (3))))) != 0) &&
      duk_hobject_has_finalizer_fast_raw(((duk_hobject *) hdr))) {







   do { } while (0)


                                    ;
   do { } while (0);
   do { do { } while (0); ((hdr))->h_flags |= ((1UL << (2 + (2)))); } while (0);
   count_finalizable++;
  }

  hdr = ((hdr)->h_next);
 }

 if (count_finalizable == 0) {
  return;
 }

 do { } while (0);

 hdr = heap->heap_allocated;
 while (hdr != 
# 354 "duk_heap_markandsweep.c" 3 4
              ((void *)0)
# 354 "duk_heap_markandsweep.c"
                  ) {
  if (((((hdr))->h_flags & ((1UL << (2 + (2))))) != 0)) {
   duk__mark_heaphdr_nonnull(heap, hdr);
  }

  hdr = ((hdr)->h_next);
 }


}







static void duk__mark_finalize_list(duk_heap *heap) {
 duk_heaphdr *hdr;




 do { } while (0);

 hdr = heap->finalize_list;
 while (hdr != 
# 380 "duk_heap_markandsweep.c" 3 4
              ((void *)0)
# 380 "duk_heap_markandsweep.c"
                  ) {
  duk__mark_heaphdr_nonnull(heap, hdr);
  hdr = ((hdr)->h_next);



 }







}
# 417 "duk_heap_markandsweep.c"
static void duk__handle_temproot(duk_heap *heap, duk_heaphdr *hdr) {

 do { } while (0);

 if (!((((hdr))->h_flags & ((1UL << (2 + (1))))) != 0)) {
  do { } while (0);
  return;
 }

 do { } while (0);
 do { do { } while (0); ((hdr))->h_flags &= ~(((1UL << (2 + (1))))); } while (0);
 do { do { } while (0); ((hdr))->h_flags &= ~(((1UL << (2 + (0))))); } while (0);



 duk__mark_heaphdr_nonnull(heap, hdr);




}

static void duk__mark_temproots_by_heap_scan(duk_heap *heap) {
 duk_heaphdr *hdr;




 do { } while (0);

 while ((((heap))->flags & ((1U << 0)))) {
  do { } while (0);




  do { ((heap))->flags &= ~((1U << 0)); } while (0);

  hdr = heap->heap_allocated;
  while (hdr) {



   duk__handle_temproot(heap, hdr);

   hdr = ((hdr)->h_next);
  }


  hdr = heap->finalize_list;
  while (hdr) {



   duk__handle_temproot(heap, hdr);

   hdr = ((hdr)->h_next);
  }





 }
}
# 493 "duk_heap_markandsweep.c"
static void duk__finalize_refcounts(duk_heap *heap) {
 duk_heaphdr *hdr;

 do { } while (0);

 do { } while (0);

 hdr = heap->heap_allocated;
 while (hdr) {
  if (!((((hdr))->h_flags & ((1UL << (2 + (0))))) != 0)) {
# 513 "duk_heap_markandsweep.c"
   do { } while (0);





   duk_heaphdr_refcount_finalize_norz(heap, hdr);
  }

  hdr = ((hdr)->h_next);
 }
}
# 539 "duk_heap_markandsweep.c"
static void duk__clear_finalize_list_flags(duk_heap *heap) {
 duk_heaphdr *hdr;

 do { } while (0);

 hdr = heap->finalize_list;
 while (hdr) {
  do { do { } while (0); ((hdr))->h_flags &= ~(((1UL << (2 + (0))))); } while (0);




  do { } while (0);
  hdr = ((hdr)->h_next);
 }
}






static void duk__sweep_stringtable(duk_heap *heap, duk_size_t *out_count_keep) {
 duk_hstring *h;
 duk_hstring *prev;
 duk_uint32_t i;



 duk_size_t count_keep = 0;

 do { } while (0);




 if (heap->strtable == 
# 575 "duk_heap_markandsweep.c" 3 4
                      ((void *)0)
# 575 "duk_heap_markandsweep.c"
                          ) {

  goto done;
 }

 for (i = 0; i < heap->st_size; i++) {



  h = heap->strtable[i];

  prev = 
# 586 "duk_heap_markandsweep.c" 3 4
        ((void *)0)
# 586 "duk_heap_markandsweep.c"
            ;
  while (h != 
# 587 "duk_heap_markandsweep.c" 3 4
             ((void *)0)
# 587 "duk_heap_markandsweep.c"
                 ) {
   duk_hstring *next;
   next = h->hdr.h_next;

   if ((((((duk_heaphdr *) h))->h_flags & ((1UL << (2 + (0))))) != 0)) {
    do { do { } while (0); (((duk_heaphdr *) h))->h_flags &= ~(((1UL << (2 + (0))))); } while (0);
    count_keep++;
    prev = h;
   } else {
# 618 "duk_heap_markandsweep.c"
    do { } while (0)
                                                                                                                                 ;



    duk_heap_strcache_string_remove(heap, (duk_hstring *) h);


    duk_heap_strtable_unlink_prev(heap, (duk_hstring *) h, (duk_hstring *) prev);




    duk_free_hstring(heap, (duk_hstring *) h);


   }

   h = next;
  }
 }

done:



 *out_count_keep = count_keep;
}





static void duk__sweep_heap(duk_heap *heap, duk_small_uint_t flags, duk_size_t *out_count_keep) {
 duk_heaphdr *prev;
 duk_heaphdr *curr;
 duk_heaphdr *next;





 duk_size_t count_keep = 0;

 do { } while (0);

 prev = 
# 664 "duk_heap_markandsweep.c" 3 4
       ((void *)0)
# 664 "duk_heap_markandsweep.c"
           ;
 curr = heap->heap_allocated;
 heap->heap_allocated = 
# 666 "duk_heap_markandsweep.c" 3 4
                       ((void *)0)
# 666 "duk_heap_markandsweep.c"
                           ;
 while (curr) {

  do { } while (0);
  do { } while (0);

  next = ((curr)->h_next);

  if (((((curr))->h_flags & ((1UL << (2 + (0))))) != 0)) {
# 689 "duk_heap_markandsweep.c"
   if (__builtin_expect((((((curr))->h_flags & ((1UL << (2 + (2))))) != 0)), 0)) {
    do { } while (0);
    do { } while (0);
    do { } while (0);


    (++(curr)->h_refcount)
             ;

    duk_heap_insert_into_finalize_list((heap), (curr));



   } else

   {
    if (__builtin_expect((((((curr))->h_flags & ((1UL << (2 + (3))))) != 0)), 0)) {
     do { } while (0);
     do { } while (0);

     if (flags & (1U << 1)) {
      do { } while (0)

                               ;
      count_keep++;
     } else {
      do { } while (0)
                                        ;

      do { do { } while (0); ((curr))->h_flags &= ~(((1UL << (2 + (3))))); } while (0);




     }
    } else {
     do { } while (0);
     count_keep++;
    }

    if (prev != 
# 729 "duk_heap_markandsweep.c" 3 4
               ((void *)0)
# 729 "duk_heap_markandsweep.c"
                   ) {
     do { } while (0);
     do { (prev)->h_next = (curr); } while (0);
    } else {
     do { } while (0);
     heap->heap_allocated = curr;
    }

    do { (curr)->h_prev = (prev); } while (0);

    do { } while (0);
    do { } while (0);
    prev = curr;
   }







   if (((curr)->h_flags & 0x01UL) && ((((&(((duk_hobject *) curr))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 18)) {
    duk_hthread *thr_curr = (duk_hthread *) curr;
    do { } while (0);
    duk_valstack_shrink_check_nothrow(thr_curr, flags & (1U << 0) );
   }

   do { do { } while (0); ((curr))->h_flags &= ~(((1UL << (2 + (0))))); } while (0);


   do { } while (0);
  } else {
# 779 "duk_heap_markandsweep.c"
   do { } while (0);

   do { } while (0);
# 807 "duk_heap_markandsweep.c"
   duk_heap_free_heaphdr_raw(heap, curr);
  }

  curr = next;
 }

 if (prev != 
# 813 "duk_heap_markandsweep.c" 3 4
            ((void *)0)
# 813 "duk_heap_markandsweep.c"
                ) {
  do { (prev)->h_next = (
# 814 "duk_heap_markandsweep.c" 3 4
 ((void *)0)
# 814 "duk_heap_markandsweep.c"
 ); } while (0);
 }
 do { } while (0);
# 825 "duk_heap_markandsweep.c"
 *out_count_keep = count_keep;
}






static void duk__wipe_litcache(duk_heap *heap) {
 duk_uint_t i;
 duk_litcache_entry *e;

 e = heap->litcache;
 for (i = 0; i < 256; i++) {
  e->addr = 
# 839 "duk_heap_markandsweep.c" 3 4
           ((void *)0)
# 839 "duk_heap_markandsweep.c"
               ;



  e++;
 }
}
# 854 "duk_heap_markandsweep.c"
static int duk__protected_compact_object(duk_hthread *thr, void *udata) {
 duk_hobject *obj;


 do { (void) (udata); } while (0);
 obj = duk_known_hobject(thr, -1);
 duk_hobject_compact_props(thr, obj);
 return 0;
}
# 872 "duk_heap_markandsweep.c"
static void duk__compact_object_list(duk_heap *heap, duk_hthread *thr, duk_heaphdr *start) {

 duk_heaphdr *curr;



 duk_hobject *obj;

 do { (void) (heap); } while (0);

 curr = start;
 while (curr) {
  do { } while (0);

  if (((curr)->h_flags & 0x00000003UL) != 1) {
   goto next;
  }
  obj = (duk_hobject *) curr;






  do { } while (0);
  duk_push_hobject(thr, obj);

  duk_safe_call(thr, duk__protected_compact_object, 
# 899 "duk_heap_markandsweep.c" 3 4
                                                   ((void *)0)
# 899 "duk_heap_markandsweep.c"
                                                       , 1, 0);
# 911 "duk_heap_markandsweep.c"
 next:
  curr = ((curr)->h_next);



 }
}

static void duk__compact_objects(duk_heap *heap) {







 do { } while (0);

 do { } while (0);







 duk__compact_object_list(heap, heap->heap_thread, heap->heap_allocated);

 duk__compact_object_list(heap, heap->heap_thread, heap->finalize_list);



 do { } while (0);
# 952 "duk_heap_markandsweep.c"
}
# 1218 "duk_heap_markandsweep.c"
static __attribute__ ((unused)) void duk_heap_mark_and_sweep(duk_heap *heap, duk_small_uint_t flags) {
 duk_size_t count_keep_obj;
 duk_size_t count_keep_str;

 duk_size_t tmp;

 duk_bool_t entry_creating_error;

 do { } while (0);
# 1236 "duk_heap_markandsweep.c"
 do { } while (0);





 if (heap->ms_prevent_count != 0) {
  do { } while (0);
  do { } while (0);
  return;
 }
 do { } while (0);






 do { } while (0);
 do { } while (0);

 do { } while (0)

                                                                 ;

 flags |= heap->ms_base_flags;

 if (heap->finalize_list != 
# 1263 "duk_heap_markandsweep.c" 3 4
                           ((void *)0)
# 1263 "duk_heap_markandsweep.c"
                               ) {
  flags |= (1U << 1);
 }
# 1292 "duk_heap_markandsweep.c"
 do { } while (0);
 do { } while (0);
 heap->ms_prevent_count = 1;
 heap->ms_running = 1;
 entry_creating_error = heap->creating_error;
 heap->creating_error = 0;







 do { } while (0);
 duk_heap_free_freelists(heap);
# 1328 "duk_heap_markandsweep.c"
 duk__wipe_litcache(heap);

 duk__mark_roots_heap(heap);

 do { } while (0);

 duk__mark_temproots_by_heap_scan(heap);


 duk__mark_finalizable(heap);
 duk__mark_finalize_list(heap);

 duk__mark_temproots_by_heap_scan(heap);
# 1359 "duk_heap_markandsweep.c"
 duk__finalize_refcounts(heap);

 duk__sweep_heap(heap, flags, &count_keep_obj);
 duk__sweep_stringtable(heap, &count_keep_str);




 do { } while (0);


 duk__clear_finalize_list_flags(heap);
# 1394 "duk_heap_markandsweep.c"
 if ((flags & (1U << 0)) && !(flags & (1U << 2))) {
  if (heap->lj.type != 0) {
   do { } while (0);
  } else {
   do { } while (0);
   duk__compact_objects(heap);
  }
 }
# 1414 "duk_heap_markandsweep.c"
 if (flags & (1U << 0)) {
  do { } while (0);
  duk_heap_strtable_force_resize(heap);
 }





 do { } while (0);
 do { } while (0);
 heap->ms_prevent_count = 0;
 heap->ms_running = 0;
 heap->creating_error = entry_creating_error;
# 1455 "duk_heap_markandsweep.c"
 tmp = (count_keep_obj + count_keep_str) / 256;
 heap->ms_trigger_counter = (duk_int_t) ((tmp * 12800L) + 1024L);
 do { } while (0)


                                                   ;
# 1506 "duk_heap_markandsweep.c"
 duk_heap_process_finalize_list(heap);

}
# 1 "duk_heap_memory.c"
# 12 "duk_heap_memory.c"
static __attribute__((noinline)) __attribute__((cold)) void *duk__heap_mem_alloc_slowpath(duk_heap *heap, duk_size_t size) {
 void *res;
 duk_small_int_t i;

 do { } while (0);
 do { } while (0);
 do { } while (0);

 if (size == 0) {
  do { } while (0);
  return 
# 22 "duk_heap_memory.c" 3 4
        ((void *)0)
# 22 "duk_heap_memory.c"
            ;
 }

 do { } while (0);
# 47 "duk_heap_memory.c"
 for (i = 0; i < 10; i++) {
  duk_small_uint_t flags;

  flags = 0;
  if (i >= 3 - 1) {
   flags |= (1U << 0);
  }

  duk_heap_mark_and_sweep(heap, flags);

  do { } while (0);
  res = heap->alloc_func(heap->heap_udata, size);
  if (res != 
# 59 "duk_heap_memory.c" 3 4
            ((void *)0)
# 59 "duk_heap_memory.c"
                ) {
   do { } while (0)

                                 ;
   return res;
  }
 }

 do { } while (0);
 return 
# 68 "duk_heap_memory.c" 3 4
       ((void *)0)
# 68 "duk_heap_memory.c"
           ;
}

static __attribute__ ((unused)) inline __attribute__((hot)) void *duk_heap_mem_alloc(duk_heap *heap, duk_size_t size) {
 void *res;

 do { } while (0);
 do { } while (0);
 do { } while (0);



 if (__builtin_expect((--(heap)->ms_trigger_counter < 0), 0)) {
  goto slowpath;
 }
# 101 "duk_heap_memory.c"
 res = heap->alloc_func(heap->heap_udata, size);
 if (__builtin_expect((res != 
# 102 "duk_heap_memory.c" 3 4
    ((void *)0)
# 102 "duk_heap_memory.c"
    ), 1)) {
  return res;
 }

slowpath:

 if (size == 0) {
  do { } while (0);
 } else {
  do { } while (0);
 }
 return duk__heap_mem_alloc_slowpath(heap, size);
}

static __attribute__ ((unused)) inline __attribute__((hot)) void *duk_heap_mem_alloc_zeroed(duk_heap *heap, duk_size_t size) {
 void *res;

 do { } while (0);
 do { } while (0);
 do { } while (0);

 res = duk_heap_mem_alloc((heap), (size));
 if (__builtin_expect((res != 
# 124 "duk_heap_memory.c" 3 4
    ((void *)0)
# 124 "duk_heap_memory.c"
    ), 1)) {
  do { void *duk__dst = (res); duk_size_t duk__len = (size); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 }
 return res;
}

static __attribute__ ((unused)) inline __attribute__((hot)) void *duk_heap_mem_alloc_checked(duk_hthread *thr, duk_size_t size) {
 void *res;

 do { } while (0);
 do { } while (0);
 do { } while (0);

 res = duk_heap_mem_alloc(thr->heap, size);
 if (__builtin_expect((res != 
# 138 "duk_heap_memory.c" 3 4
    ((void *)0)
# 138 "duk_heap_memory.c"
    ), 1)) {
  return res;
 } else if (size == 0) {
  do { } while (0);
  return res;
 }
 do { duk_err_error_alloc_failed((thr), "duk_heap_memory.c", (duk_int_t) 144); } while (0);
 do { return 
# 145 "duk_heap_memory.c" 3 4
((void *)0)
# 145 "duk_heap_memory.c"
; } while (0);
}

static __attribute__ ((unused)) inline __attribute__((hot)) void *duk_heap_mem_alloc_checked_zeroed(duk_hthread *thr, duk_size_t size) {
 void *res;

 do { } while (0);
 do { } while (0);
 do { } while (0);

 res = duk_heap_mem_alloc(thr->heap, size);
 if (__builtin_expect((res != 
# 156 "duk_heap_memory.c" 3 4
    ((void *)0)
# 156 "duk_heap_memory.c"
    ), 1)) {
  do { void *duk__dst = (res); duk_size_t duk__len = (size); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
  return res;
 } else if (size == 0) {
  do { } while (0);
  return res;
 }
 do { duk_err_error_alloc_failed((thr), "duk_heap_memory.c", (duk_int_t) 163); } while (0);
 do { return 
# 164 "duk_heap_memory.c" 3 4
((void *)0)
# 164 "duk_heap_memory.c"
; } while (0);
}






static __attribute__((noinline)) __attribute__((cold)) void *duk__heap_mem_realloc_slowpath(duk_heap *heap, void *ptr, duk_size_t newsize) {
 void *res;
 duk_small_int_t i;

 do { } while (0);
 do { } while (0);

 do { } while (0);



 do { } while (0);
# 202 "duk_heap_memory.c"
 for (i = 0; i < 10; i++) {
  duk_small_uint_t flags;

  flags = 0;
  if (i >= 3 - 1) {
   flags |= (1U << 0);
  }

  duk_heap_mark_and_sweep(heap, flags);

  res = heap->realloc_func(heap->heap_udata, ptr, newsize);
  if (res != 
# 213 "duk_heap_memory.c" 3 4
            ((void *)0) 
# 213 "duk_heap_memory.c"
                 || newsize == 0) {
   do { } while (0)

                                    ;
   return res;
  }
 }

 do { } while (0);
 return 
# 222 "duk_heap_memory.c" 3 4
       ((void *)0)
# 222 "duk_heap_memory.c"
           ;
}

static __attribute__ ((unused)) inline __attribute__((hot)) void *duk_heap_mem_realloc(duk_heap *heap, void *ptr, duk_size_t newsize) {
 void *res;

 do { } while (0);
 do { } while (0);

 do { } while (0);



 if (__builtin_expect((--(heap)->ms_trigger_counter < 0), 0)) {
  goto gc_retry;
 }
# 252 "duk_heap_memory.c"
 res = heap->realloc_func(heap->heap_udata, ptr, newsize);
 if (__builtin_expect((res != 
# 253 "duk_heap_memory.c" 3 4
    ((void *)0)
# 253 "duk_heap_memory.c"
    ), 1) || newsize == 0) {
  if (res != 
# 254 "duk_heap_memory.c" 3 4
            ((void *)0) 
# 254 "duk_heap_memory.c"
                 && newsize == 0) {
   do { } while (0);
  }
  return res;
 } else {
  goto gc_retry;
 }


gc_retry:
 return duk__heap_mem_realloc_slowpath(heap, ptr, newsize);
}
# 274 "duk_heap_memory.c"
static __attribute__((noinline)) __attribute__((cold)) void *duk__heap_mem_realloc_indirect_slowpath(duk_heap *heap,
                                                                                   duk_mem_getptr cb,
                                                                                   void *ud,
                                                                                   duk_size_t newsize) {
 void *res;
 duk_small_int_t i;

 do { } while (0);
 do { } while (0);
 do { } while (0);



 do { } while (0);
# 306 "duk_heap_memory.c"
 for (i = 0; i < 10; i++) {
  duk_small_uint_t flags;
# 317 "duk_heap_memory.c"
  flags = 0;
  if (i >= 3 - 1) {
   flags |= (1U << 0);
  }

  duk_heap_mark_and_sweep(heap, flags);
# 336 "duk_heap_memory.c"
  res = heap->realloc_func(heap->heap_udata, cb(heap, ud), newsize);
  if (res != 
# 337 "duk_heap_memory.c" 3 4
            ((void *)0) 
# 337 "duk_heap_memory.c"
                 || newsize == 0) {
   do { } while (0)

                                    ;
   return res;
  }
 }

 do { } while (0);
 return 
# 346 "duk_heap_memory.c" 3 4
       ((void *)0)
# 346 "duk_heap_memory.c"
           ;
}

static __attribute__ ((unused)) inline __attribute__((hot)) void *duk_heap_mem_realloc_indirect(duk_heap *heap,
                                                                         duk_mem_getptr cb,
                                                                         void *ud,
                                                                         duk_size_t newsize) {
 void *res;

 do { } while (0);
 do { } while (0);
 do { } while (0);



 if (__builtin_expect((--(heap)->ms_trigger_counter < 0), 0)) {
  goto gc_retry;
 }
# 378 "duk_heap_memory.c"
 res = heap->realloc_func(heap->heap_udata, cb(heap, ud), newsize);
 if (__builtin_expect((res != 
# 379 "duk_heap_memory.c" 3 4
    ((void *)0)
# 379 "duk_heap_memory.c"
    ), 1) || newsize == 0) {
  if (res != 
# 380 "duk_heap_memory.c" 3 4
            ((void *)0) 
# 380 "duk_heap_memory.c"
                 && newsize == 0) {
   do { } while (0)
                                                                                                     ;
  }
  return res;
 } else {
  goto gc_retry;
 }


gc_retry:
 return duk__heap_mem_realloc_indirect_slowpath(heap, cb, ud, newsize);
}





static __attribute__ ((unused)) inline __attribute__((hot)) void duk_heap_mem_free(duk_heap *heap, void *ptr) {
 do { } while (0);
 do { } while (0);





 heap->free_func(heap->heap_udata, ptr);





}
# 1 "duk_heap_misc.c"






static __attribute__ ((unused)) void duk_heap_insert_into_heap_allocated(duk_heap *heap, duk_heaphdr *hdr) {
 duk_heaphdr *root;

 do { } while (0);

 root = heap->heap_allocated;

 if (root != 
# 14 "duk_heap_misc.c" 3 4
            ((void *)0)
# 14 "duk_heap_misc.c"
                ) {
  do { } while (0);
  do { (root)->h_prev = (hdr); } while (0);
 }
 do { (hdr)->h_prev = (
# 18 "duk_heap_misc.c" 3 4
((void *)0)
# 18 "duk_heap_misc.c"
); } while (0);

 do { (hdr)->h_next = (root); } while (0);
 do { } while (0);
 do { } while (0);
 heap->heap_allocated = hdr;
}


static __attribute__ ((unused)) void duk_heap_remove_from_heap_allocated(duk_heap *heap, duk_heaphdr *hdr) {
 duk_heaphdr *prev;
 duk_heaphdr *next;


 do { } while (0);
 do { } while (0);
# 51 "duk_heap_misc.c"
 prev = ((hdr)->h_prev);
 next = ((hdr)->h_next);

 if (prev != 
# 54 "duk_heap_misc.c" 3 4
            ((void *)0)
# 54 "duk_heap_misc.c"
                ) {
  do { } while (0);
  do { (prev)->h_next = (next); } while (0);
 } else {
  do { } while (0);
  heap->heap_allocated = next;
 }
 if (next != 
# 61 "duk_heap_misc.c" 3 4
            ((void *)0)
# 61 "duk_heap_misc.c"
                ) {
  do { (next)->h_prev = (prev); } while (0);
 } else {
  ;
 }
}



static __attribute__ ((unused)) void duk_heap_insert_into_finalize_list(duk_heap *heap, duk_heaphdr *hdr) {
 duk_heaphdr *root;

 root = heap->finalize_list;

 do { (hdr)->h_prev = (
# 75 "duk_heap_misc.c" 3 4
((void *)0)
# 75 "duk_heap_misc.c"
); } while (0);
 if (root != 
# 76 "duk_heap_misc.c" 3 4
            ((void *)0)
# 76 "duk_heap_misc.c"
                ) {
  do { } while (0);
  do { (root)->h_prev = (hdr); } while (0);
 }

 do { (hdr)->h_next = (root); } while (0);
 do { } while (0);
 do { } while (0);
 heap->finalize_list = hdr;
}



static __attribute__ ((unused)) void duk_heap_remove_from_finalize_list(duk_heap *heap, duk_heaphdr *hdr) {

 duk_heaphdr *next;
 duk_heaphdr *prev;

 next = ((hdr)->h_next);
 prev = ((hdr)->h_prev);
 if (next != 
# 96 "duk_heap_misc.c" 3 4
            ((void *)0)
# 96 "duk_heap_misc.c"
                ) {
  do { } while (0);
  do { (next)->h_prev = (prev); } while (0);
 }
 if (prev == 
# 100 "duk_heap_misc.c" 3 4
            ((void *)0)
# 100 "duk_heap_misc.c"
                ) {
  do { } while (0);
  heap->finalize_list = next;
 } else {
  do { } while (0);
  do { (prev)->h_next = (next); } while (0);
 }
# 131 "duk_heap_misc.c"
}
# 1 "duk_heap_refcount.c"
# 35 "duk_heap_refcount.c"
static void duk__decref_tvals_norz(duk_hthread *thr, duk_tval *tv, duk_idx_t count) {
 do { } while (0);

 while (count-- > 0) {
  do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz(((thr)), duk__h); } } } while (0);
  tv++;
 }
}

static __attribute__ ((unused)) void duk_hobject_refcount_finalize_norz(duk_heap *heap, duk_hobject *h) {
 duk_hthread *thr;
 duk_uint_fast32_t i;
 duk_uint_fast32_t n;
 duk_propvalue *p_val;
 duk_tval *p_tv;
 duk_hstring **p_key;
 duk_uint8_t *p_flag;
 duk_hobject *h_proto;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 thr = heap->heap_thread;
 do { } while (0);

 p_key = ((duk_hstring **) (void *) ((((h))->props) + (((h))->e_size) * sizeof(duk_propvalue)));
 p_val = ((duk_propvalue *) (void *) ((((h))->props)));
 p_flag = ((duk_uint8_t *) (void *) ((((h))->props) + (((h))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))));
 n = ((h)->e_next);
 while (n-- > 0) {
  duk_hstring *key;

  key = p_key[n];
  if (__builtin_expect((key == 
# 70 "duk_heap_refcount.c" 3 4
     ((void *)0)
# 70 "duk_heap_refcount.c"
     ), 0)) {
   continue;
  }
  do { duk_heaphdr *duk__h = (duk_heaphdr *) ((key)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hstring_refzero)(((thr)), (duk_hstring *) duk__h); } } } while (0);
  if (__builtin_expect((p_flag[n] & (1U << 3)), 0)) {
   duk_hobject *h_getset;
   h_getset = p_val[n].a.get;
   do { } while (0);
   do { if ((h_getset) != 
# 78 "duk_heap_refcount.c" 3 4
  ((void *)0)
# 78 "duk_heap_refcount.c"
  ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((h_getset))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
   h_getset = p_val[n].a.set;
   do { } while (0);
   do { if ((h_getset) != 
# 81 "duk_heap_refcount.c" 3 4
  ((void *)0)
# 81 "duk_heap_refcount.c"
  ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((h_getset))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
  } else {
   duk_tval *tv_val;
   tv_val = &p_val[n].v;
   do { duk_tval *duk__tv = ((tv_val)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz(((thr)), duk__h); } } } while (0);
  }
 }

 p_tv = ((duk_tval *) (void *) ((((h))->props) + (((h))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - ((((h))->e_size))) & 0x07)));
 n = ((h)->a_size);
 while (n-- > 0) {
  duk_tval *tv_val;
  tv_val = p_tv + n;
  do { duk_tval *duk__tv = ((tv_val)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz(((thr)), duk__h); } } } while (0);
 }



 h_proto = (duk_hobject *) ((h)->prototype);
 do { } while (0);
 do { if ((h_proto) != 
# 101 "duk_heap_refcount.c" 3 4
((void *)0)
# 101 "duk_heap_refcount.c"
) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((h_proto))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);







 if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (7))))) != 0)) {




  do { } while (0);
  return;
 }
 do { } while (0);




 if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
  duk_hcompfunc *f = (duk_hcompfunc *) h;
  duk_tval *tv, *tv_end;
  duk_hobject **funcs, **funcs_end;

  do { } while (0);

  if (__builtin_expect((((duk_hbuffer_fixed *) (void *) (f)->data) != 
# 129 "duk_heap_refcount.c" 3 4
     ((void *)0)
# 129 "duk_heap_refcount.c"
     ), 1)) {
   tv = ((duk_tval *) (void *) ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) (((duk_hbuffer_fixed *) (void *) (((f)))->data))) + 1)));
   tv_end = ((duk_tval *) (void *) (((f))->funcs));
   while (tv < tv_end) {
    do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz(((thr)), duk__h); } } } while (0);
    tv++;
   }

   funcs = (((f))->funcs);
   funcs_end = ((duk_hobject **) (void *) (((f))->bytecode));
   while (funcs < funcs_end) {
    duk_hobject *h_func;
    h_func = *funcs;
    do { } while (0);
    do { } while (0);
    do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_hcompfunc *) h_func)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)(((thr)), (duk_hobject *) duk__h); } } } while (0);
    funcs++;
   }
  } else {

   do { } while (0);
  }

  do { if (((duk_heaphdr *) ((f)->lex_env)) != 
# 152 "duk_heap_refcount.c" 3 4
 ((void *)0)
# 152 "duk_heap_refcount.c"
 ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk_heaphdr *) ((f)->lex_env)))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } } while (0);
  do { if (((duk_heaphdr *) ((f)->var_env)) != 
# 153 "duk_heap_refcount.c" 3 4
 ((void *)0)
# 153 "duk_heap_refcount.c"
 ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk_heaphdr *) ((f)->var_env)))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } } while (0);
  do { if (((duk_hbuffer *) ((duk_hbuffer_fixed *) (void *) (f)->data)) != 
# 154 "duk_heap_refcount.c" 3 4
 ((void *)0)
# 154 "duk_heap_refcount.c"
 ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk_hbuffer *) ((duk_hbuffer_fixed *) (void *) (f)->data)))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } } while (0);
 } else if (((((&((h))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 16)) {
  duk_hdecenv *e = (duk_hdecenv *) h;
  do { } while (0);
  do { if ((e->thread) != 
# 158 "duk_heap_refcount.c" 3 4
 ((void *)0)
# 158 "duk_heap_refcount.c"
 ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((e->thread))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
  do { if ((e->varmap) != 
# 159 "duk_heap_refcount.c" 3 4
 ((void *)0)
# 159 "duk_heap_refcount.c"
 ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((e->varmap))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
 } else if (((((&((h))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 15)) {
  duk_hobjenv *e = (duk_hobjenv *) h;
  do { } while (0);
  do { } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) ((e->target)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)(((thr)), (duk_hobject *) duk__h); } } } while (0);

 } else if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {
  duk_hbufobj *b = (duk_hbufobj *) h;
  do { } while (0);
  do { if (((duk_hbuffer *) b->buf) != 
# 169 "duk_heap_refcount.c" 3 4
 ((void *)0)
# 169 "duk_heap_refcount.c"
 ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) ((((duk_hbuffer *) b->buf))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hbuffer_refzero)((((thr))), (duk_hbuffer *) duk__h); } } } while (0); } } while (0);
  do { if (((duk_hobject *) b->buf_prop) != 
# 170 "duk_heap_refcount.c" 3 4
 ((void *)0)
# 170 "duk_heap_refcount.c"
 ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) ((((duk_hobject *) b->buf_prop))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);

 } else if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0)) {
  duk_hboundfunc *f = (duk_hboundfunc *) (void *) h;
  do { } while (0);
  do { duk_tval *duk__tv = ((&f->target)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz(((thr)), duk__h); } } } while (0);
  do { duk_tval *duk__tv = ((&f->this_binding)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz(((thr)), duk__h); } } } while (0);
  duk__decref_tvals_norz(thr, f->args, f->nargs);

 } else if ((((&((h))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)) {
  duk_hproxy *p = (duk_hproxy *) h;
  do { } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) ((p->target)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)(((thr)), (duk_hobject *) duk__h); } } } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) ((p->handler)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)(((thr)), (duk_hobject *) duk__h); } } } while (0);

 } else if (((((&((h))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 18)) {
  duk_hthread *t = (duk_hthread *) h;
  duk_activation *act;
  duk_tval *tv;

  do { } while (0);

  tv = t->valstack;
  while (tv < t->valstack_top) {
   do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz(((thr)), duk__h); } } } while (0);
   tv++;
  }

  for (act = t->callstack_curr; act != 
# 198 "duk_heap_refcount.c" 3 4
                                      ((void *)0)
# 198 "duk_heap_refcount.c"
                                          ; act = act->parent) {
   do { if (((duk_hobject *) ((act)->func)) != 
# 199 "duk_heap_refcount.c" 3 4
  ((void *)0)
# 199 "duk_heap_refcount.c"
  ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) ((((duk_hobject *) ((act)->func)))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
   do { if (((duk_hobject *) act->var_env) != 
# 200 "duk_heap_refcount.c" 3 4
  ((void *)0)
# 200 "duk_heap_refcount.c"
  ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) ((((duk_hobject *) act->var_env))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
   do { if (((duk_hobject *) act->lex_env) != 
# 201 "duk_heap_refcount.c" 3 4
  ((void *)0)
# 201 "duk_heap_refcount.c"
  ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) ((((duk_hobject *) act->lex_env))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);







  }

  for (i = 0; i < 51; i++) {
   do { if (((duk_hobject *) t->builtins[i]) != 
# 212 "duk_heap_refcount.c" 3 4
  ((void *)0)
# 212 "duk_heap_refcount.c"
  ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) ((((duk_hobject *) t->builtins[i]))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
  }

  do { if (((duk_hthread *) t->resumer) != 
# 215 "duk_heap_refcount.c" 3 4
 ((void *)0)
# 215 "duk_heap_refcount.c"
 ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) ((((duk_hthread *) t->resumer))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
 } else {




  do { } while (0);
  do { } while (0);
 }
}

static __attribute__ ((unused)) void duk_heaphdr_refcount_finalize_norz(duk_heap *heap, duk_heaphdr *hdr) {
 do { } while (0);
 do { } while (0);
 do { } while (0);

 if (((hdr)->h_flags & 0x01UL)) {
  duk_hobject_refcount_finalize_norz(heap, (duk_hobject *) hdr);
 }


}
# 285 "duk_heap_refcount.c"
static void duk__refcount_free_pending(duk_heap *heap) {
 duk_heaphdr *curr;




 do { } while (0);

 curr = heap->refzero_list;
 do { } while (0);
 do { } while (0);


 do {
  duk_heaphdr *prev;

  do { } while (0);





  do { } while (0);
  do { } while (0);





  do { } while (0);
  duk_hobject_refcount_finalize_norz(heap, (duk_hobject *) curr);

  prev = ((curr)->h_prev);
  do { } while (0);


  duk_free_hobject(heap, (duk_hobject *) curr);

  curr = prev;
 } while (curr != 
# 324 "duk_heap_refcount.c" 3 4
                 ((void *)0)
# 324 "duk_heap_refcount.c"
                     );

 heap->refzero_list = 
# 326 "duk_heap_refcount.c" 3 4
                     ((void *)0)
# 326 "duk_heap_refcount.c"
                         ;

 do { } while (0);
}

static inline void duk__refcount_refzero_hobject(duk_heap *heap, duk_hobject *obj, duk_bool_t skip_free_pending) {
 duk_heaphdr *hdr;
 duk_heaphdr *root;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 hdr = (duk_heaphdr *) obj;
# 350 "duk_heap_refcount.c"
 duk_heap_remove_from_heap_allocated((heap), (hdr));





 if (__builtin_expect((duk_hobject_has_finalizer_fast_raw(((duk_hobject *) hdr)) != 0U), 0)) {






  if (((((hdr))->h_flags & ((1UL << (2 + (3))))) != 0)) {
   do { } while (0);
  } else {




   do { do { } while (0); ((hdr))->h_flags |= ((1UL << (2 + (2)))); } while (0);
   do { } while (0);
# 380 "duk_heap_refcount.c"
   (++(hdr)->h_refcount);

   duk_heap_insert_into_finalize_list((heap), (hdr));
# 391 "duk_heap_refcount.c"
   if (!skip_free_pending && heap->refzero_list == 
# 391 "duk_heap_refcount.c" 3 4
                                                  ((void *)0)
# 391 "duk_heap_refcount.c"
                                                      ) {
    duk_heap_process_finalize_list(heap);
   }
   return;
  }
 }




 root = heap->refzero_list;

 do { (hdr)->h_prev = (
# 403 "duk_heap_refcount.c" 3 4
((void *)0)
# 403 "duk_heap_refcount.c"
); } while (0);

 heap->refzero_list = hdr;

 if (root == 
# 407 "duk_heap_refcount.c" 3 4
            ((void *)0)
# 407 "duk_heap_refcount.c"
                ) {






  duk__refcount_free_pending(heap);
  do { } while (0);






  if (!skip_free_pending && __builtin_expect((heap->finalize_list != 
# 422 "duk_heap_refcount.c" 3 4
                           ((void *)0)
# 422 "duk_heap_refcount.c"
                           ), 0)) {
   duk_heap_process_finalize_list(heap);
  }

 } else {
  do { } while (0);
  do { (root)->h_prev = (hdr); } while (0);





 }
}


static __attribute__ ((unused)) inline __attribute__((always_inline)) void duk_refzero_check_fast(duk_hthread *thr) {
 do { } while (0);
 do { } while (0);
 do { } while (0);

 if (__builtin_expect((thr->heap->finalize_list != 
# 443 "duk_heap_refcount.c" 3 4
    ((void *)0)
# 443 "duk_heap_refcount.c"
    ), 0)) {
  duk_heap_process_finalize_list(thr->heap);
 }
}

static __attribute__ ((unused)) void duk_refzero_check_slow(duk_hthread *thr) {
 do { } while (0);
 do { } while (0);
 do { } while (0);

 if (__builtin_expect((thr->heap->finalize_list != 
# 453 "duk_heap_refcount.c" 3 4
    ((void *)0)
# 453 "duk_heap_refcount.c"
    ), 0)) {
  duk_heap_process_finalize_list(thr->heap);
 }
}






static inline void duk__refcount_refzero_hstring(duk_heap *heap, duk_hstring *str) {
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 duk_heap_strcache_string_remove(heap, str);
 duk_heap_strtable_unlink(heap, str);
 duk_free_hstring(heap, str);
}





static inline void duk__refcount_refzero_hbuffer(duk_heap *heap, duk_hbuffer *buf) {
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 duk_heap_remove_from_heap_allocated((heap), ((duk_heaphdr *) buf));
 duk_free_hbuffer(heap, buf);
}
# 585 "duk_heap_refcount.c"
static inline __attribute__((always_inline)) void duk__hstring_refzero_helper(duk_hthread *thr, duk_hstring *h) {
 duk_heap *heap;

 do { } while (0);
 do { } while (0);
 heap = thr->heap;

 do { do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); if (__builtin_expect(((heap->ms_running != 0)), 0)) { do { } while (0); return; } } while (0);
 do { duk__refcount_refzero_hstring(heap, (duk_hstring *) h); } while (0);
}

static inline __attribute__((always_inline)) void duk__hbuffer_refzero_helper(duk_hthread *thr, duk_hbuffer *h) {
 duk_heap *heap;

 do { } while (0);
 do { } while (0);
 heap = thr->heap;

 do { do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); if (__builtin_expect(((heap->ms_running != 0)), 0)) { do { } while (0); return; } } while (0);
 do { duk__refcount_refzero_hbuffer(heap, (duk_hbuffer *) h); } while (0);
}

static inline __attribute__((always_inline)) void duk__hobject_refzero_helper(duk_hthread *thr, duk_hobject *h, duk_bool_t skip_free_pending) {
 duk_heap *heap;

 do { } while (0);
 do { } while (0);
 heap = thr->heap;

 do { do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); if (__builtin_expect(((heap->ms_running != 0)), 0)) { do { } while (0); return; } } while (0);
 do { duk__refcount_refzero_hobject(heap, (duk_hobject *) h, skip_free_pending); } while (0);
}

static inline __attribute__((always_inline)) void duk__heaphdr_refzero_helper(duk_hthread *thr, duk_heaphdr *h, duk_bool_t skip_free_pending) {
 duk_heap *heap;
 duk_small_uint_t htype;

 do { } while (0);
 do { } while (0);
 heap = thr->heap;

 htype = (duk_small_uint_t) ((h)->h_flags & 0x00000003UL);
 do { } while (0);
 do { do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0); do { } while (0); if (__builtin_expect(((heap->ms_running != 0)), 0)) { do { } while (0); return; } } while (0);

 switch (htype) {
 case 0:






  do { duk__refcount_refzero_hstring(heap, (duk_hstring *) h); } while (0);
  break;

 case 1:




  do { duk__refcount_refzero_hobject(heap, (duk_hobject *) h, skip_free_pending); } while (0);
  break;

 default:





  do { } while (0);
  do { duk__refcount_refzero_hbuffer(heap, (duk_hbuffer *) h); } while (0);
  break;
 }
}

static __attribute__ ((unused)) __attribute__((noinline)) void duk_heaphdr_refzero(duk_hthread *thr, duk_heaphdr *h) {
 duk__heaphdr_refzero_helper(thr, h, 0 );
}

static __attribute__ ((unused)) __attribute__((noinline)) void duk_heaphdr_refzero_norz(duk_hthread *thr, duk_heaphdr *h) {
 duk__heaphdr_refzero_helper(thr, h, 1 );
}

static __attribute__ ((unused)) __attribute__((noinline)) void duk_hstring_refzero(duk_hthread *thr, duk_hstring *h) {
 duk__hstring_refzero_helper(thr, h);
}

static __attribute__ ((unused)) __attribute__((noinline)) void duk_hbuffer_refzero(duk_hthread *thr, duk_hbuffer *h) {
 duk__hbuffer_refzero_helper(thr, h);
}

static __attribute__ ((unused)) __attribute__((noinline)) void duk_hobject_refzero(duk_hthread *thr, duk_hobject *h) {
 duk__hobject_refzero_helper(thr, h, 0 );
}

static __attribute__ ((unused)) __attribute__((noinline)) void duk_hobject_refzero_norz(duk_hthread *thr, duk_hobject *h) {
 duk__hobject_refzero_helper(thr, h, 1 );
}
# 1 "duk_heap_stringcache.c"
# 20 "duk_heap_stringcache.c"
static __attribute__ ((unused)) void duk_heap_strcache_string_remove(duk_heap *heap, duk_hstring *h) {
 duk_uint_t i;
 for (i = 0; i < 4; i++) {
  duk_strcache_entry *c = heap->strcache + i;
  if (c->h == h) {
   do { } while (0)
                                                                                                             ;
   c->h = 
# 27 "duk_heap_stringcache.c" 3 4
         ((void *)0)
# 27 "duk_heap_stringcache.c"
             ;





  }
 }
}
# 45 "duk_heap_stringcache.c"
static const duk_uint8_t *duk__scan_forwards(const duk_uint8_t *p, const duk_uint8_t *q, duk_uint_fast32_t n) {
 while (n > 0) {
  for (;;) {
   p++;
   if (p >= q) {
    return 
# 50 "duk_heap_stringcache.c" 3 4
          ((void *)0)
# 50 "duk_heap_stringcache.c"
              ;
   }
   if ((*p & 0xc0) != 0x80) {
    break;
   }
  }
  n--;
 }
 return p;
}

static const duk_uint8_t *duk__scan_backwards(const duk_uint8_t *p, const duk_uint8_t *q, duk_uint_fast32_t n) {
 while (n > 0) {
  for (;;) {
   p--;
   if (p < q) {
    return 
# 66 "duk_heap_stringcache.c" 3 4
          ((void *)0)
# 66 "duk_heap_stringcache.c"
              ;
   }
   if ((*p & 0xc0) != 0x80) {
    break;
   }
  }
  n--;
 }
 return p;
}
# 93 "duk_heap_stringcache.c"
static __attribute__ ((unused)) duk_uint_fast32_t duk_heap_strcache_offset_char2byte(duk_hthread *thr, duk_hstring *h, duk_uint_fast32_t char_offset) {
 duk_heap *heap;
 duk_strcache_entry *sce;
 duk_uint_fast32_t byte_offset;
 duk_uint_t i;
 duk_bool_t use_cache;
 duk_uint_fast32_t dist_start, dist_end, dist_sce;
 duk_uint_fast32_t char_length;
 const duk_uint8_t *p_start;
 const duk_uint8_t *p_end;
 const duk_uint8_t *p_found;





 if (__builtin_expect(((((&((h))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0)), 1)) {
  return char_offset;
 }

 char_length = (duk_uint_fast32_t) duk_hstring_get_charlen((h));
 do { } while (0);

 if (__builtin_expect(((((&((h))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0)), 1)) {




  return char_offset;
 }
# 135 "duk_heap_stringcache.c"
 do { } while (0)



                                                         ;

 heap = thr->heap;
 sce = 
# 142 "duk_heap_stringcache.c" 3 4
      ((void *)0)
# 142 "duk_heap_stringcache.c"
          ;
 use_cache = (char_length > 16);

 if (use_cache) {
# 158 "duk_heap_stringcache.c"
  for (i = 0; i < 4; i++) {
   duk_strcache_entry *c = heap->strcache + i;

   if (c->h == h) {
    sce = c;
    break;
   }
  }
 }
# 175 "duk_heap_stringcache.c"
 do { } while (0);
 dist_start = char_offset;
 dist_end = char_length - char_offset;
 dist_sce = 0;
 do { (void) (dist_sce); } while (0);

 p_start = (const duk_uint8_t *) ((const duk_uint8_t *) ((h) + 1));
 p_end = (const duk_uint8_t *) (p_start + ((h)->blen));
 p_found = 
# 183 "duk_heap_stringcache.c" 3 4
          ((void *)0)
# 183 "duk_heap_stringcache.c"
              ;

 if (sce) {
  if (char_offset >= sce->cidx) {
   dist_sce = char_offset - sce->cidx;
   if ((dist_sce <= dist_start) && (dist_sce <= dist_end)) {
    do { } while (0)
# 198 "duk_heap_stringcache.c"
                                          ;

    p_found = duk__scan_forwards(p_start + sce->bidx, p_end, dist_sce);
    goto scan_done;
   }
  } else {
   dist_sce = sce->cidx - char_offset;
   if ((dist_sce <= dist_start) && (dist_sce <= dist_end)) {
    do { } while (0)
# 215 "duk_heap_stringcache.c"
                                          ;

    p_found = duk__scan_backwards(p_start + sce->bidx, p_start, dist_sce);
    goto scan_done;
   }
  }
 }



 if (dist_start <= dist_end) {
  do { } while (0)
# 235 "duk_heap_stringcache.c"
                                        ;

  p_found = duk__scan_forwards(p_start, p_end, dist_start);
 } else {
  do { } while (0)
# 248 "duk_heap_stringcache.c"
                                        ;

  p_found = duk__scan_backwards(p_end, p_start, dist_end);
 }

scan_done:

 if (__builtin_expect((p_found == 
# 255 "duk_heap_stringcache.c" 3 4
    ((void *)0)
# 255 "duk_heap_stringcache.c"
    ), 0)) {




  goto scan_error;
 }

 do { } while (0);
 do { } while (0);
 byte_offset = (duk_uint32_t) (p_found - p_start);

 do { } while (0);






 if (use_cache) {

  if (!sce) {
   sce = heap->strcache + 4 - 1;
   sce->h = h;
  }
  do { } while (0);
  sce->bidx = (duk_uint32_t) (p_found - p_start);
  sce->cidx = (duk_uint32_t) char_offset;


  if (sce > &heap->strcache[0]) {






   duk_strcache_entry tmp;

   tmp = *sce;
   do { void *duk__dst = ((void *) (&heap->strcache[1])); const void *duk__src = ((const void *) (&heap->strcache[0])); duk_size_t duk__len = ((size_t) (((char *) sce) - ((char *) &heap->strcache[0]))); do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } while (0)

                                                                         ;
   heap->strcache[0] = tmp;


  }
# 313 "duk_heap_stringcache.c"
 }

 return byte_offset;

scan_error:
 do { duk_err_error_internal((thr), "duk_heap_stringcache.c", (duk_int_t) 318); } while (0);
 do { return 0; } while (0);
}
# 1 "duk_heap_stringtable.c"
# 143 "duk_heap_stringtable.c"
static duk_hstring *duk__strtable_alloc_hstring(duk_heap *heap,
                                                   const duk_uint8_t *str,
                                                   duk_uint32_t blen,
                                                   duk_uint32_t strhash,
                                                   const duk_uint8_t *extdata) {
 duk_hstring *res;
 const duk_uint8_t *data;




 do { } while (0);
 do { (void) (extdata); } while (0);
# 186 "duk_heap_stringtable.c"
 {
  duk_uint8_t *data_tmp;


  do { } while (0);
  res = (duk_hstring *) duk_heap_mem_alloc((heap), (sizeof(duk_hstring) + blen + 1));
  if (__builtin_expect((res == 
# 192 "duk_heap_stringtable.c" 3 4
     ((void *)0)
# 192 "duk_heap_stringtable.c"
     ), 0)) {
   goto alloc_error;
  }
  do { void *duk__dst = (res); duk_size_t duk__len = (sizeof(duk_hstring)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);



  do { (&res->hdr)->h_flags = ((0) &0x00000003UL) | ((0) &(~0x00000003UL)); } while (0);

  data_tmp = (duk_uint8_t *) (res + 1);
  do { void *duk__dst = (data_tmp); const void *duk__src = (str); duk_size_t duk__len = (blen); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
  data_tmp[blen] = (duk_uint8_t) 0;
  data = (const duk_uint8_t *) data_tmp;
 }

 do { (res)->blen = (blen); } while (0);
 do { (res)->hash = (strhash); } while (0);

 do { } while (0);

 res->arridx = duk_js_to_arrayindex_string(data, blen);
 if (res->arridx != (0xffffffffUL)) {







  do { do { } while (0); (&(res)->hdr)->h_flags |= ((1UL << (7 + (1)))); } while (0);
  do { do { } while (0); (&(res)->hdr)->h_flags |= ((1UL << (7 + (0)))); } while (0);
  do { } while (0);
 } else {




  if (__builtin_expect((data[0] >= 0x80U), 0)) {
   if (data[0] <= 0x81) {
    do { do { } while (0); (&(res)->hdr)->h_flags |= ((1UL << (7 + (2)))); } while (0);
   } else if (data[0] == 0x82U || data[0] == 0xffU) {
    do { do { } while (0); (&(res)->hdr)->h_flags |= ((1UL << (7 + (3)))); } while (0);
    do { do { } while (0); (&(res)->hdr)->h_flags |= ((1UL << (7 + (2)))); } while (0);
   }
  }







  do { } while (0);






 }

 do { } while (0)



                                                                     ;

 do { } while (0);
 return res;

alloc_error:
 return 
# 263 "duk_heap_stringtable.c" 3 4
       ((void *)0)
# 263 "duk_heap_stringtable.c"
           ;
}






static void duk__strtable_grow_inplace(duk_heap *heap) {
 duk_uint32_t new_st_size;
 duk_uint32_t old_st_size;
 duk_uint32_t i;
 duk_hstring *h;
 duk_hstring *next;
 duk_hstring *prev;




 duk_hstring **new_ptr;
 duk_hstring **new_ptr_high;


 do { } while (0);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);

 new_st_size = heap->st_size << 1U;
 do { } while (0);
# 309 "duk_heap_stringtable.c"
 new_ptr = (duk_hstring **) duk_heap_mem_realloc((heap), (heap->strtable), (sizeof(duk_hstring *) * new_st_size));

 if (__builtin_expect((new_ptr == 
# 311 "duk_heap_stringtable.c" 3 4
    ((void *)0)
# 311 "duk_heap_stringtable.c"
    ), 0)) {





  do { } while (0);
  return;
 }



 heap->strtable = new_ptr;







 old_st_size = heap->st_size;
 new_ptr_high = new_ptr + old_st_size;
 for (i = 0; i < old_st_size; i++) {
  duk_hstring *new_root;
  duk_hstring *new_root_high;

  h = (new_ptr[i]);
  new_root = h;
  new_root_high = 
# 339 "duk_heap_stringtable.c" 3 4
                 ((void *)0)
# 339 "duk_heap_stringtable.c"
                     ;

  prev = 
# 341 "duk_heap_stringtable.c" 3 4
        ((void *)0)
# 341 "duk_heap_stringtable.c"
            ;
  while (h != 
# 342 "duk_heap_stringtable.c" 3 4
             ((void *)0)
# 342 "duk_heap_stringtable.c"
                 ) {
   duk_uint32_t mask;

   do { } while (0);
   next = h->hdr.h_next;





   do { } while (0);
   mask = old_st_size;
   if (((h)->hash) & mask) {
    if (prev != 
# 355 "duk_heap_stringtable.c" 3 4
               ((void *)0)
# 355 "duk_heap_stringtable.c"
                   ) {
     prev->hdr.h_next = h->hdr.h_next;
    } else {
     do { } while (0);
     new_root = h->hdr.h_next;
    }

    h->hdr.h_next = new_root_high;
    new_root_high = h;
   } else {
    prev = h;
   }
   h = next;
  }

  new_ptr[i] = (new_root);
  new_ptr_high[i] = (new_root_high);
 }

 heap->st_size = new_st_size;
 heap->st_mask = new_st_size - 1;




}







static void duk__strtable_shrink_inplace(duk_heap *heap) {
 duk_uint32_t new_st_size;
 duk_uint32_t i;
 duk_hstring *h;
 duk_hstring *other;
 duk_hstring *root;





 duk_hstring **old_ptr;
 duk_hstring **old_ptr_high;
 duk_hstring **new_ptr;


 do { } while (0);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);

 new_st_size = heap->st_size >> 1U;




 old_ptr = ((heap)->strtable);
 old_ptr_high = old_ptr + new_st_size;
 for (i = 0; i < new_st_size; i++) {
  h = (old_ptr[i]);
  other = (old_ptr_high[i]);

  if (h == 
# 425 "duk_heap_stringtable.c" 3 4
          ((void *)0)
# 425 "duk_heap_stringtable.c"
              ) {

   root = other;
  } else {

   root = h;
   while (h->hdr.h_next != 
# 431 "duk_heap_stringtable.c" 3 4
                          ((void *)0)
# 431 "duk_heap_stringtable.c"
                              ) {
    h = h->hdr.h_next;
   }
   h->hdr.h_next = other;
  }

  old_ptr[i] = (root);
 }

 heap->st_size = new_st_size;
 heap->st_mask = new_st_size - 1;
# 458 "duk_heap_stringtable.c"
 new_ptr = (duk_hstring **) duk_heap_mem_realloc((heap), (heap->strtable), (sizeof(duk_hstring *) * new_st_size));
 do { } while (0);
 heap->strtable = new_ptr;





}







static __attribute__((cold)) __attribute__((noinline)) void duk__strtable_resize_check(duk_heap *heap) {
 duk_uint32_t load_factor;

 do { } while (0);



 do { } while (0);


 do { } while (0);


 if (__builtin_expect((heap->st_resizing != 0U), 0)) {
  do { } while (0);
  return;
 }

 heap->st_resizing = 1;

 do { } while (0);
 do { } while (0);
 load_factor = heap->st_count / (heap->st_size >> 4U);

 do { } while (0)



                                                                      ;

 if (load_factor >= 17) {
  if (heap->st_size >= 268435456L) {
   do { } while (0);
  } else {
   do { } while (0)

                                                       ;



   duk__strtable_grow_inplace(heap);
  }
 } else if (load_factor <= 6) {
  if (heap->st_size <= 1024) {
   do { } while (0);
  } else {
   do { } while (0)

                                                       ;



   duk__strtable_shrink_inplace(heap);
  }
 } else {
  do { } while (0);
 }

 heap->st_resizing = 0;
}
# 564 "duk_heap_stringtable.c"
static duk_hstring *duk__strtable_do_intern(duk_heap *heap, const duk_uint8_t *str, duk_uint32_t blen, duk_uint32_t strhash) {
 duk_hstring *res;
 const duk_uint8_t *extdata;



 duk_hstring **slot;


 do { } while (0)






                                                                        ;

 do { } while (0);
# 594 "duk_heap_stringtable.c"
 heap->pf_prevent_count++;
 do { } while (0);
# 614 "duk_heap_stringtable.c"
 if (__builtin_expect(((heap->st_count & 255) == 0), 0)) {
  duk__strtable_resize_check(heap);
 }
# 625 "duk_heap_stringtable.c"
 extdata = (const duk_uint8_t *) 
# 625 "duk_heap_stringtable.c" 3 4
                                ((void *)0)
# 625 "duk_heap_stringtable.c"
                                    ;
# 635 "duk_heap_stringtable.c"
 res = duk__strtable_alloc_hstring(heap, str, blen, strhash, extdata);




 do { } while (0);
 heap->pf_prevent_count--;



 if (__builtin_expect((res == 
# 645 "duk_heap_stringtable.c" 3 4
    ((void *)0)
# 645 "duk_heap_stringtable.c"
    ), 0)) {





  return 
# 651 "duk_heap_stringtable.c" 3 4
        ((void *)0)
# 651 "duk_heap_stringtable.c"
            ;
 }






 slot = heap->strtable + (strhash & heap->st_mask);

 do { } while (0);
 res->hdr.h_next = (*slot);
 *slot = (res);




 heap->st_count++;
# 677 "duk_heap_stringtable.c"
 return res;
}
# 723 "duk_heap_stringtable.c"
static __attribute__ ((unused)) duk_hstring *duk_heap_strtable_intern(duk_heap *heap, const duk_uint8_t *str, duk_uint32_t blen) {
 duk_uint32_t strhash;
 duk_hstring *h;

 do { } while (0);




 do { } while (0);
 do { } while (0);
 do { } while (0);
 strhash = duk_heap_hashstring(heap, str, (duk_size_t) blen);



 do { } while (0);
 do { } while (0);
 do { } while (0);



 h = heap->strtable[strhash & heap->st_mask];

 while (h != 
# 747 "duk_heap_stringtable.c" 3 4
            ((void *)0)
# 747 "duk_heap_stringtable.c"
                ) {
  if (((h)->hash) == strhash && ((h)->blen) == blen &&
      duk_memcmp_unsafe((const void *) str, (const void *) ((const duk_uint8_t *) ((h) + 1)), (size_t) blen) == 0) {

   do { } while (0);
   return h;
  }
  h = h->hdr.h_next;
 }
# 772 "duk_heap_stringtable.c"
 do { } while (0);
 h = duk__strtable_do_intern(heap, str, blen, strhash);
 return h;
}
# 785 "duk_heap_stringtable.c"
static __attribute__ ((unused)) duk_hstring *duk_heap_strtable_intern_u32(duk_heap *heap, duk_uint32_t val) {
 duk_uint8_t buf[10];
 duk_uint8_t *p;

 do { } while (0);


 p = buf + sizeof(buf);
 do {
  p--;
  *p = duk_lc_digits[val % 10];
  val = val / 10;
 } while (val != 0);
 do { } while (0);

 return duk_heap_strtable_intern(heap, (const duk_uint8_t *) p, (duk_uint32_t) ((buf + sizeof(buf)) - p));
}
# 812 "duk_heap_stringtable.c"
static __attribute__ ((unused)) duk_hstring *duk_heap_strtable_intern_checked(duk_hthread *thr, const duk_uint8_t *str, duk_uint32_t blen) {
 duk_hstring *res;

 do { } while (0);
 do { } while (0);
 do { } while (0);

 res = duk_heap_strtable_intern(thr->heap, str, blen);
 if (__builtin_expect((res == 
# 820 "duk_heap_stringtable.c" 3 4
    ((void *)0)
# 820 "duk_heap_stringtable.c"
    ), 0)) {
  do { duk_err_error_alloc_failed((thr), "duk_heap_stringtable.c", (duk_int_t) 821); } while (0);
  do { return 
# 822 "duk_heap_stringtable.c" 3 4
 ((void *)0)
# 822 "duk_heap_stringtable.c"
 ; } while (0);
 }
 return res;
}


static duk_uint_t duk__strtable_litcache_key(const duk_uint8_t *str, duk_uint32_t blen) {
 duk_uintptr_t key;

 do { } while (0);
 do { } while (0);

 key = (duk_uintptr_t) blen ^ (duk_uintptr_t) str;
 key &= (duk_uintptr_t) (256 - 1);

 do { } while (0);
 return (duk_uint_t) key;
}

static __attribute__ ((unused)) duk_hstring *duk_heap_strtable_intern_literal_checked(duk_hthread *thr, const duk_uint8_t *str, duk_uint32_t blen) {
 duk_uint_t key;
 duk_litcache_entry *ent;
 duk_hstring *h;


 key = duk__strtable_litcache_key(str, blen);
 ent = thr->heap->litcache + key;
 if (ent->addr == str) {
  do { } while (0)


                                             ;
  do { } while (0);
  do { } while (0);
  do { } while (0);
  return ent->h;
 }


 h = duk_heap_strtable_intern_checked(thr, str, blen);
 ent->addr = str;
 ent->h = h;
 do { } while (0);
# 873 "duk_heap_stringtable.c"
 if (!(((&(h)->hdr)->h_flags & ((1UL << (7 + (8))))) != 0)) {
  do { } while (0);
  do { } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  do { do { } while (0); (&(h)->hdr)->h_flags |= ((1UL << (7 + (8)))); } while (0);
  do { } while (0);
 }

 return h;
}


static __attribute__ ((unused)) duk_hstring *duk_heap_strtable_intern_u32_checked(duk_hthread *thr, duk_uint32_t val) {
 duk_hstring *res;

 do { } while (0);
 do { } while (0);

 res = duk_heap_strtable_intern_u32(thr->heap, val);
 if (__builtin_expect((res == 
# 892 "duk_heap_stringtable.c" 3 4
    ((void *)0)
# 892 "duk_heap_stringtable.c"
    ), 0)) {
  do { duk_err_error_alloc_failed((thr), "duk_heap_stringtable.c", (duk_int_t) 893); } while (0);
  do { return 
# 894 "duk_heap_stringtable.c" 3 4
 ((void *)0)
# 894 "duk_heap_stringtable.c"
 ; } while (0);
 }
 return res;
}
# 908 "duk_heap_stringtable.c"
static __attribute__ ((unused)) void duk_heap_strtable_unlink(duk_heap *heap, duk_hstring *h) {



 duk_hstring **slot;

 duk_hstring *other;
 duk_hstring *prev;

 do { } while (0)



                                                                                 ;

 do { } while (0);
 do { } while (0);


 do { } while (0);
 heap->st_count--;





 slot = heap->strtable + (((h)->hash) & heap->st_mask);

 other = (*slot);
 do { } while (0);

 prev = 
# 939 "duk_heap_stringtable.c" 3 4
       ((void *)0)
# 939 "duk_heap_stringtable.c"
           ;
 while (other != h) {
  prev = other;
  other = other->hdr.h_next;
  do { } while (0);
 }
 if (prev != 
# 945 "duk_heap_stringtable.c" 3 4
            ((void *)0)
# 945 "duk_heap_stringtable.c"
                ) {

  prev->hdr.h_next = h->hdr.h_next;
 } else {

  *slot = (h->hdr.h_next);
 }




}



static __attribute__ ((unused)) void duk_heap_strtable_unlink_prev(duk_heap *heap, duk_hstring *h, duk_hstring *prev) {



 duk_hstring **slot;


 do { } while (0)




                                                                                 ;

 do { } while (0);
 do { } while (0);
 do { } while (0);


 do { } while (0);
 heap->st_count--;


 if (prev != 
# 983 "duk_heap_stringtable.c" 3 4
            ((void *)0)
# 983 "duk_heap_stringtable.c"
                ) {

  prev->hdr.h_next = h->hdr.h_next;
 } else {




  slot = heap->strtable + (((h)->hash) & heap->st_mask);

  do { } while (0);
  *slot = (h->hdr.h_next);
 }
}





static __attribute__ ((unused)) void duk_heap_strtable_force_resize(duk_heap *heap) {




 do { } while (0);
 do { (void) (heap); } while (0);





 if (heap->strtable != 
# 1014 "duk_heap_stringtable.c" 3 4
                      ((void *)0)
# 1014 "duk_heap_stringtable.c"
                          ) {

  duk__strtable_resize_check(heap);
 }

}





static __attribute__ ((unused)) void duk_heap_strtable_free(duk_heap *heap) {




 duk_hstring **strtable;
 duk_hstring **st;

 duk_hstring *h;

 do { } while (0);
# 1045 "duk_heap_stringtable.c"
 strtable = ((heap)->strtable);
 st = strtable + heap->st_size;
 do { } while (0);

 while (strtable != st) {
  --st;
  h = (*st);
  while (h) {
   duk_hstring *h_next;
   h_next = h->hdr.h_next;


   duk_free_hstring(heap, h);

   h = h_next;
  }
 }

 duk_heap_mem_free((heap), (strtable));
}
# 1 "duk_heaphdr_assert.c"
# 1 "duk_hobject_alloc.c"
# 19 "duk_hobject_alloc.c"
static void duk__init_object_parts(duk_heap *heap, duk_uint_t hobject_flags, duk_hobject *obj) {
 do { } while (0);


 obj->hdr.h_flags = hobject_flags | 1;
 do { } while (0);
# 37 "duk_hobject_alloc.c"
 do { } while (0);
 duk_heap_insert_into_heap_allocated((heap), (&obj->hdr));






}

static void *duk__hobject_alloc_init(duk_hthread *thr, duk_uint_t hobject_flags, duk_size_t size) {
 void *res;

 res = (void *) duk_heap_mem_alloc_checked_zeroed((thr), (size));
 do { } while (0);
 duk__init_object_parts(thr->heap, hobject_flags, (duk_hobject *) res);
 return res;
}
# 67 "duk_hobject_alloc.c"
static __attribute__ ((unused)) duk_hobject *duk_hobject_alloc_unchecked(duk_heap *heap, duk_uint_t hobject_flags) {
 duk_hobject *res;

 do { } while (0);


 do { } while (0);
 do { } while (0);
 do { } while (0);

 res = (duk_hobject *) duk_heap_mem_alloc_zeroed((heap), (sizeof(duk_hobject)));
 if (__builtin_expect((res == 
# 78 "duk_hobject_alloc.c" 3 4
    ((void *)0)
# 78 "duk_hobject_alloc.c"
    ), 0)) {
  return 
# 79 "duk_hobject_alloc.c" 3 4
        ((void *)0)
# 79 "duk_hobject_alloc.c"
            ;
 }
 do { } while (0);

 duk__init_object_parts(heap, hobject_flags, res);

 do { } while (0);
 return res;
}

static __attribute__ ((unused)) duk_hobject *duk_hobject_alloc(duk_hthread *thr, duk_uint_t hobject_flags) {
 duk_hobject *res;

 res = (duk_hobject *) duk__hobject_alloc_init(thr, hobject_flags, sizeof(duk_hobject));
 return res;
}

static __attribute__ ((unused)) duk_hcompfunc *duk_hcompfunc_alloc(duk_hthread *thr, duk_uint_t hobject_flags) {
 duk_hcompfunc *res;

 res = (duk_hcompfunc *) duk__hobject_alloc_init(thr, hobject_flags, sizeof(duk_hcompfunc));
# 112 "duk_hobject_alloc.c"
 return res;
}

static __attribute__ ((unused)) duk_hnatfunc *duk_hnatfunc_alloc(duk_hthread *thr, duk_uint_t hobject_flags) {
 duk_hnatfunc *res;

 res = (duk_hnatfunc *) duk__hobject_alloc_init(thr, hobject_flags, sizeof(duk_hnatfunc));




 return res;
}

static __attribute__ ((unused)) duk_hboundfunc *duk_hboundfunc_alloc(duk_heap *heap, duk_uint_t hobject_flags) {
 duk_hboundfunc *res;

 res = (duk_hboundfunc *) duk_heap_mem_alloc((heap), (sizeof(duk_hboundfunc)));
 if (!res) {
  return 
# 131 "duk_hobject_alloc.c" 3 4
        ((void *)0)
# 131 "duk_hobject_alloc.c"
            ;
 }
 do { void *duk__dst = (res); duk_size_t duk__len = (sizeof(duk_hboundfunc)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);

 duk__init_object_parts(heap, hobject_flags, &res->obj);

 do { duk_tval *duk__tv; duk__tv = (&res->target); duk__tv->t = 2; } while (0);
 do { duk_tval *duk__tv; duk__tv = (&res->this_binding); duk__tv->t = 2; } while (0);





 return res;
}


static __attribute__ ((unused)) duk_hbufobj *duk_hbufobj_alloc(duk_hthread *thr, duk_uint_t hobject_flags) {
 duk_hbufobj *res;

 res = (duk_hbufobj *) duk__hobject_alloc_init(thr, hobject_flags, sizeof(duk_hbufobj));





 do { } while (0);
 return res;
}
# 168 "duk_hobject_alloc.c"
static __attribute__ ((unused)) duk_hthread *duk_hthread_alloc_unchecked(duk_heap *heap, duk_uint_t hobject_flags) {
 duk_hthread *res;

 res = (duk_hthread *) duk_heap_mem_alloc((heap), (sizeof(duk_hthread)));
 if (__builtin_expect((res == 
# 172 "duk_hobject_alloc.c" 3 4
    ((void *)0)
# 172 "duk_hobject_alloc.c"
    ), 0)) {
  return 
# 173 "duk_hobject_alloc.c" 3 4
        ((void *)0)
# 173 "duk_hobject_alloc.c"
            ;
 }
 do { void *duk__dst = (res); duk_size_t duk__len = (sizeof(duk_hthread)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);

 duk__init_object_parts(heap, hobject_flags, &res->obj);
# 203 "duk_hobject_alloc.c"
 do { } while (0);

 res->heap = heap;


 return res;
}

static __attribute__ ((unused)) duk_hthread *duk_hthread_alloc(duk_hthread *thr, duk_uint_t hobject_flags) {
 duk_hthread *res;

 res = duk_hthread_alloc_unchecked(thr->heap, hobject_flags);
 if (res == 
# 215 "duk_hobject_alloc.c" 3 4
           ((void *)0)
# 215 "duk_hobject_alloc.c"
               ) {
  do { duk_err_error_alloc_failed((thr), "duk_hobject_alloc.c", (duk_int_t) 216); } while (0);
  do { return 
# 217 "duk_hobject_alloc.c" 3 4
 ((void *)0)
# 217 "duk_hobject_alloc.c"
 ; } while (0);
 }
 return res;
}

static __attribute__ ((unused)) duk_harray *duk_harray_alloc(duk_hthread *thr, duk_uint_t hobject_flags) {
 duk_harray *res;

 res = (duk_harray *) duk__hobject_alloc_init(thr, hobject_flags, sizeof(duk_harray));

 do { } while (0);

 return res;
}

static __attribute__ ((unused)) duk_hdecenv *duk_hdecenv_alloc(duk_hthread *thr, duk_uint_t hobject_flags) {
 duk_hdecenv *res;

 res = (duk_hdecenv *) duk__hobject_alloc_init(thr, hobject_flags, sizeof(duk_hdecenv));





 do { } while (0);
 do { } while (0);
 do { } while (0);

 return res;
}

static __attribute__ ((unused)) duk_hobjenv *duk_hobjenv_alloc(duk_hthread *thr, duk_uint_t hobject_flags) {
 duk_hobjenv *res;

 res = (duk_hobjenv *) duk__hobject_alloc_init(thr, hobject_flags, sizeof(duk_hobjenv));




 do { } while (0);

 return res;
}

static __attribute__ ((unused)) duk_hproxy *duk_hproxy_alloc(duk_hthread *thr, duk_uint_t hobject_flags) {
 duk_hproxy *res;

 res = (duk_hproxy *) duk__hobject_alloc_init(thr, hobject_flags, sizeof(duk_hproxy));





 return res;
}
# 1 "duk_hobject_assert.c"
# 1 "duk_hobject_enum.c"
# 63 "duk_hobject_enum.c"
typedef duk_uint64_t duk__sort_key_t;





static duk__sort_key_t duk__hstring_sort_key(duk_hstring *x) {
 duk__sort_key_t val;







 do { } while (0);
 do { } while (0);

 val = (duk__sort_key_t) ((x)->arridx);


 val = val + (duk__sort_key_t) ((((duk_heaphdr *) x)->h_flags) & (1UL << (7 + (2))));


 return (duk__sort_key_t) val;
}


static duk_bool_t duk__sort_compare_es6(duk_hstring *a, duk_hstring *b, duk__sort_key_t val_b) {
 duk__sort_key_t val_a;

 do { } while (0);
 do { } while (0);
 do { (void) (b); } while (0);

 val_a = duk__hstring_sort_key(a);

 if (val_a > val_b) {
  return 0;
 } else {
  return 1;
 }
}

static void duk__sort_enum_keys_es6(duk_hthread *thr, duk_hobject *h_obj, duk_int_fast32_t idx_start, duk_int_fast32_t idx_end) {
 duk_hstring **keys;
 duk_int_fast32_t idx;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);

 if (idx_end <= idx_start + 1) {
  return;
 }

 keys = ((duk_hstring **) (void *) ((((h_obj))->props) + (((h_obj))->e_size) * sizeof(duk_propvalue)));

 for (idx = idx_start + 1; idx < idx_end; idx++) {
  duk_hstring *h_curr;
  duk_int_fast32_t idx_insert;
  duk__sort_key_t val_curr;

  h_curr = keys[idx];
  do { } while (0);






  val_curr = duk__hstring_sort_key(h_curr);
  for (idx_insert = idx - 1; idx_insert >= idx_start; idx_insert--) {
   duk_hstring *h_insert;
   h_insert = keys[idx_insert];
   do { } while (0);

   if (duk__sort_compare_es6(h_insert, h_curr, val_curr)) {
    break;
   }
  }



  idx_insert++;
  do { } while (0);
# 161 "duk_hobject_enum.c"
  if (idx != idx_insert) {
   do { void *duk__dst = ((void *) (keys + idx_insert + 1)); const void *duk__src = ((const void *) (keys + idx_insert)); duk_size_t duk__len = (((size_t) (idx - idx_insert) * sizeof(duk_hstring *))); do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } while (0)

                                                                     ;
   keys[idx_insert] = h_curr;
  }
 }






 duk_hobject_resize_entrypart(thr, h_obj, ((h_obj)->e_size));
}
# 186 "duk_hobject_enum.c"
static void duk__add_enum_key(duk_hthread *thr, duk_hstring *k) {



 duk_push_hstring(thr, k);
 duk_push_true(thr);
 duk_put_prop(thr, -3);
}

static void duk__add_enum_key_stridx(duk_hthread *thr, duk_small_uint_t stridx) {
 duk__add_enum_key(thr, ((thr)->strs[(stridx)]));
}

static __attribute__ ((unused)) void duk_hobject_enumerator_create(duk_hthread *thr, duk_small_uint_t enum_flags) {
 duk_hobject *enum_target;
 duk_hobject *curr;
 duk_hobject *res;

 duk_hobject *h_proxy_target;
 duk_hobject *h_proxy_handler;
 duk_hobject *h_trap_result;

 duk_uint_fast32_t i, len;
 duk_uint_fast32_t sort_start_index;

 do { } while (0);

 enum_target = duk_require_hobject(thr, -1);
 do { } while (0);

 duk_push_bare_object(thr);
 res = duk_known_hobject(thr, -1);
# 226 "duk_hobject_enum.c"
 duk_push_hobject(thr, enum_target);
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (96))));


 duk_push_int(thr, 2);
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (97))));






 if (__builtin_expect(((enum_flags & (1U << 7)) != 0), 1)) {
  goto skip_proxy;
 }
 if (__builtin_expect((!duk_hobject_proxy_check(enum_target, &h_proxy_target, &h_proxy_handler)), 1)) {
  goto skip_proxy;
 }






 do { } while (0);
 duk_push_hobject(thr, h_proxy_handler);
 if (!(((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (75))))) {





  do { } while (0);
  do { } while (0);
  enum_target = h_proxy_target;

  duk_push_hobject(thr, enum_target);
  (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-4)) << 16) + ((duk_uint_t) (96))));

  duk_pop_2(thr);
  goto skip_proxy;
 }


 duk_insert(thr, -2);
 duk_push_hobject(thr, h_proxy_target);
 duk_call_method(thr, 1 );
 h_trap_result = duk_require_hobject(thr, -1);
 do { (void) (h_trap_result); } while (0);

 duk_proxy_ownkeys_postprocess(thr, h_proxy_target, enum_flags);




 do { } while (0);
 len = (duk_uint_fast32_t) duk_get_length(thr, -1);
 for (i = 0; i < len; i++) {
  (void) duk_get_prop_index(thr, -1, (duk_uarridx_t) i);
  do { } while (0);

  duk_push_true(thr);

  duk_put_prop(thr, -5);
 }

 duk_pop_2(thr);
 duk_remove_m2(thr);
# 303 "duk_hobject_enum.c"
 do { } while (0);
 goto compact_and_return;

skip_proxy:


 curr = enum_target;
 sort_start_index = 2;
 do { } while (0);
 while (curr) {
  duk_uint_fast32_t sort_end_index;

  duk_bool_t need_sort = 0;

  duk_bool_t cond;
# 344 "duk_hobject_enum.c"
  cond = (((&(curr)->hdr)->h_flags & ((1UL << (7 + (16))))) != 0) || (((&(curr)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0);



  cond = cond && !(enum_flags & (1U << 3));
  if (cond) {
   duk_bool_t have_length = 1;




   if ((((&(curr)->hdr)->h_flags & ((1UL << (7 + (16))))) != 0)) {
    duk_hstring *h_val;
    h_val = duk_hobject_get_internal_value_string(thr->heap, curr);
    do { } while (0);
    len = (duk_uint_fast32_t) duk_hstring_get_charlen((h_val));
   }

   else {
    duk_hbufobj *h_bufobj;
    do { } while (0);
    h_bufobj = (duk_hbufobj *) curr;

    if (h_bufobj == 
# 367 "duk_hobject_enum.c" 3 4
                   ((void *)0) 
# 367 "duk_hobject_enum.c"
                        || !h_bufobj->is_typedarray) {




     len = 0;
     have_length = 0;
    } else {



     len = (duk_uint_fast32_t) (h_bufobj->length >> h_bufobj->shift);
    }
   }


   for (i = 0; i < len; i++) {
    duk_hstring *k;




    k = duk_heap_strtable_intern_u32_checked(thr, (duk_uint32_t) i);
    do { } while (0);

    duk__add_enum_key(thr, k);


   }






   if (have_length && (enum_flags & (1U << 0))) {
    duk__add_enum_key_stridx(thr, 87);
   }
  }





  cond = !(enum_flags & (1U << 3));
  if (cond) {
   for (i = 0; i < (duk_uint_fast32_t) ((curr)->a_size); i++) {
    duk_hstring *k;
    duk_tval *tv;

    tv = (&((duk_tval *) (void *) (((((curr)))->props) + ((((curr)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((curr)))->e_size))) & 0x07)))[(i)]);
    if (((tv)->t == 7)) {
     continue;
    }
    k = duk_heap_strtable_intern_u32_checked(thr, (duk_uint32_t) i);
    do { } while (0);

    duk__add_enum_key(thr, k);


   }

   if ((((&(curr)->hdr)->h_flags & ((1UL << (7 + (15))))) != 0)) {

    if (enum_flags & (1U << 0)) {
     duk__add_enum_key_stridx(thr, 87);
    }
   }
  }





  for (i = 0; i < (duk_uint_fast32_t) ((curr)->e_next); i++) {
   duk_hstring *k;

   k = (((duk_hstring **) (void *) (((((curr)))->props) + ((((curr)))->e_size) * sizeof(duk_propvalue)))[(i)]);
   if (!k) {
    continue;
   }
   if (!(enum_flags & (1U << 0)) &&
       !(((((duk_uint8_t *) (void *) ((((((curr))))->props) + (((((curr))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))[((i))]) & (1U << 1)) != 0)) {
    continue;
   }
   if (__builtin_expect(((((&(k)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
    if (!(enum_flags & (1U << 1)) && (((&(k)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0)) {
     continue;
    }
    if (!(enum_flags & (1U << 2))) {
     continue;
    }

    need_sort = 1;

   } else {
    do { } while (0);
    if (enum_flags & (1U << 3)) {
     continue;
    }
   }
   if ((((&(k)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0)) {





    need_sort = 1;

   } else {
    if (enum_flags & (1U << 5)) {
     continue;
    }
   }

   do { } while (0)
                                                                                       ;

   duk__add_enum_key(thr, k);


  }
# 504 "duk_hobject_enum.c"
  sort_end_index = ((res)->e_next);

  if (!(enum_flags & (1U << 6))) {



   if (need_sort) {
    do { } while (0);
    duk__sort_enum_keys_es6(thr,
                            res,
                            (duk_int_fast32_t) sort_start_index,
                            (duk_int_fast32_t) sort_end_index);
   } else {
    do { } while (0);
   }

  }

  sort_start_index = sort_end_index;

  if (enum_flags & (1U << 4)) {
   break;
  }

  curr = ((curr)->prototype);
 }



 duk_remove_m2(thr);



 if (enum_flags & (1U << 6)) {
# 548 "duk_hobject_enum.c"
  duk__sort_enum_keys_es6(thr,
                          res,
                          (duk_int_fast32_t) 2,
                          (duk_int_fast32_t) ((res)->e_next));
 }


compact_and_return:


 duk_hobject_compact_props(thr, res);

 do { } while (0);
}
# 571 "duk_hobject_enum.c"
static __attribute__ ((unused)) duk_bool_t duk_hobject_enumerator_next(duk_hthread *thr, duk_bool_t get_value) {
 duk_hobject *e;
 duk_hobject *enum_target;
 duk_hstring *res = 
# 574 "duk_hobject_enum.c" 3 4
                   ((void *)0)
# 574 "duk_hobject_enum.c"
                       ;
 duk_uint_fast32_t idx;
 duk_bool_t check_existence;

 do { } while (0);



 e = duk_require_hobject(thr, -1);


 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (97))));
 idx = (duk_uint_fast32_t) duk_require_uint(thr, -1);
 duk_pop(thr);
 do { } while (0);






 (((void) 0), ((void) 0), duk_xget_owndataprop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (96))));
 enum_target = duk_require_hobject(thr, -1);
 do { } while (0);

 check_existence = (!(((&((enum_target))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0));



 duk_pop(thr);

 do { } while (0)

                                                          ;


 for (;;) {
  duk_hstring *k;

  if (idx >= ((e)->e_next)) {
   do { } while (0);
   break;
  }


  k = (((duk_hstring **) (void *) (((((e)))->props) + ((((e)))->e_size) * sizeof(duk_propvalue)))[(idx)]);
  do { } while (0);
  do { } while (0);
  do { } while (0);

  idx++;


  if (check_existence && !duk_hobject_hasprop_raw(thr, enum_target, k)) {
   do { } while (0);
   continue;
  }

  do { } while (0);
  res = k;
  break;
 }

 do { } while (0);

 duk_push_uint((thr), (duk_uint_t) ((duk_uint32_t) idx));
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (97))));



 if (res) {
  duk_push_hstring(thr, res);
  if (get_value) {
   duk_push_hobject(thr, enum_target);
   duk_dup_m2(thr);
   duk_get_prop(thr, -2);
   duk_remove_m2(thr);
   duk_remove(thr, -3);
  } else {
   duk_remove_m2(thr);
  }
  return 1;
 } else {
  duk_pop(thr);
  return 0;
 }
}






static __attribute__ ((unused)) duk_ret_t duk_hobject_get_enumerated_keys(duk_hthread *thr, duk_small_uint_t enum_flags) {
 duk_hobject *e;
 duk_hstring **keys;
 duk_tval *tv;
 duk_uint_fast32_t count;

 do { } while (0);
 do { } while (0);






 duk_hobject_enumerator_create(thr, enum_flags);
 e = duk_known_hobject(thr, -1);




 do { } while (0);
 count = (duk_uint32_t) (((e)->e_next) - 2);


 tv = duk_push_harray_with_size_outptr(thr, (duk_uint32_t) count);
 do { } while (0);
 do { } while (0);



 keys = ((duk_hstring **) (void *) ((((e))->props) + (((e))->e_size) * sizeof(duk_propvalue)));
 keys += 2;

 while (count-- > 0) {
  duk_hstring *k;

  k = *keys++;
  do { } while (0);

  do { duk_tval *duk__tv; duk__tv = (tv); duk__tv->t = 8; duk__tv->v.hstring = (k); } while (0);
  tv++;
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (k))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 }


 duk_remove_m2(thr);



 return 1;
}
# 1 "duk_hobject_misc.c"






static __attribute__ ((unused)) duk_bool_t duk_hobject_prototype_chain_contains(duk_hthread *thr,
                                                             duk_hobject *h,
                                                             duk_hobject *p,
                                                             duk_bool_t ignore_loop) {
 duk_uint_t sanity;

 do { } while (0);




 if (h == 
# 18 "duk_hobject_misc.c" 3 4
         ((void *)0) 
# 18 "duk_hobject_misc.c"
              || p == 
# 18 "duk_hobject_misc.c" 3 4
                      ((void *)0)
# 18 "duk_hobject_misc.c"
                          ) {
  return 0;
 }

 sanity = 10000L;
 do {
  if (h == p) {
   return 1;
  }

  if (sanity-- == 0) {
   if (ignore_loop) {
    break;
   } else {
    do { duk_err_range((thr), "duk_hobject_misc.c", (duk_int_t) 32, ("prototype chain limit")); } while (0);
    do { return 0; } while (0);
   }
  }
  h = ((h)->prototype);
 } while (h);

 return 0;
}

static __attribute__ ((unused)) void duk_hobject_set_prototype_updref(duk_hthread *thr, duk_hobject *h, duk_hobject *p) {

 duk_hobject *tmp;

 do { } while (0);
 tmp = ((h)->prototype);
 do { (h)->prototype = (p); } while (0);
 do { if ((p) != 
# 49 "duk_hobject_misc.c" 3 4
((void *)0)
# 49 "duk_hobject_misc.c"
) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((p)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0);
 do { if ((tmp) != 
# 50 "duk_hobject_misc.c" 3 4
((void *)0)
# 50 "duk_hobject_misc.c"
) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((tmp))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);





}
# 1 "duk_hobject_pc2line.c"
# 15 "duk_hobject_pc2line.c"
static __attribute__ ((unused)) void duk_hobject_pc2line_pack(duk_hthread *thr, duk_compiler_instr *instrs, duk_uint_fast32_t length) {
 duk_hbuffer_dynamic *h_buf;
 duk_bitencoder_ctx be_ctx_alloc;
 duk_bitencoder_ctx *be_ctx = &be_ctx_alloc;
 duk_uint32_t *hdr;
 duk_size_t new_size;
 duk_uint_fast32_t num_header_entries;
 duk_uint_fast32_t curr_offset;
 duk_int_fast32_t curr_line, next_line, diff_line;
 duk_uint_fast32_t curr_pc;
 duk_uint_fast32_t hdr_index;

 do { } while (0);

 num_header_entries = (length + 64 - 1) / 64;
 curr_offset = (duk_uint_fast32_t) (sizeof(duk_uint32_t) + num_header_entries * sizeof(duk_uint32_t) * 2);

 duk_push_buffer_raw((thr), ((duk_size_t) curr_offset), (1 << 0) );
 h_buf = (duk_hbuffer_dynamic *) duk_known_hbuffer(thr, -1);
 do { } while (0);

 hdr = (duk_uint32_t *) ((h_buf)->curr_alloc);
 do { } while (0);
 hdr[0] = (duk_uint32_t) length;

 curr_pc = 0U;
 while (curr_pc < length) {
  new_size = (duk_size_t) (curr_offset + (((64 - 1) * 35 + 7) / 8));
  duk_hbuffer_resize(thr, h_buf, new_size);

  hdr = (duk_uint32_t *) ((h_buf)->curr_alloc);
  do { } while (0);
  do { } while (0);
  hdr_index = 1 + (curr_pc / 64) * 2;
  curr_line = (duk_int_fast32_t) instrs[curr_pc].line;
  hdr[hdr_index + 0] = (duk_uint32_t) curr_line;
  hdr[hdr_index + 1] = (duk_uint32_t) curr_offset;
# 61 "duk_hobject_pc2line.c"
  do { void *duk__dst = (be_ctx); duk_size_t duk__len = (sizeof(*be_ctx)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
  be_ctx->data = ((duk_uint8_t *) hdr) + curr_offset;
  be_ctx->length = (duk_size_t) (((64 - 1) * 35 + 7) / 8);

  for (;;) {
   curr_pc++;
   if (((curr_pc % 64) == 0) ||
       (curr_pc >= length)) {
    break;
   }
   do { } while (0);
   next_line = (duk_int32_t) instrs[curr_pc].line;
   diff_line = next_line - curr_line;






   if (diff_line == 0) {

    duk_be_encode(be_ctx, 0, 1);
   } else if (diff_line >= 1 && diff_line <= 4) {

    duk_be_encode(be_ctx, (duk_uint32_t) ((0x02 << 2) + (diff_line - 1)), 4);
   } else if (diff_line >= -0x80 && diff_line <= 0x7f) {

    do { } while (0);
    duk_be_encode(be_ctx, (duk_uint32_t) ((0x06 << 8) + (diff_line + 0x80)), 11);
   } else {



    duk_be_encode(be_ctx, (duk_uint32_t) ((0x07 << 16) + ((next_line >> 16) & 0xffff)), 19);
    duk_be_encode(be_ctx, (duk_uint32_t) (next_line & 0xffff), 16);
   }

   curr_line = next_line;
  }

  duk_be_finish(be_ctx);
  do { } while (0);


  curr_offset += (duk_uint_fast32_t) be_ctx->offset;
 }


 new_size = (duk_size_t) curr_offset;
 duk_hbuffer_resize(thr, h_buf, new_size);

 (void) duk_to_buffer_raw((thr), (-1), (
# 112 "duk_hobject_pc2line.c" 3 4
       ((void *)0)
# 112 "duk_hobject_pc2line.c"
       ), 0);

 do { } while (0)



                                                          ;
}





static duk_uint_fast32_t duk__hobject_pc2line_query_raw(duk_hthread *thr, duk_hbuffer_fixed *buf, duk_uint_fast32_t pc) {
 duk_bitdecoder_ctx bd_ctx_alloc;
 duk_bitdecoder_ctx *bd_ctx = &bd_ctx_alloc;
 duk_uint32_t *hdr;
 duk_uint_fast32_t start_offset;
 duk_uint_fast32_t pc_limit;
 duk_uint_fast32_t hdr_index;
 duk_uint_fast32_t pc_base;
 duk_uint_fast32_t n;
 duk_uint_fast32_t curr_line;

 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);





 hdr_index = pc / 64;
 pc_base = hdr_index * 64;
 n = pc - pc_base;

 if ((((duk_hbuffer *) ((duk_hbuffer *) (buf)))->size) <= sizeof(duk_uint32_t)) {
  do { } while (0);
  goto pc2line_error;
 }

 hdr = (duk_uint32_t *) (void *) ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) (buf)) + 1));
 pc_limit = hdr[0];
 if (pc >= pc_limit) {

  do { } while (0);
  goto pc2line_error;
 }

 curr_line = hdr[1 + hdr_index * 2];
 start_offset = hdr[1 + hdr_index * 2 + 1];
 if ((duk_size_t) start_offset > (((duk_hbuffer *) ((duk_hbuffer *) (buf)))->size)) {
  do { } while (0)

                                                                       ;
  goto pc2line_error;
 }





 do { void *duk__dst = (bd_ctx); duk_size_t duk__len = (sizeof(*bd_ctx)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 bd_ctx->data = ((duk_uint8_t *) hdr) + start_offset;
 bd_ctx->length = (duk_size_t) ((((duk_hbuffer *) ((duk_hbuffer *) (buf)))->size) - start_offset);






 while (n > 0) {




  if (duk_bd_decode_flag(bd_ctx)) {
   if (duk_bd_decode_flag(bd_ctx)) {
    if (duk_bd_decode_flag(bd_ctx)) {

     duk_uint_fast32_t t;
     t = duk_bd_decode(bd_ctx, 16);
     t = (t << 16) + duk_bd_decode(bd_ctx, 16);
     curr_line = t;
    } else {

     duk_uint_fast32_t t;
     t = duk_bd_decode(bd_ctx, 8);
     curr_line = curr_line + t - 0x80;
    }
   } else {

    duk_uint_fast32_t t;
    t = duk_bd_decode(bd_ctx, 2);
    curr_line = curr_line + t + 1;
   }
  } else {

  }

  n--;
 }

 do { } while (0);
 return curr_line;

pc2line_error:
 do { } while (0);
 return 0;
}

static __attribute__ ((unused)) duk_uint_fast32_t duk_hobject_pc2line_query(duk_hthread *thr, duk_idx_t idx_func, duk_uint_fast32_t pc) {
 duk_hbuffer_fixed *pc2line;
 duk_uint_fast32_t line;







 (((void) 0), ((void) 0), duk_xget_owndataprop_stridx_short_raw((thr), (((duk_uint_t) (idx_func)) << 16) + ((duk_uint_t) (102))));
 pc2line = (duk_hbuffer_fixed *) (void *) duk_get_hbuffer(thr, -1);
 if (pc2line != 
# 235 "duk_hobject_pc2line.c" 3 4
               ((void *)0)
# 235 "duk_hobject_pc2line.c"
                   ) {
  do { } while (0);
  line = duk__hobject_pc2line_query_raw(thr, pc2line, (duk_uint_fast32_t) pc);
 } else {
  line = 0;
 }
 duk_pop(thr);

 return line;
}
# 1 "duk_hobject_props.c"
# 69 "duk_hobject_props.c"
static duk_bool_t duk__check_arguments_map_for_get(duk_hthread *thr,
                                                           duk_hobject *obj,
                                                           duk_hstring *key,
                                                           duk_propdesc *temp_desc);
static void duk__check_arguments_map_for_put(duk_hthread *thr,
                                                     duk_hobject *obj,
                                                     duk_hstring *key,
                                                     duk_propdesc *temp_desc,
                                                     duk_bool_t throw_flag);
static void duk__check_arguments_map_for_delete(duk_hthread *thr,
                                                        duk_hobject *obj,
                                                        duk_hstring *key,
                                                        duk_propdesc *temp_desc);

static duk_bool_t duk__handle_put_array_length_smaller(duk_hthread *thr,
                                                               duk_hobject *obj,
                                                               duk_uint32_t old_len,
                                                               duk_uint32_t new_len,
                                                               duk_bool_t force_flag,
                                                               duk_uint32_t *out_result_len);
static duk_bool_t duk__handle_put_array_length(duk_hthread *thr, duk_hobject *obj);

static duk_bool_t
duk__get_propdesc(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *out_desc, duk_small_uint_t flags);
static duk_bool_t duk__get_own_propdesc_raw(duk_hthread *thr,
                                                    duk_hobject *obj,
                                                    duk_hstring *key,
                                                    duk_uint32_t arr_idx,
                                                    duk_propdesc *out_desc,
                                                    duk_small_uint_t flags);

static void duk__abandon_array_part(duk_hthread *thr, duk_hobject *obj);
static void duk__grow_props_for_array_item(duk_hthread *thr, duk_hobject *obj, duk_uint32_t highest_arr_idx);
# 114 "duk_hobject_props.c"
static duk_uint32_t duk__tval_number_to_arr_idx(duk_tval *tv) {
 duk_double_t dbl;
 duk_uint32_t idx;

 do { } while (0);
 do { } while (0);




 dbl = ((tv)->v.d);
 idx = (duk_uint32_t) dbl;
 if (duk_double_equals((duk_double_t) idx, dbl)) {



  return idx;
 }
 return (0xffffffffUL);
}
# 163 "duk_hobject_props.c"
static duk_uint32_t duk__to_property_key(duk_hthread *thr, duk_idx_t idx, duk_hstring **out_h) {
 duk_uint32_t arr_idx;
 duk_hstring *h;
 duk_tval *tv_dst;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);







 tv_dst = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (idx));
 if (((tv_dst)->t == 8)) {






  h = ((tv_dst)->v.hstring);
 } else {
  h = duk_to_property_key_hstring(thr, idx);
 }
 do { } while (0);
 *out_h = h;

 arr_idx = ((h)->arridx);
 return arr_idx;
}

static duk_uint32_t duk__push_tval_to_property_key(duk_hthread *thr, duk_tval *tv_key, duk_hstring **out_h) {
 duk_push_tval(thr, tv_key);
 return duk__to_property_key(thr, -1, out_h);
}


static duk_bool_t duk__key_is_plain_buf_ownprop(duk_hthread *thr, duk_hbuffer *buf, duk_hstring *key, duk_uint32_t arr_idx) {
 do { (void) (thr); } while (0);






 do { } while (0);
 if (arr_idx < (((duk_hbuffer *) (buf))->size)) {
  return 1;
 }


 return (key == (((thr))->strs[(87)]));
}







static duk_uint32_t duk__get_default_h_size(duk_uint32_t e_size) {
 do { } while (0);

 if (e_size >= 8) {
  duk_uint32_t res;
  duk_uint32_t tmp;





  tmp = e_size;
  res = 2;
  while (tmp >= 0x40) {
   tmp >>= 6;
   res <<= 6;
  }
  while (tmp != 0) {
   tmp >>= 1;
   res <<= 1;
  }
  do { } while (0);
  do { } while (0);
  return res;
 } else {
  return 0;
 }
}



static duk_uint32_t duk__get_min_grow_e(duk_uint32_t e_size) {
 duk_uint32_t res;

 res = (e_size + 16) / 8;
 do { } while (0);
 return res;
}


static duk_uint32_t duk__get_min_grow_a(duk_uint32_t a_size) {
 duk_uint32_t res;

 res = (a_size + 16) / 8;
 do { } while (0);
 return res;
}


static duk_uint32_t duk__count_used_e_keys(duk_hthread *thr, duk_hobject *obj) {
 duk_uint_fast32_t i;
 duk_uint_fast32_t n = 0;
 duk_hstring **e;

 do { } while (0);
 do { (void) (thr); } while (0);

 e = ((duk_hstring **) (void *) ((((obj))->props) + (((obj))->e_size) * sizeof(duk_propvalue)));
 for (i = 0; i < ((obj)->e_next); i++) {
  if (*e++) {
   n++;
  }
 }
 return (duk_uint32_t) n;
}






static void duk__compute_a_stats(duk_hthread *thr, duk_hobject *obj, duk_uint32_t *out_used, duk_uint32_t *out_min_size) {
 duk_uint_fast32_t i;
 duk_uint_fast32_t used = 0;
 duk_uint_fast32_t highest_idx = (duk_uint_fast32_t) -1;
 duk_tval *a;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);

 a = ((duk_tval *) (void *) ((((obj))->props) + (((obj))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - ((((obj))->e_size))) & 0x07)));
 for (i = 0; i < ((obj)->a_size); i++) {
  duk_tval *tv = a++;
  if (!((tv)->t == 7)) {
   used++;
   highest_idx = i;
  }
 }






 *out_used = (duk_uint32_t) used;
 *out_min_size = (duk_uint32_t) (highest_idx + 1);
}


static duk_bool_t duk__abandon_array_density_check(duk_uint32_t a_used, duk_uint32_t a_size) {
# 345 "duk_hobject_props.c"
 return (a_used < 2 * (a_size >> 3));
}


static duk_bool_t duk__abandon_array_slow_check_required(duk_uint32_t arr_idx, duk_uint32_t old_size) {
 duk_uint32_t new_size_min;
# 373 "duk_hobject_props.c"
 new_size_min = arr_idx + 1;
 return (new_size_min >= 257) &&
        (arr_idx > 9 * ((old_size + 7) >> 3));
}

static duk_bool_t duk__abandon_array_check(duk_hthread *thr, duk_uint32_t arr_idx, duk_hobject *obj) {
 duk_uint32_t min_size;
 duk_uint32_t old_used;
 duk_uint32_t old_size;

 if (!duk__abandon_array_slow_check_required(arr_idx, ((obj)->a_size))) {
  do { } while (0);
  return 0;
 }

 duk__compute_a_stats(thr, obj, &old_used, &old_size);

 do { } while (0)


                                      ;

 min_size = arr_idx + 1;





 do { (void) (min_size); } while (0);





 if (duk__abandon_array_density_check(old_used, arr_idx)) {
  do { } while (0)
                                                                                ;





  goto do_abandon;
 }

 do { } while (0);
 return 0;

do_abandon:
 duk__abandon_array_part(thr, obj);
 do { } while (0);
 return 1;
}

static duk_tval *duk__obtain_arridx_slot_slowpath(duk_hthread *thr, duk_uint32_t arr_idx, duk_hobject *obj) {
# 446 "duk_hobject_props.c"
 do { } while (0)


                                                         ;

 if (__builtin_expect((duk__abandon_array_check(thr, arr_idx, obj) != 0), 0)) {
  do { } while (0);
  return 
# 453 "duk_hobject_props.c" 3 4
        ((void *)0)
# 453 "duk_hobject_props.c"
            ;
 }

 do { } while (0)
                                                            ;







 duk__grow_props_for_array_item(thr, obj, arr_idx);

 do { } while (0);
 do { } while (0);
 return (&((duk_tval *) (void *) (((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07)))[(arr_idx)]);
}

static inline duk_tval *duk__obtain_arridx_slot(duk_hthread *thr, duk_uint32_t arr_idx, duk_hobject *obj) {
 if (__builtin_expect((arr_idx < ((obj)->a_size)), 1)) {
  return (&((duk_tval *) (void *) (((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07)))[(arr_idx)]);
 } else {
  return duk__obtain_arridx_slot_slowpath(thr, arr_idx, obj);
 }
}






static __attribute__ ((unused)) duk_bool_t duk_hobject_proxy_check(duk_hobject *obj, duk_hobject **out_target, duk_hobject **out_handler) {
 duk_hproxy *h_proxy;

 do { } while (0);
 do { } while (0);
 do { } while (0);




 if (__builtin_expect((!(((&((obj))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)), 1)) {
  return 0;
 }
 h_proxy = (duk_hproxy *) obj;
 do { } while (0);

 do { } while (0);
 do { } while (0);
 *out_handler = h_proxy->handler;
 *out_target = h_proxy->target;

 return 1;
}






static __attribute__ ((unused)) duk_hobject *duk_hobject_resolve_proxy_target(duk_hobject *obj) {
 do { } while (0);






 while ((((&((obj))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)) {
  duk_hproxy *h_proxy;

  h_proxy = (duk_hproxy *) obj;
  do { } while (0);
  obj = h_proxy->target;
  do { } while (0);
 }

 do { } while (0);
 return obj;
}



static duk_bool_t duk__proxy_check_prop(duk_hthread *thr,
                                           duk_hobject *obj,
                                           duk_small_uint_t stridx_trap,
                                           duk_tval *tv_key,
                                           duk_hobject **out_target) {
 duk_hobject *h_handler;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 if (!duk_hobject_proxy_check(obj, out_target, &h_handler)) {
  return 0;
 }
 do { } while (0);
 do { } while (0);
# 565 "duk_hobject_props.c"
 if (((tv_key)->t == 8)) {
  duk_hstring *h_key = (duk_hstring *) ((tv_key)->v.hstring);
  do { } while (0);
  if ((((&(h_key)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0)) {




   do { } while (0);
   return 0;
  }
 }
# 591 "duk_hobject_props.c"
 duk_require_stack(thr, 20);
 duk_push_hobject(thr, h_handler);
 if ((((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (stridx_trap))))) {

  duk_insert(thr, -2);


  return 1;
 } else {
  duk_pop_2_unsafe(thr);
  return 0;
 }
}
# 635 "duk_hobject_props.c"
static __attribute__ ((unused)) void duk_hobject_realloc_props(duk_hthread *thr,
                                            duk_hobject *obj,
                                            duk_uint32_t new_e_size,
                                            duk_uint32_t new_a_size,
                                            duk_uint32_t new_h_size,
                                            duk_bool_t abandon_array) {
 duk_small_uint_t prev_ms_base_flags;
 duk_uint32_t new_alloc_size;
 duk_uint32_t new_e_size_adjusted;
 duk_uint8_t *new_p;
 duk_hstring **new_e_k;
 duk_propvalue *new_e_pv;
 duk_uint8_t *new_e_f;
 duk_tval *new_a;
 duk_uint32_t *new_h;
 duk_uint32_t new_e_next;
 duk_uint_fast32_t i;
 duk_size_t array_copy_size;




 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0)
                                                                                 ;
 do { } while (0);


 do { } while (0);
 ;

 do { } while (0);
# 688 "duk_hobject_props.c"
 do { } while (0);
 new_e_size_adjusted = new_e_size;
# 709 "duk_hobject_props.c"
 do { } while (0)
# 724 "duk_hobject_props.c"
                        ;
# 736 "duk_hobject_props.c"
 if (new_e_size_adjusted + new_a_size > 0x3fffffffUL) {
  do { duk_err_error_alloc_failed((thr), "duk_hobject_props.c", (duk_int_t) 737); } while (0);
  do { return; } while (0);
 }
# 765 "duk_hobject_props.c"
 prev_ms_base_flags = thr->heap->ms_base_flags;
 thr->heap->ms_base_flags |=
     (1U << 2);
 thr->heap->pf_prevent_count++;
 do { } while (0);

 new_alloc_size = ((new_e_size_adjusted) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - ((new_e_size_adjusted))) & 0x07) + (new_a_size) * sizeof(duk_tval) + (new_h_size) * sizeof(duk_uint32_t));
 do { } while (0);
 if (new_alloc_size == 0) {
  do { } while (0);
  do { } while (0);
  do { } while (0);
  new_p = 
# 777 "duk_hobject_props.c" 3 4
         ((void *)0)
# 777 "duk_hobject_props.c"
             ;
 } else {
# 788 "duk_hobject_props.c"
  new_p = (duk_uint8_t *) duk_heap_mem_alloc((thr->heap), (new_alloc_size));
  if (new_p == 
# 789 "duk_hobject_props.c" 3 4
              ((void *)0)
# 789 "duk_hobject_props.c"
                  ) {



   goto alloc_failed;
  }
 }




 do { (new_e_pv) = (duk_propvalue *) (void *) (new_p); (new_e_k) = (duk_hstring **) (void *) ((new_e_pv) + (new_e_size_adjusted)); (new_e_f) = (duk_uint8_t *) (void *) ((new_e_k) + (new_e_size_adjusted)); (new_a) = (duk_tval *) (void *) (((duk_uint8_t *) (new_e_f)) + sizeof(duk_uint8_t) * (new_e_size_adjusted) + ((8 - ((new_e_size_adjusted))) & 0x07)); (new_h) = (duk_uint32_t *) (void *) ((new_a) + (new_a_size)); } while (0)







                                           ;
 do { (void) (new_h); } while (0);
 new_e_next = 0;


 do { } while (0);

 do { } while (0)





                                      ;
# 831 "duk_hobject_props.c"
 if (abandon_array) {
# 846 "duk_hobject_props.c"
  do { } while (0);

  do { } while (0);

  for (i = 0; i < ((obj)->a_size); i++) {
   duk_tval *tv1;
   duk_tval *tv2;
   duk_hstring *key;

   do { } while (0);

   tv1 = (&((duk_tval *) (void *) (((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07)))[(i)]);
   if (((tv1)->t == 7)) {
    continue;
   }

   do { } while (0);
# 882 "duk_hobject_props.c"
   if (!duk_check_stack(thr, 1)) {
    goto abandon_error;
   }
   ;
   key = duk_heap_strtable_intern_u32(thr->heap, (duk_uint32_t) i);
   if (key == 
# 887 "duk_hobject_props.c" 3 4
             ((void *)0)
# 887 "duk_hobject_props.c"
                 ) {
    goto abandon_error;
   }
   duk_push_hstring(thr, key);






   new_e_k[new_e_next] = key;
   tv2 = &new_e_pv[new_e_next].v;
   do { *(tv2) = *(tv1); } while (0);
   new_e_f[new_e_next] =
       (1U << 0) | (1U << 1) | (1U << 2);
   new_e_next++;




  }


  do { } while (0);
  duk_pop_n_nodecref_unsafe(thr, (duk_idx_t) new_e_next);
 }





 for (i = 0; i < ((obj)->e_next); i++) {
  duk_hstring *key;

  do { } while (0);

  key = (((duk_hstring **) (void *) (((((obj)))->props) + ((((obj)))->e_size) * sizeof(duk_propvalue)))[(i)]);
  if (key == 
# 924 "duk_hobject_props.c" 3 4
            ((void *)0)
# 924 "duk_hobject_props.c"
                ) {
   continue;
  }

  do { } while (0);

  new_e_k[new_e_next] = key;
  new_e_pv[new_e_next] = (((duk_propvalue *) (void *) (((((obj)))->props)))[(i)]);
  new_e_f[new_e_next] = (((duk_uint8_t *) (void *) (((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))[(i)]);
  new_e_next++;
 }
# 953 "duk_hobject_props.c"
 if (new_a_size > ((obj)->a_size)) {
  array_copy_size = sizeof(duk_tval) * ((obj)->a_size);
 } else {
  array_copy_size = sizeof(duk_tval) * new_a_size;
 }

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { void *duk__dst = ((void *) new_a); const void *duk__src = ((const void *) ((duk_tval *) (void *) ((((obj))->props) + (((obj))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - ((((obj))->e_size))) & 0x07)))); duk_size_t duk__len = (array_copy_size); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0);

 for (i = ((obj)->a_size); i < new_a_size; i++) {
  duk_tval *tv = &new_a[i];
  do { duk_tval *duk__tv; duk__tv = (tv); duk__tv->t = 7; } while (0);
 }
# 979 "duk_hobject_props.c"
 if (new_h_size == 0) {
  do { } while (0);
 } else {
  duk_uint32_t mask;

  do { } while (0);


  do { } while (0);
  do { void *duk__dst = (new_h); duk_small_int_t duk__val = (0xff); duk_size_t duk__len = (sizeof(duk_uint32_t) * new_h_size); do { } while (0); (void) memset(duk__dst, duk__val, (size_t) duk__len); } while (0);

  do { } while (0);

  mask = new_h_size - 1;
  for (i = 0; i < new_e_next; i++) {
   duk_hstring *key = new_e_k[i];
   duk_uint32_t j, step;

   do { } while (0);
   j = ((key)->hash) & mask;
   step = 1;

   for (;;) {
    do { } while (0);
    if (new_h[j] == 0xffffffffUL) {
     do { } while (0);
     new_h[j] = (duk_uint32_t) i;
     break;
    }
    do { } while (0);
    j = (j + step) & mask;


   }
  }
 }






 do { } while (0)
# 1038 "duk_hobject_props.c"
                        ;





 duk_heap_mem_free((thr)->heap, (((obj)->props)));
 do { (obj)->props = (duk_uint8_t *) (new_p); } while (0);
 do { (obj)->e_size = (new_e_size_adjusted); } while (0);
 do { (obj)->e_next = (new_e_next); } while (0);
 do { (obj)->a_size = (new_a_size); } while (0);
 do { (obj)->h_size = (new_h_size); } while (0);


 if (abandon_array) {
  do { do { } while (0); (&(obj)->hdr)->h_flags &= ~(((1UL << (7 + (8))))); } while (0);
 }

 do { } while (0);

 do { } while (0);
 thr->heap->pf_prevent_count--;
 thr->heap->ms_base_flags = prev_ms_base_flags;
# 1073 "duk_hobject_props.c"
 return;
# 1083 "duk_hobject_props.c"
abandon_error:
alloc_failed:
 do { } while (0);

 duk_heap_mem_free((thr)->heap, (new_p));

 thr->heap->pf_prevent_count--;
 thr->heap->ms_base_flags = prev_ms_base_flags;





 do { duk_err_error_alloc_failed((thr), "duk_hobject_props.c", (duk_int_t) 1096); } while (0);
 do { return; } while (0);
}





static __attribute__ ((unused)) void duk_hobject_resize_entrypart(duk_hthread *thr, duk_hobject *obj, duk_uint32_t new_e_size) {
 duk_uint32_t old_e_size;
 duk_uint32_t new_a_size;
 duk_uint32_t new_h_size;

 do { } while (0);
 do { } while (0);

 old_e_size = ((obj)->e_size);
 if (old_e_size > new_e_size) {
  new_e_size = old_e_size;
 }

 new_h_size = duk__get_default_h_size(new_e_size);



 new_a_size = ((obj)->a_size);

 duk_hobject_realloc_props(thr, obj, new_e_size, new_a_size, new_h_size, 0);
}


static void duk__grow_props_for_new_entry_item(duk_hthread *thr, duk_hobject *obj) {
 duk_uint32_t old_e_used;
 duk_uint32_t new_e_size_minimum;
 duk_uint32_t new_e_size;
 duk_uint32_t new_a_size;
 duk_uint32_t new_h_size;

 do { } while (0);
 do { } while (0);
# 1144 "duk_hobject_props.c"
 old_e_used = duk__count_used_e_keys(thr, obj);
 new_e_size_minimum = old_e_used + 1;
 new_e_size = old_e_used + duk__get_min_grow_e(old_e_used);

 new_h_size = duk__get_default_h_size(new_e_size);



 new_a_size = ((obj)->a_size);
# 1165 "duk_hobject_props.c"
 do { } while (0);

 if (!(new_e_size >= new_e_size_minimum)) {
  do { duk_err_error_alloc_failed((thr), "duk_hobject_props.c", (duk_int_t) 1168); } while (0);
  do { return; } while (0);
 }

 duk_hobject_realloc_props(thr, obj, new_e_size, new_a_size, new_h_size, 0);
}


static void duk__grow_props_for_array_item(duk_hthread *thr, duk_hobject *obj, duk_uint32_t highest_arr_idx) {
 duk_uint32_t new_e_size;
 duk_uint32_t new_a_size;
 duk_uint32_t new_a_size_minimum;
 duk_uint32_t new_h_size;

 do { } while (0);
 do { } while (0);
 do { } while (0);

 new_e_size = ((obj)->e_size);
 new_h_size = ((obj)->h_size);
 new_a_size_minimum = highest_arr_idx + 1;
 new_a_size = highest_arr_idx + duk__get_min_grow_a(highest_arr_idx);
 do { } while (0);
# 1204 "duk_hobject_props.c"
 if (!(new_a_size >= new_a_size_minimum)) {
  do { duk_err_error_alloc_failed((thr), "duk_hobject_props.c", (duk_int_t) 1205); } while (0);
  do { return; } while (0);
 }

 duk_hobject_realloc_props(thr, obj, new_e_size, new_a_size, new_h_size, 0);
}






static void duk__abandon_array_part(duk_hthread *thr, duk_hobject *obj) {
 duk_uint32_t new_e_size_minimum;
 duk_uint32_t new_e_size;
 duk_uint32_t new_a_size;
 duk_uint32_t new_h_size;
 duk_uint32_t e_used;
 duk_uint32_t a_used;
 duk_uint32_t a_size;

 do { } while (0);
 do { } while (0);

 e_used = duk__count_used_e_keys(thr, obj);
 duk__compute_a_stats(thr, obj, &a_used, &a_size);







 new_e_size_minimum = e_used + a_used;
 new_e_size = new_e_size_minimum + duk__get_min_grow_e(new_e_size_minimum);
 new_a_size = 0;

 new_h_size = duk__get_default_h_size(new_e_size);
# 1259 "duk_hobject_props.c"
 if (!(new_e_size >= new_e_size_minimum)) {
  do { duk_err_error_alloc_failed((thr), "duk_hobject_props.c", (duk_int_t) 1260); } while (0);
  do { return; } while (0);
 }

 do { } while (0)
# 1273 "duk_hobject_props.c"
                                       ;

 duk_hobject_realloc_props(thr, obj, new_e_size, new_a_size, new_h_size, 1);
}
# 1290 "duk_hobject_props.c"
static __attribute__ ((unused)) void duk_hobject_compact_props(duk_hthread *thr, duk_hobject *obj) {
 duk_uint32_t e_size;
 duk_uint32_t a_size;
 duk_uint32_t a_used;
 duk_uint32_t h_size;
 duk_bool_t abandon_array;

 do { } while (0);
 do { } while (0);
# 1307 "duk_hobject_props.c"
 e_size = duk__count_used_e_keys(thr, obj);
 duk__compute_a_stats(thr, obj, &a_used, &a_size);

 do { } while (0)






                                                       ;

 if (duk__abandon_array_density_check(a_used, a_size)) {
  do { } while (0)

                                    ;
  abandon_array = 1;
  e_size += a_used;
  a_size = 0;
 } else {
  do { } while (0);
  abandon_array = 0;
 }


 if (e_size >= 8) {
  h_size = duk__get_default_h_size(e_size);
 } else {
  h_size = 0;
 }




 do { } while (0)



                                          ;

 duk_hobject_realloc_props(thr, obj, e_size, a_size, h_size, abandon_array);
}
# 1360 "duk_hobject_props.c"
static __attribute__ ((unused)) duk_bool_t
duk_hobject_find_entry(duk_heap *heap, duk_hobject *obj, duk_hstring *key, duk_int_t *e_idx, duk_int_t *h_idx) {
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { (void) (heap); } while (0);

 if (__builtin_expect((((obj)->h_size) == 0), 1)) {





  duk_uint_fast32_t i;
  duk_uint_fast32_t n;
  duk_hstring **h_keys_base;
  do { } while (0);

  h_keys_base = ((duk_hstring **) (void *) ((((obj))->props) + (((obj))->e_size) * sizeof(duk_propvalue)));
  n = ((obj)->e_next);
  for (i = 0; i < n; i++) {
   if (h_keys_base[i] == key) {
    *e_idx = (duk_int_t) i;
    *h_idx = -1;
    return 1;
   }
  }
 }

 else {

  duk_uint32_t n;
  duk_uint32_t i, step;
  duk_uint32_t *h_base;
  duk_uint32_t mask;

  do { } while (0);

  h_base = ((duk_uint32_t *) (void *) ((((obj))->props) + (((obj))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - ((((obj))->e_size))) & 0x07) + (((obj))->a_size) * sizeof(duk_tval)));
  n = ((obj)->h_size);
  mask = n - 1;
  i = ((key)->hash) & mask;
  step = 1;

  for (;;) {
   duk_uint32_t t;

   do { } while (0);
   do { } while (0);
   t = h_base[i];
   do { } while (0)
                                               ;

   if (t == 0xffffffffUL) {
    break;
   } else if (t == 0xfffffffeUL) {
    do { } while (0);
   } else {
    do { } while (0);
    if ((((duk_hstring **) (void *) (((((obj)))->props) + ((((obj)))->e_size) * sizeof(duk_propvalue)))[(t)]) == key) {
     do { } while (0)
                                                                                             ;
     *e_idx = (duk_int_t) t;
     *h_idx = (duk_int_t) i;
     return 1;
    }
    do { } while (0);
   }
   i = (i + step) & mask;


  }
 }



 return 0;
}


static __attribute__ ((unused)) duk_tval *duk_hobject_find_entry_tval_ptr(duk_heap *heap, duk_hobject *obj, duk_hstring *key) {
 duk_int_t e_idx;
 duk_int_t h_idx;

 do { } while (0);
 do { } while (0);
 do { (void) (heap); } while (0);

 if (duk_hobject_find_entry(heap, obj, key, &e_idx, &h_idx)) {
  do { } while (0);
  if (!(((((duk_uint8_t *) (void *) ((((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))[((e_idx))]) & (1U << 3)) != 0)) {
   return (&(((duk_propvalue *) (void *) ((((((obj))))->props)))[((e_idx))]).v);
  }
 }
 return 
# 1455 "duk_hobject_props.c" 3 4
       ((void *)0)
# 1455 "duk_hobject_props.c"
           ;
}

static __attribute__ ((unused)) duk_tval *duk_hobject_find_entry_tval_ptr_stridx(duk_heap *heap, duk_hobject *obj, duk_small_uint_t stridx) {
 return duk_hobject_find_entry_tval_ptr(heap, obj, ((heap)->strs[(stridx)]));
}


static __attribute__ ((unused)) duk_tval *duk_hobject_find_entry_tval_ptr_and_attrs(duk_heap *heap,
                                                                 duk_hobject *obj,
                                                                 duk_hstring *key,
                                                                 duk_uint_t *out_attrs) {
 duk_int_t e_idx;
 duk_int_t h_idx;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { (void) (heap); } while (0);

 if (duk_hobject_find_entry(heap, obj, key, &e_idx, &h_idx)) {
  do { } while (0);
  if (!(((((duk_uint8_t *) (void *) ((((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))[((e_idx))]) & (1U << 3)) != 0)) {
   *out_attrs = (((duk_uint8_t *) (void *) (((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))[(e_idx)]);
   return (&(((duk_propvalue *) (void *) ((((((obj))))->props)))[((e_idx))]).v);
  }
 }

 return 
# 1483 "duk_hobject_props.c" 3 4
       ((void *)0)
# 1483 "duk_hobject_props.c"
           ;
}


static __attribute__ ((unused)) duk_tval *duk_hobject_find_array_entry_tval_ptr(duk_heap *heap, duk_hobject *obj, duk_uarridx_t i) {
 duk_tval *tv;

 do { } while (0);
 do { (void) (heap); } while (0);

 if (!(((&(obj)->hdr)->h_flags & ((1UL << (7 + (8))))) != 0)) {
  return 
# 1494 "duk_hobject_props.c" 3 4
        ((void *)0)
# 1494 "duk_hobject_props.c"
            ;
 }
 if (i >= ((obj)->a_size)) {
  return 
# 1497 "duk_hobject_props.c" 3 4
        ((void *)0)
# 1497 "duk_hobject_props.c"
            ;
 }
 tv = (&((duk_tval *) (void *) (((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07)))[(i)]);
 return tv;
}
# 1512 "duk_hobject_props.c"
static duk_int_t duk__hobject_alloc_entry_checked(duk_hthread *thr, duk_hobject *obj, duk_hstring *key) {
 duk_uint32_t idx;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
# 1530 "duk_hobject_props.c"
 if (((obj)->e_next) >= ((obj)->e_size)) {

  do { } while (0);
  duk__grow_props_for_new_entry_item(thr, obj);
 }
 do { } while (0);
 idx = ((obj)->e_next++);


 do { (((duk_hstring **) (void *) ((((((obj))))->props) + (((((obj))))->e_size) * sizeof(duk_propvalue)))[((idx))]) = (key); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (key))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);


 if (__builtin_expect((((obj)->h_size) > 0), 0)) {
  duk_uint32_t n, mask;
  duk_uint32_t i, step;
  duk_uint32_t *h_base = ((duk_uint32_t *) (void *) ((((obj))->props) + (((obj))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - ((((obj))->e_size))) & 0x07) + (((obj))->a_size) * sizeof(duk_tval)));

  n = ((obj)->h_size);
  mask = n - 1;
  i = ((key)->hash) & mask;
  step = 1;

  for (;;) {
   duk_uint32_t t = h_base[i];
   if (t == 0xffffffffUL || t == 0xfffffffeUL) {
    do { } while (0)

                                     ;
    do { } while (0);
    do { } while (0);
    do { } while (0);
    do { } while (0);
    h_base[i] = idx;
    break;
   }
   do { } while (0);
   i = (i + step) & mask;


  }
 }






 do { } while (0);
 do { } while (0);
 do { } while (0);
 return (duk_int_t) idx;
}
# 1591 "duk_hobject_props.c"
static __attribute__ ((unused)) duk_tval *duk_hobject_get_internal_value_tval_ptr(duk_heap *heap, duk_hobject *obj) {
 return duk_hobject_find_entry_tval_ptr_stridx(heap, obj, 106);
}

static duk_heaphdr *duk_hobject_get_internal_value_heaphdr(duk_heap *heap, duk_hobject *obj) {
 duk_tval *tv;

 do { } while (0);
 do { } while (0);

 tv = duk_hobject_get_internal_value_tval_ptr(heap, obj);
 if (tv != 
# 1602 "duk_hobject_props.c" 3 4
          ((void *)0)
# 1602 "duk_hobject_props.c"
              ) {
  duk_heaphdr *h = ((tv)->v.heaphdr);
  do { } while (0);
  return h;
 }

 return 
# 1608 "duk_hobject_props.c" 3 4
       ((void *)0)
# 1608 "duk_hobject_props.c"
           ;
}

static __attribute__ ((unused)) duk_hstring *duk_hobject_get_internal_value_string(duk_heap *heap, duk_hobject *obj) {
 duk_hstring *h;

 h = (duk_hstring *) duk_hobject_get_internal_value_heaphdr(heap, obj);
 if (h != 
# 1615 "duk_hobject_props.c" 3 4
         ((void *)0)
# 1615 "duk_hobject_props.c"
             ) {
  do { } while (0);
 }
 return h;
}

static duk_hobject *duk__hobject_get_entry_object_stridx(duk_heap *heap, duk_hobject *obj, duk_small_uint_t stridx) {
 duk_tval *tv;
 duk_hobject *h;

 tv = duk_hobject_find_entry_tval_ptr_stridx(heap, obj, stridx);
 if (tv != 
# 1626 "duk_hobject_props.c" 3 4
          ((void *)0) 
# 1626 "duk_hobject_props.c"
               && ((tv)->t == 9)) {
  h = ((tv)->v.hobject);
  do { } while (0);
  return h;
 }
 return 
# 1631 "duk_hobject_props.c" 3 4
       ((void *)0)
# 1631 "duk_hobject_props.c"
           ;
}

static __attribute__ ((unused)) duk_harray *duk_hobject_get_formals(duk_hthread *thr, duk_hobject *obj) {
 duk_harray *h;

 h = (duk_harray *) duk__hobject_get_entry_object_stridx(thr->heap, obj, 99);
 if (h != 
# 1638 "duk_hobject_props.c" 3 4
         ((void *)0)
# 1638 "duk_hobject_props.c"
             ) {
  do { } while (0);
  do { } while (0);
 }
 return h;
}

static __attribute__ ((unused)) duk_hobject *duk_hobject_get_varmap(duk_hthread *thr, duk_hobject *obj) {
 duk_hobject *h;

 h = duk__hobject_get_entry_object_stridx(thr->heap, obj, 100);
 return h;
}
# 1665 "duk_hobject_props.c"
static
duk_bool_t duk__lookup_arguments_map(duk_hthread *thr,
                                     duk_hobject *obj,
                                     duk_hstring *key,
                                     duk_propdesc *temp_desc,
                                     duk_hobject **out_map,
                                     duk_hobject **out_varenv) {
 duk_hobject *map;
 duk_hobject *varenv;
 duk_bool_t rc;

 ;

 do { } while (0)






                                           ;

 if (!duk_hobject_get_own_propdesc(thr, obj, (((thr))->strs[(103)]), temp_desc, (1U << 0))) {
  do { } while (0);
  return 0;
 }

 map = duk_require_hobject(thr, -1);
 do { } while (0);
 duk_pop_unsafe(thr);

 if (!duk_hobject_get_own_propdesc(thr, map, key, temp_desc, (1U << 0))) {
  do { } while (0);
  return 0;
 }


 do { } while (0)
                                                          ;
 do { } while (0);


 rc = duk_hobject_get_own_propdesc(thr, obj, (((thr))->strs[(104)]), temp_desc, (1U << 0));
 do { (void) (rc); } while (0);
 do { } while (0);
 varenv = duk_require_hobject(thr, -1);
 do { } while (0);
 duk_pop_unsafe(thr);

 do { } while (0);


 *out_map = map;
 *out_varenv = varenv;
 return 1;
}





static duk_bool_t duk__check_arguments_map_for_get(duk_hthread *thr,
                                                      duk_hobject *obj,
                                                      duk_hstring *key,
                                                      duk_propdesc *temp_desc) {
 duk_hobject *map;
 duk_hobject *varenv;
 duk_hstring *varname;

 ;

 if (!duk__lookup_arguments_map(thr, obj, key, temp_desc, &map, &varenv)) {
  do { } while (0);
  return 0;
 }



 varname = duk_require_hstring(thr, -1);
 do { } while (0);
 duk_pop_unsafe(thr);

 do { } while (0)


                                               ;

 (void) duk_js_getvar_envrec(thr, varenv, varname, 1 );



 duk_pop_unsafe(thr);


 return 1;
}





static void duk__check_arguments_map_for_put(duk_hthread *thr,
                                                duk_hobject *obj,
                                                duk_hstring *key,
                                                duk_propdesc *temp_desc,
                                                duk_bool_t throw_flag) {
 duk_hobject *map;
 duk_hobject *varenv;
 duk_hstring *varname;

 ;

 if (!duk__lookup_arguments_map(thr, obj, key, temp_desc, &map, &varenv)) {
  do { } while (0);
  return;
 }



 varname = duk_require_hstring(thr, -1);
 do { } while (0);
 duk_pop_unsafe(thr);

 do { } while (0)



                                                              ;
# 1804 "duk_hobject_props.c"
 duk_js_putvar_envrec(thr, varenv, varname, duk_require_tval(thr, -1), throw_flag);


}





static void duk__check_arguments_map_for_delete(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *temp_desc) {
 duk_hobject *map;

 ;

 if (!duk_hobject_get_own_propdesc(thr, obj, (((thr))->strs[(103)]), temp_desc, (1U << 0))) {
  do { } while (0);
  return;
 }

 map = duk_require_hobject(thr, -1);
 do { } while (0);
 duk_pop_unsafe(thr);

 do { } while (0);


 do { } while (0);
 do { } while (0);
 (void) duk_hobject_delprop_raw(thr, map, key, 0);
 do { } while (0);
}
# 1875 "duk_hobject_props.c"
static duk_bool_t duk__get_own_propdesc_raw(duk_hthread *thr,
                                               duk_hobject *obj,
                                               duk_hstring *key,
                                               duk_uint32_t arr_idx,
                                               duk_propdesc *out_desc,
                                               duk_small_uint_t flags) {
 duk_tval *tv;

 do { } while (0)
# 1892 "duk_hobject_props.c"
                                           ;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 ;

 do { } while (0);






 do { } while (0);
# 1926 "duk_hobject_props.c"
 if (duk_hobject_find_entry(thr->heap, obj, key, &out_desc->e_idx, &out_desc->h_idx)) {
  duk_int_t e_idx = out_desc->e_idx;
  do { } while (0);
  out_desc->a_idx = -1;
  out_desc->flags = (((duk_uint8_t *) (void *) (((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))[(e_idx)]);
  out_desc->get = 
# 1931 "duk_hobject_props.c" 3 4
                 ((void *)0)
# 1931 "duk_hobject_props.c"
                     ;
  out_desc->set = 
# 1932 "duk_hobject_props.c" 3 4
                 ((void *)0)
# 1932 "duk_hobject_props.c"
                     ;
  if (__builtin_expect((out_desc->flags & (1U << 3)), 0)) {
   do { } while (0);
   out_desc->get = ((((duk_propvalue *) (void *) ((((((obj))))->props)))[((e_idx))]).a.get);
   out_desc->set = ((((duk_propvalue *) (void *) ((((((obj))))->props)))[((e_idx))]).a.set);
   if (flags & (1U << 0)) {



    duk_push_undefined(thr);
   }
  } else {
   do { } while (0);
   tv = (&(((duk_propvalue *) (void *) ((((((obj))))->props)))[((e_idx))]).v);
   if (flags & (1U << 0)) {
    duk_push_tval(thr, tv);
   }
  }
  goto prop_found;
 }





 if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (8))))) != 0) && arr_idx != (0xffffffffUL)) {
  if (arr_idx < ((obj)->a_size)) {
   tv = (&((duk_tval *) (void *) (((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07)))[(arr_idx)]);
   if (!((tv)->t == 7)) {
    do { } while (0);
    if (flags & (1U << 0)) {
     duk_push_tval(thr, tv);
    }

    out_desc->flags =
        (1U << 0) | (1U << 2) | (1U << 1);
    out_desc->get = 
# 1968 "duk_hobject_props.c" 3 4
                   ((void *)0)
# 1968 "duk_hobject_props.c"
                       ;
    out_desc->set = 
# 1969 "duk_hobject_props.c" 3 4
                   ((void *)0)
# 1969 "duk_hobject_props.c"
                       ;
    out_desc->e_idx = -1;
    out_desc->h_idx = -1;
    out_desc->a_idx = (duk_int_t) arr_idx;
    goto prop_found;
   }
  }
 }

 do { } while (0);





 if (!(((&(obj)->hdr)->h_flags & (((1UL << (7 + (15))) | (1UL << (7 + (16))) | (1UL << (7 + (6)))))) != 0)) {

  goto prop_not_found;
 }

 if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (15))))) != 0)) {
  duk_harray *a;

  do { } while (0)

                                       ;

  a = (duk_harray *) obj;
  do { } while (0);

  if (key == (((thr))->strs[(87)])) {
   do { } while (0);

   if (flags & (1U << 0)) {
    duk_push_uint(thr, (duk_uint_t) a->length);
   }
   out_desc->flags = (1U << 4);
   if ((!(a)->length_nonwritable)) {
    out_desc->flags |= (1U << 0);
   }
   out_desc->get = 
# 2009 "duk_hobject_props.c" 3 4
                  ((void *)0)
# 2009 "duk_hobject_props.c"
                      ;
   out_desc->set = 
# 2010 "duk_hobject_props.c" 3 4
                  ((void *)0)
# 2010 "duk_hobject_props.c"
                      ;
   out_desc->e_idx = -1;
   out_desc->h_idx = -1;
   out_desc->a_idx = -1;

   do { } while (0);
   goto prop_found_noexotic;
  }
 } else if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (16))))) != 0)) {
  do { } while (0)

                                       ;



  if (arr_idx != (0xffffffffUL)) {
   duk_hstring *h_val;

   do { } while (0);

   h_val = duk_hobject_get_internal_value_string(thr->heap, obj);
   do { } while (0);
   if (arr_idx < duk_hstring_get_charlen((h_val))) {
    do { } while (0);
    if (flags & (1U << 0)) {
     duk_push_hstring(thr, h_val);
     duk_substring(thr, -1, arr_idx, arr_idx + 1);
    }
    out_desc->flags = (1U << 1) |
                      (1U << 4);
    out_desc->get = 
# 2040 "duk_hobject_props.c" 3 4
                   ((void *)0)
# 2040 "duk_hobject_props.c"
                       ;
    out_desc->set = 
# 2041 "duk_hobject_props.c" 3 4
                   ((void *)0)
# 2041 "duk_hobject_props.c"
                       ;
    out_desc->e_idx = -1;
    out_desc->h_idx = -1;
    out_desc->a_idx = -1;

    do { } while (0);
    goto prop_found_noexotic;
   } else {

    do { } while (0);
   }
  } else if (key == (((thr))->strs[(87)])) {
   duk_hstring *h_val;

   do { } while (0);

   h_val = duk_hobject_get_internal_value_string(thr->heap, obj);
   do { } while (0);
   if (flags & (1U << 0)) {
    duk_push_uint(thr, (duk_uint_t) duk_hstring_get_charlen((h_val)));
   }
   out_desc->flags = (1U << 4);
   out_desc->get = 
# 2063 "duk_hobject_props.c" 3 4
                  ((void *)0)
# 2063 "duk_hobject_props.c"
                      ;
   out_desc->set = 
# 2064 "duk_hobject_props.c" 3 4
                  ((void *)0)
# 2064 "duk_hobject_props.c"
                      ;
   out_desc->e_idx = -1;
   out_desc->h_idx = -1;
   out_desc->a_idx = -1;

   do { } while (0);
   goto prop_found_noexotic;
  }
 }

 else if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {
  duk_hbufobj *h_bufobj;
  duk_uint_t byte_off;
  duk_small_uint_t elem_size;

  h_bufobj = (duk_hbufobj *) obj;
  do { } while (0);
  do { } while (0);

  if (arr_idx != (0xffffffffUL) && ((h_bufobj)->is_typedarray)) {
   do { } while (0);




   if (arr_idx < (h_bufobj->length >> h_bufobj->shift)) {
    byte_off = arr_idx << h_bufobj->shift;
    elem_size = (duk_small_uint_t) (1U << h_bufobj->shift);
    if (flags & (1U << 0)) {
     duk_uint8_t *data;

     if (h_bufobj->buf != 
# 2095 "duk_hobject_props.c" 3 4
                         ((void *)0) 
# 2095 "duk_hobject_props.c"
                              &&
         (((void) 0), ((void) 0), ((h_bufobj)->offset + (byte_off + elem_size) <= (((duk_hbuffer *) ((h_bufobj)->buf))->size)))) {
      data = (duk_uint8_t *) ((((&((h_bufobj->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h_bufobj->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h_bufobj->buf))) + 1))) +
             h_bufobj->offset + byte_off;
      duk_hbufobj_push_validated_read(thr, h_bufobj, data, elem_size);
     } else {
      do { } while (0);
      duk_push_uint(thr, 0);
     }
    }
    out_desc->flags = (1U << 0) | (1U << 4);
    if ((((&(obj)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) != 19) {



     out_desc->flags |= (1U << 1);
    }
    out_desc->get = 
# 2112 "duk_hobject_props.c" 3 4
                   ((void *)0)
# 2112 "duk_hobject_props.c"
                       ;
    out_desc->set = 
# 2113 "duk_hobject_props.c" 3 4
                   ((void *)0)
# 2113 "duk_hobject_props.c"
                       ;
    out_desc->e_idx = -1;
    out_desc->h_idx = -1;
    out_desc->a_idx = -1;

    do { } while (0);
    goto prop_found_noexotic;

   } else {

    do { } while (0);
   }
  } else if (key == (((thr))->strs[(87)]) && ((h_bufobj)->is_typedarray)) {
   do { } while (0);

   if (flags & (1U << 0)) {



    duk_push_uint(thr, h_bufobj->length >> h_bufobj->shift);
   }
   out_desc->flags = (1U << 4);
   out_desc->get = 
# 2135 "duk_hobject_props.c" 3 4
                  ((void *)0)
# 2135 "duk_hobject_props.c"
                      ;
   out_desc->set = 
# 2136 "duk_hobject_props.c" 3 4
                  ((void *)0)
# 2136 "duk_hobject_props.c"
                      ;
   out_desc->e_idx = -1;
   out_desc->h_idx = -1;
   out_desc->a_idx = -1;

   do { } while (0);
   goto prop_found_noexotic;
  }
 }
# 2159 "duk_hobject_props.c"
prop_not_found:
 do { } while (0);
 do { } while (0);
 return 0;
# 2171 "duk_hobject_props.c"
prop_found:
 do { } while (0);
# 2181 "duk_hobject_props.c"
 if (__builtin_expect(((((&(obj)->hdr)->h_flags & ((1UL << (7 + (17))))) != 0) && arr_idx != (0xffffffffUL) && (flags & (1U << 0))), 0)
                                                        ) {
  duk_propdesc temp_desc;
# 2193 "duk_hobject_props.c"
  do { } while (0);




  if (duk__check_arguments_map_for_get(thr, obj, key, &temp_desc)) {
   do { } while (0)

                                                            ;

   duk_remove_m2(thr);
  }
 }

prop_found_noexotic:
 do { } while (0);
 return 1;
}

static __attribute__ ((unused)) duk_bool_t
duk_hobject_get_own_propdesc(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *out_desc, duk_small_uint_t flags) {
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 ;

 return duk__get_own_propdesc_raw(thr, obj, key, ((key)->arridx), out_desc, flags);
}
# 2242 "duk_hobject_props.c"
static duk_bool_t
duk__get_propdesc(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_propdesc *out_desc, duk_small_uint_t flags) {
 duk_hobject *curr;
 duk_uint32_t arr_idx;
 duk_uint_t sanity;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 ;

 do { } while (0);

 arr_idx = ((key)->arridx);

 do { } while (0)
# 2268 "duk_hobject_props.c"
                                           ;

 curr = obj;
 do { } while (0);
 sanity = 10000L;
 do {
  if (duk__get_own_propdesc_raw(thr, curr, key, arr_idx, out_desc, flags)) {

   do { } while (0);
   return 1;
  }


  if (__builtin_expect((sanity-- == 0), 0)) {
   if (flags & (1U << 1)) {

    break;
   } else {
    do { duk_err_range((thr), "duk_hobject_props.c", (duk_int_t) 2286, ("prototype chain limit")); } while (0);
    do { return 0; } while (0);
   }
  }
  curr = ((curr)->prototype);
 } while (curr != 
# 2291 "duk_hobject_props.c" 3 4
                 ((void *)0)
# 2291 "duk_hobject_props.c"
                     );





 do { } while (0);
 return 0;
}
# 2322 "duk_hobject_props.c"
static duk_tval *duk__getprop_shallow_fastpath_array_tval(duk_hthread *thr, duk_hobject *obj, duk_tval *tv_key) {
 duk_tval *tv;
 duk_uint32_t idx;

 do { (void) (thr); } while (0);

 if (!((((&(obj)->hdr)->h_flags & ((1UL << (7 + (8))))) != 0) && !(((&(obj)->hdr)->h_flags & ((1UL << (7 + (17))))) != 0) && !(((&(obj)->hdr)->h_flags & ((1UL << (7 + (16))))) != 0) &&
       !(((&(obj)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0) && !(((&((obj))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0))) {




  return 
# 2334 "duk_hobject_props.c" 3 4
        ((void *)0)
# 2334 "duk_hobject_props.c"
            ;
 }



 do { } while (0)
                                                          ;






     if ((((tv_key))->t == 0)) {
  idx = duk__tval_number_to_arr_idx(tv_key);
 } else {
  do { } while (0);
  return 
# 2351 "duk_hobject_props.c" 3 4
        ((void *)0)
# 2351 "duk_hobject_props.c"
            ;
 }






 if (idx >= ((obj)->a_size)) {
  do { } while (0);
  return 
# 2361 "duk_hobject_props.c" 3 4
        ((void *)0)
# 2361 "duk_hobject_props.c"
            ;
 }
 do { } while (0);
 do { } while (0);





 do { } while (0);
 tv = (&((duk_tval *) (void *) (((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07)))[(idx)]);
 if (!((tv)->t == 7)) {
  do { } while (0);
  return tv;
 }

 do { } while (0);
 return 
# 2378 "duk_hobject_props.c" 3 4
       ((void *)0)
# 2378 "duk_hobject_props.c"
           ;
}

static duk_bool_t duk__putprop_shallow_fastpath_array_tval(duk_hthread *thr,
                                                              duk_hobject *obj,
                                                              duk_tval *tv_key,
                                                              duk_tval *tv_val) {
 duk_tval *tv;
 duk_harray *a;
 duk_uint32_t idx;
 duk_uint32_t old_len, new_len;

 if (!((((&(obj)->hdr)->h_flags & ((1UL << (7 + (15))))) != 0) && (((&(obj)->hdr)->h_flags & ((1UL << (7 + (8))))) != 0) && (((&(obj)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0))) {
  return 0;
 }
 do { } while (0);

 a = (duk_harray *) obj;
 do { } while (0);






     if ((((tv_key))->t == 0)) {
  idx = duk__tval_number_to_arr_idx(tv_key);
 } else {
  do { } while (0);
  return 0;
 }






 if (idx >= ((obj)->a_size)) {
  return 0;
 }
 do { } while (0);
 do { } while (0);

 old_len = a->length;

 if (idx >= old_len) {
  do { } while (0)


                                       ;
  if (((a)->length_nonwritable)) {




   return 0;
  }
  new_len = idx + 1;

  ((duk_harray *) obj)->length = new_len;
 }

 tv = (&((duk_tval *) (void *) (((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07)))[(idx)]);
 do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv); tv__src = (tv_val); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((tv__dst))->t & 0x08)) { h__obj = ((tv__dst)->v.heaphdr); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);

 do { } while (0);
 return 1;
}







static duk_bool_t duk__getprop_fastpath_bufobj_tval(duk_hthread *thr, duk_hobject *obj, duk_tval *tv_key) {
 duk_uint32_t idx;
 duk_hbufobj *h_bufobj;
 duk_uint_t byte_off;
 duk_small_uint_t elem_size;
 duk_uint8_t *data;

 if (!(((&(obj)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {
  return 0;
 }
 h_bufobj = (duk_hbufobj *) obj;
 if (!((h_bufobj)->is_typedarray)) {
  return 0;
 }






     if ((((tv_key))->t == 0)) {
  idx = duk__tval_number_to_arr_idx(tv_key);
 } else {
  return 0;
 }







 if (idx >= (h_bufobj->length >> h_bufobj->shift)) {
  return 0;
 }
 do { } while (0);

 byte_off = idx << h_bufobj->shift;
 elem_size = (duk_small_uint_t) (1U << h_bufobj->shift);

 if (h_bufobj->buf != 
# 2493 "duk_hobject_props.c" 3 4
                     ((void *)0) 
# 2493 "duk_hobject_props.c"
                          && (((void) 0), ((void) 0), ((h_bufobj)->offset + (byte_off + elem_size) <= (((duk_hbuffer *) ((h_bufobj)->buf))->size)))) {
  data = (duk_uint8_t *) ((((&((h_bufobj->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h_bufobj->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h_bufobj->buf))) + 1))) + h_bufobj->offset + byte_off;
  duk_hbufobj_push_validated_read(thr, h_bufobj, data, elem_size);
 } else {
  do { } while (0);
  duk_push_uint(thr, 0);
 }

 return 1;
}



static duk_bool_t duk__putprop_fastpath_bufobj_tval(duk_hthread *thr, duk_hobject *obj, duk_tval *tv_key, duk_tval *tv_val) {
 duk_uint32_t idx;
 duk_hbufobj *h_bufobj;
 duk_uint_t byte_off;
 duk_small_uint_t elem_size;
 duk_uint8_t *data;

 if (!((((&(obj)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0) && ((tv_val)->t == 0))) {
  return 0;
 }
 do { } while (0);

 h_bufobj = (duk_hbufobj *) obj;
 if (!((h_bufobj)->is_typedarray)) {
  return 0;
 }






     if ((((tv_key))->t == 0)) {
  idx = duk__tval_number_to_arr_idx(tv_key);
 } else {
  return 0;
 }







 if (idx >= (h_bufobj->length >> h_bufobj->shift)) {
  return 0;
 }
 do { } while (0);

 byte_off = idx << h_bufobj->shift;
 elem_size = (duk_small_uint_t) (1U << h_bufobj->shift);




 duk_push_tval(thr, tv_val);
 do { } while (0);

 if (h_bufobj->buf != 
# 2554 "duk_hobject_props.c" 3 4
                     ((void *)0) 
# 2554 "duk_hobject_props.c"
                          && (((void) 0), ((void) 0), ((h_bufobj)->offset + (byte_off + elem_size) <= (((duk_hbuffer *) ((h_bufobj)->buf))->size)))) {
  data = (duk_uint8_t *) ((((&((h_bufobj->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h_bufobj->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h_bufobj->buf))) + 1))) + h_bufobj->offset + byte_off;
  duk_hbufobj_validated_write(thr, h_bufobj, data, elem_size);
 } else {
  do { } while (0);
 }

 duk_pop_unsafe(thr);
 return 1;
}






static __attribute__ ((unused)) duk_bool_t duk_hobject_getprop(duk_hthread *thr, duk_tval *tv_obj, duk_tval *tv_key) {
 duk_tval tv_obj_copy;
 duk_tval tv_key_copy;
 duk_hobject *curr = 
# 2573 "duk_hobject_props.c" 3 4
                    ((void *)0)
# 2573 "duk_hobject_props.c"
                        ;
 duk_hstring *key = 
# 2574 "duk_hobject_props.c" 3 4
                   ((void *)0)
# 2574 "duk_hobject_props.c"
                       ;
 duk_uint32_t arr_idx = (0xffffffffUL);
 duk_propdesc desc;
 duk_uint_t sanity;

 do { } while (0)




                                           ;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 ;

 do { } while (0);
# 2604 "duk_hobject_props.c"
 do { *(&tv_obj_copy) = *(tv_obj); } while (0);
 do { *(&tv_key_copy) = *(tv_key); } while (0);
 tv_obj = &tv_obj_copy;
 tv_key = &tv_key_copy;





 switch (((tv_obj)->t)) {
 case 2:
 case 3: {

  do { } while (0);



  do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 2621; do { } while (0); do { } while (0); duk_err_handle_error_fmt((thr), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("cannot read property %s of %s"), (duk_push_string_tval_readable(thr, tv_key)), (duk_push_string_tval_readable(thr, tv_obj))); } while (0)



                                                            ;

  do { return 0; } while (0);
  break;
 }

 case 4: {
  do { } while (0);
  curr = thr->builtins[12];
  break;
 }

 case 8: {
  duk_hstring *h = ((tv_obj)->v.hstring);
  duk_int_t pop_count;

  if (__builtin_expect(((((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {

   do { } while (0);
   curr = thr->builtins[38];
   break;
  }
# 2655 "duk_hobject_props.c"
      if (((tv_key)->t == 0)) {
   arr_idx = duk__tval_number_to_arr_idx(tv_key);
   do { } while (0);
   pop_count = 0;
  } else {
   arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
   do { } while (0);
   do { } while (0)


                                        ;
   pop_count = 1;
  }

  if (arr_idx != (0xffffffffUL) && arr_idx < duk_hstring_get_charlen((h))) {
   duk_pop_n_unsafe(thr, pop_count);
   duk_push_hstring(thr, h);
   duk_substring(thr, -1, arr_idx, arr_idx + 1);

   do { } while (0);
   do { } while (0)

                                                            ;
   return 1;
  }

  if (pop_count == 0) {



   arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
   do { } while (0);
   do { } while (0)


                                        ;
  }

  if (key == (((thr))->strs[(87)])) {
   duk_pop_unsafe(thr);
   duk_push_uint(thr, (duk_uint_t) duk_hstring_get_charlen((h)));

   do { } while (0);
   do { } while (0)

                                                            ;
   return 1;
  }

  do { } while (0);
  curr = thr->builtins[10];
  goto lookup;
 }

 case 9: {

  duk_tval *tmp;


  curr = ((tv_obj)->v.hobject);
  do { } while (0);




  tmp = duk__getprop_shallow_fastpath_array_tval(thr, curr, tv_key);
  if (tmp) {
   duk_push_tval(thr, tmp);

   do { } while (0)

                                                            ;
   do { } while (0);
   return 1;
  }



  if (duk__getprop_fastpath_bufobj_tval(thr, curr, tv_key) != 0) {

   do { } while (0)

                                                            ;
   do { } while (0);
   return 1;
  }



  if (__builtin_expect(((((&((curr))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)), 0)) {
   duk_hobject *h_target;

   if (duk__proxy_check_prop(thr, curr, 73, tv_key, &h_target)) {

    do { } while (0);
    do { } while (0);
    duk_push_hobject(thr, h_target);
    duk_push_tval(thr, tv_key);
    duk_push_tval(thr, tv_obj);
    duk_call_method(thr, 3 );




    arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
    do { } while (0);

    if (duk__get_own_propdesc_raw(thr, h_target, key, arr_idx, &desc, (1U << 0))) {
     duk_tval *tv_hook = duk_require_tval(thr, -3);
     duk_tval *tv_targ = duk_require_tval(thr, -1);
     duk_bool_t datadesc_reject;
     duk_bool_t accdesc_reject;

     do { } while (0)







                                             ;

     datadesc_reject = !(desc.flags & (1U << 3)) &&
                       !(desc.flags & (1U << 2)) &&
                       !(desc.flags & (1U << 0)) &&
                       !duk_js_equals_helper(
# 2781 "duk_hobject_props.c" 3 4
                       ((void *)0)
# 2781 "duk_hobject_props.c"
                       , (tv_hook), (tv_targ), (1U << 0));
     accdesc_reject = (desc.flags & (1U << 3)) &&
                      !(desc.flags & (1U << 2)) && (desc.get == 
# 2783 "duk_hobject_props.c" 3 4
                                                                                    ((void *)0)
# 2783 "duk_hobject_props.c"
                                                                                        ) &&
                      !((tv_hook)->t == 2);
     if (datadesc_reject || accdesc_reject) {
      do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 2786; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("proxy rejected"))); } while (0); } while (0);
      do { return 0; } while (0);
     }

     duk_pop_2_unsafe(thr);
    } else {
     duk_pop_unsafe(thr);
    }
    return 1;
   }

   curr = h_target;
   do { duk_tval *duk__tv; duk__tv = (tv_obj); duk__tv->t = 9; duk__tv->v.hobject = (curr); } while (0);
  }


  if ((((&(curr)->hdr)->h_flags & ((1UL << (7 + (17))))) != 0)) {
   arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
   do { } while (0);

   do { } while (0);
   if (duk__check_arguments_map_for_get(thr, curr, key, &desc)) {
    do { } while (0)


                                                             ;



    duk_remove_m2(thr);
    return 1;
   }

   goto lookup;
  }
  break;
 }




 case 10: {
  duk_hbuffer *h = ((tv_obj)->v.hbuffer);
  duk_int_t pop_count;
# 2843 "duk_hobject_props.c"
      if (((tv_key)->t == 0)) {
   arr_idx = duk__tval_number_to_arr_idx(tv_key);
   do { } while (0);
   pop_count = 0;
  } else {
   arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
   do { } while (0);
   do { } while (0)


                                        ;
   pop_count = 1;
  }

  if (arr_idx != (0xffffffffUL) && arr_idx < (((duk_hbuffer *) (h))->size)) {
   duk_pop_n_unsafe(thr, pop_count);
   duk_push_uint(thr, ((duk_uint8_t *) ((((&((h))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h))) + 1))))[arr_idx]);
   do { } while (0);
   do { } while (0)

                                                            ;
   return 1;
  }

  if (pop_count == 0) {



   arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
   do { } while (0);
   do { } while (0)


                                        ;
  }

  if (key == (((thr))->strs[(87)])) {
   duk_pop_unsafe(thr);
   duk_push_uint(thr, (duk_uint_t) (((duk_hbuffer *) (h))->size));
   do { } while (0);

   do { } while (0)

                                                            ;
   return 1;
  }

  do { } while (0);
  curr = thr->builtins[42];
  goto lookup;
 }

 case 5: {
  do { } while (0);
  curr = thr->builtins[36];
  break;
 }

 case 6: {

  do { } while (0);
  curr = thr->builtins[6];
  break;
 }




 default: {

  do { } while (0);
  do { } while (0);
  do { } while (0);
  curr = thr->builtins[14];
  break;
 }
 }


 do { } while (0);
 arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
 do { } while (0);




lookup:

 do { } while (0);
 do { } while (0);

 sanity = 10000L;
 do {
  if (!duk__get_own_propdesc_raw(thr, curr, key, arr_idx, &desc, (1U << 0))) {
   goto next_in_chain;
  }

  if (desc.get != 
# 2940 "duk_hobject_props.c" 3 4
                 ((void *)0)
# 2940 "duk_hobject_props.c"
                     ) {

   do { } while (0);

   duk_pop_unsafe(thr);
   duk_push_hobject(thr, desc.get);
   duk_push_tval(thr, tv_obj);

   duk_dup_m3(thr);
   duk_call_method(thr, 1);



  } else {



   do { } while (0);


   do { } while (0);






  }

  goto found;

 next_in_chain:



  if (__builtin_expect((sanity-- == 0), 0)) {
   do { duk_err_range((thr), "duk_hobject_props.c", (duk_int_t) 2976, ("prototype chain limit")); } while (0);
   do { return 0; } while (0);
  }
  curr = ((curr)->prototype);
 } while (curr != 
# 2980 "duk_hobject_props.c" 3 4
                 ((void *)0)
# 2980 "duk_hobject_props.c"
                     );





 duk_to_undefined(thr, -1);

 do { } while (0);
 return 0;





found:
# 3025 "duk_hobject_props.c"
 if (key == (((thr))->strs[(69)]) && ((tv_obj)->t == 9)) {
  duk_hobject *orig = ((tv_obj)->v.hobject);
  do { } while (0);

  if ((((&(orig)->hdr)->h_flags & ((1UL << (7 + (4))) | (1UL << (7 + (5))))) != 0) || (((&(orig)->hdr)->h_flags & ((1UL << (7 + (17))))) != 0)) {
   duk_hobject *h;







   do { } while (0);

   h = duk_get_hobject(thr, -1);
   if (h && (((&(h)->hdr)->h_flags & ((1UL << (7 + (3))) | (1UL << (7 + (4))) | (1UL << (7 + (5))))) != 0) && (((&(h)->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)) {

    do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 3043; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("cannot read strict 'caller'"))); } while (0); } while (0);
    do { return 0; } while (0);
   }
  }
 }


 duk_remove_m2(thr);

 do { } while (0);
 return 1;
}
# 3063 "duk_hobject_props.c"
static __attribute__ ((unused)) duk_bool_t duk_hobject_hasprop(duk_hthread *thr, duk_tval *tv_obj, duk_tval *tv_key) {
 duk_tval tv_key_copy;
 duk_hobject *obj;
 duk_hstring *key;
 duk_uint32_t arr_idx;
 duk_bool_t rc;
 duk_propdesc desc;

 do { } while (0)




                                           ;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 ;

 do { *(&tv_key_copy) = *(tv_key); } while (0);
 tv_key = &tv_key_copy;
# 3101 "duk_hobject_props.c"
 if (((tv_obj)->t == 9)) {
  obj = ((tv_obj)->v.hobject);
  do { } while (0);

  arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
 } else if (((tv_obj)->t == 10)) {
  arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
  if (duk__key_is_plain_buf_ownprop(thr, ((tv_obj)->v.hbuffer), key, arr_idx)) {
   rc = 1;
   goto pop_and_return;
  }
  obj = thr->builtins[42];
 } else if (((tv_obj)->t == 6)) {
  arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);






  obj = thr->builtins[6];
 } else {

  do { } while (0);
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 3125; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid base value"))); } while (0); } while (0);
  do { return 0; } while (0);
 }



 do { } while (0);
 do { } while (0);
 do { (void) (arr_idx); } while (0);


 if (__builtin_expect(((((&((obj))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)), 0)) {
  duk_hobject *h_target;
  duk_bool_t tmp_bool;






  if (duk__proxy_check_prop(thr, obj, 74, tv_key, &h_target)) {

   do { } while (0);
   duk_push_hobject(thr, h_target);
   duk_push_tval(thr, tv_key);
   duk_call_method(thr, 2 );
   tmp_bool = duk_to_boolean_top_pop(thr);
   if (!tmp_bool) {




    if (duk__get_own_propdesc_raw(thr, h_target, key, arr_idx, &desc, 0 )) {

     do { } while (0)





                                             ;




     if (!((desc.flags & (1U << 2)) &&
           (((&(h_target)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0))) {
      do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 3172; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("proxy rejected"))); } while (0); } while (0);
      do { return 0; } while (0);
     }
    }
   }

   duk_pop_unsafe(thr);
   return tmp_bool;
  }

  obj = h_target;
 }




 rc = duk__get_propdesc(thr, obj, key, &desc, 0 );


pop_and_return:
 duk_pop_unsafe(thr);
 return rc;
}
# 3208 "duk_hobject_props.c"
static __attribute__ ((unused)) duk_bool_t duk_hobject_hasprop_raw(duk_hthread *thr, duk_hobject *obj, duk_hstring *key) {
 duk_propdesc dummy;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 ;

 return duk__get_propdesc(thr, obj, key, &dummy, (1U << 1));
}
# 3232 "duk_hobject_props.c"
static duk_uint32_t duk__to_new_array_length_checked(duk_hthread *thr, duk_tval *tv) {
 duk_uint32_t res;
 duk_double_t d;
# 3254 "duk_hobject_props.c"
 if ((((tv))->t == 0)) {
  d = ((tv)->v.d);
 }

 else

 {



  d = duk_js_tonumber(thr, tv);
 }




 res = duk_double_to_uint32_t(d);
 if (!duk_double_equals((duk_double_t) res, d)) {
  goto fail_range;
 }

 return res;

fail_range:
 do { duk_err_range((thr), "duk_hobject_props.c", (duk_int_t) 3278, ("invalid array length")); } while (0);
 do { return 0; } while (0);
}
# 3289 "duk_hobject_props.c"
static
duk_bool_t duk__handle_put_array_length_smaller(duk_hthread *thr,
                                                duk_hobject *obj,
                                                duk_uint32_t old_len,
                                                duk_uint32_t new_len,
                                                duk_bool_t force_flag,
                                                duk_uint32_t *out_result_len) {
 duk_uint32_t target_len;
 duk_uint_fast32_t i;
 duk_uint32_t arr_idx;
 duk_hstring *key;
 duk_tval *tv;
 duk_bool_t rc;

 do { } while (0)


                                      ;
# 3322 "duk_hobject_props.c"
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 ;

 do { } while (0);
 do { } while (0);

 if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (8))))) != 0)) {







  do { } while (0);

  if (old_len < ((obj)->a_size)) {

   i = old_len;
  } else {
   i = ((obj)->a_size);
  }
  do { } while (0);

  while (i > new_len) {
   i--;
   tv = (&((duk_tval *) (void *) (((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07)))[(i)]);
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 7; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
  }

  *out_result_len = new_len;
  return 1;
 } else {
# 3366 "duk_hobject_props.c"
  do { } while (0);

  do { } while (0)
                                                                               ;

  target_len = new_len;
  if (force_flag) {
   do { } while (0);
   goto skip_stage1;
  }
  for (i = 0; i < ((obj)->e_next); i++) {
   key = (((duk_hstring **) (void *) (((((obj)))->props) + ((((obj)))->e_size) * sizeof(duk_propvalue)))[(i)]);
   if (!key) {
    do { } while (0);
    continue;
   }
   if (!(((&(key)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0)) {
    do { } while (0);
    continue;
   }

   do { } while (0)
                                   ;
   arr_idx = ((key)->arridx);
   do { } while (0);
   do { } while (0);

   if (arr_idx < new_len) {
    do { } while (0)

                                         ;
    continue;
   }
   if ((((((duk_uint8_t *) (void *) ((((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))[((i))]) & (1U << 2)) != 0)) {
    do { } while (0)

                                         ;
    continue;
   }


   if (arr_idx >= target_len) {
    do { } while (0)




                                               ;
    target_len = arr_idx + 1;
   }
  }
 skip_stage1:



  do { } while (0)
                                                                                                                  ;

  do { } while (0)
                                                ;

  for (i = 0; i < ((obj)->e_next); i++) {
   key = (((duk_hstring **) (void *) (((((obj)))->props) + ((((obj)))->e_size) * sizeof(duk_propvalue)))[(i)]);
   if (!key) {
    do { } while (0);
    continue;
   }
   if (!(((&(key)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0)) {
    do { } while (0);
    continue;
   }

   do { } while (0)
                                   ;
   arr_idx = ((key)->arridx);
   do { } while (0);
   do { } while (0);

   if (arr_idx < target_len) {
    do { } while (0)

                                         ;
    continue;
   }
   do { } while (0);

   do { } while (0);






   rc = duk_hobject_delprop_raw(thr, obj, key, force_flag ? (1U << 1) : 0);
   do { (void) (rc); } while (0);
   do { } while (0);
  }



  do { } while (0);

  *out_result_len = target_len;

  if (target_len == new_len) {
   do { } while (0);
   return 1;
  }
  do { } while (0)
                                                                ;
  return 0;
 }

 do { __builtin_unreachable(); } while (0);
}


static duk_bool_t duk__handle_put_array_length(duk_hthread *thr, duk_hobject *obj) {
 duk_harray *a;
 duk_uint32_t old_len;
 duk_uint32_t new_len;
 duk_uint32_t result_len;
 duk_bool_t rc;

 do { } while (0)

                                                          ;

 do { } while (0);
 do { } while (0);

 ;

 do { } while (0);
 do { } while (0);
 a = (duk_harray *) obj;
 do { } while (0);

 do { } while (0);





 old_len = a->length;
 new_len = duk__to_new_array_length_checked(thr, ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)));
 do { } while (0);





 if (((a)->length_nonwritable)) {
  do { } while (0);
  return 0;
 }






 if (new_len >= old_len) {
  do { } while (0);
  a->length = new_len;
  return 1;
 }

 do { } while (0);
# 3544 "duk_hobject_props.c"
 rc = duk__handle_put_array_length_smaller(thr, obj, old_len, new_len, 0 , &result_len);
 do { } while (0);

 a->length = result_len;



 return rc;
}
# 3583 "duk_hobject_props.c"
static __attribute__ ((unused)) duk_bool_t
duk_hobject_putprop(duk_hthread *thr, duk_tval *tv_obj, duk_tval *tv_key, duk_tval *tv_val, duk_bool_t throw_flag) {
 duk_tval tv_obj_copy;
 duk_tval tv_key_copy;
 duk_tval tv_val_copy;
 duk_hobject *orig = 
# 3588 "duk_hobject_props.c" 3 4
                    ((void *)0)
# 3588 "duk_hobject_props.c"
                        ;
 duk_hobject *curr;
 duk_hstring *key = 
# 3590 "duk_hobject_props.c" 3 4
                   ((void *)0)
# 3590 "duk_hobject_props.c"
                       ;
 duk_propdesc desc;
 duk_tval *tv;
 duk_uint32_t arr_idx;
 duk_bool_t rc;
 duk_int_t e_idx;
 duk_uint_t sanity;
 duk_uint32_t new_array_length = 0;

 do { } while (0)
# 3608 "duk_hobject_props.c"
                                           ;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 ;

 do { } while (0);
# 3628 "duk_hobject_props.c"
 do { *(&tv_obj_copy) = *(tv_obj); } while (0);
 do { *(&tv_key_copy) = *(tv_key); } while (0);
 do { *(&tv_val_copy) = *(tv_val); } while (0);
 tv_obj = &tv_obj_copy;
 tv_key = &tv_key_copy;
 tv_val = &tv_val_copy;





 switch (((tv_obj)->t)) {
 case 2:
 case 3: {

  do { } while (0);



  do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 3647; do { } while (0); do { } while (0); duk_err_handle_error_fmt((thr), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("cannot write property %s of %s"), (duk_push_string_tval_readable(thr, tv_key)), (duk_push_string_tval_readable(thr, tv_obj))); } while (0)



                                                            ;

  do { return 0; } while (0);
  break;
 }

 case 4: {
  do { } while (0);
  curr = thr->builtins[12];
  break;
 }

 case 8: {
  duk_hstring *h = ((tv_obj)->v.hstring);






  do { } while (0);
  arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
  do { } while (0);

  if (__builtin_expect(((((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {

   curr = thr->builtins[38];
   goto lookup;
  }

  if (key == (((thr))->strs[(87)])) {
   goto fail_not_writable;
  }

  if (arr_idx != (0xffffffffUL) && arr_idx < duk_hstring_get_charlen((h))) {
   goto fail_not_writable;
  }

  do { } while (0);
  curr = thr->builtins[10];
  goto lookup;
 }

 case 9: {
  orig = ((tv_obj)->v.hobject);
  do { } while (0);
# 3728 "duk_hobject_props.c"
  if (duk__putprop_shallow_fastpath_array_tval(thr, orig, tv_key, tv_val) != 0) {
   do { } while (0);
   do { } while (0);
   return 1;
  }



  if (duk__putprop_fastpath_bufobj_tval(thr, orig, tv_key, tv_val) != 0) {
   do { } while (0);
   do { } while (0);
   return 1;
  }



  if (__builtin_expect(((((&((orig))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)), 0)) {
   duk_hobject *h_target;
   duk_bool_t tmp_bool;

   if (duk__proxy_check_prop(thr, orig, 88, tv_key, &h_target)) {

    do { } while (0);
    do { } while (0);
    duk_push_hobject(thr, h_target);
    duk_push_tval(thr, tv_key);
    duk_push_tval(thr, tv_val);
    duk_push_tval(thr, tv_obj);
    duk_call_method(thr, 4 );
    tmp_bool = duk_to_boolean_top_pop(thr);
    if (!tmp_bool) {
     goto fail_proxy_rejected;
    }




    arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
    do { } while (0);

    if (duk__get_own_propdesc_raw(thr, h_target, key, arr_idx, &desc, (1U << 0))) {
     duk_tval *tv_targ = duk_require_tval(thr, -1);
     duk_bool_t datadesc_reject;
     duk_bool_t accdesc_reject;

     do { } while (0)







                                             ;

     datadesc_reject = !(desc.flags & (1U << 3)) &&
                       !(desc.flags & (1U << 2)) &&
                       !(desc.flags & (1U << 0)) &&
                       !duk_js_equals_helper(
# 3786 "duk_hobject_props.c" 3 4
                       ((void *)0)
# 3786 "duk_hobject_props.c"
                       , (tv_val), (tv_targ), (1U << 0));
     accdesc_reject = (desc.flags & (1U << 3)) &&
                      !(desc.flags & (1U << 2)) && (desc.set == 
# 3788 "duk_hobject_props.c" 3 4
                                                                                    ((void *)0)
# 3788 "duk_hobject_props.c"
                                                                                        );
     if (datadesc_reject || accdesc_reject) {
      do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 3790; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("proxy rejected"))); } while (0); } while (0);
      do { return 0; } while (0);
     }

     duk_pop_2_unsafe(thr);
    } else {
     duk_pop_unsafe(thr);
    }
    return 1;
   }

   orig = h_target;
   do { duk_tval *duk__tv; duk__tv = (tv_obj); duk__tv->t = 9; duk__tv->v.hobject = (orig); } while (0);
  }


  curr = orig;
  break;
 }

 case 10: {
  duk_hbuffer *h = ((tv_obj)->v.hbuffer);
  duk_int_t pop_count = 0;
# 3826 "duk_hobject_props.c"
      if (((tv_key)->t == 0)) {
   arr_idx = duk__tval_number_to_arr_idx(tv_key);
   do { } while (0);
   pop_count = 0;
  } else {
   arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
   do { } while (0);
   do { } while (0)


                                        ;
   pop_count = 1;
  }

  if (arr_idx != (0xffffffffUL) && arr_idx < (((duk_hbuffer *) (h))->size)) {
   duk_uint8_t *data;
   do { } while (0);
   data = (duk_uint8_t *) ((((&((h))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h))) + 1)));
# 3854 "duk_hobject_props.c"
   {
    duk_push_tval(thr, tv_val);
    data[arr_idx] = (duk_uint8_t) duk_to_uint32(thr, -1);
    pop_count++;
   }

   duk_pop_n_unsafe(thr, pop_count);
   do { } while (0);
   do { } while (0);
   return 1;
  }

  if (pop_count == 0) {



   arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
   do { } while (0);
   do { } while (0)


                                        ;
  }

  if (key == (((thr))->strs[(87)])) {
   goto fail_not_writable;
  }

  do { } while (0);
  curr = thr->builtins[42];
  goto lookup;
 }

 case 5: {
  do { } while (0);
  curr = thr->builtins[36];
  break;
 }

 case 6: {




  do { } while (0);
  curr = thr->builtins[6];
  break;
 }




 default: {

  do { } while (0);
  do { } while (0);
  curr = thr->builtins[14];
  break;
 }
 }

 do { } while (0);
 arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
 do { } while (0);

lookup:
# 3929 "duk_hobject_props.c"
 do { } while (0);
 sanity = 10000L;
 do {
  if (!duk__get_own_propdesc_raw(thr, curr, key, arr_idx, &desc, 0 )) {
   goto next_in_chain;
  }

  if (desc.flags & (1U << 3)) {
# 3946 "duk_hobject_props.c"
   duk_hobject *setter;

   do { } while (0);

   setter = ((((duk_propvalue *) (void *) ((((((curr))))->props)))[((desc.e_idx))]).a.set);
   if (!setter) {
    goto fail_no_setter;
   }
   duk_push_hobject(thr, setter);
   duk_push_tval(thr, tv_obj);
   duk_push_tval(thr, tv_val);

   duk_dup_m4(thr);
   duk_call_method(thr, 2);



   duk_pop_unsafe(thr);
   goto success_no_arguments_exotic;
  }

  if (orig == 
# 3967 "duk_hobject_props.c" 3 4
             ((void *)0)
# 3967 "duk_hobject_props.c"
                 ) {




   do { } while (0);
   goto fail_base_primitive;
  }

  if (curr != orig) {





   if (!(((&(orig)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0)) {
    do { } while (0)
                                                                                                      ;
    goto fail_not_extensible;
   }
   if (!(desc.flags & (1U << 0))) {
    do { } while (0)
                                                             ;
    goto fail_not_writable;
   }
   do { } while (0);
   goto create_new;
  } else {





   if (!(desc.flags & (1U << 0))) {
    do { } while (0)
                                                                                                       ;
    goto fail_not_writable;
   }
   if (desc.flags & (1U << 4)) {
    do { } while (0);

    if ((((&((curr))->hdr)->h_flags & ((1UL << (7 + (15))))) != 0)) {
# 4019 "duk_hobject_props.c"
     do { } while (0);

     do { } while (0)
                                                                                      ;






     duk_push_tval(thr, tv_val);
     rc = duk__handle_put_array_length(thr, orig);
     duk_pop_unsafe(thr);
     if (!rc) {
      goto fail_array_length_partial;
     }


     goto success_no_arguments_exotic;
    }

    else if ((((&(curr)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0)) {
     duk_hbufobj *h_bufobj;
     duk_uint_t byte_off;
     duk_small_uint_t elem_size;

     h_bufobj = (duk_hbufobj *) curr;
     do { } while (0);

     do { } while (0);




     if (arr_idx < (h_bufobj->length >> h_bufobj->shift) &&
         ((h_bufobj)->is_typedarray)) {
      duk_uint8_t *data;
      do { } while (0);

      do { } while (0);
      byte_off = arr_idx
                 << h_bufobj->shift;
      elem_size = (duk_small_uint_t) (1U << h_bufobj->shift);






      duk_push_tval(thr, tv_val);
      (void) duk_to_number_m1(thr);

      if (h_bufobj->buf != 
# 4071 "duk_hobject_props.c" 3 4
                          ((void *)0) 
# 4071 "duk_hobject_props.c"
                               &&
          (((void) 0), ((void) 0), ((h_bufobj)->offset + (byte_off + elem_size) <= (((duk_hbuffer *) ((h_bufobj)->buf))->size)))) {
       data = (duk_uint8_t *) ((((&((h_bufobj->buf))->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) ? (((duk_hbuffer_dynamic *) (h_bufobj->buf))->curr_alloc) : ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) ((duk_hbuffer_fixed *) (void *) (h_bufobj->buf))) + 1))) +
              h_bufobj->offset + byte_off;
       duk_hbufobj_validated_write(thr, h_bufobj, data, elem_size);
      } else {
       do { } while (0)
                                                                               ;
      }
      duk_pop_unsafe(thr);
      goto success_no_arguments_exotic;
     }
    }


    do { } while (0);
    goto fail_internal;
   }
   do { } while (0);
   goto update_old;
  }
  do { __builtin_unreachable(); } while (0);

 next_in_chain:



  if (__builtin_expect((sanity-- == 0), 0)) {
   do { duk_err_range((thr), "duk_hobject_props.c", (duk_int_t) 4099, ("prototype chain limit")); } while (0);
   do { return 0; } while (0);
  }
  curr = ((curr)->prototype);
 } while (curr != 
# 4103 "duk_hobject_props.c" 3 4
                 ((void *)0)
# 4103 "duk_hobject_props.c"
                     );





 do { } while (0);

 if (orig == 
# 4111 "duk_hobject_props.c" 3 4
            ((void *)0)
# 4111 "duk_hobject_props.c"
                ) {
  do { } while (0);
  goto fail_base_primitive;
 }

 if (!(((&(orig)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0)) {
  do { } while (0);
  goto fail_not_extensible;
 }

 goto create_new;

update_old:







 do { } while (0);

 do { } while (0);
# 4147 "duk_hobject_props.c"
 do { } while (0);
 do { } while (0);


 do { } while (0);

 if (desc.e_idx >= 0) {
  tv = (&(((duk_propvalue *) (void *) ((((((orig))))->props)))[((desc.e_idx))]).v);
  do { } while (0);
  do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv); tv__src = (tv_val); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((tv__dst))->t & 0x08)) { h__obj = ((tv__dst)->v.heaphdr); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);

  do { } while (0);
 } else {





  do { } while (0);
  tv = (&((duk_tval *) (void *) (((((orig)))->props) + ((((orig)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((orig)))->e_size))) & 0x07)))[(desc.a_idx)]);
  do { } while (0);
  do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv); tv__src = (tv_val); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((tv__dst))->t & 0x08)) { h__obj = ((tv__dst)->v.heaphdr); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);
  do { } while (0)

                                      ;
 }





 goto success_with_arguments_exotic;

create_new:
# 4193 "duk_hobject_props.c"
 do { } while (0);

 do { } while (0);


 do { } while (0);
# 4213 "duk_hobject_props.c"
 do { } while (0);

 if ((((&(orig)->hdr)->h_flags & ((1UL << (7 + (15))))) != 0) && arr_idx != (0xffffffffUL)) {

  duk_uint32_t old_len;
  duk_harray *a;

  a = (duk_harray *) orig;
  do { } while (0);

  old_len = a->length;

  if (arr_idx >= old_len) {
   do { } while (0)


                                        ;

   if (((a)->length_nonwritable)) {
    do { } while (0);
    goto fail_not_writable;
   }







   do { } while (0);
   new_array_length = arr_idx + 1;
  } else {
   do { } while (0)


                                        ;
  }
 }
# 4263 "duk_hobject_props.c"
 if (arr_idx != (0xffffffffUL) && (((&(orig)->hdr)->h_flags & ((1UL << (7 + (8))))) != 0)) {
  tv = duk__obtain_arridx_slot(thr, arr_idx, orig);
  if (tv == 
# 4265 "duk_hobject_props.c" 3 4
           ((void *)0)
# 4265 "duk_hobject_props.c"
               ) {
   do { } while (0);
   goto write_to_entry_part;
  }


  do { } while (0);
  do { *(tv) = *(tv_val); } while (0);
  do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  do { } while (0);





  goto entry_updated;
 }

write_to_entry_part:
# 4293 "duk_hobject_props.c"
 e_idx = duk__hobject_alloc_entry_checked(thr, orig, key);
 do { } while (0);

 tv = (&(((duk_propvalue *) (void *) ((((((orig))))->props)))[((e_idx))]).v);

 do { *(tv) = *(tv_val); } while (0);
 do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 do { (((duk_uint8_t *) (void *) ((((((orig))))->props) + (((((orig))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))[((e_idx))]) = (duk_uint8_t) (((1U << 0) | (1U << 1) | (1U << 2))); } while (0);
 goto entry_updated;

entry_updated:






 if (new_array_length > 0) {




  do { } while (0);

  do { } while (0);

  ((duk_harray *) orig)->length = new_array_length;
 }
# 4329 "duk_hobject_props.c"
 goto success_no_arguments_exotic;

success_with_arguments_exotic:
# 4346 "duk_hobject_props.c"
 if (arr_idx != (0xffffffffUL) && (((&(orig)->hdr)->h_flags & ((1UL << (7 + (17))))) != 0)) {




  do { } while (0);







  duk_push_tval(thr, tv_val);
  (void) duk__check_arguments_map_for_put(thr, orig, key, &desc, throw_flag);
  duk_pop_unsafe(thr);
 }


success_no_arguments_exotic:

 do { } while (0);
 duk_pop_unsafe(thr);
 return 1;


fail_proxy_rejected:
 do { } while (0);
 if (throw_flag) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 4375; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("proxy rejected"))); } while (0); } while (0);
  do { return 0; } while (0);
 }

 return 0;


fail_base_primitive:
 do { } while (0);
 if (throw_flag) {



  do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 4388; do { } while (0); do { } while (0); duk_err_handle_error_fmt((thr), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("cannot write property %s of %s"), (duk_push_string_tval_readable(thr, tv_key)), (duk_push_string_tval_readable(thr, tv_obj))); } while (0)



                                                            ;

  do { return 0; } while (0);
 }
 duk_pop_unsafe(thr);
 return 0;

fail_not_extensible:
 do { } while (0);
 if (throw_flag) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 4402; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not extensible"))); } while (0); } while (0);
  do { return 0; } while (0);
 }
 duk_pop_unsafe(thr);
 return 0;

fail_not_writable:
 do { } while (0);
 if (throw_flag) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 4411; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not writable"))); } while (0); } while (0);
  do { return 0; } while (0);
 }
 duk_pop_unsafe(thr);
 return 0;
# 4427 "duk_hobject_props.c"
fail_array_length_partial:
 do { } while (0);
 if (throw_flag) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 4430; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not configurable"))); } while (0); } while (0);
  do { return 0; } while (0);
 }
 duk_pop_unsafe(thr);
 return 0;

fail_no_setter:
 do { } while (0);
 if (throw_flag) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 4439; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("setter undefined"))); } while (0); } while (0);
  do { return 0; } while (0);
 }
 duk_pop_unsafe(thr);
 return 0;

fail_internal:
 do { } while (0);
 if (throw_flag) {
  do { duk_err_error_internal((thr), "duk_hobject_props.c", (duk_int_t) 4448); } while (0);
  do { return 0; } while (0);
 }
 duk_pop_unsafe(thr);
 return 0;
}





static __attribute__ ((unused)) duk_bool_t duk_hobject_delprop_raw(duk_hthread *thr, duk_hobject *obj, duk_hstring *key, duk_small_uint_t flags) {
 duk_propdesc desc;
 duk_tval *tv;
 duk_uint32_t arr_idx;
 duk_bool_t throw_flag;
 duk_bool_t force_flag;

 throw_flag = (flags & (1U << 0));
 force_flag = (flags & (1U << 1));

 do { } while (0)






                                           ;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 ;

 arr_idx = ((key)->arridx);


 if (!duk__get_own_propdesc_raw(thr, obj, key, arr_idx, &desc, 0 )) {
  do { } while (0);
  goto success;
 }
# 4500 "duk_hobject_props.c"
 if ((desc.flags & (1U << 2)) == 0 && !force_flag) {
  goto fail_not_configurable;
 }
 if (desc.a_idx < 0 && desc.e_idx < 0) {



  do { } while (0);
  goto fail_virtual;
 }

 if (desc.a_idx >= 0) {
  do { } while (0);

  tv = (&((duk_tval *) (void *) (((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07)))[(desc.a_idx)]);
  do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 7; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
  goto success;
 } else {
  do { } while (0);



  if (desc.h_idx >= 0) {
   duk_uint32_t *h_base = ((duk_uint32_t *) (void *) ((((obj))->props) + (((obj))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - ((((obj))->e_size))) & 0x07) + (((obj))->a_size) * sizeof(duk_tval)));

   do { } while (0);
   do { } while (0);
   do { } while (0);
   h_base[desc.h_idx] = 0xfffffffeUL;
  } else {
   do { } while (0);
  }
# 4540 "duk_hobject_props.c"
  do { } while (0)


                                                                                   ;
  do { } while (0);
  if ((((((duk_uint8_t *) (void *) ((((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))[((desc.e_idx))]) & (1U << 3)) != 0)) {
   duk_hobject *tmp;

   tmp = ((((duk_propvalue *) (void *) ((((((obj))))->props)))[((desc.e_idx))]).a.get);
   do { (((duk_propvalue *) (void *) ((((((obj))))->props)))[((desc.e_idx))]).a.get = (
# 4549 "duk_hobject_props.c" 3 4
  ((void *)0)
# 4549 "duk_hobject_props.c"
  ); } while (0);
   do { (void) (tmp); } while (0);
   do { if ((tmp) != 
# 4551 "duk_hobject_props.c" 3 4
  ((void *)0)
# 4551 "duk_hobject_props.c"
  ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((tmp))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);

   tmp = ((((duk_propvalue *) (void *) ((((((obj))))->props)))[((desc.e_idx))]).a.set);
   do { (((duk_propvalue *) (void *) ((((((obj))))->props)))[((desc.e_idx))]).a.set = (
# 4554 "duk_hobject_props.c" 3 4
  ((void *)0)
# 4554 "duk_hobject_props.c"
  ); } while (0);
   do { (void) (tmp); } while (0);
   do { if ((tmp) != 
# 4556 "duk_hobject_props.c" 3 4
  ((void *)0)
# 4556 "duk_hobject_props.c"
  ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((tmp))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
  } else {
   tv = (&(((duk_propvalue *) (void *) ((((((obj))))->props)))[((desc.e_idx))]).v);
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 2; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz((((thr))), duk__h); } } } while (0); } while (0);
  }






  do { } while (0)


                                                                                   ;
  do { } while (0);
  do { } while (0);
  do { (((duk_hstring **) (void *) ((((((obj))))->props) + (((((obj))))->e_size) * sizeof(duk_propvalue)))[((desc.e_idx))]) = (
# 4573 "duk_hobject_props.c" 3 4
 ((void *)0)
# 4573 "duk_hobject_props.c"
 ); } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) ((key)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hstring_refzero)(((thr)), (duk_hstring *) duk__h); } } } while (0);





  do { duk_refzero_check_slow((thr)); } while (0);
  goto success;
 }

 do { __builtin_unreachable(); } while (0);

success:
# 4597 "duk_hobject_props.c"
 do { } while (0);

 if (arr_idx != (0xffffffffUL) && (((&(obj)->hdr)->h_flags & ((1UL << (7 + (17))))) != 0)) {




  do { } while (0);


  (void) duk__check_arguments_map_for_delete(thr, obj, key, &desc);
 }

 do { } while (0);
 return 1;

fail_virtual:
fail_not_configurable:
 do { } while (0);

 if (throw_flag) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 4618; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not configurable"))); } while (0); } while (0);
  do { return 0; } while (0);
 }
 return 0;
}





static __attribute__ ((unused)) duk_bool_t duk_hobject_delprop(duk_hthread *thr, duk_tval *tv_obj, duk_tval *tv_key, duk_bool_t throw_flag) {
 duk_hstring *key = 
# 4629 "duk_hobject_props.c" 3 4
                   ((void *)0)
# 4629 "duk_hobject_props.c"
                       ;

 duk_propdesc desc;

 duk_int_t entry_top;
 duk_uint32_t arr_idx = (0xffffffffUL);
 duk_bool_t rc;

 do { } while (0)




                                           ;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 ;




 entry_top = duk_get_top(thr);

 if (((tv_obj)->t == 2) || ((tv_obj)->t == 3)) {
  do { } while (0);
  goto fail_invalid_base_uncond;
 }

 duk_push_tval(thr, tv_obj);
 duk_push_tval(thr, tv_key);

 tv_obj = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-2));
 if (((tv_obj)->t == 9)) {
  duk_hobject *obj = ((tv_obj)->v.hobject);
  do { } while (0);


  if (__builtin_expect(((((&((obj))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)), 0)) {
   duk_hobject *h_target;
   duk_bool_t tmp_bool;



   if (duk__proxy_check_prop(thr, obj, 72, tv_key, &h_target)) {

    do { } while (0);
    duk_push_hobject(thr, h_target);
    duk_dup_m4(thr);
    duk_call_method(thr, 2 );
    tmp_bool = duk_to_boolean_top_pop(thr);
    if (!tmp_bool) {
     goto fail_proxy_rejected;
    }




    tv_key = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));
    arr_idx = duk__push_tval_to_property_key(thr, tv_key, &key);
    do { } while (0);

    if (duk__get_own_propdesc_raw(thr, h_target, key, arr_idx, &desc, 0 )) {

     duk_small_int_t desc_reject;

     do { } while (0)





                                             ;

     desc_reject = !(desc.flags & (1U << 2));
     if (desc_reject) {

      do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 4709; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("proxy rejected"))); } while (0); } while (0);
      do { return 0; } while (0);
     }
    }
    rc = 1;
    goto done_rc;
   }

   obj = h_target;
  }


  arr_idx = duk__to_property_key(thr, -1, &key);
  do { } while (0);

  rc = duk_hobject_delprop_raw(thr, obj, key, throw_flag ? (1U << 0) : 0);
  goto done_rc;
 } else if (((tv_obj)->t == 8)) {







  duk_hstring *h = ((tv_obj)->v.hstring);
  do { } while (0);

  arr_idx = duk__to_property_key(thr, -1, &key);
  do { } while (0);

  if (key == (((thr))->strs[(87)])) {
   goto fail_not_configurable;
  }

  if (arr_idx != (0xffffffffUL) && arr_idx < duk_hstring_get_charlen((h))) {
   goto fail_not_configurable;
  }
 } else if (((tv_obj)->t == 10)) {




  duk_hbuffer *h = ((tv_obj)->v.hbuffer);
  do { } while (0);

  arr_idx = duk__to_property_key(thr, -1, &key);
  do { } while (0);

  if (key == (((thr))->strs[(87)])) {
   goto fail_not_configurable;
  }

  if (arr_idx != (0xffffffffUL) && arr_idx < (((duk_hbuffer *) (h))->size)) {
   goto fail_not_configurable;
  }
 } else if (((tv_obj)->t == 6)) {




  arr_idx = duk__to_property_key(thr, -1, &key);
  do { } while (0);
  do { (void) (key); } while (0);
 }


 rc = 1;
 goto done_rc;

done_rc:
 duk_set_top_unsafe(thr, entry_top);
 return rc;

fail_invalid_base_uncond:

 do { } while (0);



 do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 4789; do { } while (0); do { } while (0); duk_err_handle_error_fmt((thr), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("cannot delete property %s of %s"), (duk_push_string_tval_readable(thr, tv_key)), (duk_push_string_tval_readable(thr, tv_obj))); } while (0)



                                                           ;

 do { return 0; } while (0);


fail_proxy_rejected:
 if (throw_flag) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 4800; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("proxy rejected"))); } while (0); } while (0);
  do { return 0; } while (0);
 }
 duk_set_top_unsafe(thr, entry_top);
 return 0;


fail_not_configurable:
 if (throw_flag) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 4809; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not configurable"))); } while (0); } while (0);
  do { return 0; } while (0);
 }
 duk_set_top_unsafe(thr, entry_top);
 return 0;
}
# 4835 "duk_hobject_props.c"
static __attribute__ ((unused)) void duk_hobject_define_property_internal(duk_hthread *thr,
                                                       duk_hobject *obj,
                                                       duk_hstring *key,
                                                       duk_small_uint_t flags) {
 duk_propdesc desc;
 duk_uint32_t arr_idx;
 duk_int_t e_idx;
 duk_tval *tv1 = 
# 4842 "duk_hobject_props.c" 3 4
                ((void *)0)
# 4842 "duk_hobject_props.c"
                    ;
 duk_tval *tv2 = 
# 4843 "duk_hobject_props.c" 3 4
                ((void *)0)
# 4843 "duk_hobject_props.c"
                    ;
 duk_small_uint_t propflags = flags & ((1U << 0) | (1U << 1) | (1U << 2) | (1U << 3));

 do { } while (0)




                                                          ;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 ;
 do { } while (0);

 arr_idx = ((key)->arridx);

 if (duk__get_own_propdesc_raw(thr, obj, key, arr_idx, &desc, 0 )) {
  if (desc.e_idx >= 0) {
   if (flags & (1U << 4)) {
    do { } while (0);
    goto pop_exit;
   }
   do { } while (0);
   if (__builtin_expect(((((((duk_uint8_t *) (void *) ((((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))[((desc.e_idx))]) & (1U << 3)) != 0)), 0)) {
    do { } while (0);
    goto error_internal;
   }

   do { (((duk_uint8_t *) (void *) ((((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))[((desc.e_idx))]) = (duk_uint8_t) (propflags); } while (0);
   tv1 = (&(((duk_propvalue *) (void *) ((((((obj))))->props)))[((desc.e_idx))]).v);
  } else if (desc.a_idx >= 0) {
   if (flags & (1U << 4)) {
    do { } while (0);
    goto pop_exit;
   }
   do { } while (0);
   if (propflags != ((1U << 0) | (1U << 1) | (1U << 2))) {
    do { } while (0)
                                                ;
    goto error_internal;
   }

   tv1 = (&((duk_tval *) (void *) (((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07)))[(desc.a_idx)]);
  } else {
   if (flags & (1U << 4)) {
    do { } while (0);
    goto pop_exit;
   }
   if (key == (((thr))->strs[(87)]) && (((&(obj)->hdr)->h_flags & ((1UL << (7 + (15))))) != 0)) {
    duk_uint32_t new_len;




    new_len = duk__to_new_array_length_checked(thr, ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)));
    ((duk_harray *) obj)->length = new_len;
    do { } while (0)

                                                            ;
    goto pop_exit;
   }
   do { } while (0);
   goto error_virtual;
  }

  goto write_value;
 }

 if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (8))))) != 0)) {
  if (arr_idx != (0xffffffffUL)) {
   do { } while (0)
                                                           ;
   do { } while (0);

   tv1 = duk__obtain_arridx_slot(thr, arr_idx, obj);
   if (tv1 == 
# 4922 "duk_hobject_props.c" 3 4
             ((void *)0)
# 4922 "duk_hobject_props.c"
                 ) {
    do { } while (0);
    goto write_to_entry_part;
   }

   tv1 = (&((duk_tval *) (void *) (((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07)))[(arr_idx)]);
   goto write_value;
  }
 }

write_to_entry_part:
 do { } while (0)
                                                                                                                   ;
 e_idx = duk__hobject_alloc_entry_checked(thr, obj, key);
 do { } while (0);
 do { (((duk_uint8_t *) (void *) ((((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))[((e_idx))]) = (duk_uint8_t) (propflags); } while (0);
 tv1 = (&(((duk_propvalue *) (void *) ((((((obj))))->props)))[((e_idx))]).v);

 do { duk_tval *duk__tv; duk__tv = (tv1); duk__tv->t = 2; } while (0);
 goto write_value;

write_value:


 tv2 = duk_require_tval(thr, -1);
 do { } while (0);

 do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv1); tv__src = (tv2); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((tv__dst))->t & 0x08)) { h__obj = ((tv__dst)->v.heaphdr); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);
 goto pop_exit;

pop_exit:
 duk_pop_unsafe(thr);
 return;

error_virtual:
error_internal:
 do { duk_err_error_internal((thr), "duk_hobject_props.c", (duk_int_t) 4958); } while (0);
 do { return; } while (0);
}







static __attribute__ ((unused)) void duk_hobject_define_property_internal_arridx(duk_hthread *thr,
                                                              duk_hobject *obj,
                                                              duk_uarridx_t arr_idx,
                                                              duk_small_uint_t flags) {
 duk_hstring *key;
 duk_tval *tv1, *tv2;

 do { } while (0)





                                                          ;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (8))))) != 0) && arr_idx != (0xffffffffUL) && flags == ((1U << 0) | (1U << 1) | (1U << 2))) {
  do { } while (0);

  do { } while (0);

  tv1 = duk__obtain_arridx_slot(thr, arr_idx, obj);
  if (tv1 == 
# 4994 "duk_hobject_props.c" 3 4
            ((void *)0)
# 4994 "duk_hobject_props.c"
                ) {
   do { } while (0);
   goto write_slow;
  }
  tv2 = duk_require_tval(thr, -1);

  do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv1); tv__src = (tv2); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((tv__dst))->t & 0x08)) { h__obj = ((tv__dst)->v.heaphdr); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);

  duk_pop_unsafe(thr);
  return;
 }

write_slow:
 do { } while (0);

 key = duk_push_uint_to_hstring(thr, (duk_uint_t) arr_idx);
 do { } while (0);
 duk_insert(thr, -2);

 duk_hobject_define_property_internal(thr, obj, key, flags);

 duk_pop_unsafe(thr);
}





static __attribute__ ((unused)) duk_size_t duk_hobject_get_length(duk_hthread *thr, duk_hobject *obj) {
 duk_double_t val;

 do { } while (0);
 do { } while (0);


 if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (15))))) != 0)) {
  return ((duk_harray *) obj)->length;
 }


 duk_push_hobject(thr, obj);
 duk_push_hstring_stridx(thr, 87);
 (void) duk_hobject_getprop(thr, ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-2)), ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)));
 val = duk_to_number_m1(thr);
 duk_pop_3_unsafe(thr);




 if (val >= 0.0 && val <= (duk_double_t) 
# 5043 "duk_hobject_props.c" 3 4
                                        (18446744073709551615UL)
# 5043 "duk_hobject_props.c"
                                                    ) {
  return (duk_size_t) val;
 }
 return 0;
}
# 5058 "duk_hobject_props.c"
static __attribute__ ((unused)) duk_bool_t duk_hobject_has_finalizer_fast_raw(duk_hobject *obj) {

 duk_uint_t sanity;

 do { } while (0);

 sanity = 10000L;
 do {
  if (__builtin_expect(((((&(obj)->hdr)->h_flags & ((1UL << (7 + (14))))) != 0)), 0)) {
   return 1;
  }
  if (__builtin_expect((sanity-- == 0), 0)) {
   do { } while (0);
   return 0;
  }




  obj = ((obj)->prototype);

 } while (obj != 
# 5079 "duk_hobject_props.c" 3 4
                ((void *)0)
# 5079 "duk_hobject_props.c"
                    );

 return 0;
}







static __attribute__ ((unused)) void duk_hobject_object_get_own_property_descriptor(duk_hthread *thr, duk_idx_t obj_idx) {
 duk_hobject *obj;
 duk_hstring *key;
 duk_propdesc pd;

 do { } while (0);
 do { } while (0);

 obj = duk_require_hobject_promote_mask(thr, obj_idx, (1U << 9U) | (1U << 7U));
 key = duk_to_property_key_hstring(thr, -1);
 do { } while (0);

 ;

 if (!duk_hobject_get_own_propdesc(thr, obj, key, &pd, (1U << 0))) {
  duk_push_undefined(thr);
  duk_remove_m2(thr);
  return;
 }

 duk_push_object(thr);



 if ((((&pd)->flags & (1U << 3)) != 0)) {



  if (pd.get) {
   duk_push_hobject(thr, pd.get);
  } else {
   duk_push_undefined(thr);
  }
  (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (73))));
  if (pd.set) {
   duk_push_hobject(thr, pd.set);
  } else {
   duk_push_undefined(thr);
  }
  (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (88))));
 } else {
  duk_dup_m2(thr);
  (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (34))));
  duk_push_boolean(thr, (((&pd)->flags & (1U << 0)) != 0));
  (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (35))));
 }
 duk_push_boolean(thr, (((&pd)->flags & (1U << 1)) != 0));
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (37))));
 duk_push_boolean(thr, (((&pd)->flags & (1U << 2)) != 0));
 (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (36))));



 duk_replace(thr, -3);
 duk_pop_unsafe(thr);
}
# 5163 "duk_hobject_props.c"
static __attribute__ ((unused))
void duk_hobject_prepare_property_descriptor(duk_hthread *thr,
                                             duk_idx_t idx_in,
                                             duk_uint_t *out_defprop_flags,
                                             duk_idx_t *out_idx_value,
                                             duk_hobject **out_getter,
                                             duk_hobject **out_setter) {
 duk_idx_t idx_value = -1;
 duk_hobject *getter = 
# 5171 "duk_hobject_props.c" 3 4
                      ((void *)0)
# 5171 "duk_hobject_props.c"
                          ;
 duk_hobject *setter = 
# 5172 "duk_hobject_props.c" 3 4
                      ((void *)0)
# 5172 "duk_hobject_props.c"
                          ;
 duk_bool_t is_data_desc = 0;
 duk_bool_t is_acc_desc = 0;
 duk_uint_t defprop_flags = 0;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 idx_in = duk_require_normalize_index(thr, idx_in);
 (void) duk_require_hobject(thr, idx_in);







 if (duk_get_prop_stridx(thr, idx_in, 34)) {
  is_data_desc = 1;
  defprop_flags |= (1U << 6);
  idx_value = duk_get_top_index(thr);
 }

 if (duk_get_prop_stridx(thr, idx_in, 35)) {
  is_data_desc = 1;
  if (duk_to_boolean_top_pop(thr)) {
   defprop_flags |= (1U << 3) | (1U << 0);
  } else {
   defprop_flags |= (1U << 3);
  }
 }

 if (duk_get_prop_stridx(thr, idx_in, 73)) {
  duk_tval *tv = duk_require_tval(thr, -1);
  duk_hobject *h_get;

  if (((tv)->t == 2)) {

   do { } while (0);
  } else {




   h_get = duk_get_hobject_promote_mask((thr), (-1), (1U << 9U));
   if (h_get == 
# 5221 "duk_hobject_props.c" 3 4
               ((void *)0) 
# 5221 "duk_hobject_props.c"
                    || !(((&((h_get))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)) {
    goto type_error;
   }
   getter = h_get;
  }
  is_acc_desc = 1;
  defprop_flags |= (1U << 7);
 }

 if (duk_get_prop_stridx(thr, idx_in, 88)) {
  duk_tval *tv = duk_require_tval(thr, -1);
  duk_hobject *h_set;

  if (((tv)->t == 2)) {

   do { } while (0);
  } else {




   h_set = duk_get_hobject_promote_mask((thr), (-1), (1U << 9U));
   if (h_set == 
# 5243 "duk_hobject_props.c" 3 4
               ((void *)0) 
# 5243 "duk_hobject_props.c"
                    || !(((&((h_set))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)) {
    goto type_error;
   }
   setter = h_set;
  }
  is_acc_desc = 1;
  defprop_flags |= (1U << 8);
 }

 if (duk_get_prop_stridx(thr, idx_in, 37)) {
  if (duk_to_boolean_top_pop(thr)) {
   defprop_flags |= (1U << 4) | (1U << 1);
  } else {
   defprop_flags |= (1U << 4);
  }
 }

 if (duk_get_prop_stridx(thr, idx_in, 36)) {
  if (duk_to_boolean_top_pop(thr)) {
   defprop_flags |= (1U << 5) | (1U << 2);
  } else {
   defprop_flags |= (1U << 5);
  }
 }

 if (is_data_desc && is_acc_desc) {
  goto type_error;
 }

 *out_defprop_flags = defprop_flags;
 *out_idx_value = idx_value;
 *out_getter = getter;
 *out_setter = setter;


 return;

type_error:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 5281; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid descriptor"))); } while (0); } while (0);
 do { return; } while (0);
}
# 5305 "duk_hobject_props.c"
static __attribute__ ((unused))
duk_bool_t duk_hobject_define_property_helper(duk_hthread *thr,
                                              duk_uint_t defprop_flags,
                                              duk_hobject *obj,
                                              duk_hstring *key,
                                              duk_idx_t idx_value,
                                              duk_hobject *get,
                                              duk_hobject *set,
                                              duk_bool_t throw_flag) {
 duk_uint32_t arr_idx;
 duk_tval tv;
 duk_bool_t has_enumerable;
 duk_bool_t has_configurable;
 duk_bool_t has_writable;
 duk_bool_t has_value;
 duk_bool_t has_get;
 duk_bool_t has_set;
 duk_bool_t is_enumerable;
 duk_bool_t is_configurable;
 duk_bool_t is_writable;
 duk_bool_t force_flag;
 duk_small_uint_t new_flags;
 duk_propdesc curr;
 duk_uint32_t arridx_new_array_length;
 duk_uint32_t arrlen_old_len;
 duk_uint32_t arrlen_new_len;
 duk_bool_t pending_write_protect;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 ;



 has_writable = (defprop_flags & (1U << 3));
 has_enumerable = (defprop_flags & (1U << 4));
 has_configurable = (defprop_flags & (1U << 5));
 has_value = (defprop_flags & (1U << 6));
 has_get = (defprop_flags & (1U << 7));
 has_set = (defprop_flags & (1U << 8));
 is_writable = (defprop_flags & (1U << 0));
 is_enumerable = (defprop_flags & (1U << 1));
 is_configurable = (defprop_flags & (1U << 2));
 force_flag = (defprop_flags & (1U << 9));

 arr_idx = ((key)->arridx);

 arridx_new_array_length = 0;
 pending_write_protect = 0;
 arrlen_old_len = 0;
 arrlen_new_len = 0;

 do { } while (0)
# 5383 "duk_hobject_props.c"
                                         ;







 if (!(((&(obj)->hdr)->h_flags & ((1UL << (7 + (15))))) != 0)) {
  goto skip_array_exotic;
 }

 if (key == (((thr))->strs[(87)])) {
  duk_harray *a;


  if (!has_value) {
   do { } while (0);
   goto skip_array_exotic;
  }

  do { } while (0);





  a = (duk_harray *) obj;
  do { } while (0);
  arrlen_old_len = a->length;

  do { } while (0);
  arrlen_new_len = duk__to_new_array_length_checked(thr, ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (idx_value)));
  duk_push_uint((thr), (duk_uint_t) (arrlen_new_len));
  duk_replace(thr, idx_value);

  do { } while (0);

  if (arrlen_new_len >= arrlen_old_len) {

   do { } while (0);
   goto skip_array_exotic;
  }
  do { } while (0);


  if (((a)->length_nonwritable) && !force_flag) {



   goto fail_not_configurable;
  }


  if (has_writable && !is_writable) {
   do { } while (0);
   is_writable = 1;
   pending_write_protect = 1;
  }


 } else if (arr_idx != (0xffffffffUL)) {



  duk_uint32_t old_len;
  duk_harray *a;

  a = (duk_harray *) obj;
  do { } while (0);

  old_len = a->length;

  if (arr_idx >= old_len) {
   do { } while (0)


                                        ;

   if (((a)->length_nonwritable) && !force_flag) {




    goto fail_not_configurable;
   }




   do { } while (0);
   arridx_new_array_length = arr_idx + 1;
  } else {
   do { } while (0)


                                        ;
  }
 }
skip_array_exotic:
# 5500 "duk_hobject_props.c"
 if (!duk__get_own_propdesc_raw(thr, obj, key, arr_idx, &curr, (1U << 0))) {
  do { } while (0);

  if (!(((&(obj)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0) && !force_flag) {
   goto fail_not_extensible;
  }
# 5524 "duk_hobject_props.c"
  if (has_set || has_get) {
   duk_int_t e_idx;

   do { } while (0);

   do { } while (0);
   do { } while (0);
   do { } while (0);
   do { } while (0);

   new_flags = (1U << 3);
   if (has_enumerable && is_enumerable) {
    new_flags |= (1U << 1);
   }
   if (has_configurable && is_configurable) {
    new_flags |= (1U << 2);
   }

   if (arr_idx != (0xffffffffUL) && (((&(obj)->hdr)->h_flags & ((1UL << (7 + (8))))) != 0)) {
    do { } while (0);
    duk__abandon_array_part(thr, obj);
   }


   e_idx = duk__hobject_alloc_entry_checked(thr, obj, key);
   do { } while (0);

   do { (((duk_propvalue *) (void *) ((((((obj))))->props)))[((e_idx))]).a.get = (get); } while (0);
   do { (((duk_propvalue *) (void *) ((((((obj))))->props)))[((e_idx))]).a.set = (set); } while (0);
   do { if ((get) != 
# 5553 "duk_hobject_props.c" 3 4
  ((void *)0)
# 5553 "duk_hobject_props.c"
  ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((get)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0);
   do { if ((set) != 
# 5554 "duk_hobject_props.c" 3 4
  ((void *)0)
# 5554 "duk_hobject_props.c"
  ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((set)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0);

   do { (((duk_uint8_t *) (void *) ((((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))[((e_idx))]) = (duk_uint8_t) (new_flags); } while (0);
   goto success_exotics;
  } else {
   duk_int_t e_idx;
   duk_tval *tv2;

   do { } while (0);

   do { } while (0);
   do { } while (0);

   new_flags = 0;
   if (has_writable && is_writable) {
    new_flags |= (1U << 0);
   }
   if (has_enumerable && is_enumerable) {
    new_flags |= (1U << 1);
   }
   if (has_configurable && is_configurable) {
    new_flags |= (1U << 2);
   }
   if (has_value) {
    duk_tval *tv_tmp = duk_require_tval(thr, idx_value);
    do { *(&tv) = *(tv_tmp); } while (0);
   } else {
    do { duk_tval *duk__tv; duk__tv = (&tv); duk__tv->t = 2; } while (0);
   }

   if (arr_idx != (0xffffffffUL) && (((&(obj)->hdr)->h_flags & ((1UL << (7 + (8))))) != 0)) {
    if (new_flags == ((1U << 0) | (1U << 1) | (1U << 2))) {
     do { } while (0)
                                                                                              ;
     tv2 = duk__obtain_arridx_slot(thr, arr_idx, obj);
     if (tv2 == 
# 5589 "duk_hobject_props.c" 3 4
               ((void *)0)
# 5589 "duk_hobject_props.c"
                   ) {
      do { } while (0);
     } else {
      do { } while (0);
      do { } while (0);
      do { } while (0);
      do { *(tv2) = *(&tv); } while (0);
      do { duk_tval *duk__tv = ((tv2)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
      goto success_exotics;
     }
    } else {
     do { } while (0);
     duk__abandon_array_part(thr, obj);
    }

   }


   e_idx = duk__hobject_alloc_entry_checked(thr, obj, key);
   do { } while (0);
   tv2 = (&(((duk_propvalue *) (void *) ((((((obj))))->props)))[((e_idx))]).v);
   do { *(tv2) = *(&tv); } while (0);
   do { duk_tval *duk__tv = ((tv2)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);

   do { (((duk_uint8_t *) (void *) ((((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))[((e_idx))]) = (duk_uint8_t) (new_flags); } while (0);
   goto success_exotics;
  }
  do { __builtin_unreachable(); } while (0);
 }


 do { } while (0);
# 5629 "duk_hobject_props.c"
 if (has_enumerable) {
  if (is_enumerable) {
   if (!(curr.flags & (1U << 1))) {
    goto need_check;
   }
  } else {
   if (curr.flags & (1U << 1)) {
    goto need_check;
   }
  }
 }
 if (has_configurable) {
  if (is_configurable) {
   if (!(curr.flags & (1U << 2))) {
    goto need_check;
   }
  } else {
   if (curr.flags & (1U << 2)) {
    goto need_check;
   }
  }
 }
 if (has_value) {
  duk_tval *tmp1;
  duk_tval *tmp2;


  if (curr.flags & (1U << 3)) {
   goto need_check;
  }

  tmp1 = duk_require_tval(thr, -1);
  tmp2 = duk_require_tval(thr, idx_value);
  if (!duk_js_equals_helper(
# 5662 "duk_hobject_props.c" 3 4
      ((void *)0)
# 5662 "duk_hobject_props.c"
      , (tmp1), (tmp2), (1U << 0))) {
   goto need_check;
  }
 }
 if (has_writable) {

  if (curr.flags & (1U << 3)) {
   goto need_check;
  }

  if (is_writable) {
   if (!(curr.flags & (1U << 0))) {
    goto need_check;
   }
  } else {
   if (curr.flags & (1U << 0)) {
    goto need_check;
   }
  }
 }
 if (has_set) {
  if (curr.flags & (1U << 3)) {
   if (set != curr.set) {
    goto need_check;
   }
  } else {
   goto need_check;
  }
 }
 if (has_get) {
  if (curr.flags & (1U << 3)) {
   if (get != curr.get) {
    goto need_check;
   }
  } else {
   goto need_check;
  }
 }




 goto success_no_exotics;

need_check:






 if (!(curr.flags & (1U << 2)) && !force_flag) {
  if (has_configurable && is_configurable) {
   goto fail_not_configurable;
  }
  if (has_enumerable) {
   if (curr.flags & (1U << 1)) {
    if (!is_enumerable) {
     goto fail_not_configurable;
    }
   } else {
    if (is_enumerable) {
     goto fail_not_configurable;
    }
   }
  }
 }
# 5752 "duk_hobject_props.c"
 if (has_set || has_get) {

  do { } while (0);
  do { } while (0);

  if (curr.flags & (1U << 3)) {

   if (!(curr.flags & (1U << 2)) && !force_flag) {
    if (has_set && set != curr.set) {
     goto fail_not_configurable;
    }
    if (has_get && get != curr.get) {
     goto fail_not_configurable;
    }
   }
  } else {
   duk_bool_t rc;
   duk_tval *tv1;


   if (!(curr.flags & (1U << 2)) && !force_flag) {
    goto fail_not_configurable;
   }

   do { } while (0);
   if (curr.a_idx >= 0) {
    do { } while (0)
                                                                                                     ;
    duk__abandon_array_part(thr, obj);
    duk_pop_unsafe(thr);
    rc = duk__get_own_propdesc_raw(thr, obj, key, arr_idx, &curr, (1U << 0));
    do { (void) (rc); } while (0);
    do { } while (0);
    do { } while (0);
   }
   if (curr.e_idx < 0) {
    do { } while (0);
    goto fail_virtual;
   }

   do { } while (0);
   do { } while (0);

   tv1 = (&(((duk_propvalue *) (void *) ((((((obj))))->props)))[((curr.e_idx))]).v);
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv1); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 2; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz((((thr))), duk__h); } } } while (0); } while (0);

   do { (((duk_propvalue *) (void *) ((((((obj))))->props)))[((curr.e_idx))]).a.get = (
# 5798 "duk_hobject_props.c" 3 4
  ((void *)0)
# 5798 "duk_hobject_props.c"
  ); } while (0);
   do { (((duk_propvalue *) (void *) ((((((obj))))->props)))[((curr.e_idx))]).a.set = (
# 5799 "duk_hobject_props.c" 3 4
  ((void *)0)
# 5799 "duk_hobject_props.c"
  ); } while (0);
   do { ((duk_uint8_t *) (void *) ((((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))[((curr.e_idx))] &= ~((1U << 0)); } while (0);
   do { ((duk_uint8_t *) (void *) ((((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))[((curr.e_idx))] |= ((1U << 3)); } while (0);

   do { } while (0)
                                                                                             ;

   curr.flags &= ~(1U << 0);
   curr.flags |= (1U << 3);
  }
 } else if (has_value || has_writable) {

  do { } while (0);
  do { } while (0);

  if (curr.flags & (1U << 3)) {
   duk_hobject *tmp;


   if (!(curr.flags & (1U << 2)) && !force_flag) {
    goto fail_not_configurable;
   }


   do { } while (0);
   if (curr.e_idx < 0) {
    goto fail_virtual;
   }

   do { } while (0);

   do { } while (0);
   tmp = ((((duk_propvalue *) (void *) ((((((obj))))->props)))[((curr.e_idx))]).a.get);
   do { (void) (tmp); } while (0);
   do { (((duk_propvalue *) (void *) ((((((obj))))->props)))[((curr.e_idx))]).a.get = (
# 5833 "duk_hobject_props.c" 3 4
  ((void *)0)
# 5833 "duk_hobject_props.c"
  ); } while (0);
   do { if ((tmp) != 
# 5834 "duk_hobject_props.c" 3 4
  ((void *)0)
# 5834 "duk_hobject_props.c"
  ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((tmp))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
   tmp = ((((duk_propvalue *) (void *) ((((((obj))))->props)))[((curr.e_idx))]).a.set);
   do { (void) (tmp); } while (0);
   do { (((duk_propvalue *) (void *) ((((((obj))))->props)))[((curr.e_idx))]).a.set = (
# 5837 "duk_hobject_props.c" 3 4
  ((void *)0)
# 5837 "duk_hobject_props.c"
  ); } while (0);
   do { if ((tmp) != 
# 5838 "duk_hobject_props.c" 3 4
  ((void *)0)
# 5838 "duk_hobject_props.c"
  ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((tmp))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);

   do { duk_tval *duk__tv; duk__tv = ((&(((duk_propvalue *) (void *) ((((((obj))))->props)))[((curr.e_idx))]).v)); duk__tv->t = 2; } while (0);
   do { ((duk_uint8_t *) (void *) ((((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))[((curr.e_idx))] &= ~((1U << 0)); } while (0);
   do { ((duk_uint8_t *) (void *) ((((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))[((curr.e_idx))] &= ~((1U << 3)); } while (0);

   do { } while (0)
                                                                                             ;


   curr.flags &= ~((1U << 0) | (1U << 3));
  } else {

   if (!(curr.flags & (1U << 2)) && !force_flag) {
    if (!(curr.flags & (1U << 0)) && has_writable && is_writable) {
     goto fail_not_configurable;
    }

    if (!(curr.flags & (1U << 0)) && has_value) {
     duk_tval *tmp1 = duk_require_tval(thr, -1);
     duk_tval *tmp2 = duk_require_tval(thr, idx_value);
     if (!duk_js_equals_helper(
# 5859 "duk_hobject_props.c" 3 4
         ((void *)0)
# 5859 "duk_hobject_props.c"
         , (tmp1), (tmp2), (1U << 0))) {
      goto fail_not_configurable;
     }
    }
   }
  }
 } else {





  do { } while (0);
 }
# 5881 "duk_hobject_props.c"
 new_flags = curr.flags;

 if (has_enumerable) {
  if (is_enumerable) {
   new_flags |= (1U << 1);
  } else {
   new_flags &= ~(1U << 1);
  }
 }
 if (has_configurable) {
  if (is_configurable) {
   new_flags |= (1U << 2);
  } else {
   new_flags &= ~(1U << 2);
  }
 }
 if (has_writable) {
  if (is_writable) {
   new_flags |= (1U << 0);
  } else {
   new_flags &= ~(1U << 0);
  }
 }



 do { } while (0);





 if (curr.a_idx >= 0) {
  duk_bool_t rc;

  do { } while (0);

  if (new_flags == ((1U << 0) | (1U << 1) | (1U << 2))) {
   duk_tval *tv1, *tv2;

   do { } while (0);

   do { } while (0);
   do { } while (0);
   do { } while (0);
   do { } while (0)

         ;

   tv2 = duk_require_tval(thr, idx_value);
   tv1 = (&((duk_tval *) (void *) (((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07)))[(curr.a_idx)]);
   do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv1); tv__src = (tv2); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((tv__dst))->t & 0x08)) { h__obj = ((tv__dst)->v.heaphdr); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);
   goto success_exotics;
  }

  do { } while (0)
                                                                                                                    ;
  duk__abandon_array_part(thr, obj);
  duk_pop_unsafe(thr);
  rc = duk__get_own_propdesc_raw(thr, obj, key, arr_idx, &curr, (1U << 0));
  do { (void) (rc); } while (0);
  do { } while (0);
  do { } while (0);
 }

 do { } while (0);




 do { } while (0);

 do { } while (0);
 if (curr.e_idx >= 0) {
  do { (((duk_uint8_t *) (void *) ((((((obj))))->props) + (((((obj))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))[((curr.e_idx))]) = (duk_uint8_t) (new_flags); } while (0);
 } else {



  if (key == (((thr))->strs[(87)]) && (((&(obj)->hdr)->h_flags & ((1UL << (7 + (15))))) != 0)) {
   duk_harray *a;
   a = (duk_harray *) obj;
   do { } while (0)
                                                 ;
   do { } while (0);
   if ((new_flags & ((1U << 1) | (1U << 2))) != (curr.flags & ((1U << 1) | (1U << 2)))) {
    do { } while (0)
                                                     ;
    goto fail_virtual;
   }
   if (new_flags & (1U << 0)) {
    do { (a)->length_nonwritable = 0; } while (0);
   } else {
    do { (a)->length_nonwritable = 1; } while (0);
   }
  }
 }

 if (has_set) {
  duk_hobject *tmp;




  if (curr.e_idx < 0) {
   goto fail_virtual;
  }

  do { } while (0);
  do { } while (0);

  tmp = ((((duk_propvalue *) (void *) ((((((obj))))->props)))[((curr.e_idx))]).a.set);
  do { (void) (tmp); } while (0);
  do { (((duk_propvalue *) (void *) ((((((obj))))->props)))[((curr.e_idx))]).a.set = (set); } while (0);
  do { if ((set) != 
# 5995 "duk_hobject_props.c" 3 4
 ((void *)0)
# 5995 "duk_hobject_props.c"
 ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((set)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0);
  do { if ((tmp) != 
# 5996 "duk_hobject_props.c" 3 4
 ((void *)0)
# 5996 "duk_hobject_props.c"
 ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((tmp))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
 }
 if (has_get) {
  duk_hobject *tmp;

  if (curr.e_idx < 0) {
   goto fail_virtual;
  }

  do { } while (0);
  do { } while (0);

  tmp = ((((duk_propvalue *) (void *) ((((((obj))))->props)))[((curr.e_idx))]).a.get);
  do { (void) (tmp); } while (0);
  do { (((duk_propvalue *) (void *) ((((((obj))))->props)))[((curr.e_idx))]).a.get = (get); } while (0);
  do { if ((get) != 
# 6011 "duk_hobject_props.c" 3 4
 ((void *)0)
# 6011 "duk_hobject_props.c"
 ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((get)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0);
  do { if ((tmp) != 
# 6012 "duk_hobject_props.c" 3 4
 ((void *)0)
# 6012 "duk_hobject_props.c"
 ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((tmp))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
 }
 if (has_value) {
  duk_tval *tv1, *tv2;

  do { } while (0);

  if (curr.e_idx >= 0) {
   do { } while (0);
   tv2 = duk_require_tval(thr, idx_value);
   tv1 = (&(((duk_propvalue *) (void *) ((((((obj))))->props)))[((curr.e_idx))]).v);
   do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv1); tv__src = (tv2); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((tv__dst))->t & 0x08)) { h__obj = ((tv__dst)->v.heaphdr); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);
  } else {
   do { } while (0);

   do { } while (0);



   if (key == (((thr))->strs[(87)]) && (((&(obj)->hdr)->h_flags & ((1UL << (7 + (15))))) != 0)) {
    duk_harray *a;
    a = (duk_harray *) obj;
    do { } while (0)
                                              ;
    do { } while (0);
    a->length = arrlen_new_len;
   } else {
    goto fail_virtual;
   }
  }
 }
# 6056 "duk_hobject_props.c"
success_exotics:







 if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (15))))) != 0)) {
  duk_harray *a;

  a = (duk_harray *) obj;
  do { } while (0);

  if (arridx_new_array_length > 0) {







   do { } while (0)
                                                        ;

   a->length = arridx_new_array_length;
  }

  if (key == (((thr))->strs[(87)]) && arrlen_new_len < arrlen_old_len) {
# 6094 "duk_hobject_props.c"
   duk_uint32_t result_len;
   duk_bool_t rc;

   do { } while (0)
                                                                          ;

   rc =
       duk__handle_put_array_length_smaller(thr, obj, arrlen_old_len, arrlen_new_len, force_flag, &result_len);


   do { } while (0);

   a->length = result_len;

   if (pending_write_protect) {
    do { } while (0);
    do { (a)->length_nonwritable = 1; } while (0);
   }


   if (!rc) {
    do { } while (0);
    goto fail_not_configurable;
   }
  }
 } else if (arr_idx != (0xffffffffUL) && (((&(obj)->hdr)->h_flags & ((1UL << (7 + (17))))) != 0)) {
  duk_hobject *map;
  duk_hobject *varenv;

  do { } while (0);
  do { } while (0);

  map = 
# 6126 "duk_hobject_props.c" 3 4
       ((void *)0)
# 6126 "duk_hobject_props.c"
           ;
  varenv = 
# 6127 "duk_hobject_props.c" 3 4
          ((void *)0)
# 6127 "duk_hobject_props.c"
              ;
  if (!duk__lookup_arguments_map(thr, obj, key, &curr, &map, &varenv)) {
   goto success_no_exotics;
  }
  do { } while (0);
  do { } while (0);



  if (has_set || has_get) {

   do { } while (0)
                                                                            ;

   (void) duk_hobject_delprop_raw(thr, map, key, 0);
  } else {

   do { } while (0)
                                                                     ;

   if (has_value) {
    duk_hstring *varname;

    do { } while (0)
                                                                   ;

    varname = duk_require_hstring(thr, -1);
    do { } while (0);

    do { } while (0)



                                                                        ;


    duk_js_putvar_envrec(thr, varenv, varname, duk_require_tval(thr, idx_value), 1 );
   }
   if (has_writable && !is_writable) {
    do { } while (0)
                                                                              ;

    (void) duk_hobject_delprop_raw(thr, map, key, 0);
   }
  }




 }

success_no_exotics:



 do { duk_refzero_check_slow((thr)); } while (0);
 return 1;

fail_not_extensible:
 if (throw_flag) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 6187; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not extensible"))); } while (0); } while (0);
  do { return 0; } while (0);
 }
 return 0;

fail_virtual:
fail_not_configurable:
 if (throw_flag) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 6195; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_hobject_props.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("not configurable"))); } while (0); } while (0);
  do { return 0; } while (0);
 }
 return 0;
}





static __attribute__ ((unused)) duk_bool_t duk_hobject_object_ownprop_helper(duk_hthread *thr, duk_small_uint_t required_desc_flags) {
 duk_hstring *h_v;
 duk_hobject *h_obj;
 duk_propdesc desc;
 duk_bool_t ret;


 h_v = duk_to_hstring_acceptsymbol(thr, 0);
 do { } while (0);

 h_obj = duk_push_this_coercible_to_object(thr);
 do { } while (0);

 ret = duk_hobject_get_own_propdesc(thr, h_obj, h_v, &desc, 0 );

 duk_push_boolean(thr, ret && ((desc.flags & required_desc_flags) == required_desc_flags));
 return 1;
}
# 6239 "duk_hobject_props.c"
static __attribute__ ((unused)) void duk_hobject_object_seal_freeze_helper(duk_hthread *thr, duk_hobject *obj, duk_bool_t is_freeze) {
 duk_uint_fast32_t i;

 do { } while (0);
 do { } while (0);
 do { } while (0);

 ;
# 6263 "duk_hobject_props.c"
 duk__abandon_array_part(thr, obj);
 do { } while (0);

 for (i = 0; i < ((obj)->e_next); i++) {
  duk_uint8_t *fp;


  do { } while (0);


  fp = (&((duk_uint8_t *) (void *) (((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))[(i)]);
  if (is_freeze && !((*fp) & (1U << 3))) {
   *fp &= ~((1U << 0) | (1U << 2));
  } else {
   *fp &= ~(1U << 2);
  }
 }

 do { do { } while (0); (&(obj)->hdr)->h_flags &= ~(((1UL << (7 + (0))))); } while (0);





 return;
}
# 6301 "duk_hobject_props.c"
static __attribute__ ((unused)) duk_bool_t duk_hobject_object_is_sealed_frozen_helper(duk_hthread *thr, duk_hobject *obj, duk_bool_t is_frozen) {
 duk_uint_fast32_t i;

 do { } while (0);
 do { (void) (thr); } while (0);




 if ((((&(obj)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0)) {
  return 0;
 }






 for (i = 0; i < ((obj)->e_next); i++) {
  duk_small_uint_t flags;

  if (!(((duk_hstring **) (void *) (((((obj)))->props) + ((((obj)))->e_size) * sizeof(duk_propvalue)))[(i)])) {
   continue;
  }


  flags = (duk_small_uint_t) (((duk_uint8_t *) (void *) (((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))[(i)]);

  if (flags & (1U << 2)) {
   return 0;
  }
  if (is_frozen && !(flags & (1U << 3)) && (flags & (1U << 0))) {
   return 0;
  }
 }




 for (i = 0; i < ((obj)->a_size); i++) {
  duk_tval *tv = (&((duk_tval *) (void *) (((((obj)))->props) + ((((obj)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((obj)))->e_size))) & 0x07)))[(i)]);
  if (!((tv)->t == 7)) {
   return 0;
  }
 }

 return 1;
}
# 1 "duk_hstring_assert.c"
# 1 "duk_hstring_misc.c"
# 11 "duk_hstring_misc.c"
static __attribute__ ((unused)) duk_ucodepoint_t duk_hstring_char_code_at_raw(duk_hthread *thr,
                                                           duk_hstring *h,
                                                           duk_uint_t pos,
                                                           duk_bool_t surrogate_aware) {
 duk_uint32_t boff;
 const duk_uint8_t *p, *p_start, *p_end;
 duk_ucodepoint_t cp1;
 duk_ucodepoint_t cp2;


 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 boff = (duk_uint32_t) duk_heap_strcache_offset_char2byte(thr, h, (duk_uint32_t) pos);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 p_start = ((const duk_uint8_t *) ((h) + 1));
 p_end = p_start + ((h)->blen);
 p = p_start + boff;
 do { } while (0);




 if (duk_unicode_decode_xutf8(thr, &p, p_start, p_end, &cp1)) {
  if (surrogate_aware && cp1 >= 0xd800UL && cp1 <= 0xdbffUL) {




   cp2 = 0;
   (void) duk_unicode_decode_xutf8(thr, &p, p_start, p_end, &cp2);
   if (cp2 >= 0xdc00UL && cp2 <= 0xdfffUL) {
    cp1 = (duk_ucodepoint_t) (((cp1 - 0xd800UL) << 10) + (cp2 - 0xdc00UL) + 0x10000UL);
   }
  }
 } else {
  cp1 = 0xfffdL;
 }

 return cp1;
}
# 100 "duk_hstring_misc.c"
static __attribute__((cold)) duk_size_t duk__hstring_get_charlen_slowpath(duk_hstring *h) {
 duk_size_t res;

 do { } while (0);
# 114 "duk_hstring_misc.c"
 res = duk_unicode_unvalidated_utf8_length(((const duk_uint8_t *) ((h) + 1)), ((h)->blen));




 h->clen = (duk_uint32_t) res;

 if (__builtin_expect((res == ((h)->blen)), 1)) {
  do { do { } while (0); (&(h)->hdr)->h_flags |= ((1UL << (7 + (0)))); } while (0);
 }
 return res;
}
# 158 "duk_hstring_misc.c"
static __attribute__ ((unused)) __attribute__((hot)) duk_size_t duk_hstring_get_charlen(duk_hstring *h) {





 if (__builtin_expect((h->clen != 0), 1)) {
  return h->clen;
 }

 return duk__hstring_get_charlen_slowpath(h);
}
# 182 "duk_hstring_misc.c"
static __attribute__ ((unused)) duk_bool_t duk_hstring_equals_ascii_cstring(duk_hstring *h, const char *cstr) {
 duk_size_t len;

 do { } while (0);
 do { } while (0);

 len = strlen(cstr);
 if (len != ((h)->blen)) {
  return 0;
 }
 if (duk_memcmp((const void *) cstr, (const void *) ((const duk_uint8_t *) ((h) + 1)), len) == 0) {
  return 1;
 }
 return 0;
}
# 1 "duk_hthread_alloc.c"
# 13 "duk_hthread_alloc.c"
static __attribute__ ((unused)) duk_bool_t duk_hthread_init_stacks(duk_heap *heap, duk_hthread *thr) {
 duk_size_t alloc_size;
 duk_size_t i;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 do { } while (0);
 alloc_size = sizeof(duk_tval) * 96U;
 thr->valstack = (duk_tval *) duk_heap_mem_alloc((heap), (alloc_size));
 if (!thr->valstack) {
  goto fail;
 }
 do { void *duk__dst = (thr->valstack); duk_size_t duk__len = (alloc_size); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 thr->valstack_end = thr->valstack + 64U;
 thr->valstack_alloc_end = thr->valstack + 96U;
 thr->valstack_bottom = thr->valstack;
 thr->valstack_top = thr->valstack;

 for (i = 0; i < 96U; i++) {
  do { duk_tval *duk__tv; duk__tv = (&thr->valstack[i]); duk__tv->t = 2; } while (0);
 }

 return 1;

fail:
 duk_heap_mem_free((heap), (thr->valstack));
 do { } while (0);

 thr->valstack = 
# 49 "duk_hthread_alloc.c" 3 4
                ((void *)0)
# 49 "duk_hthread_alloc.c"
                    ;
 return 0;
}



static __attribute__ ((unused)) void *duk_hthread_get_valstack_ptr(duk_heap *heap, void *ud) {
 duk_hthread *thr = (duk_hthread *) ud;
 do { (void) (heap); } while (0);
 return (void *) thr->valstack;
}
# 1 "duk_hthread_builtins.c"
# 153 "duk_hthread_builtins.c"
static void duk__push_stridx(duk_hthread *thr, duk_bitdecoder_ctx *bd) {
 duk_small_uint_t n;

 n = (duk_small_uint_t) duk_bd_decode_varuint(bd);
 do { } while (0);
 do { } while (0);
 duk_push_hstring_stridx(thr, n);
}
static void duk__push_string(duk_hthread *thr, duk_bitdecoder_ctx *bd) {



 duk_uint8_t tmp[256];
 duk_small_uint_t len;

 len = duk_bd_decode_bitpacked_string(bd, tmp);
 duk_push_lstring(thr, (const char *) tmp, (duk_size_t) len);
}
static void duk__push_stridx_or_string(duk_hthread *thr, duk_bitdecoder_ctx *bd) {
 duk_small_uint_t n;

 n = (duk_small_uint_t) duk_bd_decode_varuint(bd);
 if (n == 0) {
  duk__push_string(thr, bd);
 } else {
  n--;
  do { } while (0);
  duk_push_hstring_stridx(thr, n);
 }
}
static void duk__push_double(duk_hthread *thr, duk_bitdecoder_ctx *bd) {
 duk_double_union du;
 duk_small_uint_t i;

 for (i = 0; i < 8; i++) {



  du.uc[i] = (duk_uint8_t) duk_bd_decode(bd, 8);
 }

 duk_push_number(thr, du.d);
}

static __attribute__ ((unused)) void duk_hthread_create_builtin_objects(duk_hthread *thr) {
 duk_bitdecoder_ctx bd_ctx;
 duk_bitdecoder_ctx *bd = &bd_ctx;
 duk_hobject *h;
 duk_small_uint_t i, j;

 do { } while (0)

                                              ;

 do { void *duk__dst = (&bd_ctx); duk_size_t duk__len = (sizeof(bd_ctx)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 bd->data = (const duk_uint8_t *) duk_builtins_data;
 bd->length = (duk_size_t) 4281;
# 226 "duk_hthread_builtins.c"
 duk_require_stack(thr, 80);

 do { } while (0);
 do { } while (0);
 for (i = 0; i < 80; i++) {
  duk_small_uint_t class_num;
  duk_small_int_t len = -1;

  class_num = (duk_small_uint_t) duk_bd_decode_varuint(bd);
  len = (duk_small_int_t) duk_bd_decode_flagged_signed(bd, 3, (duk_int32_t) -1 );

  if (class_num == 3) {
   duk_small_uint_t natidx;
   duk_small_int_t c_nargs;
   duk_c_function c_func;
   duk_int16_t magic;

   do { } while (0);
   do { } while (0);

   natidx = (duk_small_uint_t) duk_bd_decode_varuint(bd);
   do { } while (0);
   c_func = duk_bi_native_functions[natidx];
   do { } while (0);

   c_nargs = (duk_small_int_t) duk_bd_decode_flagged_signed(bd, 3, len );
   if (c_nargs == 0x07) {
    c_nargs = ((duk_int_t) (-1));
   }


   (void) duk_push_c_function_builtin(thr, c_func, c_nargs);
   h = duk_known_hobject(thr, -1);





   do { } while (0);



   duk__push_stridx_or_string(thr, bd);

   (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (93)) << 8) + (duk_uint_t) (((1U << 2)))));
# 279 "duk_hthread_builtins.c"
   if (duk_bd_decode_flag(bd)) {
    do { } while (0);
   } else {
    do { do { } while (0); (&(h)->hdr)->h_flags &= ~(((1UL << (7 + (1))))); } while (0);
   }


   magic = (duk_int16_t) duk_bd_decode_varuint(bd);
   ((duk_hnatfunc *) h)->magic = magic;
  } else if (class_num == 2) {
   duk_push_array(thr);
  } else if (class_num == 15) {
   duk_hobjenv *env;
   duk_hobject *global;

   do { } while (0);
   do { } while (0);

   env = duk_hobjenv_alloc(thr,
                           (1UL << (7 + (0))) | (((duk_uint_t) (15)) << (7 + (20))));
   do { } while (0);
   duk_push_hobject(thr, (duk_hobject *) env);

   global = duk_known_hobject(thr, 0);
   do { } while (0);
   env->target = global;
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (global))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   do { } while (0);

   do { } while (0);
  } else {
   do { } while (0);

   (void) duk_push_object_helper(thr,
                                 (1UL << (7 + (7))) | (1UL << (7 + (0))),
                                 -1);
  }

  h = duk_known_hobject(thr, -1);
  do { (&(h)->hdr)->h_flags = ((&(h)->hdr)->h_flags & (~(((1UL << (5)) - 1UL) << ((7 + (20)))))) | (((class_num)) << ((7 + (20)))); } while (0);

  if (i < 51) {
   thr->builtins[i] = h;
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (&h->hdr))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  }

  if (len >= 0) {
# 336 "duk_hthread_builtins.c"
   do { } while (0);
   duk_push_int(thr, len);
   (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (87)) << 8) + (duk_uint_t) (((1U << 2)))));
  }



  if (class_num == 2) {
   do { } while (0);
  }
  if (class_num == 12) {
   do { do { } while (0); (&(h)->hdr)->h_flags |= ((1UL << (7 + (16)))); } while (0);
  }



  do { } while (0);

  do { } while (0);
  do { } while (0);

  do { } while (0);
  do { } while (0);
  do { } while (0);

  do { } while (0)
                                       ;
  do { } while (0);
  do { } while (0);


  do { } while (0);

  do { } while (0);
 }







 do { } while (0);
 for (i = 0; i < 80; i++) {
  duk_small_uint_t t;
  duk_small_uint_t num;

  do { } while (0);
  h = duk_known_hobject(thr, (duk_idx_t) i);

  t = (duk_small_uint_t) duk_bd_decode_varuint(bd);
  if (t > 0) {
   t--;
   do { } while (0);
   duk_hobject_set_prototype_updref((thr), (h), (duk_known_hobject(thr, (duk_idx_t) t)));
  } else if ((((&(h)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)) {




   do { } while (0);
   duk_hobject_set_prototype_updref((thr), (h), (thr->builtins[5]));
  }

  t = (duk_small_uint_t) duk_bd_decode_varuint(bd);
  if (t > 0) {





   t--;
   do { } while (0);
   duk_dup(thr, (duk_idx_t) t);
   duk_xdef_prop_stridx(thr, (duk_idx_t) i, 50, 0);
  }

  t = (duk_small_uint_t) duk_bd_decode_varuint(bd);
  if (t > 0) {





   t--;
   do { } while (0);
   duk_dup(thr, (duk_idx_t) t);
   duk_xdef_prop_stridx(thr, (duk_idx_t) i, 51, ((1U << 0) | (1U << 2)));
  }


  num = (duk_small_uint_t) duk_bd_decode_varuint(bd);
  do { } while (0);
  for (j = 0; j < num; j++) {
   duk_small_uint_t defprop_flags;

   duk__push_stridx_or_string(thr, bd);
# 441 "duk_hthread_builtins.c"
   defprop_flags = (duk_small_uint_t) duk_bd_decode_flagged(bd,
                                                            3,
                                                            (duk_uint32_t) ((1U << 0) | (1U << 2)));
   defprop_flags |= (1U << 9) | (1U << 6) | (1U << 3) |
                    (1U << 4) |
                    (1U << 5);




   do { } while (0);
   do { } while (0);
   do { } while (0);

   t = (duk_small_uint_t) duk_bd_decode(bd, 3);

   do { } while (0)




                                  ;

   switch (t) {
   case 0: {
    duk__push_double(thr, bd);
    break;
   }
   case 1: {
    duk__push_string(thr, bd);
    break;
   }
   case 2: {
    duk__push_stridx(thr, bd);
    break;
   }
   case 3: {
    duk_small_uint_t bidx;

    bidx = (duk_small_uint_t) duk_bd_decode_varuint(bd);
    duk_dup(thr, (duk_idx_t) bidx);
    break;
   }
   case 4: {
    duk_push_undefined(thr);
    break;
   }
   case 5: {
    duk_push_true(thr);
    break;
   }
   case 6: {
    duk_push_false(thr);
    break;
   }
   case 7: {
    duk_small_uint_t natidx_getter = (duk_small_uint_t) duk_bd_decode_varuint(bd);
    duk_small_uint_t natidx_setter = (duk_small_uint_t) duk_bd_decode_varuint(bd);
    duk_small_uint_t accessor_magic = (duk_small_uint_t) duk_bd_decode_varuint(bd);
    duk_c_function c_func_getter;
    duk_c_function c_func_setter;

    do { } while (0)





                                       ;

    c_func_getter = duk_bi_native_functions[natidx_getter];
    if (c_func_getter != 
# 512 "duk_hthread_builtins.c" 3 4
                        ((void *)0)
# 512 "duk_hthread_builtins.c"
                            ) {
     duk_push_c_function_builtin_noconstruct(thr, c_func_getter, 0);
     duk_set_magic(thr, -1, (duk_int_t) accessor_magic);
     defprop_flags |= (1U << 7);
    }
    c_func_setter = duk_bi_native_functions[natidx_setter];
    if (c_func_setter != 
# 518 "duk_hthread_builtins.c" 3 4
                        ((void *)0)
# 518 "duk_hthread_builtins.c"
                            ) {
     duk_push_c_function_builtin_noconstruct(thr, c_func_setter, 1);
     duk_set_magic(thr, -1, (duk_int_t) accessor_magic);
     defprop_flags |= (1U << 8);
    }


    do { } while (0);

    defprop_flags &= ~((1U << 6) | (1U << 3));
    defprop_flags |= (1U << 4) | (1U << 5);
    break;
   }
   default: {

    do { __builtin_unreachable(); } while (0);
   }
   }

   duk_def_prop(thr, (duk_idx_t) i, defprop_flags);
   do { } while (0);
  }


  num = (duk_small_uint_t) duk_bd_decode_varuint(bd);
  do { } while (0);
  for (j = 0; j < num; j++) {
   duk_hstring *h_key;
   duk_small_uint_t natidx;
   duk_int_t c_nargs;
   duk_small_uint_t c_length;
   duk_int16_t magic;
   duk_c_function c_func;
   duk_hnatfunc *h_func;



   duk_small_uint_t defprop_flags;

   duk__push_stridx_or_string(thr, bd);
   h_key = duk_known_hstring(thr, -1);
   do { (void) (h_key); } while (0);
   natidx = (duk_small_uint_t) duk_bd_decode_varuint(bd);

   c_length = (duk_small_uint_t) duk_bd_decode(bd, 3);
   c_nargs = (duk_int_t) duk_bd_decode_flagged(bd, 3, (duk_uint32_t) c_length );
   if (c_nargs == 0x07) {
    c_nargs = ((duk_int_t) (-1));
   }

   c_func = duk_bi_native_functions[natidx];

   do { } while (0)






                                                                           ;


   magic = (duk_int16_t) duk_bd_decode_varuint(bd);
# 633 "duk_hthread_builtins.c"
   duk_push_c_function_builtin_noconstruct(thr, c_func, c_nargs);
   h_func = duk_known_hnatfunc(thr, -1);
   do { (void) (h_func); } while (0);




   if (c_func == duk_bi_global_object_eval || c_func == duk_bi_function_prototype_call ||
       c_func == duk_bi_function_prototype_apply || c_func == duk_bi_reflect_apply ||
       c_func == duk_bi_reflect_construct) {
    do { do { } while (0); (&((duk_hobject *) h_func)->hdr)->h_flags |= ((1UL << (7 + (19)))); } while (0);
   }







   do { do { } while (0); (&((duk_hobject *) h_func)->hdr)->h_flags |= ((1UL << (7 + (9)))); } while (0);




   do { } while (0);




   h_func->magic = magic;



   duk_push_uint(thr, c_length);
   (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (87)) << 8) + (duk_uint_t) (((1U << 2)))));

   duk_dup_m2(thr);
   (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (93)) << 8) + (duk_uint_t) (((1U << 2)))));



   do { } while (0)


                                                          ;
# 690 "duk_hthread_builtins.c"
   defprop_flags = (duk_small_uint_t) duk_bd_decode_flagged(bd,
                                                            3,
                                                            (duk_uint32_t) ((1U << 0) | (1U << 2)));
   defprop_flags |= (1U << 9) | (1U << 6) | (1U << 3) |
                    (1U << 4) | (1U << 5);
   do { } while (0);
   do { } while (0);
   do { } while (0);

   duk_def_prop(thr, (duk_idx_t) i, defprop_flags);


  }
 }
# 723 "duk_hthread_builtins.c"
 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (16)) << 16) + ((duk_uint_t) (41))));
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (16)) << 24) + (((duk_uint_t) (43)) << 8) + (duk_uint_t) (((1U << 0) | (1U << 2)))));


 h = duk_known_hobject(thr, 37);
 do { do { } while (0); (&(h)->hdr)->h_flags &= ~(((1UL << (7 + (0))))); } while (0);
# 747 "duk_hthread_builtins.c"
 duk_push_string(thr,


                 "l"
# 759 "duk_hthread_builtins.c"
                 "l"







                 " "




                 "u"




                 " "





                 "n"
# 820 "duk_hthread_builtins.c"
                 "l"

                 " "




                 "p2"





                 " "




                 "a8"





                 " "

                 "x64" " " "linux" " " "gcc");
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (34)) << 24) + (((duk_uint_t) (111)) << 8) + (duk_uint_t) (((1U << 0) | (1U << 2)))));





 do { } while (0);
 for (i = 0; i < 80; i++) {
  duk_hobject_compact_props(thr, duk_known_hobject(thr, (duk_idx_t) i));
 }

 do { } while (0);
# 874 "duk_hthread_builtins.c"
 duk_set_top(thr, 0);
 do { } while (0);
}


static __attribute__ ((unused)) void duk_hthread_copy_builtin_objects(duk_hthread *thr_from, duk_hthread *thr_to) {
 duk_small_uint_t i;

 for (i = 0; i < 51; i++) {
  thr_to->builtins[i] = thr_from->builtins[i];
  do { if ((thr_to->builtins[i]) != 
# 884 "duk_hthread_builtins.c" 3 4
 ((void *)0)
# 884 "duk_hthread_builtins.c"
 ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((thr_to->builtins[i])))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0);
 }
}
# 1 "duk_hthread_misc.c"






static __attribute__ ((unused)) void duk_hthread_terminate(duk_hthread *thr) {
 do { } while (0);

 while (thr->callstack_curr != 
# 10 "duk_hthread_misc.c" 3 4
                              ((void *)0)
# 10 "duk_hthread_misc.c"
                                  ) {
  duk_hthread_activation_unwind_norz(thr);
 }

 thr->valstack_bottom = thr->valstack;
 duk_set_top(thr, 0);

 thr->state = 5;
# 28 "duk_hthread_misc.c"
 do { duk_refzero_check_slow((thr)); } while (0);
}
# 48 "duk_hthread_misc.c"
static __attribute__ ((unused)) duk_uint_fast32_t duk_hthread_get_act_prev_pc(duk_hthread *thr, duk_activation *act) {
 duk_instr_t *bcode;
 duk_uint_fast32_t ret;

 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);

 if (act->func && (((&(act->func)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
  bcode = ((((duk_hcompfunc *) (act->func)))->bytecode);
  ret = (duk_uint_fast32_t) (act->curr_pc - bcode);
  if (ret > 0) {
   ret--;
  }
  return ret;
 }
 return 0;
}


static __attribute__ ((unused)) void duk_hthread_sync_currpc(duk_hthread *thr) {
 duk_activation *act;

 do { } while (0);

 if (thr->ptr_curr_pc != 
# 73 "duk_hthread_misc.c" 3 4
                        ((void *)0)
# 73 "duk_hthread_misc.c"
                            ) {

  do { } while (0);
  do { } while (0);
  act = thr->callstack_curr;
  do { } while (0);
  act->curr_pc = *thr->ptr_curr_pc;
 }
}

static __attribute__ ((unused)) void duk_hthread_sync_and_null_currpc(duk_hthread *thr) {
 duk_activation *act;

 do { } while (0);

 if (thr->ptr_curr_pc != 
# 88 "duk_hthread_misc.c" 3 4
                        ((void *)0)
# 88 "duk_hthread_misc.c"
                            ) {

  do { } while (0);
  do { } while (0);
  act = thr->callstack_curr;
  do { } while (0);
  act->curr_pc = *thr->ptr_curr_pc;
  thr->ptr_curr_pc = 
# 95 "duk_hthread_misc.c" 3 4
                    ((void *)0)
# 95 "duk_hthread_misc.c"
                        ;
 }
}
# 1 "duk_hthread_stacks.c"
# 13 "duk_hthread_stacks.c"
static __attribute__ ((unused)) void duk_hthread_catcher_unwind_norz(duk_hthread *thr, duk_activation *act) {
 duk_catcher *cat;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 cat = act->cat;
 do { } while (0);

 do { } while (0);

 if (((cat)->flags & (1U << 7))) {
  duk_hobject *env;

  env = act->lex_env;
  do { } while (0);
  act->lex_env = ((env)->prototype);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (act->lex_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) ((env)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)(((thr)), (duk_hobject *) duk__h); } } } while (0);




 }

 act->cat = cat->parent;
 duk_hthread_catcher_free(thr, cat);
}


static __attribute__ ((unused)) void duk_hthread_catcher_unwind_nolexenv_norz(duk_hthread *thr, duk_activation *act) {
 duk_catcher *cat;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 cat = act->cat;
 do { } while (0);

 do { } while (0);

 do { } while (0);

 act->cat = cat->parent;
 duk_hthread_catcher_free(thr, cat);
}

static

__attribute__((noinline))

duk_catcher *duk__hthread_catcher_alloc_slow(duk_hthread *thr) {
 duk_catcher *cat;

 cat = (duk_catcher *) duk_heap_mem_alloc_checked((thr), (sizeof(duk_catcher)));
 do { } while (0);
 return cat;
}


static __attribute__ ((unused)) inline duk_catcher *duk_hthread_catcher_alloc(duk_hthread *thr) {
 duk_catcher *cat;

 do { } while (0);

 cat = thr->heap->catcher_free;
 if (__builtin_expect((cat != 
# 79 "duk_hthread_stacks.c" 3 4
    ((void *)0)
# 79 "duk_hthread_stacks.c"
    ), 1)) {
  thr->heap->catcher_free = cat->parent;
  return cat;
 }

 return duk__hthread_catcher_alloc_slow(thr);
}






static __attribute__ ((unused)) void duk_hthread_catcher_free(duk_hthread *thr, duk_catcher *cat) {
 do { } while (0);
 do { } while (0);



 cat->parent = thr->heap->catcher_free;
 thr->heap->catcher_free = cat;



}

static

__attribute__((noinline))

duk_activation *duk__hthread_activation_alloc_slow(duk_hthread *thr) {
 duk_activation *act;

 act = (duk_activation *) duk_heap_mem_alloc_checked((thr), (sizeof(duk_activation)));
 do { } while (0);
 return act;
}


static __attribute__ ((unused)) inline duk_activation *duk_hthread_activation_alloc(duk_hthread *thr) {
 duk_activation *act;

 do { } while (0);

 act = thr->heap->activation_free;
 if (__builtin_expect((act != 
# 124 "duk_hthread_stacks.c" 3 4
    ((void *)0)
# 124 "duk_hthread_stacks.c"
    ), 1)) {
  thr->heap->activation_free = act->parent;
  return act;
 }

 return duk__hthread_activation_alloc_slow(thr);
}






static __attribute__ ((unused)) void duk_hthread_activation_free(duk_hthread *thr, duk_activation *act) {
 do { } while (0);
 do { } while (0);



 act->parent = thr->heap->activation_free;
 thr->heap->activation_free = act;



}




static void duk__activation_unwind_nofree_norz(duk_hthread *thr) {



 duk_activation *act;
 duk_hobject *func;
 duk_hobject *tmp;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 act = thr->callstack_curr;
 do { } while (0);
# 243 "duk_hthread_stacks.c"
 while (act->cat != 
# 243 "duk_hthread_stacks.c" 3 4
                   ((void *)0)
# 243 "duk_hthread_stacks.c"
                       ) {
  duk_hthread_catcher_unwind_norz(thr, act);
 }
# 257 "duk_hthread_stacks.c"
 func = ((act)->func);
 if (func != 
# 258 "duk_hthread_stacks.c" 3 4
            ((void *)0) 
# 258 "duk_hthread_stacks.c"
                 && !(((&(func)->hdr)->h_flags & ((1UL << (7 + (11))))) != 0)) {
  do { } while (0);
  goto skip_env_close;
 }






 do { } while (0);







 if (act->var_env != 
# 276 "duk_hthread_stacks.c" 3 4
                    ((void *)0)
# 276 "duk_hthread_stacks.c"
                        ) {
  do { } while (0);
  duk_js_close_environment_record(thr, act->var_env);
 }

skip_env_close:





 if (act->flags & (1U << 3)) {
  do { } while (0);
  thr->callstack_preventcount--;
 }
# 301 "duk_hthread_stacks.c"
 do { if ((act->var_env) != 
# 301 "duk_hthread_stacks.c" 3 4
((void *)0)
# 301 "duk_hthread_stacks.c"
) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((act->var_env))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
 do { if ((act->lex_env) != 
# 302 "duk_hthread_stacks.c" 3 4
((void *)0)
# 302 "duk_hthread_stacks.c"
) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((act->lex_env))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
 tmp = ((act)->func);
 do { if ((tmp) != 
# 304 "duk_hthread_stacks.c" 3 4
((void *)0)
# 304 "duk_hthread_stacks.c"
) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((tmp))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
 do { (void) (tmp); } while (0);
}





static __attribute__ ((unused)) void duk_hthread_activation_unwind_norz(duk_hthread *thr) {
 duk_activation *act;

 duk__activation_unwind_nofree_norz(thr);

 do { } while (0);
 do { } while (0);
 act = thr->callstack_curr;
 thr->callstack_curr = act->parent;
 thr->callstack_top--;
# 330 "duk_hthread_stacks.c"
 duk_hthread_activation_free(thr, act);




}

static __attribute__ ((unused)) void duk_hthread_activation_unwind_reuse_norz(duk_hthread *thr) {
 duk__activation_unwind_nofree_norz(thr);
}






static __attribute__ ((unused)) duk_activation *duk_hthread_get_activation_for_level(duk_hthread *thr, duk_int_t level) {
 duk_activation *act;

 if (level >= 0) {
  return 
# 350 "duk_hthread_stacks.c" 3 4
        ((void *)0)
# 350 "duk_hthread_stacks.c"
            ;
 }
 act = thr->callstack_curr;
 for (;;) {
  if (act == 
# 354 "duk_hthread_stacks.c" 3 4
            ((void *)0)
# 354 "duk_hthread_stacks.c"
                ) {
   return act;
  }
  if (level == -1) {
   return act;
  }
  level++;
  act = act->parent;
 }

}
# 1 "duk_js_arith.c"
# 11 "duk_js_arith.c"
static __attribute__ ((unused)) double duk_js_arith_mod(double d1, double d2) {
# 34 "duk_js_arith.c"
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0)
                                                                 ;
 do { } while (0)
                                                                  ;
 do { } while (0)
                                                                 ;
 do { } while (0)
                                                                   ;
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 return (duk_double_t) fmod((double) d1, (double) d2);
}


static __attribute__ ((unused)) double duk_js_arith_pow(double x, double y) {






 duk_small_int_t cx, cy, sx;

 do { (void) (cx); } while (0);
 do { (void) (sx); } while (0);
 cy = (duk_small_int_t) 
# 75 "duk_js_arith.c" 3 4
                       __builtin_fpclassify (0, 1, 4, 3, 2, 
# 75 "duk_js_arith.c"
                       y
# 75 "duk_js_arith.c" 3 4
                       )
# 75 "duk_js_arith.c"
                                        ;

 if (cy == 
# 77 "duk_js_arith.c" 3 4
          0
# 77 "duk_js_arith.c"
                    ) {
  goto ret_nan;
 }
 if (duk_double_equals(fabs(x), 1.0) && cy == 
# 80 "duk_js_arith.c" 3 4
                                                 1
# 80 "duk_js_arith.c"
                                                                ) {
  goto ret_nan;
 }
# 131 "duk_js_arith.c"
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 return pow(x, y);

ret_nan:
 return 
# 140 "duk_js_arith.c" 3 4
       (__builtin_nanf (""))
# 140 "duk_js_arith.c"
                     ;
}
# 1 "duk_js_call.c"
# 39 "duk_js_call.c"
static __attribute__ ((unused)) void duk_native_stack_check(duk_hthread *thr) {





 do { (void) (thr); } while (0);

}
# 59 "duk_js_call.c"
static __attribute__((noinline)) void duk__call_c_recursion_limit_check_slowpath(duk_hthread *thr) {




 if (thr->heap->augmenting_error) {
  if (thr->heap->call_recursion_depth < thr->heap->call_recursion_limit + (10 + 2)) {
   do { } while (0);
   return;
  }
 }


 do { } while (0);
 do { duk_err_range((thr), "duk_js_call.c", (duk_int_t) 73, ("C stack depth limit")); } while (0);
 do { return; } while (0);
}

static inline __attribute__((always_inline)) void duk__call_c_recursion_limit_check(duk_hthread *thr) {
 do { } while (0);
 do { } while (0);

 duk_native_stack_check(thr);




 if (__builtin_expect((thr->heap->call_recursion_depth < thr->heap->call_recursion_limit), 1)) {
  return;
 }

 duk__call_c_recursion_limit_check_slowpath(thr);
}

static __attribute__((noinline)) void duk__call_callstack_limit_check_slowpath(duk_hthread *thr) {




 if (thr->heap->augmenting_error) {
  if (thr->callstack_top < 10000 + (10 + 2)) {
   do { } while (0);
   return;
  }
 }






 do { } while (0);
 do { duk_err_range((thr), "duk_js_call.c", (duk_int_t) 111, ("callstack limit")); } while (0);
 do { return; } while (0);
}

static inline __attribute__((always_inline)) void duk__call_callstack_limit_check(duk_hthread *thr) {



 if (__builtin_expect((thr->callstack_top < 10000), 1)) {
  return;
 }

 duk__call_callstack_limit_check_slowpath(thr);
}
# 171 "duk_js_call.c"
static void duk__create_arguments_object(duk_hthread *thr, duk_hobject *func, duk_hobject *varenv, duk_idx_t idx_args) {
 duk_hobject *arg;
 duk_hobject *formals;
 duk_idx_t i_arg;
 duk_idx_t i_map;
 duk_idx_t i_mappednames;
 duk_idx_t i_formals;
 duk_idx_t i_argbase;
 duk_idx_t n_formals;
 duk_idx_t idx;
 duk_idx_t num_stack_args;
 duk_bool_t need_map;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);





 need_map = 0;

 i_argbase = idx_args;
 num_stack_args = duk_get_top(thr) - i_argbase - 1;
 do { } while (0);
 do { } while (0);

 formals = (duk_hobject *) duk_hobject_get_formals(thr, (duk_hobject *) func);
 if (formals) {
  n_formals = (duk_idx_t) ((duk_harray *) formals)->length;
  duk_push_hobject(thr, formals);
 } else {





  do { } while (0);
  n_formals = 0;
  duk_push_undefined(thr);
 }
 i_formals = duk_require_top_index(thr);

 do { } while (0);
 do { } while (0);

 do { } while (0)
                                                                                                                           ;
# 231 "duk_js_call.c"
 arg = duk_push_object_helper(thr,
                              (1UL << (7 + (0))) | (1UL << (7 + (7))) | (1UL << (7 + (8))) |
                                  (((duk_uint_t) (4)) << (7 + (20))),
                              3);
 do { } while (0);
 (void) duk_push_object_helper(thr,
                               (1UL << (7 + (0))) | (1UL << (7 + (7))) |
                                   (((duk_uint_t) (1)) << (7 + (20))),
                               -1);
 (void) duk_push_object_helper(thr,
                               (1UL << (7 + (0))) | (1UL << (7 + (7))) |
                                   (((duk_uint_t) (1)) << (7 + (20))),
                               -1);
 i_arg = duk_get_top(thr) - 3;
 i_map = i_arg + 1;
 i_mappednames = i_arg + 2;
 do { } while (0);
 do { } while (0);
 do { } while (0);



 do { } while (0)
# 262 "duk_js_call.c"
                                                                           ;





 duk_push_int(thr, num_stack_args);
 duk_xdef_prop_stridx(thr, i_arg, 87, ((1U << 0) | (1U << 2)));






 idx = num_stack_args - 1;
 while (idx >= 0) {
  do { } while (0)
                                                                                                                   ;

  do { } while (0);
  duk_dup(thr, i_argbase + idx);
  duk_xdef_prop_index((thr), (i_arg), ((duk_uarridx_t) idx), ((1U << 0) | (1U << 1) | (1U << 2)));
  do { } while (0);


  if (!(((&(func)->hdr)->h_flags & ((1UL << (7 + (9))))) != 0) && idx < n_formals) {
   do { } while (0);

   do { } while (0);

   duk_get_prop_index(thr, i_formals, (duk_uarridx_t) idx);
   do { } while (0);

   duk_dup_top(thr);

   if (!duk_has_prop(thr, i_mappednames)) {






    need_map = 1;

    do { } while (0)
                                                                                                    ;
    duk_dup_top(thr);
    (void) duk_push_uint_to_hstring(thr, (duk_uint_t) idx);
    duk_xdef_prop((thr), (i_mappednames), ((1U << 0) | (1U << 1) | (1U << 2)));

    do { } while (0);
    duk_dup_top(thr);
    duk_xdef_prop_index((thr), (i_map), ((duk_uarridx_t) idx), ((1U << 0) | (1U << 1) | (1U << 2)));
   } else {

   }


   duk_pop(thr);
  }

  idx--;
 }

 do { } while (0);


 if (need_map) {
  do { } while (0);


  do { } while (0);

  duk_dup(thr, i_map);
  duk_xdef_prop_stridx(thr, i_arg, 103, 0);
# 347 "duk_js_call.c"
  duk_push_hobject(thr, varenv);
  duk_xdef_prop_stridx(thr, i_arg, 104, 0);
 }


 if ((((&(func)->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)) {
# 366 "duk_js_call.c"
  do { } while (0);


  duk_xdef_prop_stridx_thrower(thr, i_arg, 68);
 } else {
  do { } while (0);
  duk_push_hobject(thr, func);
  duk_xdef_prop_stridx(thr, i_arg, 68, ((1U << 0) | (1U << 2)));
 }


 if (need_map) {
# 389 "duk_js_call.c"
  do { } while (0);

  do { } while (0);
  do { do { } while (0); (&(arg)->hdr)->h_flags |= ((1UL << (7 + (17)))); } while (0);
 } else {
  do { } while (0);
 }

 do { } while (0)
# 406 "duk_js_call.c"
                                                                           ;



 duk_pop_2(thr);
 duk_remove_m2(thr);


}




static void duk__handle_createargs_for_call(duk_hthread *thr, duk_hobject *func, duk_hobject *env, duk_idx_t idx_args) {
 do { } while (0);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);



 duk__create_arguments_object(thr, func, env, idx_args);



 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (67)) << 8) + (duk_uint_t) ((((&(func)->hdr)->h_flags & ((1UL << (7 + (9))))) != 0) ? ((1U << 1)) : ((1U << 0) | (1U << 1)))))



                                                                                        ;

}
# 474 "duk_js_call.c"
static void duk__update_default_instance_proto(duk_hthread *thr, duk_idx_t idx_func) {
 duk_hobject *proto;
 duk_hobject *fallback;

 do { } while (0);

 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (idx_func)) << 16) + ((duk_uint_t) (50))));
 proto = duk_get_hobject(thr, -1);
 if (proto == 
# 482 "duk_js_call.c" 3 4
             ((void *)0)
# 482 "duk_js_call.c"
                 ) {
  do { } while (0)
                                                                                   ;
 } else {
  do { } while (0)

                                              ;



  fallback = duk_known_hobject(thr, idx_func + 1);
  do { } while (0);
  duk_hobject_set_prototype_updref((thr), (fallback), (proto));
 }
 duk_pop(thr);
}


static __attribute__ ((unused)) void duk_call_construct_postprocess(duk_hthread *thr, duk_small_uint_t proxy_invariant) {
# 510 "duk_js_call.c"
 if (duk_check_type_mask(thr, -1, (1U << 6U) | (1U << 7U) | (1U << 9U))) {
  do { } while (0);
 } else {
  if (__builtin_expect((proxy_invariant != 0U), 0)) {

   do { duk_err_type_invalid_trap_result((thr), "duk_js_call.c", (duk_int_t) 515); } while (0);
   do { return; } while (0);
  }

  duk_pop(thr);
  duk_push_this(thr);
 }
# 531 "duk_js_call.c"
 do { } while (0);
 duk_err_augment_error_create(thr, thr, 
# 532 "duk_js_call.c" 3 4
                                       ((void *)0)
# 532 "duk_js_call.c"
                                           , 0, (1U << 0) | (1U << 1));

}
# 549 "duk_js_call.c"
static void duk__handle_bound_chain_for_call(duk_hthread *thr, duk_idx_t idx_func, duk_bool_t is_constructor_call) {
 duk_tval *tv_func;
 duk_hobject *func;
 duk_idx_t len;

 do { } while (0);





 do { } while (0);

 tv_func = duk_require_tval(thr, idx_func);
 do { } while (0);

 if (((tv_func)->t == 9)) {
  func = ((tv_func)->v.hobject);


  if ((((&(func)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0)) {
   duk_hboundfunc *h_bound;
   duk_tval *tv_args;
   duk_tval *tv_gap;

   h_bound = (duk_hboundfunc *) (void *) func;
   tv_args = h_bound->args;
   len = h_bound->nargs;
   do { } while (0);

   do { } while (0)

                                 ;



   if (is_constructor_call) {

    do { } while (0);
   } else {

    duk_push_tval(thr, &h_bound->this_binding);
    duk_replace(thr, idx_func + 1);
   }



   duk_require_stack(thr, len);

   tv_gap = duk_reserve_gap(thr, idx_func + 2, len);
   duk_copy_tvals_incref(thr, tv_gap, tv_args, (duk_size_t) len);



   duk_push_tval(thr, &h_bound->target);
   duk_replace(thr, idx_func);

   do { } while (0)

                                                     ;
  }
 } else if (((tv_func)->t == 6)) {

  ;
 } else {

  do { duk_err_error_internal((thr), "duk_js_call.c", (duk_int_t) 615); } while (0);
  do { return; } while (0);
 }

 do { } while (0);

 do { } while (0);
# 633 "duk_js_call.c"
}





static duk_bool_t duk__handle_specialfuncs_for_call(duk_hthread *thr,
                                                       duk_idx_t idx_func,
                                                       duk_hobject *func,
                                                       duk_small_uint_t *call_flags,
                                                       duk_bool_t first) {



 duk_tval *tv_args;

 do { } while (0);
 do { } while (0);
# 663 "duk_js_call.c"
 do { } while (0);





 if (__builtin_expect((((duk_hnatfunc *) func)->magic == 15), 0)) {



  do { } while (0);
  if (first && (*call_flags & (1U << 2))) {
   *call_flags = (*call_flags & ~(1U << 2)) | (1U << 4);
  }
  do { } while (0);
  return 1;
 }







 switch (((duk_hnatfunc *) func)->magic) {
 case 0: {
# 702 "duk_js_call.c"
  do { } while (0);
  duk_remove_unsafe(thr, idx_func);
  tv_args = thr->valstack_bottom + idx_func + 2;
  if (thr->valstack_top < tv_args) {
   do { } while (0);
   thr->valstack_top = tv_args;
  }
  break;
 }
 case 1: {
# 725 "duk_js_call.c"
  do { } while (0);
  duk_remove_unsafe(thr, idx_func);
  goto apply_shared;
 }

 case 2: {
# 745 "duk_js_call.c"
  do { } while (0);
  duk_remove_n_unsafe(thr, idx_func, 2);
  goto apply_shared;
 }
 case 3: {
# 772 "duk_js_call.c"
  duk_idx_t top;

  do { } while (0);
  *call_flags |= (1U << 1);
  duk_remove_n_unsafe(thr, idx_func, 2);
  top = duk_get_top(thr);
  if (!duk_is_constructable(thr, idx_func)) {




   duk_set_top_unsafe(thr, idx_func + 2);
   break;
  }
  duk_push_object(thr);
  duk_insert(thr, idx_func + 1);



  top = duk_get_top(thr);
  if (top < idx_func + 3) {

   do { duk_err_type_invalid_args((thr), "duk_js_call.c", (duk_int_t) 794); } while (0);
   do { return 0; } while (0);
  }
  if (top > idx_func + 3) {
   if (!duk_strict_equals(thr, idx_func, idx_func + 3)) {

    do { do { duk_errcode_t duk__err = (1); duk_int_t duk__line = (duk_int_t) 800; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_call.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("unsupported")); } while (0); } while (0);
    do { return 0; } while (0);
   }
   duk_set_top_unsafe(thr, idx_func + 3);
  }
  do { } while (0);
  do { } while (0);
  (void) duk_unpack_array_like(thr,
                               idx_func + 2);
  duk_remove(thr, idx_func + 2);
  do { } while (0);
  break;
 }

 default: {
  do { } while (0);
  do { __builtin_unreachable(); } while (0);
 }
 }

 do { } while (0);
 return 0;

apply_shared:
 tv_args = thr->valstack_bottom + idx_func + 2;
 if (thr->valstack_top <= tv_args) {
  do { } while (0);
  thr->valstack_top = tv_args;

 } else {
  do { } while (0);
  if (thr->valstack_top > tv_args + 1) {
   duk_set_top_unsafe(thr, idx_func + 3);
  }
  do { } while (0);
  if (!duk_is_function((thr), (idx_func))) {



  } else {
   (void) duk_unpack_array_like(thr, idx_func + 2);
   duk_remove(thr, idx_func + 2);
  }
 }
 do { } while (0);
 return 0;
}






static void duk__handle_proxy_for_call(duk_hthread *thr, duk_idx_t idx_func, duk_hproxy *h_proxy, duk_small_uint_t *call_flags) {
 duk_bool_t rc;
# 890 "duk_js_call.c"
 duk_push_hobject(thr, h_proxy->handler);
 rc = (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) ((*call_flags & (1U << 1)) ? 71 : 70))));
 if (rc == 0) {




  if (*call_flags & (1U << 1)) {
   if (!(*call_flags & (1U << 6))) {
    *call_flags |= (1U << 6);
    duk__update_default_instance_proto(thr, idx_func);
   }
  }
  duk_pop_2(thr);
  duk_push_hobject(thr, h_proxy->target);
  duk_replace(thr, idx_func);
  return;
 }
# 925 "duk_js_call.c"
 duk_insert(thr, idx_func + 1);
 duk_insert(thr, idx_func + 2);
 duk_push_hobject(thr, h_proxy->target);
 duk_insert(thr, idx_func + 3);
 duk_pack(thr, duk_get_top(thr) - (idx_func + 5));
 do { } while (0);
# 940 "duk_js_call.c"
 do { } while (0);

 if (*call_flags & (1U << 1)) {
  *call_flags |= (1U << 5);
  *call_flags &= ~((1U << 1));




  duk_remove(thr, idx_func + 4);
  duk_push_hobject(thr, (duk_hobject *) h_proxy);
 }


 duk_remove(thr, idx_func);
 h_proxy = 
# 955 "duk_js_call.c" 3 4
          ((void *)0)
# 955 "duk_js_call.c"
              ;
 do { } while (0);
}







static void duk__handle_oldenv_for_call(duk_hthread *thr, duk_hobject *func, duk_activation *act) {
 duk_hcompfunc *f;
 duk_hobject *h_lex;
 duk_hobject *h_var;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);

 f = (duk_hcompfunc *) func;
 h_lex = ((f)->lex_env);
 h_var = ((f)->var_env);
 do { } while (0);
 do { } while (0);
 act->lex_env = h_lex;
 act->var_env = h_var;
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_lex))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h_var))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
}
# 1105 "duk_js_call.c"
static inline void duk__coerce_nonstrict_this_binding(duk_hthread *thr, duk_idx_t idx_this) {
 duk_tval *tv_this;
 duk_hobject *obj_global;

 tv_this = thr->valstack_bottom + idx_this;
 switch (((tv_this)->t)) {
 case 9:
  do { } while (0);
  break;
 case 2:
 case 3:
  do { } while (0);
  obj_global = thr->builtins[0];

  if (__builtin_expect((obj_global != 
# 1119 "duk_js_call.c" 3 4
     ((void *)0)
# 1119 "duk_js_call.c"
     ), 1)) {
   do { } while (0);
   do { duk_tval *duk__tv; duk__tv = (tv_this); duk__tv->t = 9; duk__tv->v.hobject = (obj_global); } while (0);
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (obj_global))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  } else {



   do { } while (0);
   do { } while (0);
   do { duk_tval *duk__tv; duk__tv = (tv_this); duk__tv->t = 2; } while (0);
  }
  break;
 default:





  do { } while (0);
  do { } while (0);
  duk_to_object(thr, idx_this);
  break;
 }
}

static inline __attribute__((always_inline)) duk_bool_t duk__resolve_target_fastpath_check(duk_hthread *thr,
                                                                          duk_idx_t idx_func,
                                                                          duk_hobject **out_func,
                                                                          duk_small_uint_t call_flags) {






 duk_tval *tv_func;
 duk_hobject *func;

 if (__builtin_expect((call_flags & (1U << 1)), 0)) {
  return 0;
 }

 tv_func = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (idx_func));
 do { } while (0);

 if (__builtin_expect((((tv_func)->t == 9)), 1)) {
  func = ((tv_func)->v.hobject);
  if ((((&((func))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0) && !(((&(func)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0) && !(((&(func)->hdr)->h_flags & ((1UL << (7 + (19))))) != 0)) {
   *out_func = func;

   if ((((&(func)->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)) {

    return 1;
   }

   duk__coerce_nonstrict_this_binding(thr, idx_func + 1);
   return 1;
  }
 } else if (((tv_func)->t == 6)) {
  *out_func = 
# 1179 "duk_js_call.c" 3 4
             ((void *)0)
# 1179 "duk_js_call.c"
                 ;





  return 1;
 }

 return 0;
}

static duk_hobject *duk__resolve_target_func_and_this_binding(duk_hthread *thr,
                                                                 duk_idx_t idx_func,
                                                                 duk_small_uint_t *call_flags) {
 duk_tval *tv_func;
 duk_hobject *func;
 duk_bool_t first;

 do { } while (0);

 for (first = 1;; first = 0) {
  do { } while (0);

  tv_func = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (idx_func));
  do { } while (0);

  do { } while (0);

  if (((tv_func)->t == 9)) {
   func = ((tv_func)->v.hobject);

   if (*call_flags & (1U << 1)) {
    if (__builtin_expect((!(((&(func)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0)), 0)) {
     goto not_constructable;
    }
   } else {
    if (__builtin_expect((!(((&((func))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
     goto not_callable;
    }
   }

   if (__builtin_expect((!(((&(func)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0) && !(((&(func)->hdr)->h_flags & ((1UL << (7 + (19))))) != 0) && !(((&(func)->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)), 1)
                                                         ) {



    break;
   }



   if ((((&(func)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0)) {
    do { } while (0);
    do { } while (0);






    duk__handle_bound_chain_for_call(thr, idx_func, *call_flags & (1U << 1));

    do { } while (0)
                                                                      ;
   } else {
    do { } while (0);


    if ((((&(func)->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)) {







     duk__handle_proxy_for_call(thr, idx_func, (duk_hproxy *) func, call_flags);
    } else

    {
     do { } while (0);
     do { } while (0);
     do { } while (0);


     if (duk__handle_specialfuncs_for_call(thr, idx_func, func, call_flags, first) != 0) {



      break;
     }
    }
   }

  } else if (((tv_func)->t == 6)) {






   func = 
# 1281 "duk_js_call.c" 3 4
         ((void *)0)
# 1281 "duk_js_call.c"
             ;
   goto finished;
  } else {
   goto not_callable;
  }
 }

 do { } while (0);

 if (!(((&(func)->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)) {




  duk__coerce_nonstrict_this_binding(thr, idx_func + 1);
 }
 if (*call_flags & (1U << 1)) {
  if (!(*call_flags & (1U << 6))) {
   *call_flags |= (1U << 6);
   duk__update_default_instance_proto(thr, idx_func);
  }
 }

finished :
# 1320 "duk_js_call.c"
 return func;

not_callable:
 do { } while (0);
# 1333 "duk_js_call.c"
 if (((tv_func)->t == 9)) {
  duk_tval *tv_wrap =
      duk_hobject_find_entry_tval_ptr_stridx(thr->heap, ((tv_func)->v.hobject), 96);
  if (tv_wrap != 
# 1336 "duk_js_call.c" 3 4
                ((void *)0)
# 1336 "duk_js_call.c"
                    ) {
   do { } while (0);
   duk_push_tval(thr, tv_wrap);
   (void) (duk_throw_raw((thr)), (duk_ret_t) 0);
   do { return 
# 1340 "duk_js_call.c" 3 4
  ((void *)0)
# 1340 "duk_js_call.c"
  ; } while (0);
  }
 }






 do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 1349; do { } while (0); do { } while (0); duk_err_handle_error_fmt((thr), "duk_js_call.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("%s not callable"), (duk_push_string_tval_readable(thr, tv_func))); } while (0);




 do { return 
# 1354 "duk_js_call.c" 3 4
((void *)0)
# 1354 "duk_js_call.c"
; } while (0);

not_constructable:





 do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 1362; do { } while (0); do { } while (0); duk_err_handle_error_fmt((thr), "duk_js_call.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("%s not constructable"), (duk_push_string_tval_readable(thr, tv_func))); } while (0);




 do { return 
# 1367 "duk_js_call.c" 3 4
((void *)0)
# 1367 "duk_js_call.c"
; } while (0);
}
# 1380 "duk_js_call.c"
static void duk__safe_call_adjust_valstack(duk_hthread *thr,
                                              duk_idx_t idx_retbase,
                                              duk_idx_t num_stack_rets,
                                              duk_idx_t num_actual_rets) {
 duk_idx_t idx_rcbase;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 idx_rcbase = duk_get_top(thr) - num_actual_rets;
 if (__builtin_expect((idx_rcbase < 0), 0)) {
  do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 1393; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_call.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid C function rc"))); } while (0); } while (0);
  do { return; } while (0);
 }

 do { } while (0)





                                         ;

 do { } while (0);
# 1416 "duk_js_call.c"
 if (idx_rcbase > idx_retbase) {
  duk_idx_t count = idx_rcbase - idx_retbase;

  do { } while (0)


                                          ;




  do { } while (0);
  duk_remove_n(thr, idx_retbase, count);
 } else {
  duk_idx_t count = idx_retbase - idx_rcbase;

  do { } while (0)


                                          ;




  do { } while (0);
  do { } while (0);
  duk_insert_undefined_n(thr, idx_rcbase, count);
 }


 duk_set_top_unsafe(thr, idx_retbase + num_stack_rets);
}






static duk_small_uint_t duk__call_setup_act_attempt_tailcall(duk_hthread *thr,
                                                                duk_small_uint_t call_flags,
                                                                duk_idx_t idx_func,
                                                                duk_hobject *func,
                                                                duk_size_t entry_valstack_bottom_byteoff,
                                                                duk_size_t entry_valstack_end_byteoff,
                                                                duk_idx_t *out_nargs,
                                                                duk_idx_t *out_nregs,
                                                                duk_size_t *out_vs_min_bytes,
                                                                duk_activation **out_act) {
 duk_activation *act;
 duk_tval *tv1, *tv2;
 duk_idx_t idx_args;
 duk_small_uint_t flags1, flags2;




 do { (void) (entry_valstack_end_byteoff); } while (0);




 do { } while (0);

 act = thr->callstack_curr;
 do { } while (0);
 *out_act = act;

 if (func == 
# 1483 "duk_js_call.c" 3 4
            ((void *)0) 
# 1483 "duk_js_call.c"
                 || !(((&(func)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
  do { } while (0);
  return 0;
 }
 if (act->flags & (1U << 3)) {
  do { } while (0);
  return 0;
 }







 flags1 = (duk_small_uint_t) ((act->flags & (1U << 2)) ? 1 : 0)

          | (duk_small_uint_t) ((act->flags & (1U << 5)) ? 2 : 0)

     ;
 flags2 = (duk_small_uint_t) ((call_flags & (1U << 1)) ? 1 : 0)

          | (duk_small_uint_t) ((call_flags & (1U << 5)) ? 2 : 0);

 ;
 if (flags1 != flags2) {
  do { } while (0);
  return 0;
 }
 do { } while (0)
                                                                                                ;
 do { } while (0)
                                                                                                            ;
 if ((((&(func)->hdr)->h_flags & ((1UL << (7 + (10))))) != 0)) {

  do { } while (0);
  return 0;
 }
# 1545 "duk_js_call.c"
 do { } while (0);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);




 do { } while (0);
 do { } while (0);
# 1570 "duk_js_call.c"
 duk_hthread_activation_unwind_reuse_norz(thr);



 do { } while (0);
# 1584 "duk_js_call.c"
 act->cat = 
# 1584 "duk_js_call.c" 3 4
           ((void *)0)
# 1584 "duk_js_call.c"
               ;
 act->var_env = 
# 1585 "duk_js_call.c" 3 4
               ((void *)0)
# 1585 "duk_js_call.c"
                   ;
 act->lex_env = 
# 1586 "duk_js_call.c" 3 4
               ((void *)0)
# 1586 "duk_js_call.c"
                   ;
 do { } while (0);
 do { } while (0);
 act->func = func;




 act->curr_pc = ((((duk_hcompfunc *) func))->bytecode);



 do { duk_tval *duk__tv; duk__tv = (&act->tv_func); duk__tv->t = 9; duk__tv->v.hobject = (func); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (func))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);

 act->flags = (1U << 1);
 if ((((&(func)->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)) {
  act->flags |= (1U << 0);
 }
 if (call_flags & (1U << 1)) {
  act->flags |= (1U << 2);
 }

 if (call_flags & (1U << 5)) {
  act->flags |= (1U << 5);
 }


 do { } while (0);
 do { } while (0);
 do { } while (0);
 act->bottom_byteoff = entry_valstack_bottom_byteoff;
# 1626 "duk_js_call.c"
 act->reserve_byteoff = 0;
# 1640 "duk_js_call.c"
 tv1 = thr->valstack_bottom - 1;
 tv2 = thr->valstack_bottom + idx_func + 1;
 do { } while (0);
 do { } while (0);
 do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv1); tv__src = (tv2); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((tv__dst))->t & 0x08)) { h__obj = ((tv__dst)->v.heaphdr); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);

 idx_args = idx_func + 2;
 duk_remove_n(thr, 0, idx_args);

 idx_func = 0;
 do { (void) (idx_func); } while (0);
 idx_args = 0;

 *out_nargs = ((duk_hcompfunc *) func)->nargs;
 *out_nregs = ((duk_hcompfunc *) func)->nregs;
 do { } while (0);
 do { } while (0);
 *out_vs_min_bytes =
     entry_valstack_bottom_byteoff + sizeof(duk_tval) * ((duk_size_t) *out_nregs + 32U);
# 1673 "duk_js_call.c"
 return 1;
}


static void duk__call_setup_act_not_tailcall(duk_hthread *thr,
                                                duk_small_uint_t call_flags,
                                                duk_idx_t idx_func,
                                                duk_hobject *func,
                                                duk_size_t entry_valstack_bottom_byteoff,
                                                duk_size_t entry_valstack_end_byteoff,
                                                duk_idx_t *out_nargs,
                                                duk_idx_t *out_nregs,
                                                duk_size_t *out_vs_min_bytes,
                                                duk_activation **out_act) {
 duk_activation *act;
 duk_activation *new_act;

 do { (void) (entry_valstack_end_byteoff); } while (0);

 do { } while (0);

 duk__call_callstack_limit_check(thr);
 new_act = duk_hthread_activation_alloc(thr);
 do { } while (0);

 act = thr->callstack_curr;
 if (act != 
# 1699 "duk_js_call.c" 3 4
           ((void *)0)
# 1699 "duk_js_call.c"
               ) {
# 1710 "duk_js_call.c"
  act->retval_byteoff = entry_valstack_bottom_byteoff + (duk_size_t) idx_func * sizeof(duk_tval);
 }

 new_act->parent = act;
 thr->callstack_curr = new_act;
 thr->callstack_top++;
 act = new_act;
 *out_act = act;

 do { } while (0);
 do { } while (0);

 act->cat = 
# 1722 "duk_js_call.c" 3 4
           ((void *)0)
# 1722 "duk_js_call.c"
               ;

 act->flags = 0;
 if (call_flags & (1U << 1)) {
  act->flags |= (1U << 2);
 }

 if (call_flags & (1U << 5)) {
  act->flags |= (1U << 5);
 }

 if (call_flags & (1U << 4)) {
  act->flags |= (1U << 4);
 }


 act->func = func;
 if (__builtin_expect((func != 
# 1739 "duk_js_call.c" 3 4
    ((void *)0)
# 1739 "duk_js_call.c"
    ), 1)) {
  do { duk_tval *duk__tv; duk__tv = (&act->tv_func); duk__tv->t = 9; duk__tv->v.hobject = (func); } while (0);
  if ((((&(func)->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)) {
   act->flags |= (1U << 0);
  }
  if ((((&(func)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
   *out_nargs = ((duk_hcompfunc *) func)->nargs;
   *out_nregs = ((duk_hcompfunc *) func)->nregs;
   do { } while (0);
   do { } while (0);
   *out_vs_min_bytes =
       entry_valstack_bottom_byteoff +
       sizeof(duk_tval) * ((duk_size_t) idx_func + 2U + (duk_size_t) *out_nregs + 32U);
  } else {

   do { } while (0);

   *out_nargs = ((duk_hnatfunc *) func)->nargs;
   *out_nregs = *out_nargs;
   if (*out_nargs >= 0) {
    *out_vs_min_bytes =
        entry_valstack_bottom_byteoff +
        sizeof(duk_tval) * ((duk_size_t) idx_func + 2U + (duk_size_t) *out_nregs +
                            64U + 32U);
   } else {

    duk_size_t valstack_top_byteoff =
        (duk_size_t) ((duk_uint8_t *) thr->valstack_top - ((duk_uint8_t *) thr->valstack));
    *out_vs_min_bytes = valstack_top_byteoff + sizeof(duk_tval) * (64U +
                                                                   32U);
   }
  }
 } else {
  duk_small_uint_t lf_flags;
  duk_tval *tv_func;

  act->flags |= (1U << 0);

  tv_func = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (idx_func));
  do { } while (0);
  do { *(&act->tv_func) = *(tv_func); } while (0);

  lf_flags = ((duk_small_uint_t) ((tv_func)->v_extra));
  *out_nargs = ((lf_flags) &0x0fU);
  if (*out_nargs != 0x0f) {
   *out_vs_min_bytes = entry_valstack_bottom_byteoff +
                       sizeof(duk_tval) * ((duk_size_t) idx_func + 2U + (duk_size_t) *out_nargs +
                                           64U + 32U);
  } else {
   duk_size_t valstack_top_byteoff =
       (duk_size_t) ((duk_uint8_t *) thr->valstack_top - ((duk_uint8_t *) thr->valstack));
   *out_vs_min_bytes = valstack_top_byteoff +
                       sizeof(duk_tval) * (64U + 32U);
   *out_nargs = -1;
  }
  *out_nregs = *out_nargs;
 }

 act->var_env = 
# 1797 "duk_js_call.c" 3 4
               ((void *)0)
# 1797 "duk_js_call.c"
                   ;
 act->lex_env = 
# 1798 "duk_js_call.c" 3 4
               ((void *)0)
# 1798 "duk_js_call.c"
                   ;



 act->curr_pc = 
# 1802 "duk_js_call.c" 3 4
               ((void *)0)
# 1802 "duk_js_call.c"
                   ;



 act->bottom_byteoff = entry_valstack_bottom_byteoff + sizeof(duk_tval) * ((duk_size_t) idx_func + 2U);







 act->reserve_byteoff = 0;





 do { if ((func) != 
# 1820 "duk_js_call.c" 3 4
((void *)0)
# 1820 "duk_js_call.c"
) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((func)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0);






}





static void duk__call_env_setup(duk_hthread *thr, duk_hobject *func, duk_activation *act, duk_idx_t idx_args) {
 duk_hobject *env;

 do { } while (0);

 if (__builtin_expect((func != 
# 1838 "duk_js_call.c" 3 4
    ((void *)0)
# 1838 "duk_js_call.c"
    ), 1)) {
  if (__builtin_expect(((((&(func)->hdr)->h_flags & ((1UL << (7 + (11))))) != 0)), 1)) {
   do { } while (0);
   if (__builtin_expect((!(((&(func)->hdr)->h_flags & ((1UL << (7 + (13))))) != 0)), 1)) {




    do { } while (0);
    do { } while (0);
   } else {





    env = duk_create_activation_environment_record(thr, func, act->bottom_byteoff);
    do { } while (0);



    do { } while (0);
    duk__handle_createargs_for_call(thr, func, env, idx_args);



    act->lex_env = env;
    act->var_env = env;
    do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
    do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
    duk_pop(thr);
   }
  } else {




   do { } while (0);

   do { } while (0);
   duk__handle_oldenv_for_call(thr, func, act);

   do { } while (0);
   do { } while (0);
  }
 } else {

  do { } while (0);
  do { } while (0);
  do { } while (0);
 }
}






static void duk__call_thread_state_update(duk_hthread *thr) {
 do { } while (0);

 if (__builtin_expect((thr == thr->heap->curr_thread), 1)) {
  if (__builtin_expect((thr->state != 2), 0)) {

   goto thread_state_error;
  }
 } else {
  do { } while (0);
  if (__builtin_expect((thr->state != 1), 0)) {
   goto thread_state_error;
  }
  do { (thr->heap)->curr_thread = (thr); } while (0);
  thr->state = 2;




 }
 do { } while (0);
 do { } while (0);
 return;

thread_state_error:
 do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 1921; do { } while (0); do { } while (0); duk_err_handle_error_fmt((thr), "duk_js_call.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("invalid thread state (%ld)"), ((long) thr->state)); } while (0);
 do { return; } while (0);
}
# 1946 "duk_js_call.c"
static duk_int_t duk__handle_call_raw(duk_hthread *thr, duk_idx_t idx_func, duk_small_uint_t call_flags) {




 duk_size_t entry_valstack_bottom_byteoff;
 duk_size_t entry_valstack_end_byteoff;
 duk_int_t entry_call_recursion_depth;
 duk_hthread *entry_curr_thread;
 duk_uint_fast8_t entry_thread_state;
 duk_instr_t **entry_ptr_curr_pc;
 duk_idx_t idx_args;
 duk_idx_t nargs;
 duk_idx_t nregs;
 duk_size_t vs_min_bytes;
 duk_hobject *func;
 duk_activation *act;
 duk_ret_t rc;
 duk_small_uint_t use_tailcall;

 do { } while (0);
 do { } while (0);



 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);
# 2012 "duk_js_call.c"
 entry_valstack_bottom_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_bottom - (duk_uint8_t *) thr->valstack);
 entry_valstack_end_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack);
 entry_call_recursion_depth = thr->heap->call_recursion_depth;
 entry_curr_thread = thr->heap->curr_thread;
 entry_thread_state = thr->state;
 entry_ptr_curr_pc = thr->ptr_curr_pc;





 duk_hthread_sync_and_null_currpc(thr);
 do { } while (0);

 do { } while (0)
# 2045 "duk_js_call.c"
                                               ;





 duk__call_thread_state_update(thr);
# 2069 "duk_js_call.c"
 duk__call_c_recursion_limit_check(thr);
 thr->heap->call_recursion_depth++;
 duk_require_stack(thr, 8);







 if (__builtin_expect((duk__resolve_target_fastpath_check(thr, idx_func, &func, call_flags) != 0U), 1)) {
  do { } while (0);
 } else {
  do { } while (0);
  func = duk__resolve_target_func_and_this_binding(thr, idx_func, &call_flags);
 }
 do { } while (0);

 do { } while (0);
 do { } while (0);
# 2103 "duk_js_call.c"
 act = 
# 2103 "duk_js_call.c" 3 4
      ((void *)0)
# 2103 "duk_js_call.c"
          ;
 nargs = 0;
 nregs = 0;
 vs_min_bytes = 0;


 use_tailcall = (call_flags & (1U << 0));
 if (use_tailcall) {
  use_tailcall = duk__call_setup_act_attempt_tailcall(thr,
                                                      call_flags,
                                                      idx_func,
                                                      func,
                                                      entry_valstack_bottom_byteoff,
                                                      entry_valstack_end_byteoff,
                                                      &nargs,
                                                      &nregs,
                                                      &vs_min_bytes,
                                                      &act);
 }





 if (use_tailcall) {
  idx_args = 0;
  do { } while (0);
 } else {
  duk__call_setup_act_not_tailcall(thr,
                                   call_flags,
                                   idx_func,
                                   func,
                                   entry_valstack_bottom_byteoff,
                                   entry_valstack_end_byteoff,
                                   &nargs,
                                   &nregs,
                                   &vs_min_bytes,
                                   &act);
  idx_args = idx_func + 2;
 }


 do { } while (0);
# 2155 "duk_js_call.c"
 duk_valstack_grow_check_throw(thr, vs_min_bytes);
 act->reserve_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_end - (duk_uint8_t *) thr->valstack);
# 2171 "duk_js_call.c"
 duk__call_env_setup(thr, func, act, idx_args);
# 2181 "duk_js_call.c"
 if (use_tailcall) {
  do { } while (0);
  do { } while (0);
  duk_set_top_and_wipe(thr, nregs, nargs);
 } else {
  if (nregs >= 0) {
   do { } while (0);
   duk_set_top_and_wipe(thr, idx_func + 2 + nregs, idx_func + 2 + nargs);
  } else {
   ;
  }
  thr->valstack_bottom = thr->valstack_bottom + idx_func + 2;
 }
 do { } while (0);
 do { } while (0);
 do { } while (0);







 if (func != 
# 2204 "duk_js_call.c" 3 4
            ((void *)0) 
# 2204 "duk_js_call.c"
                 && (((&(func)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {




  do { } while (0);
  do { } while (0);
  act->curr_pc = ((((duk_hcompfunc *) func))->bytecode);

  if (call_flags & (1U << 3)) {
   do { } while (0);
   do { } while (0);
   do { } while (0);
   do { duk_refzero_check_fast((thr)); } while (0);
   do { } while (0);
   thr->heap->call_recursion_depth--;
   return 1;
  }
  do { } while (0);


  do { } while (0);
  act->flags |= (1U << 3);
  thr->callstack_preventcount++;
# 2244 "duk_js_call.c"
  do { } while (0);
  do { } while (0);
  duk_js_execute_bytecode(thr);
  do { } while (0);
 } else {




  do { } while (0);
  do { } while (0);




  do { } while (0);
  act->flags |= (1U << 3);
  thr->callstack_preventcount++;


  do { } while (0);


  if (func) {
   rc = ((duk_hnatfunc *) func)->func(thr);
  } else {
   duk_tval *tv_func;
   duk_c_function funcptr;

   tv_func = &act->tv_func;
   do { } while (0);
   funcptr = ((tv_func)->v.lightfunc);
   rc = funcptr(thr);
  }



  if (rc == 0) {
   do { } while (0);
   do { } while (0);
   thr->valstack_top++;
  } else if (rc == 1) {
   ;
  } else if (rc < 0) {
   duk_error_throw_from_negative_rc(thr, rc);
   do { return 0; } while (0);
  } else {
   do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 2291; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_call.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid C function rc"))); } while (0); } while (0);
   do { return 0; } while (0);
  }
 }
 do { } while (0);
 do { } while (0);






 if (call_flags & ((1U << 1) | (1U << 5))) {
  duk_call_construct_postprocess(thr, call_flags & (1U << 5));
 }
# 2316 "duk_js_call.c"
 do { } while (0);
 do { } while (0);
 do { } while (0);
 duk_hthread_activation_unwind_norz(thr);
 do { } while (0);
 do { } while (0);

 thr->valstack_bottom = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + entry_valstack_bottom_byteoff);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);





 {
  duk_tval *tv_ret;
  duk_tval *tv_funret;

  tv_ret = thr->valstack_bottom + idx_func;
  tv_funret = thr->valstack_top - 1;




  do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv_ret); tv__src = (tv_funret); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((tv__dst))->t & 0x08)) { h__obj = ((tv__dst)->v.heaphdr); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);
 }

 duk_set_top_unsafe(thr, idx_func + 1);




 do { } while (0);
 do { } while (0);
 thr->valstack_end = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + entry_valstack_end_byteoff);






 thr->ptr_curr_pc = entry_ptr_curr_pc;

 do { (thr->heap)->curr_thread = (entry_curr_thread); } while (0);
 thr->state = (duk_uint8_t) entry_thread_state;
# 2373 "duk_js_call.c"
 thr->heap->call_recursion_depth = entry_call_recursion_depth;
# 2398 "duk_js_call.c"
 do { } while (0);
 do { } while (0);
 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);

 do { duk_refzero_check_fast((thr)); } while (0);

 return 0;
}

static __attribute__ ((unused)) duk_int_t duk_handle_call_unprotected_nargs(duk_hthread *thr, duk_idx_t nargs, duk_small_uint_t call_flags) {
 duk_idx_t idx_func;
 do { } while (0);
 idx_func = duk_get_top(thr) - (nargs + 2);
 do { } while (0);
 return duk_handle_call_unprotected(thr, idx_func, call_flags);
}

static __attribute__ ((unused)) duk_int_t duk_handle_call_unprotected(duk_hthread *thr, duk_idx_t idx_func, duk_small_uint_t call_flags) {
 do { } while (0);
 do { } while (0);
 return duk__handle_call_raw(thr, idx_func, call_flags);
}
# 2438 "duk_js_call.c"
static void duk__handle_safe_call_inner(duk_hthread *thr,
                                           duk_safe_call_function func,
                                           void *udata,




                                           duk_hthread *entry_curr_thread,
                                           duk_uint_fast8_t entry_thread_state,
                                           duk_idx_t idx_retbase,
                                           duk_idx_t num_stack_rets) {
 duk_ret_t rc;

 do { } while (0);
 do { } while (0);





 duk__call_thread_state_update(thr);





 duk__call_c_recursion_limit_check(thr);
 thr->heap->call_recursion_depth++;





 rc = func(thr, udata);

 do { } while (0);






 do { } while (0);
 do { } while (0);
 do { } while (0)
                                          ;
 do { } while (0);
 do { } while (0);

 if (__builtin_expect((rc < 0), 0)) {
  duk_error_throw_from_negative_rc(thr, rc);
  do { return; } while (0);
 }
 do { } while (0);

 duk__safe_call_adjust_valstack(thr, idx_retbase, num_stack_rets, rc);

 do { (thr->heap)->curr_thread = (entry_curr_thread); } while (0);
 thr->state = (duk_uint8_t) entry_thread_state;
}

static void duk__handle_safe_call_error(duk_hthread *thr,
                                           duk_activation *entry_act,



                                           duk_hthread *entry_curr_thread,
                                           duk_uint_fast8_t entry_thread_state,
                                           duk_idx_t idx_retbase,
                                           duk_idx_t num_stack_rets,
                                           duk_size_t entry_valstack_bottom_byteoff,
                                           duk_jmpbuf *old_jmpbuf_ptr) {
 do { } while (0);
 do { } while (0);
# 2521 "duk_js_call.c"
 do { } while (0);




 do { } while (0);
 do { do { } while (0); do { } while (0); } while (0);


 thr->heap->lj.jmpbuf_ptr = old_jmpbuf_ptr;







 do { } while (0);
 while (thr->callstack_curr != entry_act) {
  do { } while (0);
  duk_hthread_activation_unwind_norz(thr);
 }
 do { } while (0);




 do { (thr->heap)->curr_thread = (entry_curr_thread); } while (0);
 thr->state = (duk_uint8_t) entry_thread_state;

 do { } while (0);
 do { } while (0);


 thr->valstack_bottom = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + entry_valstack_bottom_byteoff);




 duk_push_tval(thr, &thr->heap->lj.value1);



 do { } while (0);

 duk__safe_call_adjust_valstack(thr, idx_retbase, num_stack_rets, 1);




 thr->heap->lj.type = 0;
 thr->heap->lj.iserror = 0;
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (&thr->heap->lj.value1); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 2; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz((((thr))), duk__h); } } } while (0); } while (0);
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (&thr->heap->lj.value2); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 2; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz((((thr))), duk__h); } } } while (0); } while (0);
# 2583 "duk_js_call.c"
 do { } while (0);
 thr->heap->pf_prevent_count--;
 do { } while (0);





}

static void duk__handle_safe_call_shared_unwind(duk_hthread *thr,
                                                   duk_idx_t idx_retbase,
                                                   duk_idx_t num_stack_rets,



                                                   duk_int_t entry_call_recursion_depth,
                                                   duk_hthread *entry_curr_thread,
                                                   duk_instr_t **entry_ptr_curr_pc) {
 do { } while (0);
 do { } while (0);
 do { (void) (idx_retbase); } while (0);
 do { (void) (num_stack_rets); } while (0);
 do { (void) (entry_curr_thread); } while (0);

 do { } while (0);





 thr->ptr_curr_pc = entry_ptr_curr_pc;

 thr->heap->call_recursion_depth = entry_call_recursion_depth;


 do { } while (0);
# 2628 "duk_js_call.c"
}

static __attribute__ ((unused)) duk_int_t duk_handle_safe_call(duk_hthread *thr,
                                            duk_safe_call_function func,
                                            void *udata,
                                            duk_idx_t num_stack_args,
                                            duk_idx_t num_stack_rets) {
 duk_activation *entry_act;
 duk_size_t entry_valstack_bottom_byteoff;





 duk_int_t entry_call_recursion_depth;
 duk_hthread *entry_curr_thread;
 duk_uint_fast8_t entry_thread_state;
 duk_instr_t **entry_ptr_curr_pc;
 duk_jmpbuf *old_jmpbuf_ptr = 
# 2646 "duk_js_call.c" 3 4
                             ((void *)0)
# 2646 "duk_js_call.c"
                                 ;
 duk_jmpbuf our_jmpbuf;
 duk_idx_t idx_retbase;
 duk_int_t retval;

 do { } while (0);
 do { } while (0);

 do { } while (0);
# 2663 "duk_js_call.c"
 entry_act = thr->callstack_curr;
 entry_valstack_bottom_byteoff = (duk_size_t) ((duk_uint8_t *) thr->valstack_bottom - (duk_uint8_t *) thr->valstack);





 entry_call_recursion_depth = thr->heap->call_recursion_depth;
 entry_curr_thread = thr->heap->curr_thread;
 entry_thread_state = thr->state;
 entry_ptr_curr_pc = thr->ptr_curr_pc;
 idx_retbase = duk_get_top(thr) - num_stack_args;
 do { } while (0);

 do { } while (0);
 do { } while (0);


 do { } while (0)
# 2696 "duk_js_call.c"
                                               ;


 old_jmpbuf_ptr = thr->heap->lj.jmpbuf_ptr;
 thr->heap->lj.jmpbuf_ptr = &our_jmpbuf;





 thr->callstack_preventcount++;




 do { } while (0);
 if (
# 2712 "duk_js_call.c" 3 4
    _setjmp (
# 2712 "duk_js_call.c"
    (our_jmpbuf.jb)
# 2712 "duk_js_call.c" 3 4
    ) 
# 2712 "duk_js_call.c"
                              == 0) {


  do { } while (0);

  duk__handle_safe_call_inner(thr,
                              func,
                              udata,




                              entry_curr_thread,
                              entry_thread_state,
                              idx_retbase,
                              num_stack_rets);

  do { } while (0);


  thr->heap->lj.jmpbuf_ptr = old_jmpbuf_ptr;




  do { } while (0);
  do { } while (0)
                                        ;

  retval = 0;




 } else {


  do { } while (0)
                                        ;

  do { } while (0);

  duk__handle_safe_call_error(thr,
                              entry_act,



                              entry_curr_thread,
                              entry_thread_state,
                              idx_retbase,
                              num_stack_rets,
                              entry_valstack_bottom_byteoff,
                              old_jmpbuf_ptr);

  retval = 1;
 }
# 2831 "duk_js_call.c"
 do { } while (0);

 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);

 do { } while (0);
 duk__handle_safe_call_shared_unwind(thr,
                                     idx_retbase,
                                     num_stack_rets,



                                     entry_call_recursion_depth,
                                     entry_curr_thread,
                                     entry_ptr_curr_pc);


 thr->callstack_preventcount--;
 do { } while (0);


 do { } while (0);
 do { } while (0)
                                          ;
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { do { } while (0); do { } while (0); do { } while (0); do { } while (0); do { } while (0); } while (0);


 do { duk_refzero_check_fast((thr)); } while (0);

 return retval;
}
# 2877 "duk_js_call.c"
static __attribute__ ((unused)) __attribute__((noinline)) __attribute__((cold)) void duk_call_setup_propcall_error(duk_hthread *thr, duk_tval *tv_base, duk_tval *tv_key) {
 const char *str_targ, *str_key, *str_base;
 duk_idx_t entry_top;

 entry_top = duk_get_top(thr);




 duk_push_tval(thr, tv_base);
 duk_push_tval(thr, tv_key);

 do { } while (0);

 duk_push_bare_object(thr);
# 2922 "duk_js_call.c"
 str_targ = duk_push_string_readable(thr, -4);
 str_key = duk_push_string_readable(thr, -3);
 str_base = duk_push_string_readable(thr, -5);
 duk_push_error_object_raw((thr), (6 | (1L << 24)), (const char *) ("duk_js_call.c"), (duk_int_t) (2925), "%s not callable (property %s of %s)", str_targ, str_key, str_base)




                                ;

 duk_xdef_prop_stridx(thr, -5, 96, 0);

 duk_swap(thr, -4, entry_top - 1);




 duk_set_top(thr, entry_top);


 do { } while (0);
}
# 1 "duk_js_compiler.c"
# 98 "duk_js_compiler.c"
typedef struct {
 duk_small_uint_t flags;
 duk_compiler_ctx comp_ctx_alloc;
 duk_lexer_point lex_pt_alloc;
} duk__compiler_stkstate;






static void duk__advance_helper(duk_compiler_ctx *comp_ctx, duk_small_int_t expect);
static void duk__advance_expect(duk_compiler_ctx *comp_ctx, duk_small_int_t expect);
static void duk__advance(duk_compiler_ctx *ctx);


static void duk__init_func_valstack_slots(duk_compiler_ctx *comp_ctx);
static void duk__reset_func_for_pass2(duk_compiler_ctx *comp_ctx);
static void duk__init_varmap_and_prologue_for_pass2(duk_compiler_ctx *comp_ctx, duk_regconst_t *out_stmt_value_reg);
static void duk__convert_to_func_template(duk_compiler_ctx *comp_ctx);
static duk_int_t duk__cleanup_varmap(duk_compiler_ctx *comp_ctx);


static duk_int_t duk__get_current_pc(duk_compiler_ctx *comp_ctx);
static duk_compiler_instr *duk__get_instr_ptr(duk_compiler_ctx *comp_ctx, duk_int_t pc);
static void duk__emit(duk_compiler_ctx *comp_ctx, duk_instr_t ins);
static void duk__emit_op_only(duk_compiler_ctx *comp_ctx, duk_small_uint_t op);
static void duk__emit_a_b_c(duk_compiler_ctx *comp_ctx,
                                    duk_small_uint_t op_flags,
                                    duk_regconst_t a,
                                    duk_regconst_t b,
                                    duk_regconst_t c);
static void duk__emit_a_b(duk_compiler_ctx *comp_ctx, duk_small_uint_t op_flags, duk_regconst_t a, duk_regconst_t b);
static void duk__emit_b_c(duk_compiler_ctx *comp_ctx, duk_small_uint_t op_flags, duk_regconst_t b, duk_regconst_t c);




static void duk__emit_a_bc(duk_compiler_ctx *comp_ctx, duk_small_uint_t op_flags, duk_regconst_t a, duk_regconst_t bc);
static void duk__emit_bc(duk_compiler_ctx *comp_ctx, duk_small_uint_t op, duk_regconst_t bc);
static void duk__emit_abc(duk_compiler_ctx *comp_ctx, duk_small_uint_t op, duk_regconst_t abc);
static void duk__emit_load_int32(duk_compiler_ctx *comp_ctx, duk_regconst_t reg, duk_int32_t val);
static void duk__emit_load_int32_noshuffle(duk_compiler_ctx *comp_ctx, duk_regconst_t reg, duk_int32_t val);
static void duk__emit_jump(duk_compiler_ctx *comp_ctx, duk_int_t target_pc);
static duk_int_t duk__emit_jump_empty(duk_compiler_ctx *comp_ctx);
static void duk__insert_jump_entry(duk_compiler_ctx *comp_ctx, duk_int_t jump_pc);
static void duk__patch_jump(duk_compiler_ctx *comp_ctx, duk_int_t jump_pc, duk_int_t target_pc);
static void duk__patch_jump_here(duk_compiler_ctx *comp_ctx, duk_int_t jump_pc);
static void duk__patch_trycatch(duk_compiler_ctx *comp_ctx,
                                        duk_int_t ldconst_pc,
                                        duk_int_t trycatch_pc,
                                        duk_regconst_t reg_catch,
                                        duk_regconst_t const_varname,
                                        duk_small_uint_t flags);
static void duk__emit_if_false_skip(duk_compiler_ctx *comp_ctx, duk_regconst_t regconst);
static void duk__emit_if_true_skip(duk_compiler_ctx *comp_ctx, duk_regconst_t regconst);
static void duk__emit_invalid(duk_compiler_ctx *comp_ctx);


static void duk__ivalue_regconst(duk_ivalue *x, duk_regconst_t regconst);
static void duk__ivalue_plain_fromstack(duk_compiler_ctx *comp_ctx, duk_ivalue *x);
static void duk__ivalue_var_fromstack(duk_compiler_ctx *comp_ctx, duk_ivalue *x);
static void duk__ivalue_var_hstring(duk_compiler_ctx *comp_ctx, duk_ivalue *x, duk_hstring *h);
static void duk__copy_ispec(duk_compiler_ctx *comp_ctx, duk_ispec *src, duk_ispec *dst);
static void duk__copy_ivalue(duk_compiler_ctx *comp_ctx, duk_ivalue *src, duk_ivalue *dst);
static duk_regconst_t duk__alloctemps(duk_compiler_ctx *comp_ctx, duk_small_int_t num);
static duk_regconst_t duk__alloctemp(duk_compiler_ctx *comp_ctx);
static void duk__settemp_checkmax(duk_compiler_ctx *comp_ctx, duk_regconst_t temp_next);
static duk_regconst_t duk__getconst(duk_compiler_ctx *comp_ctx);
static
duk_regconst_t duk__ispec_toregconst_raw(duk_compiler_ctx *comp_ctx,
                                         duk_ispec *x,
                                         duk_regconst_t forced_reg,
                                         duk_small_uint_t flags);
static void duk__ispec_toforcedreg(duk_compiler_ctx *comp_ctx, duk_ispec *x, duk_regconst_t forced_reg);
static void duk__ivalue_toplain_raw(duk_compiler_ctx *comp_ctx, duk_ivalue *x, duk_regconst_t forced_reg);
static void duk__ivalue_toplain(duk_compiler_ctx *comp_ctx, duk_ivalue *x);
static void duk__ivalue_toplain_ignore(duk_compiler_ctx *comp_ctx, duk_ivalue *x);
static
duk_regconst_t duk__ivalue_toregconst_raw(duk_compiler_ctx *comp_ctx,
                                          duk_ivalue *x,
                                          duk_regconst_t forced_reg,
                                          duk_small_uint_t flags);
static duk_regconst_t duk__ivalue_toreg(duk_compiler_ctx *comp_ctx, duk_ivalue *x);



static void duk__ivalue_toforcedreg(duk_compiler_ctx *comp_ctx, duk_ivalue *x, duk_int_t forced_reg);
static duk_regconst_t duk__ivalue_toregconst(duk_compiler_ctx *comp_ctx, duk_ivalue *x);
static duk_regconst_t duk__ivalue_totempconst(duk_compiler_ctx *comp_ctx, duk_ivalue *x);


static duk_regconst_t duk__lookup_active_register_binding(duk_compiler_ctx *comp_ctx);
static duk_bool_t duk__lookup_lhs(duk_compiler_ctx *ctx, duk_regconst_t *out_reg_varbind, duk_regconst_t *out_rc_varname);


static void duk__add_label(duk_compiler_ctx *comp_ctx, duk_hstring *h_label, duk_int_t pc_label, duk_int_t label_id);
static void duk__update_label_flags(duk_compiler_ctx *comp_ctx, duk_int_t label_id, duk_small_uint_t flags);
static void duk__lookup_active_label(duk_compiler_ctx *comp_ctx,
                                             duk_hstring *h_label,
                                             duk_bool_t is_break,
                                             duk_int_t *out_label_id,
                                             duk_int_t *out_label_catch_depth,
                                             duk_int_t *out_label_pc,
                                             duk_bool_t *out_is_closest);
static void duk__reset_labels_to_length(duk_compiler_ctx *comp_ctx, duk_size_t len);


static void duk__expr_nud(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
static void duk__expr_led(duk_compiler_ctx *comp_ctx, duk_ivalue *left, duk_ivalue *res);
static duk_small_uint_t duk__expr_lbp(duk_compiler_ctx *comp_ctx);
static duk_bool_t duk__expr_is_empty(duk_compiler_ctx *comp_ctx);


static void duk__expr(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);
static void duk__exprtop(duk_compiler_ctx *ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);
# 222 "duk_js_compiler.c"
static void duk__expr_toforcedreg(duk_compiler_ctx *comp_ctx,
                                          duk_ivalue *res,
                                          duk_small_uint_t rbp_flags,
                                          duk_regconst_t forced_reg);
static duk_regconst_t duk__expr_toregconst(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);



static void duk__expr_toplain(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);
static void duk__expr_toplain_ignore(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);
static duk_regconst_t duk__exprtop_toreg(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);



static void duk__exprtop_toforcedreg(duk_compiler_ctx *comp_ctx,
                                             duk_ivalue *res,
                                             duk_small_uint_t rbp_flags,
                                             duk_regconst_t forced_reg);
static duk_regconst_t duk__exprtop_toregconst(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags);





static duk_int_t duk__parse_arguments(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
static void duk__nud_array_literal(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
static void duk__nud_object_literal(duk_compiler_ctx *comp_ctx, duk_ivalue *res);


static void duk__parse_var_decl(duk_compiler_ctx *comp_ctx,
                                        duk_ivalue *res,
                                        duk_small_uint_t expr_flags,
                                        duk_regconst_t *out_reg_varbind,
                                        duk_regconst_t *out_rc_varname);
static void duk__parse_var_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t expr_flags);
static void duk__parse_for_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_int_t pc_label_site);
static void duk__parse_switch_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_int_t pc_label_site);
static void duk__parse_if_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
static void duk__parse_do_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_int_t pc_label_site);
static void duk__parse_while_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_int_t pc_label_site);
static void duk__parse_break_or_continue_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
static void duk__parse_return_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
static void duk__parse_throw_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
static void duk__parse_try_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
static void duk__parse_with_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res);
static void duk__parse_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_bool_t allow_source_elem);
static duk_int_t duk__stmt_label_site(duk_compiler_ctx *comp_ctx, duk_int_t label_id);
static void duk__parse_stmts(duk_compiler_ctx *comp_ctx,
                                     duk_bool_t allow_source_elem,
                                     duk_bool_t expect_eof,
                                     duk_bool_t regexp_after);

static void duk__parse_func_body(duk_compiler_ctx *comp_ctx,
                                         duk_bool_t expect_eof,
                                         duk_bool_t implicit_return_value,
                                         duk_bool_t regexp_after,
                                         duk_small_int_t expect_token);
static void duk__parse_func_formals(duk_compiler_ctx *comp_ctx);
static void duk__parse_func_like_raw(duk_compiler_ctx *comp_ctx, duk_small_uint_t flags);
static duk_int_t duk__parse_func_like_fnum(duk_compiler_ctx *comp_ctx, duk_small_uint_t flags);
# 336 "duk_js_compiler.c"
static const duk_uint8_t duk__token_lbp[] = {
 ((2) >> 1),
 (((0) >> 1) | ((1 << 5))),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((24) >> 1),
 ((24) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 (((0) >> 1) | ((1 << 5))),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 (((0) >> 1) | ((1 << 5))),
 (((0) >> 1) | ((1 << 5))),
 (((0) >> 1) | ((1 << 5))),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 (((0) >> 1) | ((1 << 5))),
 ((38) >> 1),
 (((4) >> 1) | ((1 << 5))),
 ((36) >> 1),
 (((4) >> 1) | ((1 << 5))),
 ((38) >> 1),
 ((0) >> 1),
 ((6) >> 1),
 ((24) >> 1),
 ((24) >> 1),
 ((24) >> 1),
 ((24) >> 1),
 ((22) >> 1),
 ((22) >> 1),
 ((22) >> 1),
 ((22) >> 1),
 ((28) >> 1),
 ((28) >> 1),
 ((30) >> 1),
 ((30) >> 1),
 ((30) >> 1),
 ((32) >> 1),
 (((34) >> 1) | ((1 << 5))),
 (((34) >> 1) | ((1 << 5))),
 ((26) >> 1),
 ((26) >> 1),
 ((26) >> 1),
 ((20) >> 1),
 ((16) >> 1),
 ((18) >> 1),
 ((0) >> 1),
 ((0) >> 1),
 ((14) >> 1),
 ((12) >> 1),
 ((10) >> 1),
 ((0) >> 1),
 ((8) >> 1),
 ((8) >> 1),
 ((8) >> 1),
 ((8) >> 1),
 ((8) >> 1),
 ((8) >> 1),
 ((8) >> 1),
 ((8) >> 1),
 ((8) >> 1),
 ((8) >> 1),
 ((8) >> 1),
 ((8) >> 1),
 ((8) >> 1),
 (((0) >> 1) | ((1 << 5))),
 (((0) >> 1) | ((1 << 5))),
 (((0) >> 1) | ((1 << 5))),
};





static void duk__comp_recursion_increase(duk_compiler_ctx *comp_ctx) {
 do { } while (0);
 do { } while (0);
 if (comp_ctx->recursion_depth >= comp_ctx->recursion_limit) {
  do { duk_err_range((comp_ctx->thr), "duk_js_compiler.c", (duk_int_t) 449, ("compiler recursion limit")); } while (0);
  do { return; } while (0);
 }
 comp_ctx->recursion_depth++;
}

static void duk__comp_recursion_decrease(duk_compiler_ctx *comp_ctx) {
 do { } while (0);
 do { } while (0);
 comp_ctx->recursion_depth--;
}

static duk_bool_t duk__hstring_is_eval_or_arguments(duk_compiler_ctx *comp_ctx, duk_hstring *h) {
 do { (void) (comp_ctx); } while (0);
 do { } while (0);
 return (((&(h)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0);
}

static duk_bool_t duk__hstring_is_eval_or_arguments_in_strict_mode(duk_compiler_ctx *comp_ctx, duk_hstring *h) {
 do { } while (0);
 return (comp_ctx->curr_func.is_strict && (((&(h)->hdr)->h_flags & ((1UL << (7 + (6))))) != 0));
}
# 480 "duk_js_compiler.c"
static void duk__advance_helper(duk_compiler_ctx *comp_ctx, duk_small_int_t expect) {
 duk_hthread *thr = comp_ctx->thr;
 duk_bool_t regexp;

 do { } while (0);
 do { } while (0);
# 496 "duk_js_compiler.c"
 regexp = 1;
 if (duk__token_lbp[comp_ctx->curr_token.t] & (1 << 5)) {
  regexp = 0;
 }
 if (comp_ctx->curr_func.reject_regexp_in_adv) {
  comp_ctx->curr_func.reject_regexp_in_adv = 0;
  regexp = 0;
 }
 if (comp_ctx->curr_func.allow_regexp_in_adv) {
  comp_ctx->curr_func.allow_regexp_in_adv = 0;
  regexp = 1;
 }

 if (expect >= 0 && comp_ctx->curr_token.t != (duk_small_uint_t) expect) {
  do { } while (0);
  do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 511; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("parse error"))); } while (0); } while (0);
  do { return; } while (0);
 }


 do { void *duk__dst = (&comp_ctx->prev_token); const void *duk__src = (&comp_ctx->curr_token); duk_size_t duk__len = (sizeof(duk_token)); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
 duk_copy(thr, comp_ctx->tok11_idx, comp_ctx->tok21_idx);
 duk_copy(thr, comp_ctx->tok12_idx, comp_ctx->tok22_idx);


 duk_lexer_parse_js_input_element(&comp_ctx->lex, &comp_ctx->curr_token, comp_ctx->curr_func.is_strict, regexp);

 do { } while (0)
# 536 "duk_js_compiler.c"
                                                                           ;
}


static void duk__advance_expect(duk_compiler_ctx *comp_ctx, duk_small_int_t expect) {
 duk__advance_helper(comp_ctx, expect);
}


static void duk__advance(duk_compiler_ctx *comp_ctx) {
 duk__advance_helper(comp_ctx, -1);
}






static void duk__init_func_valstack_slots(duk_compiler_ctx *comp_ctx) {
 duk_compiler_func *func = &comp_ctx->curr_func;
 duk_hthread *thr = comp_ctx->thr;
 duk_idx_t entry_top;

 entry_top = duk_get_top(thr);

 do { void *duk__dst = (func); duk_size_t duk__len = (sizeof(*func)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
# 573 "duk_js_compiler.c"
 duk_require_stack(thr, 16);

 do { duk_bw_init_pushbuf((thr), (&func->bw_code), (256 * sizeof(duk_compiler_instr))); } while (0);


 duk_push_bare_array(thr);
 func->consts_idx = entry_top + 1;
 func->h_consts = ((((void) 0), ((void) 0)), ((((duk_hthread *) (thr))->valstack_bottom + (entry_top + 1))->v.hobject));
 do { } while (0);

 duk_push_bare_array(thr);
 func->funcs_idx = entry_top + 2;
 func->h_funcs = ((((void) 0), ((void) 0)), ((((duk_hthread *) (thr))->valstack_bottom + (entry_top + 2))->v.hobject));
 do { } while (0);
 do { } while (0);

 duk_push_bare_array(thr);
 func->decls_idx = entry_top + 3;
 func->h_decls = ((((void) 0), ((void) 0)), ((((duk_hthread *) (thr))->valstack_bottom + (entry_top + 3))->v.hobject));
 do { } while (0);

 duk_push_bare_array(thr);
 func->labelnames_idx = entry_top + 4;
 func->h_labelnames = ((((void) 0), ((void) 0)), ((((duk_hthread *) (thr))->valstack_bottom + (entry_top + 4))->v.hobject));
 do { } while (0);

 duk_push_buffer_raw((thr), (0), (1 << 0) );
 func->labelinfos_idx = entry_top + 5;
 func->h_labelinfos = (duk_hbuffer_dynamic *) duk_known_hbuffer(thr, entry_top + 5);
 do { } while (0);
 do { } while (0);

 duk_push_bare_array(thr);
 func->argnames_idx = entry_top + 6;
 func->h_argnames = ((((void) 0), ((void) 0)), ((((duk_hthread *) (thr))->valstack_bottom + (entry_top + 6))->v.hobject));
 do { } while (0);

 duk_push_bare_object(thr);
 func->varmap_idx = entry_top + 7;
 func->h_varmap = ((((void) 0), ((void) 0)), ((((duk_hthread *) (thr))->valstack_bottom + (entry_top + 7))->v.hobject));
 do { } while (0);
}


static void duk__reset_func_for_pass2(duk_compiler_ctx *comp_ctx) {
 duk_compiler_func *func = &comp_ctx->curr_func;
 duk_hthread *thr = comp_ctx->thr;




 do { (&func->bw_code)->p = (&func->bw_code)->p_base; } while (0);

 duk_set_length(thr, func->consts_idx, 0);

 func->fnum_next = 0;

 duk_set_length(thr, func->labelnames_idx, 0);
 duk_hbuffer_reset(thr, func->h_labelinfos);



 duk_push_bare_object(thr);
 duk_replace(thr, func->varmap_idx);
 func->h_varmap = ((((void) 0), ((void) 0)), ((((duk_hthread *) (thr))->valstack_bottom + (func->varmap_idx))->v.hobject));
 do { } while (0);
}




static duk_int_t duk__cleanup_varmap(duk_compiler_ctx *comp_ctx) {
 duk_hthread *thr = comp_ctx->thr;
 duk_hobject *h_varmap;
 duk_hstring *h_key;
 duk_tval *tv;
 duk_uint32_t i, e_next;
 duk_int_t ret;



 h_varmap = ((((void) 0), ((void) 0)), ((((duk_hthread *) (thr))->valstack_top + (-1))->v.hobject));
 do { } while (0);

 ret = 0;
 e_next = ((h_varmap)->e_next);
 for (i = 0; i < e_next; i++) {
  h_key = (((duk_hstring **) (void *) (((((h_varmap)))->props) + ((((h_varmap)))->e_size) * sizeof(duk_propvalue)))[(i)]);
  if (!h_key) {
   continue;
  }

  do { } while (0);
# 674 "duk_js_compiler.c"
  tv = (&(((duk_propvalue *) (void *) ((((((h_varmap))))->props)))[((i))]).v);
  if (!((tv)->t == 0)) {
   do { } while (0);
   do { (((duk_hstring **) (void *) ((((((h_varmap))))->props) + (((((h_varmap))))->e_size) * sizeof(duk_propvalue)))[((i))]) = (
# 677 "duk_js_compiler.c" 3 4
  ((void *)0)
# 677 "duk_js_compiler.c"
  ); } while (0);
   do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h_key)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hstring_refzero)(((thr)), (duk_hstring *) duk__h); } } } while (0);

  } else {
   ret++;
  }
 }

 duk_compact_m1(thr);

 return ret;
}





static void duk__convert_to_func_template(duk_compiler_ctx *comp_ctx) {
 duk_compiler_func *func = &comp_ctx->curr_func;
 duk_hthread *thr = comp_ctx->thr;
 duk_hcompfunc *h_res;
 duk_hbuffer_fixed *h_data;
 duk_size_t consts_count;
 duk_size_t funcs_count;
 duk_size_t code_count;
 duk_size_t code_size;
 duk_size_t data_size;
 duk_size_t i;
 duk_tval *p_const;
 duk_hobject **p_func;
 duk_instr_t *p_instr;
 duk_compiler_instr *q_instr;
 duk_tval *tv;
 duk_bool_t keep_varmap;
 duk_bool_t keep_formals;

 duk_size_t formals_length;


 do { } while (0);







 h_res = duk_push_hcompfunc(thr);
 do { } while (0);
 do { } while (0);
 duk_hobject_set_prototype_updref((thr), ((duk_hobject *) h_res), (
# 727 "duk_js_compiler.c" 3 4
((void *)0)
# 727 "duk_js_compiler.c"
));

 if (func->is_function) {
  do { } while (0);
  do { do { } while (0); (&((duk_hobject *) h_res)->hdr)->h_flags |= ((1UL << (7 + (11)))); } while (0);

  if (!func->is_arguments_shadowed) {





   if (func->id_access_arguments || func->may_direct_eval) {
    do { } while (0)
                                                         ;
    do { do { } while (0); (&((duk_hobject *) h_res)->hdr)->h_flags |= ((1UL << (7 + (13)))); } while (0);
   }
  }
 } else if (func->is_eval && func->is_strict) {
  do { } while (0);
  do { do { } while (0); (&((duk_hobject *) h_res)->hdr)->h_flags |= ((1UL << (7 + (11)))); } while (0);
 } else {



  do { } while (0);
  do { } while (0);
 }


 if (func->is_function && func->is_namebinding && func->h_name != 
# 757 "duk_js_compiler.c" 3 4
                                                                 ((void *)0)
# 757 "duk_js_compiler.c"
                                                                     ) {




  do { } while (0);
  do { do { } while (0); (&((duk_hobject *) h_res)->hdr)->h_flags |= ((1UL << (7 + (12)))); } while (0);
 }


 if (func->is_strict) {
  do { } while (0);
  do { do { } while (0); (&((duk_hobject *) h_res)->hdr)->h_flags |= ((1UL << (7 + (9)))); } while (0);
 }

 if (func->is_notail) {
  do { } while (0);
  do { do { } while (0); (&((duk_hobject *) h_res)->hdr)->h_flags |= ((1UL << (7 + (10)))); } while (0);
 }

 if (func->is_constructable) {
  do { } while (0);
  do { do { } while (0); (&((duk_hobject *) h_res)->hdr)->h_flags |= ((1UL << (7 + (1)))); } while (0);
 }
# 791 "duk_js_compiler.c"
 consts_count = duk_hobject_get_length(thr, func->h_consts);
 funcs_count = duk_hobject_get_length(thr, func->h_funcs) / 3;
 code_count = ((duk_size_t) ((&func->bw_code)->p - (&func->bw_code)->p_base)) / sizeof(duk_compiler_instr);
 code_size = code_count * sizeof(duk_instr_t);

 data_size = consts_count * sizeof(duk_tval) + funcs_count * sizeof(duk_hobject *) + code_size;

 do { } while (0)
# 808 "duk_js_compiler.c"
                                        ;

 duk_push_fixed_buffer_nozero(thr, data_size);
 h_data = (duk_hbuffer_fixed *) (void *) duk_known_hbuffer(thr, -1);

 do { (h_res)->data = (duk_hbuffer *) ((duk_hbuffer *) h_data); } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h_data)); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);

 p_const = (duk_tval *) (void *) ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) (h_data)) + 1));
 for (i = 0; i < consts_count; i++) {
  do { } while (0);
  tv = duk_hobject_find_array_entry_tval_ptr(thr->heap, func->h_consts, (duk_uarridx_t) i);
  do { } while (0);
  do { *(p_const) = *(tv); } while (0);
  p_const++;
  do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);

  do { } while (0);
 }

 p_func = (duk_hobject **) p_const;
 do { (h_res)->funcs = (p_func); } while (0);
 for (i = 0; i < funcs_count; i++) {
  duk_hobject *h;
  do { } while (0);
  tv = duk_hobject_find_array_entry_tval_ptr(thr->heap, func->h_funcs, (duk_uarridx_t) (i * 3));
  do { } while (0);
  do { } while (0);
  h = ((tv)->v.hobject);
  do { } while (0);
  do { } while (0);
  *p_func++ = h;
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (h))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);

  do { } while (0);
 }

 p_instr = (duk_instr_t *) p_func;
 do { (h_res)->bytecode = (p_instr); } while (0);


 q_instr = (duk_compiler_instr *) (void *) ((&func->bw_code)->p_base);
 for (i = 0; i < code_count; i++) {
  p_instr[i] = q_instr[i].ins;
 }


 do { } while (0);

 duk_pop(thr);
# 869 "duk_js_compiler.c"
 do { } while (0);
 h_res->nregs = (duk_uint16_t) func->temp_max;
 h_res->nargs = (duk_uint16_t) duk_hobject_get_length(thr, func->h_argnames);
 do { } while (0);
# 885 "duk_js_compiler.c"
 do { } while (0);
# 900 "duk_js_compiler.c"
 if (func->id_access_slow_own ||
     func->id_access_arguments ||
     func->may_direct_eval ||
     funcs_count >
         0) {
  do { } while (0)
                                                    ;
  keep_varmap = 1;
 } else {
  do { } while (0);
  keep_varmap = 0;
 }


 if (keep_varmap) {
  duk_int_t num_used;
  duk_dup(thr, func->varmap_idx);
  num_used = duk__cleanup_varmap(comp_ctx);
  do { } while (0);

  if (num_used > 0) {
   (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (100)) << 8) + (duk_uint_t) (0)));
  } else {
   do { } while (0);
   duk_pop(thr);
  }
 }
# 940 "duk_js_compiler.c"
 formals_length = duk_get_length(thr, func->argnames_idx);
 if (formals_length != (duk_size_t) h_res->nargs) {



  do { } while (0);
  keep_formals = 1;
 } else if ((func->id_access_arguments || func->may_direct_eval) && (formals_length > 0)) {



  do { } while (0)
                                                                                                             ;
  keep_formals = 1;
 } else {
  do { } while (0);
  keep_formals = 0;
 }


 if (keep_formals) {
  duk_dup(thr, func->argnames_idx);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (99)) << 8) + (duk_uint_t) (0)));
 }



 if (func->h_name) {
  duk_push_hstring(thr, func->h_name);
  do { } while (0);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (93)) << 8) + (duk_uint_t) (0)));
 }
# 1024 "duk_js_compiler.c"
 if (1) {




  do { } while (0);
  duk_hobject_pc2line_pack(thr, q_instr, (duk_uint_fast32_t) code_count);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (102)) << 8) + (duk_uint_t) (0)));




 }




 if (comp_ctx->h_filename) {




  duk_push_hstring(thr, comp_ctx->h_filename);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (94)) << 8) + (duk_uint_t) (0)));
 }


 do { } while (0);





 duk_compact_m1(thr);
# 1087 "duk_js_compiler.c"
}
# 1133 "duk_js_compiler.c"
static duk_int_t duk__get_current_pc(duk_compiler_ctx *comp_ctx) {
 duk_compiler_func *func;
 func = &comp_ctx->curr_func;
 return (duk_int_t) (((duk_size_t) ((&func->bw_code)->p - (&func->bw_code)->p_base)) / sizeof(duk_compiler_instr));
}

static duk_compiler_instr *duk__get_instr_ptr(duk_compiler_ctx *comp_ctx, duk_int_t pc) {
 do { } while (0);
 do { } while (0)
                                                                                                                     ;
 return ((duk_compiler_instr *) (void *) ((&comp_ctx->curr_func.bw_code)->p_base)) + pc;
}




static void duk__emit(duk_compiler_ctx *comp_ctx, duk_instr_t ins) {

 duk_int_t line;

 duk_compiler_instr *instr;

 do { } while (0)




                                         ;

 instr = (duk_compiler_instr *) (void *) (((duk_size_t) (((&comp_ctx->curr_func.bw_code))->p_limit - ((&comp_ctx->curr_func.bw_code)->p)) >= ((sizeof(duk_compiler_instr)))) ? ((&comp_ctx->curr_func.bw_code)->p) : (((&comp_ctx->curr_func.bw_code))->p = ((&comp_ctx->curr_func.bw_code)->p), duk_bw_resize(((comp_ctx->thr)), ((&comp_ctx->curr_func.bw_code)), ((sizeof(duk_compiler_instr))))))

                                                                                         ;
 do { (&comp_ctx->curr_func.bw_code)->p += (sizeof(duk_compiler_instr)); } while (0);
# 1177 "duk_js_compiler.c"
 line = comp_ctx->prev_token.start_line;
 if (line == 0) {
  line = comp_ctx->curr_token.start_line;
 }


 instr->ins = ins;

 instr->line = (duk_uint32_t) line;
# 1197 "duk_js_compiler.c"
 if (__builtin_expect((((duk_size_t) ((&comp_ctx->curr_func.bw_code)->p - (&comp_ctx->curr_func.bw_code)->p_base)) > 2147418112L), 0)) {
  goto fail_bc_limit;
 }







 if (__builtin_expect((line > 2147418112L), 0)) {
  goto fail_bc_limit;
 }



 return;

fail_bc_limit:
 do { duk_err_range((comp_ctx->thr), "duk_js_compiler.c", (duk_int_t) 1216, ("bytecode limit")); } while (0);
 do { return; } while (0);
}






static void duk__update_lineinfo_currtoken(duk_compiler_ctx *comp_ctx) {
# 1240 "duk_js_compiler.c"
 do { (void) (comp_ctx); } while (0);

}

static void duk__emit_op_only(duk_compiler_ctx *comp_ctx, duk_small_uint_t op) {
 duk__emit(comp_ctx, ((duk_instr_t) ((((duk_instr_t) (0)) << 8) | ((duk_instr_t) (op)))));
}


static void duk__emit_a_b_c(duk_compiler_ctx *comp_ctx,
                               duk_small_uint_t op_flags,
                               duk_regconst_t a,
                               duk_regconst_t b,
                               duk_regconst_t c) {
 duk_instr_t ins = 0;
 duk_int_t a_out = -1;
 duk_int_t b_out = -1;
 duk_int_t c_out = -1;
 duk_int_t tmp;
 duk_small_uint_t op = op_flags & 0xffU;

 do { } while (0);
# 1270 "duk_js_compiler.c"
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
# 1287 "duk_js_compiler.c"
 if (a <= 0xffL) {

  ;
 } else if (op_flags & (1 << 8)) {
  do { } while (0);
  goto error_outofregs;
 } else if (a <= 0xffffL) {
  comp_ctx->curr_func.needs_shuffle = 1;
  tmp = comp_ctx->curr_func.shuffle1;
  if (op_flags & (1 << 11)) {
   duk__emit(comp_ctx, ((duk_instr_t) ((((duk_instr_t) (a)) << 16) | (((duk_instr_t) (tmp)) << 8) | ((duk_instr_t) (0)))));
  } else {

   a_out = a;




   do { } while (0)
                                                                                 ;
   if (op == 172) {



    if (a + 1 > 0xffffL) {
     goto error_outofregs;
    }
   }
  }
  a = tmp;
 } else {
  do { } while (0);
  goto error_outofregs;
 }



 if ((b & 
# 1324 "duk_js_compiler.c" 3 4
         (-2147483647-1)
# 1324 "duk_js_compiler.c"
                          ) != 0) {
  do { } while (0);
  do { } while (0);
  b = b & ~
# 1327 "duk_js_compiler.c" 3 4
          (-2147483647-1)
# 1327 "duk_js_compiler.c"
                           ;



  if (b <= 0xff) {

   if (op_flags & (1 << 14)) {

    do { } while (0);
    ins |= ((duk_instr_t) ((((duk_instr_t) (0)) << 24) | (((duk_instr_t) (0)) << 16) | (((duk_instr_t) (0)) << 8) | ((duk_instr_t) (0x01))));
   } else {
    do { } while (0);
   }
  } else if (b <= 0xffffL) {
   comp_ctx->curr_func.needs_shuffle = 1;
   tmp = comp_ctx->curr_func.shuffle2;
   duk__emit(comp_ctx, ((duk_instr_t) ((((duk_instr_t) (b)) << 16) | (((duk_instr_t) (tmp)) << 8) | ((duk_instr_t) (3)))));
   b = tmp;
  } else {
   do { } while (0);
   goto error_outofregs;
  }
 } else {



  if (b <= 0xff) {

   ;
  } else if (op_flags & (1 << 9)) {
   if (b > 0xffL) {

    do { } while (0)
                                                                                                      ;
    goto error_outofregs;
   }
  } else if (b <= 0xffffL) {
   comp_ctx->curr_func.needs_shuffle = 1;
   tmp = comp_ctx->curr_func.shuffle2;
   if (op_flags & (1 << 12)) {

    b_out = b;
   }
   if (!(op_flags & (1 << 12))) {
    if (op == 194 || op == 198) {





     do { } while (0);
     duk__emit_load_int32_noshuffle(comp_ctx, tmp, b);
     do { } while (0);
     do { } while (0);
     op_flags++;
    } else {
     duk__emit(comp_ctx, ((duk_instr_t) ((((duk_instr_t) (b)) << 16) | (((duk_instr_t) (tmp)) << 8) | ((duk_instr_t) (0)))));
    }
   }
   b = tmp;
  } else {
   do { } while (0);
   goto error_outofregs;
  }
 }



 if ((c & 
# 1395 "duk_js_compiler.c" 3 4
         (-2147483647-1)
# 1395 "duk_js_compiler.c"
                          ) != 0) {
  do { } while (0);
  do { } while (0);
  c = c & ~
# 1398 "duk_js_compiler.c" 3 4
          (-2147483647-1)
# 1398 "duk_js_compiler.c"
                           ;



  if (c <= 0xff) {

   if (op_flags & (1 << 14)) {

    do { } while (0);
    ins |= ((duk_instr_t) ((((duk_instr_t) (0)) << 24) | (((duk_instr_t) (0)) << 16) | (((duk_instr_t) (0)) << 8) | ((duk_instr_t) (0x02))));
   } else {
    do { } while (0);
   }
  } else if (c <= 0xffffL) {
   comp_ctx->curr_func.needs_shuffle = 1;
   tmp = comp_ctx->curr_func.shuffle3;
   duk__emit(comp_ctx, ((duk_instr_t) ((((duk_instr_t) (c)) << 16) | (((duk_instr_t) (tmp)) << 8) | ((duk_instr_t) (3)))));
   c = tmp;
  } else {
   do { } while (0);
   goto error_outofregs;
  }
 } else {



  if (c <= 0xff) {

   ;
  } else if (op_flags & (1 << 10)) {
   if (c > 0xffL) {

    do { } while (0)
                                                                                                      ;
    goto error_outofregs;
   }
  } else if (c <= 0xffffL) {
   comp_ctx->curr_func.needs_shuffle = 1;
   tmp = comp_ctx->curr_func.shuffle3;
   if (op_flags & (1 << 13)) {

    c_out = c;
   } else {
    duk__emit(comp_ctx, ((duk_instr_t) ((((duk_instr_t) (c)) << 16) | (((duk_instr_t) (tmp)) << 8) | ((duk_instr_t) (0)))));
   }
   c = tmp;
  } else {
   do { } while (0);
   goto error_outofregs;
  }
 }



 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 ins |= ((duk_instr_t) ((((duk_instr_t) (c)) << 24) | (((duk_instr_t) (b)) << 16) | (((duk_instr_t) (a)) << 8) | ((duk_instr_t) (op_flags & 0xff))));
 duk__emit(comp_ctx, ins);






 if (op_flags & (1 << 15)) {
  comp_ctx->emit_jumpslot_pc = duk__get_current_pc(comp_ctx);
  duk__emit_abc(comp_ctx, 2, 0);
 }
# 1479 "duk_js_compiler.c"
 if (a_out >= 0) {
  do { } while (0);
  do { } while (0);
  duk__emit(comp_ctx, ((duk_instr_t) ((((duk_instr_t) (a_out)) << 16) | (((duk_instr_t) (a)) << 8) | ((duk_instr_t) (1)))));

  if (op == 172) {






   duk__emit(comp_ctx, ((duk_instr_t) ((((duk_instr_t) (a_out + 1)) << 16) | (((duk_instr_t) (a + 1)) << 8) | ((duk_instr_t) (1)))));
  }
 } else if (b_out >= 0) {
  do { } while (0);
  do { } while (0);
  duk__emit(comp_ctx, ((duk_instr_t) ((((duk_instr_t) (b_out)) << 16) | (((duk_instr_t) (b)) << 8) | ((duk_instr_t) (1)))));
 } else if (c_out >= 0) {
  do { } while (0);
  do { } while (0);
  duk__emit(comp_ctx, ((duk_instr_t) ((((duk_instr_t) (c_out)) << 16) | (((duk_instr_t) (c)) << 8) | ((duk_instr_t) (1)))));
 }

 return;

error_outofregs:
 do { duk_err_range((comp_ctx->thr), "duk_js_compiler.c", (duk_int_t) 1506, ("register limit")); } while (0);
 do { return; } while (0);
}
# 1519 "duk_js_compiler.c"
static void duk__emit_a_b(duk_compiler_ctx *comp_ctx, duk_small_uint_t op_flags, duk_regconst_t a, duk_regconst_t b) {



 duk__emit_a_b_c(comp_ctx, op_flags, a, b, 0);
}

static void duk__emit_b_c(duk_compiler_ctx *comp_ctx, duk_small_uint_t op_flags, duk_regconst_t b, duk_regconst_t c) {



 duk__emit_a_b_c(comp_ctx, op_flags, 0, b, c);
}
# 1551 "duk_js_compiler.c"
static void duk__emit_a_bc(duk_compiler_ctx *comp_ctx, duk_small_uint_t op_flags, duk_regconst_t a, duk_regconst_t bc) {
 duk_instr_t ins;
 duk_int_t tmp;


 do { } while (0);
 bc = bc & (~
# 1557 "duk_js_compiler.c" 3 4
            (-2147483647-1)
# 1557 "duk_js_compiler.c"
                             );

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 if (bc <= 0xffffL) {
  ;
 } else {

  goto error_outofregs;
 }




 if (a <= 0xffL) {

  ins = ((duk_instr_t) ((((duk_instr_t) (bc)) << 16) | (((duk_instr_t) (a)) << 8) | ((duk_instr_t) (op_flags & 0xff))));
  duk__emit(comp_ctx, ins);
 } else if (op_flags & (1 << 8)) {
  goto error_outofregs;
 } else if ((op_flags & 0xf0U) == 176) {
  comp_ctx->curr_func.needs_shuffle = 1;
  tmp = comp_ctx->curr_func.shuffle1;
  duk__emit_load_int32_noshuffle(comp_ctx, tmp, a);
  op_flags |= (1U << 3);
  ins = ((duk_instr_t) ((((duk_instr_t) (bc)) << 16) | (((duk_instr_t) (tmp)) << 8) | ((duk_instr_t) (op_flags & 0xff))));
  duk__emit(comp_ctx, ins);
 } else if (a <= 0xffffL) {
  comp_ctx->curr_func.needs_shuffle = 1;
  tmp = comp_ctx->curr_func.shuffle1;
  ins = ((duk_instr_t) ((((duk_instr_t) (bc)) << 16) | (((duk_instr_t) (tmp)) << 8) | ((duk_instr_t) (op_flags & 0xff))));
  if (op_flags & (1 << 11)) {
   duk__emit(comp_ctx, ((duk_instr_t) ((((duk_instr_t) (a)) << 16) | (((duk_instr_t) (tmp)) << 8) | ((duk_instr_t) (0)))));
   duk__emit(comp_ctx, ins);
  } else {
   duk__emit(comp_ctx, ins);
   duk__emit(comp_ctx, ((duk_instr_t) ((((duk_instr_t) (a)) << 16) | (((duk_instr_t) (tmp)) << 8) | ((duk_instr_t) (1)))));
  }
 } else {
  goto error_outofregs;
 }
 return;

error_outofregs:
 do { duk_err_range((comp_ctx->thr), "duk_js_compiler.c", (duk_int_t) 1605, ("register limit")); } while (0);
 do { return; } while (0);
}

static void duk__emit_bc(duk_compiler_ctx *comp_ctx, duk_small_uint_t op, duk_regconst_t bc) {



 duk__emit_a_bc(comp_ctx, op, 0, bc);
}

static void duk__emit_abc(duk_compiler_ctx *comp_ctx, duk_small_uint_t op, duk_regconst_t abc) {
 duk_instr_t ins;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 if (abc <= 0xffffffL) {
  ;
 } else {
  goto error_outofregs;
 }
 ins = ((duk_instr_t) ((((duk_instr_t) (abc)) << 8) | ((duk_instr_t) (op))));
 do { } while (0)






                                         ;
 duk__emit(comp_ctx, ins);
 return;

error_outofregs:
 do { duk_err_range((comp_ctx->thr), "duk_js_compiler.c", (duk_int_t) 1644, ("register limit")); } while (0);
 do { return; } while (0);
}

static void duk__emit_load_int32_raw(duk_compiler_ctx *comp_ctx,
                                        duk_regconst_t reg,
                                        duk_int32_t val,
                                        duk_small_uint_t op_flags) {





 if ((val >= (duk_int32_t) 0 - (duk_int32_t) (1L << 15)) &&
     (val <= (duk_int32_t) 0xffffL - (duk_int32_t) (1L << 15))) {
  do { } while (0);
  duk__emit_a_bc(comp_ctx, 4 | op_flags, reg, (duk_regconst_t) (val + (duk_int32_t) (1L << 15)));
 } else {
  duk_int32_t hi = val >> 16;
  duk_int32_t lo = val & ((((duk_int32_t) 1) << 16) - 1);
  do { } while (0);
  do { } while (0)



                                  ;
  duk__emit_a_bc(comp_ctx, 4 | op_flags, reg, (duk_regconst_t) (hi + (duk_int32_t) (1L << 15)));
  duk__emit_a_bc(comp_ctx, 5 | op_flags, reg, (duk_regconst_t) lo);
 }
}

static void duk__emit_load_int32(duk_compiler_ctx *comp_ctx, duk_regconst_t reg, duk_int32_t val) {
 duk__emit_load_int32_raw(comp_ctx, reg, val, 0 );
}
# 1687 "duk_js_compiler.c"
static void duk__emit_load_int32_noshuffle(duk_compiler_ctx *comp_ctx, duk_regconst_t reg, duk_int32_t val) {



 do { } while (0);
 duk__emit_load_int32(comp_ctx, reg, val);
}


static void duk__emit_jump(duk_compiler_ctx *comp_ctx, duk_int_t target_pc) {
 duk_int_t curr_pc;
 duk_int_t offset;

 curr_pc = (duk_int_t) (((duk_size_t) ((&comp_ctx->curr_func.bw_code)->p - (&comp_ctx->curr_func.bw_code)->p_base)) / sizeof(duk_compiler_instr));
 offset = (duk_int_t) target_pc - (duk_int_t) curr_pc - 1;
 do { } while (0);
 do { } while (0);
 duk__emit_abc(comp_ctx, 2, (duk_regconst_t) (offset + (1L << 23)));
}

static duk_int_t duk__emit_jump_empty(duk_compiler_ctx *comp_ctx) {
 duk_int_t ret;

 ret = duk__get_current_pc(comp_ctx);
 duk__emit_op_only(comp_ctx, 2);
 return ret;
}




static void duk__insert_jump_entry(duk_compiler_ctx *comp_ctx, duk_int_t jump_pc) {

 duk_int_t line;

 duk_compiler_instr *instr;
 duk_size_t offset;

 do { } while (0);
 offset = (duk_size_t) jump_pc * sizeof(duk_compiler_instr);
 instr = (duk_compiler_instr *) (void *)
     duk_bw_insert_ensure_area((comp_ctx->thr), (&comp_ctx->curr_func.bw_code), (offset), (sizeof(duk_compiler_instr)));


 line = comp_ctx->curr_token.start_line;

 instr->ins = ((duk_instr_t) ((((duk_instr_t) (0)) << 8) | ((duk_instr_t) (2))));

 instr->line = (duk_uint32_t) line;


 do { (&comp_ctx->curr_func.bw_code)->p += (sizeof(duk_compiler_instr)); } while (0);
 if (__builtin_expect((((duk_size_t) ((&comp_ctx->curr_func.bw_code)->p - (&comp_ctx->curr_func.bw_code)->p_base)) > 2147418112L), 0)) {
  goto fail_bc_limit;
 }
 return;

fail_bc_limit:
 do { duk_err_range((comp_ctx->thr), "duk_js_compiler.c", (duk_int_t) 1745, ("bytecode limit")); } while (0);
 do { return; } while (0);
}




static void duk__patch_jump(duk_compiler_ctx *comp_ctx, duk_int_t jump_pc, duk_int_t target_pc) {
 duk_compiler_instr *instr;
 duk_int_t offset;


 if (jump_pc < 0) {
  do { } while (0)
                                                                                                                     ;
  return;
 }
 do { } while (0);


 instr = duk__get_instr_ptr(comp_ctx, jump_pc);
 do { } while (0);


 offset = target_pc - jump_pc - 1;

 instr->ins = ((duk_instr_t) ((((duk_instr_t) (offset + (1L << 23))) << 8) | ((duk_instr_t) (2))));
 do { } while (0)


                                     ;
}

static void duk__patch_jump_here(duk_compiler_ctx *comp_ctx, duk_int_t jump_pc) {
 duk__patch_jump(comp_ctx, jump_pc, duk__get_current_pc(comp_ctx));
}

static void duk__patch_trycatch(duk_compiler_ctx *comp_ctx,
                                   duk_int_t ldconst_pc,
                                   duk_int_t trycatch_pc,
                                   duk_regconst_t reg_catch,
                                   duk_regconst_t const_varname,
                                   duk_small_uint_t flags) {
 duk_compiler_instr *instr;

 do { } while (0);

 instr = duk__get_instr_ptr(comp_ctx, ldconst_pc);
 do { } while (0);
 do { } while (0);
 if (const_varname & 
# 1795 "duk_js_compiler.c" 3 4
                    (-2147483647-1)
# 1795 "duk_js_compiler.c"
                                     ) {

  const_varname = const_varname & (~
# 1797 "duk_js_compiler.c" 3 4
                                   (-2147483647-1)
# 1797 "duk_js_compiler.c"
                                                    );
  if (reg_catch > 0xffffL || const_varname > 0xffffL) {







   do { } while (0)



                                          ;
   do { duk_err_range((comp_ctx->thr), "duk_js_compiler.c", (duk_int_t) 1811, ("register limit")); } while (0);
   do { return; } while (0);
  }
  instr->ins |= ((duk_instr_t) ((((duk_instr_t) (const_varname)) << 16) | (((duk_instr_t) (0)) << 8) | ((duk_instr_t) (0))));
 } else {



  instr->ins = ((duk_instr_t) (205));
 }

 instr = duk__get_instr_ptr(comp_ctx, trycatch_pc);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 instr->ins = ((duk_instr_t) ((((duk_instr_t) (reg_catch)) << 16) | (((duk_instr_t) (flags)) << 8) | ((duk_instr_t) (165))));
}

static void duk__emit_if_false_skip(duk_compiler_ctx *comp_ctx, duk_regconst_t regconst) {
 duk_small_uint_t op;

 op = ((regconst) >= 0) ? 50 : 51;
 duk__emit_bc(comp_ctx, op, regconst);
}

static void duk__emit_if_true_skip(duk_compiler_ctx *comp_ctx, duk_regconst_t regconst) {
 duk_small_uint_t op;

 op = ((regconst) >= 0) ? 48 : 49;
 duk__emit_bc(comp_ctx, op, regconst);
}

static void duk__emit_invalid(duk_compiler_ctx *comp_ctx) {
 duk__emit_op_only(comp_ctx, 206);
}
# 1854 "duk_js_compiler.c"
static void duk__peephole_optimize_bytecode(duk_compiler_ctx *comp_ctx) {
 duk_compiler_instr *bc;
 duk_small_uint_t iter;
 duk_int_t i, n;
 duk_int_t count_opt;

 bc = (duk_compiler_instr *) (void *) ((&comp_ctx->curr_func.bw_code)->p_base);



 do { } while (0)
                                     ;

 n = (duk_int_t) (((duk_size_t) ((&comp_ctx->curr_func.bw_code)->p - (&comp_ctx->curr_func.bw_code)->p_base)) / sizeof(duk_compiler_instr));

 for (iter = 0; iter < 3; iter++) {
  count_opt = 0;

  for (i = 0; i < n; i++) {
   duk_instr_t ins;
   duk_int_t target_pc1;
   duk_int_t target_pc2;

   ins = bc[i].ins;
   if (((ins) &0xffUL) != 2) {
    continue;
   }

   target_pc1 = i + 1 + (duk_int_t) (((ins) >> 8) & 0xffffffUL) - (duk_int_t) (1L << 23);
   do { } while (0);
   do { } while (0);
   do { } while (0);






   ins = bc[target_pc1].ins;
   if (((ins) &0xffUL) != 2) {
    continue;
   }

   target_pc2 = target_pc1 + 1 + (duk_int_t) (((ins) >> 8) & 0xffffffUL) - (duk_int_t) (1L << 23);

   do { } while (0)


                                           ;

   bc[i].ins = ((duk_instr_t) ((((duk_instr_t) (target_pc2 - (i + 1) + (1L << 23))) << 8) | ((duk_instr_t) (2))));

   count_opt++;
  }

  do { } while (0);

  if (count_opt == 0) {
   break;
  }
 }
}
# 1968 "duk_js_compiler.c"
static void duk__ivalue_regconst(duk_ivalue *x, duk_regconst_t regconst) {
 x->t = 1;
 x->x1.t = 2;
 x->x1.regconst = regconst;
}

static void duk__ivalue_plain_fromstack(duk_compiler_ctx *comp_ctx, duk_ivalue *x) {
 x->t = 1;
 x->x1.t = 1;
 duk_replace(comp_ctx->thr, x->x1.valstack_idx);
}

static void duk__ivalue_var_fromstack(duk_compiler_ctx *comp_ctx, duk_ivalue *x) {
 x->t = 4;
 x->x1.t = 1;
 duk_replace(comp_ctx->thr, x->x1.valstack_idx);
}

static void duk__ivalue_var_hstring(duk_compiler_ctx *comp_ctx, duk_ivalue *x, duk_hstring *h) {
 do { } while (0);
 duk_push_hstring(comp_ctx->thr, h);
 duk__ivalue_var_fromstack(comp_ctx, x);
}

static void duk__copy_ispec(duk_compiler_ctx *comp_ctx, duk_ispec *src, duk_ispec *dst) {
 dst->t = src->t;
 dst->regconst = src->regconst;
 duk_copy(comp_ctx->thr, src->valstack_idx, dst->valstack_idx);
}

static void duk__copy_ivalue(duk_compiler_ctx *comp_ctx, duk_ivalue *src, duk_ivalue *dst) {
 dst->t = src->t;
 dst->op = src->op;
 dst->x1.t = src->x1.t;
 dst->x1.regconst = src->x1.regconst;
 dst->x2.t = src->x2.t;
 dst->x2.regconst = src->x2.regconst;
 duk_copy(comp_ctx->thr, src->x1.valstack_idx, dst->x1.valstack_idx);
 duk_copy(comp_ctx->thr, src->x2.valstack_idx, dst->x2.valstack_idx);
}

static duk_regconst_t duk__alloctemps(duk_compiler_ctx *comp_ctx, duk_small_int_t num) {
 duk_regconst_t res;

 res = comp_ctx->curr_func.temp_next;
 comp_ctx->curr_func.temp_next += num;

 if (comp_ctx->curr_func.temp_next > 0xffffL) {
  do { duk_err_range((comp_ctx->thr), "duk_js_compiler.c", (duk_int_t) 2016, ("temp limit")); } while (0);
  do { return 0; } while (0);
 }


 if (comp_ctx->curr_func.temp_next > comp_ctx->curr_func.temp_max) {
  comp_ctx->curr_func.temp_max = comp_ctx->curr_func.temp_next;
 }

 return res;
}

static duk_regconst_t duk__alloctemp(duk_compiler_ctx *comp_ctx) {
 return duk__alloctemps(comp_ctx, 1);
}

static void duk__settemp_checkmax(duk_compiler_ctx *comp_ctx, duk_regconst_t temp_next) {
 comp_ctx->curr_func.temp_next = temp_next;
 if (temp_next > comp_ctx->curr_func.temp_max) {
  comp_ctx->curr_func.temp_max = temp_next;
 }
}


static duk_regconst_t duk__getconst(duk_compiler_ctx *comp_ctx) {
 duk_hthread *thr = comp_ctx->thr;
 duk_compiler_func *f = &comp_ctx->curr_func;
 duk_tval *tv1;
 duk_int_t i, n, n_check;

 n = (duk_int_t) duk_get_length(thr, f->consts_idx);

 tv1 = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));
 do { } while (0);
# 2060 "duk_js_compiler.c"
 n_check = (n > 256 ? 256 : n);
 for (i = 0; i < n_check; i++) {
  duk_tval *tv2 = (&((duk_tval *) (void *) (((((f->h_consts)))->props) + ((((f->h_consts)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue) + sizeof(duk_uint8_t)) + ((8 - (((((f->h_consts)))->e_size))) & 0x07)))[(i)]);




  if (duk_js_equals_helper(
# 2067 "duk_js_compiler.c" 3 4
     ((void *)0)
# 2067 "duk_js_compiler.c"
     , (tv1), (tv2), (1U << 0))) {
   do { } while (0);
   duk_pop(thr);
   return (duk_regconst_t) i | (duk_regconst_t) 
# 2070 "duk_js_compiler.c" 3 4
                                               (-2147483647-1)
# 2070 "duk_js_compiler.c"
                                                                ;
  }
 }

 if (n > 0xffffL) {
  do { duk_err_range((comp_ctx->thr), "duk_js_compiler.c", (duk_int_t) 2075, ("const limit")); } while (0);
  do { return 0; } while (0);
 }

 do { } while (0);
 (void) duk_put_prop_index(thr, f->consts_idx, (duk_uarridx_t) n);
 return (duk_regconst_t) n | (duk_regconst_t) 
# 2081 "duk_js_compiler.c" 3 4
                                             (-2147483647-1)
# 2081 "duk_js_compiler.c"
                                                              ;
}

static duk_bool_t duk__const_needs_refcount(duk_compiler_ctx *comp_ctx, duk_regconst_t rc) {

 duk_compiler_func *f = &comp_ctx->curr_func;
 duk_bool_t ret;

 do { } while (0);
 (void) duk_get_prop_index(comp_ctx->thr, f->consts_idx, (duk_uarridx_t) rc);
 ret = !duk_is_number(comp_ctx->thr, -1);
 duk_pop(comp_ctx->thr);
 return ret;






}
# 2118 "duk_js_compiler.c"
static
duk_regconst_t duk__ispec_toregconst_raw(duk_compiler_ctx *comp_ctx,
                                         duk_ispec *x,
                                         duk_regconst_t forced_reg,
                                         duk_small_uint_t flags) {
 duk_hthread *thr = comp_ctx->thr;

 do { } while (0)
# 2134 "duk_js_compiler.c"
                                                                               ;

 switch (x->t) {
 case 1: {
  duk_tval *tv;

  tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (x->valstack_idx));
  do { } while (0);

  switch (((tv)->t)) {
  case 2: {




   duk_regconst_t dest = (forced_reg >= 0 ? forced_reg : duk__alloctemp((comp_ctx)));
   duk__emit_bc(comp_ctx, 7, dest);
   return dest;
  }
  case 3: {
   duk_regconst_t dest = (forced_reg >= 0 ? forced_reg : duk__alloctemp((comp_ctx)));
   duk__emit_bc(comp_ctx, 8, dest);
   return dest;
  }
  case 4: {
   duk_regconst_t dest = (forced_reg >= 0 ? forced_reg : duk__alloctemp((comp_ctx)));
   duk__emit_bc(comp_ctx, (((duk_small_uint_t) (tv)->v.i) ? 9 : 10), dest);
   return dest;
  }
  case 5: {
   do { __builtin_unreachable(); } while (0);
   break;
  }
  case 8: {
   duk_hstring *h;
   duk_regconst_t dest;
   duk_regconst_t constidx;

   h = ((tv)->v.hstring);
   do { (void) (h); } while (0);
   do { } while (0);
# 2184 "duk_js_compiler.c"
   duk_dup(thr, x->valstack_idx);
   constidx = duk__getconst(comp_ctx);

   if (flags & (1 << 0)) {
    return constidx;
   }

   dest = (forced_reg >= 0 ? forced_reg : duk__alloctemp((comp_ctx)));
   duk__emit_a_bc(comp_ctx, 3, dest, constidx);
   return dest;
  }
  case 9: {
   do { __builtin_unreachable(); } while (0);
   break;
  }
  case 10: {
   do { __builtin_unreachable(); } while (0);
   break;
  }
  case 6: {
   do { __builtin_unreachable(); } while (0);
   break;
  }



  default: {

   duk_regconst_t dest;
   duk_regconst_t constidx;
   duk_double_t dval;
   duk_int32_t ival;

   do { } while (0);
   do { } while (0);
   dval = ((tv)->v.d);

   if (!(flags & (1 << 0))) {






    if (duk_is_whole_get_int32_nonegzero(dval, &ival)) {
     dest = (forced_reg >= 0 ? forced_reg : duk__alloctemp((comp_ctx)));
     duk__emit_load_int32(comp_ctx, dest, ival);
     return dest;
    }
   }

   duk_dup(thr, x->valstack_idx);
   constidx = duk__getconst(comp_ctx);

   if (flags & (1 << 0)) {
    return constidx;
   } else {
    dest = (forced_reg >= 0 ? forced_reg : duk__alloctemp((comp_ctx)));
    duk__emit_a_bc(comp_ctx, 3, dest, constidx);
    return dest;
   }
  }
  }
  goto fail_internal;
 }
 case 2: {
  if (forced_reg >= 0) {
   if (((x->regconst) < 0)) {
    duk__emit_a_bc(comp_ctx, 3, forced_reg, x->regconst);
   } else if (x->regconst != forced_reg) {
    duk__emit_a_bc(comp_ctx, 0, forced_reg, x->regconst);
   } else {
    ;
   }
   return forced_reg;
  }

  do { } while (0);
  if (((x->regconst) < 0)) {
   if (!(flags & (1 << 0))) {
    duk_regconst_t dest = duk__alloctemp((comp_ctx));
    duk__emit_a_bc(comp_ctx, 3, dest, x->regconst);
    return dest;
   }
   return x->regconst;
  }

  do { } while (0);
  if ((flags & (1 << 1)) && !((duk_int32_t) (x->regconst) >= (duk_int32_t) ((comp_ctx)->curr_func.temp_first))) {
   duk_regconst_t dest = duk__alloctemp((comp_ctx));
   duk__emit_a_bc(comp_ctx, 0, dest, x->regconst);
   return dest;
  }
  return x->regconst;
 }
 default: {
  break;
 }
 }

fail_internal:
 do { duk_err_error_internal((thr), "duk_js_compiler.c", (duk_int_t) 2285); } while (0);
 do { return 0; } while (0);
}

static void duk__ispec_toforcedreg(duk_compiler_ctx *comp_ctx, duk_ispec *x, duk_regconst_t forced_reg) {
 do { } while (0);
 (void) duk__ispec_toregconst_raw(comp_ctx, x, forced_reg, 0 );
}






static void duk__ivalue_toplain_raw(duk_compiler_ctx *comp_ctx, duk_ivalue *x, duk_regconst_t forced_reg) {
 duk_hthread *thr = comp_ctx->thr;

 do { } while (0)
# 2312 "duk_js_compiler.c"
                                         ;

 switch (x->t) {
 case 1: {
  return;
 }

 case 2: {
  duk_regconst_t arg1;
  duk_regconst_t arg2;
  duk_regconst_t dest;
  duk_tval *tv1;
  duk_tval *tv2;

  do { } while (0);



  if (x->x1.t == 1 && x->x2.t == 1 && x->t == 2) {
   tv1 = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (x->x1.valstack_idx));
   tv2 = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (x->x2.valstack_idx));
   do { } while (0);
   do { } while (0);

   do { } while (0);

   if (((tv1)->t == 0) && ((tv2)->t == 0)) {
    duk_double_t d1 = ((tv1)->v.d);
    duk_double_t d2 = ((tv2)->v.d);
    duk_double_t d3;
    duk_bool_t accept_fold = 1;

    do { } while (0)


                                       ;
    switch (x->op) {
    case 52: {
     d3 = d1 + d2;
     break;
    }
    case 56: {
     d3 = d1 - d2;
     break;
    }
    case 60: {
     d3 = d1 * d2;
     break;
    }
    case 64: {



     d3 = duk_double_div(d1, d2);
     break;
    }
    case 72: {
     d3 = (duk_double_t) duk_js_arith_pow((double) d1, (double) d2);
     break;
    }
    default: {
     d3 = 0.0;
     accept_fold = 0;
     break;
    }
    }

    if (accept_fold) {
     duk_double_union du;
     du.d = d3;
     ;
     d3 = du.d;

     x->t = 1;
     do { } while (0);
     do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = (d3); ; duk__tv = (tv1); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0);
     return;
    }
   } else if (x->op == 52 && ((tv1)->t == 8) && ((tv2)->t == 8)) {



    duk_dup(thr, x->x1.valstack_idx);
    duk_dup(thr, x->x2.valstack_idx);
    duk_concat(thr, 2);
    duk_replace(thr, x->x1.valstack_idx);
    x->t = 1;
    do { } while (0);
    return;
   }
  }

  arg1 = duk__ispec_toregconst_raw(comp_ctx,
                                   &x->x1,
                                   -1,
                                   (1 << 0) | (1 << 2) );
  arg2 = duk__ispec_toregconst_raw(comp_ctx,
                                   &x->x2,
                                   -1,
                                   (1 << 0) | (1 << 2) );




  if (forced_reg >= 0) {
   dest = forced_reg;
  } else if (((duk_int32_t) (arg1) >= (duk_int32_t) ((comp_ctx)->curr_func.temp_first))) {
   dest = arg1;
  } else if (((duk_int32_t) (arg2) >= (duk_int32_t) ((comp_ctx)->curr_func.temp_first))) {
   dest = arg2;
  } else {
   dest = duk__alloctemp((comp_ctx));
  }

  do { } while (0);
  duk__emit_a_b_c(comp_ctx, x->op | (1 << 14), dest, arg1, arg2);

  duk__ivalue_regconst(x, dest);
  return;
 }
 case 3: {

  duk_regconst_t arg1;
  duk_regconst_t arg2;
  duk_regconst_t dest;


  arg1 = duk__ispec_toregconst_raw(comp_ctx,
                                   &x->x1,
                                   -1,
                                   (1 << 0) | (1 << 2) );
  arg2 = duk__ispec_toregconst_raw(comp_ctx,
                                   &x->x2,
                                   -1,
                                   (1 << 0) | (1 << 2) );
# 2457 "duk_js_compiler.c"
  if (forced_reg >= 0) {
   dest = forced_reg;
  } else if (((duk_int32_t) (arg1) >= (duk_int32_t) ((comp_ctx)->curr_func.temp_first))) {
   dest = arg1;
  } else if (((duk_int32_t) (arg2) >= (duk_int32_t) ((comp_ctx)->curr_func.temp_first))) {
   dest = arg2;
  } else {
   dest = duk__alloctemp((comp_ctx));
  }

  duk__emit_a_b_c(comp_ctx, 108 | (1 << 14), dest, arg1, arg2);

  duk__ivalue_regconst(x, dest);
  return;
 }
 case 4: {

  duk_regconst_t dest;
  duk_regconst_t reg_varbind;
  duk_regconst_t rc_varname;

  do { } while (0);

  duk_dup(thr, x->x1.valstack_idx);
  if (duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname)) {
   duk__ivalue_regconst(x, reg_varbind);
  } else {
   dest = (forced_reg >= 0 ? forced_reg : duk__alloctemp((comp_ctx)));
   duk__emit_a_bc(comp_ctx, 11, dest, rc_varname);
   duk__ivalue_regconst(x, dest);
  }
  return;
 }
 case 0:
 default: {
  do { } while (0);
  break;
 }
 }

 do { duk_err_error_internal((thr), "duk_js_compiler.c", (duk_int_t) 2497); } while (0);
 do { return; } while (0);
}


static void duk__ivalue_toplain(duk_compiler_ctx *comp_ctx, duk_ivalue *x) {
 duk__ivalue_toplain_raw(comp_ctx, x, -1 );
}


static void duk__ivalue_toplain_ignore(duk_compiler_ctx *comp_ctx, duk_ivalue *x) {
 duk_regconst_t temp;




 temp = ((comp_ctx)->curr_func.temp_next);
 duk__ivalue_toplain_raw(comp_ctx, x, -1 );
 ((comp_ctx)->curr_func.temp_next = (temp));
}







static
duk_regconst_t duk__ivalue_toregconst_raw(duk_compiler_ctx *comp_ctx,
                                          duk_ivalue *x,
                                          duk_regconst_t forced_reg,
                                          duk_small_uint_t flags) {
 duk_hthread *thr = comp_ctx->thr;
 duk_regconst_t reg;
 do { (void) (thr); } while (0);

 do { } while (0)
# 2547 "duk_js_compiler.c"
                                                                               ;


 duk__ivalue_toplain_raw(comp_ctx, x, forced_reg);
 do { } while (0);


 reg = duk__ispec_toregconst_raw(comp_ctx, &x->x1, forced_reg, flags);
 duk__ivalue_regconst(x, reg);

 return reg;
}

static duk_regconst_t duk__ivalue_toreg(duk_compiler_ctx *comp_ctx, duk_ivalue *x) {
 return duk__ivalue_toregconst_raw(comp_ctx, x, -1, 0 );
}







static void duk__ivalue_toforcedreg(duk_compiler_ctx *comp_ctx, duk_ivalue *x, duk_int_t forced_reg) {
 do { } while (0);
 (void) duk__ivalue_toregconst_raw(comp_ctx, x, forced_reg, 0 );
}

static duk_regconst_t duk__ivalue_toregconst(duk_compiler_ctx *comp_ctx, duk_ivalue *x) {
 return duk__ivalue_toregconst_raw(comp_ctx, x, -1, (1 << 0) );
}

static duk_regconst_t duk__ivalue_totempconst(duk_compiler_ctx *comp_ctx, duk_ivalue *x) {
 return duk__ivalue_toregconst_raw(comp_ctx, x, -1, (1 << 0) | (1 << 1) );
}
# 2595 "duk_js_compiler.c"
static duk_regconst_t duk__lookup_active_register_binding(duk_compiler_ctx *comp_ctx) {
 duk_hthread *thr = comp_ctx->thr;
 duk_hstring *h_varname;
 duk_regconst_t ret;

 do { } while (0);





 h_varname = duk_known_hstring(thr, -1);

 if (h_varname == (((thr))->strs[(67)])) {
  do { } while (0);
  comp_ctx->curr_func.id_access_arguments = 1;
 }






 if (comp_ctx->curr_func.with_depth > 0) {
  do { } while (0);
  goto slow_path_own;
 }
# 2631 "duk_js_compiler.c"
 duk_get_prop(thr, comp_ctx->curr_func.varmap_idx);
 if (duk_is_number(thr, -1)) {
  ret = duk_to_int(thr, -1);
  duk_pop(thr);
 } else {
  duk_pop(thr);
  if (comp_ctx->curr_func.catch_depth > 0 || comp_ctx->curr_func.with_depth > 0) {
   do { } while (0);
   goto slow_path_own;
  } else {




   do { } while (0);
   goto slow_path_notown;
  }
 }

 do { } while (0);
 return ret;

slow_path_notown:
 do { } while (0);

 comp_ctx->curr_func.id_access_slow = 1;
 return (duk_regconst_t) -1;

slow_path_own:
 do { } while (0);

 comp_ctx->curr_func.id_access_slow = 1;
 comp_ctx->curr_func.id_access_slow_own = 1;
 return (duk_regconst_t) -1;
}
# 2675 "duk_js_compiler.c"
static duk_bool_t duk__lookup_lhs(duk_compiler_ctx *comp_ctx, duk_regconst_t *out_reg_varbind, duk_regconst_t *out_rc_varname) {
 duk_hthread *thr = comp_ctx->thr;
 duk_regconst_t reg_varbind;
 duk_regconst_t rc_varname;



 duk_dup_top(thr);
 reg_varbind = duk__lookup_active_register_binding(comp_ctx);

 if (reg_varbind >= 0) {
  *out_reg_varbind = reg_varbind;
  *out_rc_varname = 0;
  duk_pop(thr);
  return 1;
 } else {
  rc_varname = duk__getconst(comp_ctx);
  *out_reg_varbind = -1;
  *out_rc_varname = rc_varname;
  return 0;
 }
}
# 2706 "duk_js_compiler.c"
static void duk__add_label(duk_compiler_ctx *comp_ctx, duk_hstring *h_label, duk_int_t pc_label, duk_int_t label_id) {
 duk_hthread *thr = comp_ctx->thr;
 duk_size_t n;
 duk_size_t new_size;
 duk_uint8_t *p;
 duk_labelinfo *li_start, *li;
# 2722 "duk_js_compiler.c"
 p = (duk_uint8_t *) ((comp_ctx->curr_func.h_labelinfos)->curr_alloc);
 li_start = (duk_labelinfo *) (void *) p;
 li = (duk_labelinfo *) (void *) (p + (((duk_hbuffer *) (comp_ctx->curr_func.h_labelinfos))->size));
 n = (duk_size_t) (li - li_start);

 while (li > li_start) {
  li--;

  if (li->h_label == h_label && h_label != (((thr))->strs[(15)])) {
   do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 2731; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("duplicate label"))); } while (0); } while (0);
   do { return; } while (0);
  }
 }

 duk_push_hstring(thr, h_label);
 do { } while (0);
 (void) duk_put_prop_index(thr, comp_ctx->curr_func.labelnames_idx, (duk_uarridx_t) n);

 new_size = (n + 1) * sizeof(duk_labelinfo);
 duk_hbuffer_resize(thr, comp_ctx->curr_func.h_labelinfos, new_size);



 p = (duk_uint8_t *) ((comp_ctx->curr_func.h_labelinfos)->curr_alloc);
 li_start = (duk_labelinfo *) (void *) p;
 do { (void) (li_start); } while (0);
 li = (duk_labelinfo *) (void *) (p + (((duk_hbuffer *) (comp_ctx->curr_func.h_labelinfos))->size));
 li--;
# 2758 "duk_js_compiler.c"
 li->flags = (1U << 0);
 li->label_id = label_id;
 li->h_label = h_label;
 li->catch_depth = comp_ctx->curr_func.catch_depth;
 li->pc_label = pc_label;

 do { } while (0)




                                           ;
}


static void duk__update_label_flags(duk_compiler_ctx *comp_ctx, duk_int_t label_id, duk_small_uint_t flags) {
 duk_uint8_t *p;
 duk_labelinfo *li_start, *li;

 p = (duk_uint8_t *) ((comp_ctx->curr_func.h_labelinfos)->curr_alloc);
 li_start = (duk_labelinfo *) (void *) p;
 li = (duk_labelinfo *) (void *) (p + (((duk_hbuffer *) (comp_ctx->curr_func.h_labelinfos))->size));





 while (li > li_start) {
  li--;

  if (li->label_id != label_id) {
   break;
  }

  do { } while (0)


                                     ;

  li->flags = flags;
 }
}
# 2816 "duk_js_compiler.c"
static void duk__lookup_active_label(duk_compiler_ctx *comp_ctx,
                                        duk_hstring *h_label,
                                        duk_bool_t is_break,
                                        duk_int_t *out_label_id,
                                        duk_int_t *out_label_catch_depth,
                                        duk_int_t *out_label_pc,
                                        duk_bool_t *out_is_closest) {
 duk_hthread *thr = comp_ctx->thr;
 duk_uint8_t *p;
 duk_labelinfo *li_start, *li_end, *li;
 duk_bool_t match = 0;

 do { } while (0);

 do { (void) (thr); } while (0);

 p = (duk_uint8_t *) ((comp_ctx->curr_func.h_labelinfos)->curr_alloc);
 li_start = (duk_labelinfo *) (void *) p;
 li_end = (duk_labelinfo *) (void *) (p + (((duk_hbuffer *) (comp_ctx->curr_func.h_labelinfos))->size));
 li = li_end;




 while (li > li_start) {
  li--;

  if (li->h_label != h_label) {
   do { } while (0)


                                                 ;
   continue;
  }

  do { } while (0)

                                                ;


  do { } while (0);

  if (is_break) {

   match = 1;
   break;
  } else if (li->flags & (1U << 1)) {

   match = 1;
   break;
  } else {




   if (h_label != (((thr))->strs[(15)])) {
    do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 2872; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid label"))); } while (0); } while (0);
    do { return; } while (0);
   } else {
    do { } while (0)
                                                                                      ;
   }
  }
 }

 if (!match) {
  do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 2882; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid label"))); } while (0); } while (0);
  do { return; } while (0);
 }

 do { } while (0)



                                           ;

 *out_label_id = li->label_id;
 *out_label_catch_depth = li->catch_depth;
 *out_label_pc = li->pc_label;
 *out_is_closest = (li == li_end - 1);
}

static void duk__reset_labels_to_length(duk_compiler_ctx *comp_ctx, duk_size_t len) {
 duk_hthread *thr = comp_ctx->thr;

 duk_set_length(thr, comp_ctx->curr_func.labelnames_idx, len);
 duk_hbuffer_resize(thr, comp_ctx->curr_func.h_labelinfos, sizeof(duk_labelinfo) * len);
}
# 2918 "duk_js_compiler.c"
static void duk__nud_array_literal(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 duk_hthread *thr = comp_ctx->thr;
 duk_regconst_t reg_obj;
 duk_regconst_t reg_temp;
 duk_regconst_t temp_start;
 duk_small_uint_t max_init_values;
 duk_small_uint_t num_values;
 duk_uarridx_t curr_idx;
 duk_uarridx_t start_idx;
 duk_uarridx_t init_idx;
 duk_bool_t require_comma;

 duk_int_t pc_newarr;
 duk_compiler_instr *instr;



 do { } while (0);

 max_init_values = 20;

 reg_obj = duk__alloctemp((comp_ctx));

 pc_newarr = duk__get_current_pc(comp_ctx);

 duk__emit_bc(comp_ctx, 193, reg_obj);
 temp_start = ((comp_ctx)->curr_func.temp_next);
# 2958 "duk_js_compiler.c"
 curr_idx = 0;
 init_idx = 0;
 start_idx = 0;
 require_comma = 0;

 for (;;) {
  num_values = 0;
  ((comp_ctx)->curr_func.temp_next = (temp_start));

  if (comp_ctx->curr_token.t == 52) {
   break;
  }

  for (;;) {
   if (comp_ctx->curr_token.t == 52) {

    break;
   }


   if (require_comma) {
    if (comp_ctx->curr_token.t == 57) {

     duk__advance(comp_ctx);
     require_comma = 0;
     continue;
    } else {
     goto syntax_error;
    }
   } else {
    if (comp_ctx->curr_token.t == 57) {

     curr_idx++;
     duk__advance(comp_ctx);

     break;
    }
   }



   if (num_values == 0) {
    start_idx = curr_idx;
    reg_temp = duk__alloctemp((comp_ctx));
    duk__emit_load_int32(comp_ctx, reg_temp, (duk_int32_t) start_idx);
   }

   reg_temp = duk__alloctemp((comp_ctx));
   ((comp_ctx)->curr_func.temp_next = (reg_temp));
   duk__expr_toforcedreg(comp_ctx, res, 6 , reg_temp );
   ((comp_ctx)->curr_func.temp_next = (reg_temp + 1));

   num_values++;
   curr_idx++;
   require_comma = 1;

   if (num_values >= max_init_values) {

    break;
   }
  }

  if (num_values > 0) {
# 3029 "duk_js_compiler.c"
   duk__emit_a_b_c(comp_ctx,
                   198 | (1 << 10) | (1 << 11),
                   reg_obj,
                   temp_start,
                   (duk_regconst_t) (num_values + 1));
   init_idx = start_idx + num_values;


  }
 }





 instr = duk__get_instr_ptr(comp_ctx, pc_newarr);
 instr->ins |= ((duk_instr_t) ((((duk_instr_t) (0)) << 24) | (((duk_instr_t) (0)) << 16) | (((duk_instr_t) ((curr_idx > 0xffL ? 0xffL : curr_idx))) << 8) | ((duk_instr_t) ((0)))));


 do { } while (0);
 duk__advance(comp_ctx);

 do { } while (0);


 if (curr_idx > init_idx) {

  do { } while (0);
  reg_temp = duk__alloctemp((comp_ctx));
  duk__emit_load_int32(comp_ctx, reg_temp, (duk_int_t) curr_idx);
  duk__emit_a_bc(comp_ctx, 200 | (1 << 11), reg_obj, reg_temp);
 }

 ((comp_ctx)->curr_func.temp_next = (temp_start));

 duk__ivalue_regconst(res, reg_obj);
 return;

syntax_error:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 3068; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid array literal"))); } while (0); } while (0);
 do { return; } while (0);
}

typedef struct {
 duk_regconst_t reg_obj;
 duk_regconst_t temp_start;
 duk_small_uint_t num_pairs;
 duk_small_uint_t num_total_pairs;
} duk__objlit_state;

static void duk__objlit_flush_keys(duk_compiler_ctx *comp_ctx, duk__objlit_state *st) {
 if (st->num_pairs > 0) {
# 3089 "duk_js_compiler.c"
  do { } while (0);
  duk__emit_a_b_c(comp_ctx,
                  194 | (1 << 10) | (1 << 11),
                  st->reg_obj,
                  st->temp_start,
                  (duk_regconst_t) (st->num_pairs * 2));
  st->num_total_pairs += st->num_pairs;
  st->num_pairs = 0;
 }
 ((comp_ctx)->curr_func.temp_next = (st->temp_start));
}

static duk_bool_t duk__objlit_load_key(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_token *tok, duk_regconst_t reg_temp) {
 if (tok->t_nores == 1 || tok->t_nores == 100) {

  do { } while (0);
  duk_push_hstring(comp_ctx->thr, tok->str1);
 } else if (tok->t == 99) {

  duk_push_number(comp_ctx->thr, tok->num);
 } else {
  return 1;
 }

 duk__ivalue_plain_fromstack(comp_ctx, res);
 ((comp_ctx)->curr_func.temp_next = (reg_temp + 1));
 duk__ivalue_toforcedreg(comp_ctx, res, reg_temp);
 ((comp_ctx)->curr_func.temp_next = (reg_temp + 1));
 return 0;
}

static void duk__nud_object_literal(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 duk_hthread *thr = comp_ctx->thr;
 duk__objlit_state st;
 duk_regconst_t reg_temp;
 duk_small_uint_t max_init_pairs;
 duk_bool_t first;
 duk_bool_t is_set, is_get;

 duk_int_t pc_newobj;
 duk_compiler_instr *instr;


 do { } while (0);

 max_init_pairs = 10;

 st.reg_obj = duk__alloctemp((comp_ctx));
 st.temp_start = ((comp_ctx)->curr_func.temp_next);
 st.num_pairs = 0;
 st.num_total_pairs = 0;


 pc_newobj = duk__get_current_pc(comp_ctx);

 duk__emit_bc(comp_ctx, 192, st.reg_obj);
# 3153 "duk_js_compiler.c"
 first = 1;
 for (;;) {
# 3178 "duk_js_compiler.c"
  do { } while (0);

  if (comp_ctx->curr_token.t == 50) {
   break;
  }

  if (first) {
   first = 0;
  } else {
   if (comp_ctx->curr_token.t != 57) {
    goto syntax_error;
   }
   duk__advance(comp_ctx);
   if (comp_ctx->curr_token.t == 50) {

    break;
   }
  }


  duk__advance(comp_ctx);


  if (st.num_pairs >= max_init_pairs) {
   duk__objlit_flush_keys(comp_ctx, &st);
   do { } while (0);
  }




  ((comp_ctx)->curr_func.temp_next = (st.temp_start + 2 * (duk_regconst_t) st.num_pairs));
  reg_temp = duk__alloctemps((comp_ctx), (2));







  is_get = (comp_ctx->prev_token.t == 1 && comp_ctx->prev_token.str1 == (((thr))->strs[(73)]));
  is_set = (comp_ctx->prev_token.t == 1 && comp_ctx->prev_token.str1 == (((thr))->strs[(88)]));
  if ((is_get || is_set) && comp_ctx->curr_token.t != 85) {

   duk_int_t fnum;

   duk__objlit_flush_keys(comp_ctx, &st);
   do { } while (0)
                            ;
   reg_temp = duk__alloctemps((comp_ctx), (2));

   if (duk__objlit_load_key(comp_ctx, res, &comp_ctx->curr_token, reg_temp) != 0) {
    goto syntax_error;
   }


   fnum = duk__parse_func_like_fnum(comp_ctx, (1 << 1));

   duk__emit_a_bc(comp_ctx, 152, st.temp_start + 1, (duk_regconst_t) fnum);





   duk__emit_a_bc(comp_ctx,
                  (is_get ? 197 : 196) | (1 << 11),
                  st.reg_obj,
                  st.temp_start);

   do { } while (0);

  } else if (comp_ctx->prev_token.t == 1 &&
             (comp_ctx->curr_token.t == 57 || comp_ctx->curr_token.t == 50)) {
   duk_bool_t load_rc;

   load_rc = duk__objlit_load_key(comp_ctx, res, &comp_ctx->prev_token, reg_temp);
   do { (void) (load_rc); } while (0);
   do { } while (0);

   duk__ivalue_var_hstring(comp_ctx, res, comp_ctx->prev_token.str1);
   do { } while (0);
   duk__ivalue_toforcedreg(comp_ctx, res, reg_temp + 1);

   st.num_pairs++;
  } else if ((comp_ctx->prev_token.t == 1 || comp_ctx->prev_token.t == 100 ||
              comp_ctx->prev_token.t == 99) &&
             comp_ctx->curr_token.t == 53) {
   duk_int_t fnum;
# 3274 "duk_js_compiler.c"
   if (duk__objlit_load_key(comp_ctx, res, &comp_ctx->prev_token, reg_temp) != 0) {
    goto syntax_error;
   }

   fnum = duk__parse_func_like_fnum(comp_ctx, (1 << 4) | (1 << 2));

   duk__emit_a_bc(comp_ctx, 152, reg_temp + 1, (duk_regconst_t) fnum);

   st.num_pairs++;

  } else {

   if (comp_ctx->prev_token.t == 51) {



    ((comp_ctx)->curr_func.temp_next = (reg_temp));
    duk__expr_toforcedreg(comp_ctx, res, 4, reg_temp);
    duk__advance_expect(comp_ctx, 52);







   } else

   {
    if (duk__objlit_load_key(comp_ctx, res, &comp_ctx->prev_token, reg_temp) != 0) {
     goto syntax_error;
    }
   }

   duk__advance_expect(comp_ctx, 85);

   ((comp_ctx)->curr_func.temp_next = (reg_temp + 1));
   duk__expr_toforcedreg(comp_ctx, res, 6 , reg_temp + 1 );

   st.num_pairs++;
  }
 }


 duk__objlit_flush_keys(comp_ctx, &st);
 do { } while (0);
 do { } while (0);
# 3329 "duk_js_compiler.c"
 instr = duk__get_instr_ptr(comp_ctx, pc_newobj);
 instr->ins |= ((duk_instr_t) ((((duk_instr_t) (0)) << 24) | (((duk_instr_t) (0)) << 16) | (((duk_instr_t) ((st.num_total_pairs > 0xffL ? 0xffL : st.num_total_pairs))) << 8) | ((duk_instr_t) ((0)))));


 do { } while (0);
 duk__advance(comp_ctx);

 duk__ivalue_regconst(res, st.reg_obj);
 return;

syntax_error:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 3340; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid object literal"))); } while (0); } while (0);
 do { return; } while (0);
}





static duk_int_t duk__parse_arguments(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 duk_int_t nargs = 0;
 duk_regconst_t reg_temp;



 do { } while (0)

                                                     ;

 for (;;) {
  if (comp_ctx->curr_token.t == 54) {
   break;
  }
  if (nargs > 0) {
   duk__advance_expect(comp_ctx, 57);
  }
# 3373 "duk_js_compiler.c"
  reg_temp = duk__alloctemp((comp_ctx));
  ((comp_ctx)->curr_func.temp_next = (reg_temp));


  duk__expr_toforcedreg(comp_ctx,
                        res,
                        6 ,
                        reg_temp);

  ((comp_ctx)->curr_func.temp_next = (reg_temp + 1));
  nargs++;

  do { } while (0);
 }


 duk__advance_expect(comp_ctx, 54);

 do { } while (0);

 return nargs;
}

static duk_bool_t duk__expr_is_empty(duk_compiler_ctx *comp_ctx) {

 return (comp_ctx->curr_func.nud_count == 0) && (comp_ctx->curr_func.led_count == 0);
}

static void duk__expr_nud(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 duk_hthread *thr = comp_ctx->thr;
 duk_token *tk;
 duk_regconst_t temp_at_entry;
 duk_small_uint_t tok;
 duk_uint32_t args;
# 3415 "duk_js_compiler.c"
 temp_at_entry = ((comp_ctx)->curr_func.temp_next);

 comp_ctx->curr_func.nud_count++;

 tk = &comp_ctx->prev_token;
 tok = tk->t;
 res->t = 0;

 do { } while (0)


                                                              ;

 switch (tok) {


 case 20: {
  duk_regconst_t reg_temp;
  reg_temp = duk__alloctemp((comp_ctx));
  duk__emit_bc(comp_ctx, 6, reg_temp);
  duk__ivalue_regconst(res, reg_temp);
  return;
 }
 case 1: {
  duk__ivalue_var_hstring(comp_ctx, res, tk->str1);
  return;
 }
 case 35: {
  duk_push_null(thr);
  goto plain_value;
 }
 case 36: {
  duk_push_true(thr);
  goto plain_value;
 }
 case 37: {
  duk_push_false(thr);
  goto plain_value;
 }
 case 99: {
  duk_push_number(thr, tk->num);
  goto plain_value;
 }
 case 100: {
  do { } while (0);
  duk_push_hstring(thr, tk->str1);
  goto plain_value;
 }
 case 101: {

  duk_regconst_t reg_temp;
  duk_regconst_t rc_re_bytecode;
  duk_regconst_t rc_re_source;

  do { } while (0);
  do { } while (0);

  do { } while (0);

  reg_temp = duk__alloctemp((comp_ctx));
  duk_push_hstring(thr, tk->str1);
  duk_push_hstring(thr, tk->str2);



  duk_regexp_compile(thr);



  rc_re_bytecode = duk__getconst(comp_ctx);
  rc_re_source = duk__getconst(comp_ctx);

  duk__emit_a_b_c(comp_ctx,
                  148 | (1 << 14),
                  reg_temp ,
                  rc_re_bytecode ,
                  rc_re_source );

  duk__ivalue_regconst(res, reg_temp);
  return;



 }
 case 51: {
  do { } while (0);
  duk__nud_array_literal(comp_ctx, res);
  return;
 }
 case 49: {
  do { } while (0);
  duk__nud_object_literal(comp_ctx, res);
  return;
 }
 case 53: {
  duk_bool_t prev_allow_in;

  comp_ctx->curr_func.paren_level++;
  prev_allow_in = comp_ctx->curr_func.allow_in;
  comp_ctx->curr_func.allow_in = 1;

  duk__expr(comp_ctx, res, 4 );

  duk__advance_expect(comp_ctx, 54);
  comp_ctx->curr_func.allow_in = prev_allow_in;
  comp_ctx->curr_func.paren_level--;
  return;
 }



 case 17: {
# 3541 "duk_js_compiler.c"
  duk_regconst_t reg_target;
  duk_int_t nargs;

  do { } while (0);

  reg_target = duk__alloctemps((comp_ctx), (2));


  if (comp_ctx->curr_token.t == 55) {

   do { } while (0);
   duk__advance(comp_ctx);
   if (comp_ctx->curr_token.t_nores != 1 ||
       !duk_hstring_equals_ascii_cstring(comp_ctx->curr_token.str1, "target")) {
    goto syntax_error_newtarget;
   }
   if (comp_ctx->curr_func.is_global) {
    goto syntax_error_newtarget;
   }
   duk__advance(comp_ctx);
   duk__emit_bc(comp_ctx, 203, reg_target);
   duk__ivalue_regconst(res, reg_target);
   return;
  }


  duk__expr_toforcedreg(comp_ctx, res, 36 , reg_target );
  duk__emit_bc(comp_ctx, 192, reg_target + 1);
  ((comp_ctx)->curr_func.temp_next = (reg_target + 2));





  if (comp_ctx->curr_token.t == 53) {

   do { } while (0);
   duk__advance(comp_ctx);
   nargs = duk__parse_arguments(comp_ctx, res);

  } else {

   do { } while (0);
   nargs = 0;
  }

  duk__emit_a_bc(comp_ctx, 176 | (1U << 1), nargs , reg_target );

  do { } while (0);

  duk__ivalue_regconst(res, reg_target);
  return;
 }



 case 13: {
# 3609 "duk_js_compiler.c"
  duk_regconst_t reg_temp;
  duk_int_t fnum;

  reg_temp = duk__alloctemp((comp_ctx));


  fnum = duk__parse_func_like_fnum(comp_ctx, 0 );
  do { } while (0);

  duk__emit_a_bc(comp_ctx, 152, reg_temp , (duk_regconst_t) fnum );

  duk__ivalue_regconst(res, reg_temp);
  return;
 }



 case 8: {





  duk__expr(comp_ctx, res, 30 );
  if (res->t == 4) {





   duk_regconst_t reg_temp;
   duk_regconst_t reg_varbind;
   duk_regconst_t rc_varname;

   if (comp_ctx->curr_func.is_strict) {
    do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 3644; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("cannot delete identifier"))); } while (0); } while (0);
    do { return; } while (0);
   }

   ((comp_ctx)->curr_func.temp_next = (temp_at_entry));
   reg_temp = duk__alloctemp((comp_ctx));

   duk_dup(thr, res->x1.valstack_idx);
   if (duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname)) {

    duk__emit_bc(comp_ctx, 10, reg_temp);
   } else {
    duk_dup(thr, res->x1.valstack_idx);
    rc_varname = duk__getconst(comp_ctx);
    duk__emit_a_bc(comp_ctx, 156, reg_temp, rc_varname);
   }
   duk__ivalue_regconst(res, reg_temp);
  } else if (res->t == 3) {
   duk_regconst_t reg_temp;
   duk_regconst_t reg_obj;
   duk_regconst_t rc_key;

   ((comp_ctx)->curr_func.temp_next = (temp_at_entry));
   reg_temp = duk__alloctemp((comp_ctx));
   reg_obj =
       duk__ispec_toregconst_raw(comp_ctx, &res->x1, -1 , 0 );
   rc_key =
       duk__ispec_toregconst_raw(comp_ctx, &res->x2, -1 , (1 << 0) );
   duk__emit_a_b_c(comp_ctx, 116 | (1 << 14), reg_temp, reg_obj, rc_key);

   duk__ivalue_regconst(res, reg_temp);
  } else {

   duk_push_true(thr);
   goto plain_value;
  }
  return;
 }
 case 26: {
  duk__expr_toplain_ignore(comp_ctx, res, 30 );
  duk_push_undefined(thr);
  goto plain_value;
 }
 case 23: {





  duk__expr(comp_ctx, res, 30 );

  if (res->t == 4) {
   duk_regconst_t reg_varbind;
   duk_regconst_t rc_varname;
   duk_regconst_t reg_temp;

   duk_dup(thr, res->x1.valstack_idx);
   if (!duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname)) {
    do { } while (0)
                                                                                   ;
    reg_temp = duk__alloctemp((comp_ctx));
    duk__emit_a_bc(comp_ctx, 154, reg_temp, rc_varname);
    duk__ivalue_regconst(res, reg_temp);
    return;
   }
  }

  args = 153;
  goto unary;
 }
 case 72: {
  args = (128 << 8) + 120;
  goto preincdec;
 }
 case 73: {
  args = (132 << 8) + 121;
  goto preincdec;
 }
 case 66: {

  duk__expr(comp_ctx, res, 30 );
  if (res->t == 1 && res->x1.t == 1 && duk_is_number(thr, res->x1.valstack_idx)) {

   return;
  }
  args = 15;
  goto unary;
 }
 case 67: {

  duk__expr(comp_ctx, res, 30 );
  if (res->t == 1 && res->x1.t == 1 && duk_is_number(thr, res->x1.valstack_idx)) {



   duk_tval *tv_num;
   duk_double_union du;

   tv_num = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (res->x1.valstack_idx));
   do { } while (0);
   do { } while (0);
   du.d = ((tv_num)->v.d);
   du.d = -du.d;
   ;
   do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = (du.d); ; duk__tv = (tv_num); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0);
   return;
  }
  args = 14;
  goto unary;
 }
 case 81: {
  duk__expr(comp_ctx, res, 30 );
  args = 12;
  goto unary;
 }
 case 80: {
  duk__expr(comp_ctx, res, 30 );
  if (res->t == 1 && res->x1.t == 1) {



   duk_tval *tv_val;

   tv_val = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + (res->x1.valstack_idx));
   do { } while (0);
   if (((tv_val)->t == 0)) {
    duk_double_t d;
    d = ((tv_val)->v.d);
    if (duk_double_equals(d, 0.0)) {

     do { } while (0);
     do { duk_tval *duk__tv; duk__tv = ((tv_val)); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) (1); } while (0);
     return;
    } else if (duk_double_equals(d, 1.0)) {
     do { } while (0);
     do { duk_tval *duk__tv; duk__tv = ((tv_val)); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) (0); } while (0);
     return;
    }
   } else if (((tv_val)->t == 4)) {
    duk_small_uint_t v;
    v = ((duk_small_uint_t) (tv_val)->v.i);
    do { } while (0);
    do { } while (0);
    do { duk_tval *duk__tv; duk__tv = (tv_val); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) (v ^ 0x01); } while (0);
    return;
   }
  }
  args = 13;
  goto unary;
 }

 }

 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 3797; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("parse error"))); } while (0); } while (0);
 do { return; } while (0);

unary : {





 duk_regconst_t reg_src, reg_res;

 reg_src = duk__ivalue_toregconst_raw(comp_ctx, res, -1 , 0 );
 if (((duk_int32_t) (reg_src) >= (duk_int32_t) ((comp_ctx)->curr_func.temp_first))) {
  reg_res = reg_src;
 } else {
  reg_res = duk__alloctemp((comp_ctx));
 }
 duk__emit_a_bc(comp_ctx, args, reg_res, reg_src);
 duk__ivalue_regconst(res, reg_res);
 return;
}

preincdec : {

 duk_regconst_t reg_res;
 duk_small_uint_t args_op1 = args & 0xff;
 duk_small_uint_t args_op2 = args >> 8;


 do { } while (0);
 do { } while (0);

 reg_res = duk__alloctemp((comp_ctx));

 duk__expr(comp_ctx, res, 30 );
 if (res->t == 4) {
  duk_hstring *h_varname;
  duk_regconst_t reg_varbind;
  duk_regconst_t rc_varname;

  h_varname = duk_known_hstring(thr, res->x1.valstack_idx);

  if (duk__hstring_is_eval_or_arguments_in_strict_mode(comp_ctx, h_varname)) {
   goto syntax_error;
  }

  duk_dup(thr, res->x1.valstack_idx);
  if (duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname)) {
   duk__emit_a_bc(comp_ctx,
                  args_op1,
                  reg_res,
                  reg_varbind);
  } else {
   duk__emit_a_bc(comp_ctx,
                  args_op1 + 4,
                  reg_res,
                  rc_varname);
  }

  do { } while (0)


                                          ;
 } else if (res->t == 3) {
  duk_regconst_t reg_obj;
  duk_regconst_t rc_key;
  reg_obj = duk__ispec_toregconst_raw(comp_ctx, &res->x1, -1 , 0 );
  rc_key = duk__ispec_toregconst_raw(comp_ctx, &res->x2, -1 , (1 << 0) );
  duk__emit_a_b_c(comp_ctx,
                  args_op2 | (1 << 14),
                  reg_res,
                  reg_obj,
                  rc_key);
 } else {






  duk__ivalue_toforcedreg(comp_ctx, res, reg_res);
  duk__emit_bc(comp_ctx, 15, reg_res);
  duk__emit_op_only(comp_ctx, 170);
 }
 ((comp_ctx)->curr_func.temp_next = (reg_res + 1));
 duk__ivalue_regconst(res, reg_res);
 return;
}

plain_value : {

 duk__ivalue_plain_fromstack(comp_ctx, res);
 return;
}


syntax_error_newtarget:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 3894; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid new.target"))); } while (0); } while (0);
 do { return; } while (0);


syntax_error:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 3899; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid expression"))); } while (0); } while (0);
 do { return; } while (0);
}





static void duk__expr_led(duk_compiler_ctx *comp_ctx, duk_ivalue *left, duk_ivalue *res) {
 duk_hthread *thr = comp_ctx->thr;
 duk_token *tk;
 duk_small_uint_t tok;
 duk_uint32_t args;






 comp_ctx->curr_func.led_count++;


 tk = &comp_ctx->prev_token;
 tok = tk->t;

 do { } while (0)


                                                              ;



 switch (tok) {


 case 55: {
# 3951 "duk_js_compiler.c"
  duk__ivalue_toplain(comp_ctx, left);


  if (comp_ctx->curr_token.t_nores != 1) {
   do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 3955; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("expected identifier"))); } while (0); } while (0);
   do { return; } while (0);
  }

  res->t = 3;
  duk__copy_ispec(comp_ctx, &left->x1, &res->x1);
  do { } while (0);
  duk_push_hstring(thr, comp_ctx->curr_token.str1);
  duk_replace(thr, res->x2.valstack_idx);
  res->x2.t = 1;


  comp_ctx->curr_func.reject_regexp_in_adv = 1;

  duk__advance(comp_ctx);
  return;
 }
 case 51: {
# 3994 "duk_js_compiler.c"
  duk__ivalue_totempconst(comp_ctx, left);
  duk__expr_toplain(comp_ctx, res, 4 );
  duk__advance_expect(comp_ctx, 52);

  res->t = 3;
  duk__copy_ispec(comp_ctx, &res->x1, &res->x2);
  duk__copy_ispec(comp_ctx, &left->x1, &res->x1);
  return;
 }
 case 53: {

  duk_regconst_t reg_cs = duk__alloctemps((comp_ctx), (2));
  duk_int_t nargs;
  duk_small_uint_t call_op = 176;
# 4021 "duk_js_compiler.c"
  if (left->t == 4) {
   duk_hstring *h_varname;
   duk_regconst_t reg_varbind;
   duk_regconst_t rc_varname;

   do { } while (0);

   h_varname = duk_known_hstring(thr, left->x1.valstack_idx);
   if (h_varname == (((thr))->strs[(33)])) {





    do { } while (0)

                                               ;
    call_op |= (1U << 2);
    comp_ctx->curr_func.may_direct_eval = 1;
   }

   duk_dup(thr, left->x1.valstack_idx);
   if (duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname)) {
    duk__emit_a_bc(comp_ctx, 171 | (1 << 11), reg_varbind, reg_cs + 0);
   } else {



    do { } while (0);
    duk__emit_a_b(comp_ctx, 172 | (1 << 14), reg_cs + 0, rc_varname);
   }
  } else if (left->t == 3) {






   duk_regconst_t reg_key;


   do { } while (0);
# 4072 "duk_js_compiler.c"
   duk__ispec_toforcedreg(comp_ctx, &left->x1, reg_cs + 1);

   reg_key = duk__ispec_toregconst_raw(comp_ctx, &left->x2, -1, (1 << 0) );
   duk__emit_a_b_c(comp_ctx, 208 | (1 << 14), reg_cs + 0, reg_cs + 1, reg_key);



  } else {
   do { } while (0);

   duk__ivalue_toforcedreg(comp_ctx, left, reg_cs + 0);
# 4092 "duk_js_compiler.c"
   duk__emit_bc(comp_ctx, 7, reg_cs + 1);
  }

  ((comp_ctx)->curr_func.temp_next = (reg_cs + 2));
  nargs = duk__parse_arguments(comp_ctx, res);





  duk__emit_a_bc(comp_ctx, call_op, (duk_regconst_t) nargs , reg_cs );
  ((comp_ctx)->curr_func.temp_next = (reg_cs + 1));

  duk__ivalue_regconst(res, reg_cs);
  return;
 }



 case 72: {
  args = (136 << 16) + (122 << 8) + 0;
  goto postincdec;
 }
 case 73: {
  args = (140 << 16) + (123 << 8) + 0;
  goto postincdec;
 }




 case 71: {
  args = (72 << 8) + 32 - 1;
  goto binary;
 }




 case 68: {
  args = (60 << 8) + 30;
  goto binary;
 }
 case 69: {
  args = (64 << 8) + 30;
  goto binary;
 }
 case 70: {
  args = (68 << 8) + 30;
  goto binary;
 }



 case 66: {
  args = (52 << 8) + 28;
  goto binary;
 }
 case 67: {
  args = (56 << 8) + 28;
  goto binary;
 }



 case 74: {

  args = (88 << 8) + 26;
  goto binary;
 }
 case 75: {

  args = (96 << 8) + 26;
  goto binary;
 }
 case 76: {

  args = (92 << 8) + 26;
  goto binary;
 }



 case 58: {

  args = (40 << 8) + 24;
  goto binary;
 }
 case 59: {
  args = (32 << 8) + 24;
  goto binary;
 }
 case 60: {
  args = (44 << 8) + 24;
  goto binary;
 }
 case 61: {
  args = (36 << 8) + 24;
  goto binary;
 }
 case 16: {
  args = (100 << 8) + 24;
  goto binary;
 }
 case 15: {
  args = (104 << 8) + 24;
  goto binary;
 }



 case 62: {
  args = (16 << 8) + 22;
  goto binary;
 }
 case 63: {
  args = (20 << 8) + 22;
  goto binary;
 }
 case 64: {
  args = (24 << 8) + 22;
  goto binary;
 }
 case 65: {
  args = (28 << 8) + 22;
  goto binary;
 }



 case 77: {
  args = (76 << 8) + 20;
  goto binary;
 }
 case 79: {
  args = (84 << 8) + 18;
  goto binary;
 }
 case 78: {
  args = (80 << 8) + 16;
  goto binary;
 }



 case 82: {

  args = (1 << 8) + 14 - 1;
  goto binary_logical;
 }
 case 83: {

  args = (0 << 8) + 12 - 1;
  goto binary_logical;
 }



 case 84: {



  duk_regconst_t reg_temp;
  duk_int_t pc_jump1;
  duk_int_t pc_jump2;

  reg_temp = duk__alloctemp((comp_ctx));
  duk__ivalue_toforcedreg(comp_ctx, left, reg_temp);
  duk__emit_if_true_skip(comp_ctx, reg_temp);
  pc_jump1 = duk__emit_jump_empty(comp_ctx);
  duk__expr_toforcedreg(comp_ctx,
                        res,
                        6 ,
                        reg_temp );
  duk__advance_expect(comp_ctx, 85);
  pc_jump2 = duk__emit_jump_empty(comp_ctx);
  duk__patch_jump_here(comp_ctx, pc_jump1);
  duk__expr_toforcedreg(comp_ctx,
                        res,
                        6 ,
                        reg_temp );
  duk__patch_jump_here(comp_ctx, pc_jump2);

  ((comp_ctx)->curr_func.temp_next = (reg_temp + 1));
  duk__ivalue_regconst(res, reg_temp);
  return;
 }



 case 86: {
# 4294 "duk_js_compiler.c"
  args = (256 << 8) + 8 - 1;
  goto assign;
 }
 case 87: {

  args = (52 << 8) + 8 - 1;
  goto assign;
 }
 case 88: {

  args = (56 << 8) + 8 - 1;
  goto assign;
 }
 case 89: {

  args = (60 << 8) + 8 - 1;
  goto assign;
 }
 case 90: {

  args = (64 << 8) + 8 - 1;
  goto assign;
 }
 case 91: {

  args = (68 << 8) + 8 - 1;
  goto assign;
 }

 case 92: {

  args = (72 << 8) + 8 - 1;
  goto assign;
 }

 case 93: {

  args = (88 << 8) + 8 - 1;
  goto assign;
 }
 case 94: {

  args = (96 << 8) + 8 - 1;
  goto assign;
 }
 case 95: {

  args = (92 << 8) + 8 - 1;
  goto assign;
 }
 case 96: {

  args = (76 << 8) + 8 - 1;
  goto assign;
 }
 case 97: {

  args = (80 << 8) + 8 - 1;
  goto assign;
 }
 case 98: {

  args = (84 << 8) + 8 - 1;
  goto assign;
 }



 case 57: {


  duk__ivalue_toplain_ignore(comp_ctx, left);
  duk__expr_toplain(comp_ctx, res, 6 - 1 );


  return;
 }

 default: {
  break;
 }
 }

 do { } while (0);
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 4378; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("parse error"))); } while (0); } while (0);
 do { return; } while (0);
# 4388 "duk_js_compiler.c"
binary:





 {
  duk__ivalue_toplain(comp_ctx, left);
  duk__expr_toplain(comp_ctx, res, args & 0xff );


  do { } while (0);
  do { } while (0);

  res->t = 2;
  res->op = (args >> 8) & 0xff;

  res->x2.t = res->x1.t;
  res->x2.regconst = res->x1.regconst;
  duk_copy(thr, res->x1.valstack_idx, res->x2.valstack_idx);

  res->x1.t = left->x1.t;
  res->x1.regconst = left->x1.regconst;
  duk_copy(thr, left->x1.valstack_idx, res->x1.valstack_idx);

  do { } while (0)




                                                         ;
  return;
 }

binary_logical:
# 4442 "duk_js_compiler.c"
 {
  duk_regconst_t reg_temp;
  duk_int_t pc_jump;
  duk_small_uint_t args_truthval = args >> 8;
  duk_small_uint_t args_rbp = args & 0xff;



  reg_temp = duk__alloctemp((comp_ctx));

  duk__ivalue_toforcedreg(comp_ctx, left, reg_temp);
  do { } while (0);
  duk__emit_bc(comp_ctx,
               (args_truthval ? 48 : 50),
               reg_temp);
  pc_jump = duk__emit_jump_empty(comp_ctx);
  duk__expr_toforcedreg(comp_ctx, res, args_rbp , reg_temp );
  duk__patch_jump_here(comp_ctx, pc_jump);

  duk__ivalue_regconst(res, reg_temp);
  return;
 }

assign:
# 4497 "duk_js_compiler.c"
 {
  duk_small_uint_t args_op = args >> 8;
  duk_small_uint_t args_rbp = args & 0xff;
  duk_bool_t toplevel_assign;
# 4517 "duk_js_compiler.c"
  toplevel_assign = (comp_ctx->curr_func.nud_count == 1 &&
                     comp_ctx->curr_func.led_count == 1);
  do { } while (0)


                                               ;

  if (left->t == 4) {
   duk_hstring *h_varname;
   duk_regconst_t reg_varbind;
   duk_regconst_t rc_varname;

   do { } while (0);

   h_varname = duk_known_hstring(thr, left->x1.valstack_idx);
   if (duk__hstring_is_eval_or_arguments_in_strict_mode(comp_ctx, h_varname)) {

    goto syntax_error_lvalue;
   }
   duk_dup(thr, left->x1.valstack_idx);
   (void) duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname);

   if (args_op == 256) {
    duk__expr(comp_ctx, res, args_rbp );
    if (toplevel_assign) {

     do { } while (0);
    } else {

     do { } while (0)
                                                                                     ;
     if (res->t != 1 ||
         (res->x1.t == 2 && ((duk_uint32_t) (res->x1.regconst) < (duk_uint32_t) ((comp_ctx)->curr_func.temp_first)))) {
      duk__ivalue_totempconst(comp_ctx, res);
     }
    }
   } else {





    duk_regconst_t reg_temp;

    reg_temp = duk__alloctemp((comp_ctx));

    if (reg_varbind >= 0) {
     duk_regconst_t reg_res;
     duk_regconst_t reg_src;
     duk_int_t pc_temp_load;
     duk_int_t pc_before_rhs;
     duk_int_t pc_after_rhs;

     if (toplevel_assign) {




      do { } while (0);
      reg_res = reg_varbind;
     } else {



      do { } while (0);
      reg_res = reg_temp;
      reg_temp = duk__alloctemp((comp_ctx));
     }
# 4593 "duk_js_compiler.c"
     pc_temp_load = duk__get_current_pc(comp_ctx);
     duk__emit_a_bc(comp_ctx, 0, reg_temp, reg_varbind);

     pc_before_rhs = duk__get_current_pc(comp_ctx);
     duk__expr_toregconst(comp_ctx, res, args_rbp );
     do { } while (0);
     pc_after_rhs = duk__get_current_pc(comp_ctx);

     do { } while (0)


                                             ;

     if (pc_after_rhs == pc_before_rhs) {




      do { } while (0)
                                            ;
      do { (&comp_ctx->curr_func.bw_code)->p += ((pc_temp_load - pc_before_rhs) * (duk_int_t) sizeof(duk_compiler_instr)); } while (0)


                                                                ;
      reg_src = reg_varbind;
     } else {
      do { } while (0)
                                                       ;
      reg_src = reg_temp;
     }

     duk__emit_a_b_c(comp_ctx,
                     args_op | (1 << 14),
                     reg_res,
                     reg_src,
                     res->x1.regconst);

     res->x1.regconst = reg_res;


     if (((duk_int32_t) (reg_res) >= (duk_int32_t) ((comp_ctx)->curr_func.temp_first))) {
      ((comp_ctx)->curr_func.temp_next = (reg_res + 1));
     }
    } else {




     duk__emit_a_bc(comp_ctx, 11, reg_temp, rc_varname);

     duk__expr_toregconst(comp_ctx, res, args_rbp );
     do { } while (0);

     duk__emit_a_b_c(comp_ctx,
                     args_op | (1 << 14),
                     reg_temp,
                     reg_temp,
                     res->x1.regconst);
     res->x1.regconst = reg_temp;
    }

    do { } while (0);
   }
# 4664 "duk_js_compiler.c"
   if (reg_varbind >= 0) {
    if (res->t != 1) {




     if (toplevel_assign) {
      duk__ivalue_toforcedreg(comp_ctx, res, (duk_int_t) reg_varbind);
     } else {
      duk__ivalue_totempconst(comp_ctx, res);
      duk__copy_ivalue(comp_ctx, res, left);
      duk__ivalue_toforcedreg(comp_ctx, left, (duk_int_t) reg_varbind);
     }
    } else {




     duk__copy_ivalue(comp_ctx, res, left);
     duk__ivalue_toforcedreg(comp_ctx, left, (duk_int_t) reg_varbind);
    }
   } else {
# 4694 "duk_js_compiler.c"
    duk__ivalue_toreg(comp_ctx, res);
    duk__emit_a_bc(comp_ctx, 155 | (1 << 11), res->x1.regconst, rc_varname);
   }


  } else if (left->t == 3) {

   duk_regconst_t reg_obj;
   duk_regconst_t rc_key;
   duk_regconst_t rc_res;
   duk_regconst_t reg_temp;
# 4717 "duk_js_compiler.c"
   reg_obj = duk__ispec_toregconst_raw(comp_ctx,
                                       &left->x1,
                                       -1 ,
                                       (1 << 1) );

   rc_key = duk__ispec_toregconst_raw(comp_ctx,
                                      &left->x2,
                                      -1 ,
                                      (1 << 1) | (1 << 0) );



   if (args_op == 256) {
    duk__expr_toregconst(comp_ctx, res, args_rbp );
    do { } while (0);
    rc_res = res->x1.regconst;
   } else {
    reg_temp = duk__alloctemp((comp_ctx));
    duk__emit_a_b_c(comp_ctx, 108 | (1 << 14), reg_temp, reg_obj, rc_key);

    duk__expr_toregconst(comp_ctx, res, args_rbp );
    do { } while (0);

    duk__emit_a_b_c(comp_ctx,
                    args_op | (1 << 14),
                    reg_temp,
                    reg_temp,
                    res->x1.regconst);
    rc_res = reg_temp;
   }

   duk__emit_a_b_c(comp_ctx,
                   112 | (1 << 11) | (1 << 14),
                   reg_obj,
                   rc_key,
                   rc_res);

   duk__ivalue_regconst(res, rc_res);
  } else {
# 4767 "duk_js_compiler.c"
   duk_regconst_t rc_res;


   duk__ivalue_toplain_ignore(comp_ctx, left);





   rc_res = duk__expr_toregconst(comp_ctx, res, args_rbp );

   duk__emit_op_only(comp_ctx, 170);

   duk__ivalue_regconst(res, rc_res);
  }

  return;
 }

postincdec : {
# 4798 "duk_js_compiler.c"
 duk_regconst_t reg_res;
 duk_small_uint_t args_op1 = (args >> 8) & 0xff;
 duk_small_uint_t args_op2 = args >> 16;


 do { } while (0);
 do { } while (0);

 reg_res = duk__alloctemp((comp_ctx));

 if (left->t == 4) {
  duk_hstring *h_varname;
  duk_regconst_t reg_varbind;
  duk_regconst_t rc_varname;

  h_varname = duk_known_hstring(thr, left->x1.valstack_idx);

  if (duk__hstring_is_eval_or_arguments_in_strict_mode(comp_ctx, h_varname)) {
   goto syntax_error;
  }

  duk_dup(thr, left->x1.valstack_idx);
  if (duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname)) {
   duk__emit_a_bc(comp_ctx,
                  args_op1,
                  reg_res,
                  reg_varbind);
  } else {
   duk__emit_a_bc(comp_ctx,
                  args_op1 + 4,
                  reg_res,
                  rc_varname);
  }

  do { } while (0)


                                          ;
 } else if (left->t == 3) {
  duk_regconst_t reg_obj;
  duk_regconst_t rc_key;

  reg_obj = duk__ispec_toregconst_raw(comp_ctx, &left->x1, -1 , 0 );
  rc_key = duk__ispec_toregconst_raw(comp_ctx, &left->x2, -1 , (1 << 0) );
  duk__emit_a_b_c(comp_ctx,
                  args_op2 | (1 << 14),
                  reg_res,
                  reg_obj,
                  rc_key);
 } else {





  duk__ivalue_toforcedreg(comp_ctx, left, reg_res);
  duk__emit_bc(comp_ctx, 15, reg_res);
  duk__emit_op_only(comp_ctx, 170);
 }

 ((comp_ctx)->curr_func.temp_next = (reg_res + 1));
 duk__ivalue_regconst(res, reg_res);
 return;
}

syntax_error:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 4864; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid expression"))); } while (0); } while (0);
 do { return; } while (0);

syntax_error_lvalue:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 4868; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid lvalue"))); } while (0); } while (0);
 do { return; } while (0);
}

static duk_small_uint_t duk__expr_lbp(duk_compiler_ctx *comp_ctx) {
 duk_small_uint_t tok = comp_ctx->curr_token.t;

 do { } while (0);
 do { } while (0);
 do { } while (0);






 if (tok == 15 && !comp_ctx->curr_func.allow_in) {
  return 0;
 }

 if ((tok == 73 || tok == 72) && (comp_ctx->curr_token.lineterm)) {






  return 0;
 }

 return ((duk_small_uint_t) (((duk__token_lbp[tok]) &0x1f) * 2));
}
# 4916 "duk_js_compiler.c"
static void duk__expr(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags) {
 duk_hthread *thr = comp_ctx->thr;
 duk_ivalue tmp_alloc;
 duk_ivalue *tmp = &tmp_alloc;
 duk_small_uint_t rbp;

 do { do { } while (0); duk__comp_recursion_increase((comp_ctx)); } while (0);

 duk_require_stack(thr, 16);


 rbp = rbp_flags & 0xff;

 do { } while (0)



                                                              ;

 do { void *duk__dst = (&tmp_alloc); duk_size_t duk__len = (sizeof(tmp_alloc)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 tmp->x1.valstack_idx = duk_get_top(thr);
 tmp->x2.valstack_idx = tmp->x1.valstack_idx + 1;
 duk_push_undefined(thr);
 duk_push_undefined(thr);
# 4950 "duk_js_compiler.c"
 if (comp_ctx->curr_token.t == 56 || comp_ctx->curr_token.t == 54) {

  do { } while (0);
  if (!(rbp_flags & (1 << 9))) {
   do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 4954; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("empty expression not allowed"))); } while (0); } while (0);
   do { return; } while (0);
  }
  duk_push_undefined(thr);
  duk__ivalue_plain_fromstack(comp_ctx, res);
  goto cleanup;
 }

 duk__advance(comp_ctx);
 duk__expr_nud(comp_ctx, res);
 while (rbp < duk__expr_lbp(comp_ctx)) {
  duk__advance(comp_ctx);
  duk__expr_led(comp_ctx, res, tmp);
  duk__copy_ivalue(comp_ctx, tmp, res);
 }

cleanup:


 duk_pop_2(thr);

 do { do { } while (0); duk__comp_recursion_decrease((comp_ctx)); } while (0);
}

static void duk__exprtop(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags) {
 duk_hthread *thr = comp_ctx->thr;




 comp_ctx->curr_func.nud_count = 0;
 comp_ctx->curr_func.led_count = 0;
 comp_ctx->curr_func.paren_level = 0;
 comp_ctx->curr_func.expr_lhs = 1;
 comp_ctx->curr_func.allow_in = (rbp_flags & (1 << 8) ? 0 : 1);

 duk__expr(comp_ctx, res, rbp_flags);

 if (!(rbp_flags & (1 << 9)) && duk__expr_is_empty(comp_ctx)) {
  do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 4993; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("empty expression not allowed"))); } while (0); } while (0);
  do { return; } while (0);
 }
}
# 5018 "duk_js_compiler.c"
static void duk__expr_toforcedreg(duk_compiler_ctx *comp_ctx,
                                     duk_ivalue *res,
                                     duk_small_uint_t rbp_flags,
                                     duk_regconst_t forced_reg) {
 do { } while (0);
 duk__expr(comp_ctx, res, rbp_flags);
 duk__ivalue_toforcedreg(comp_ctx, res, forced_reg);
}

static duk_regconst_t duk__expr_toregconst(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags) {
 duk__expr(comp_ctx, res, rbp_flags);
 return duk__ivalue_toregconst(comp_ctx, res);
}
# 5039 "duk_js_compiler.c"
static void duk__expr_toplain(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags) {
 duk__expr(comp_ctx, res, rbp_flags);
 duk__ivalue_toplain(comp_ctx, res);
}

static void duk__expr_toplain_ignore(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags) {
 duk__expr(comp_ctx, res, rbp_flags);
 duk__ivalue_toplain_ignore(comp_ctx, res);
}

static duk_regconst_t duk__exprtop_toreg(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags) {
 duk__exprtop(comp_ctx, res, rbp_flags);
 return duk__ivalue_toreg(comp_ctx, res);
}
# 5061 "duk_js_compiler.c"
static void duk__exprtop_toforcedreg(duk_compiler_ctx *comp_ctx,
                                        duk_ivalue *res,
                                        duk_small_uint_t rbp_flags,
                                        duk_regconst_t forced_reg) {
 do { } while (0);
 duk__exprtop(comp_ctx, res, rbp_flags);
 duk__ivalue_toforcedreg(comp_ctx, res, forced_reg);
}

static duk_regconst_t duk__exprtop_toregconst(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t rbp_flags) {
 duk__exprtop(comp_ctx, res, rbp_flags);
 return duk__ivalue_toregconst(comp_ctx, res);
}
# 5118 "duk_js_compiler.c"
static void duk__parse_var_decl(duk_compiler_ctx *comp_ctx,
                                   duk_ivalue *res,
                                   duk_small_uint_t expr_flags,
                                   duk_regconst_t *out_reg_varbind,
                                   duk_regconst_t *out_rc_varname) {
 duk_hthread *thr = comp_ctx->thr;
 duk_hstring *h_varname;
 duk_regconst_t reg_varbind;
 duk_regconst_t rc_varname;




 if (comp_ctx->curr_token.t != 1) {
  goto syntax_error;
 }
 h_varname = comp_ctx->curr_token.str1;

 do { } while (0);


 if (duk__hstring_is_eval_or_arguments_in_strict_mode(comp_ctx, h_varname)) {
  goto syntax_error;
 }


 if (comp_ctx->curr_func.in_scanning) {
  duk_uarridx_t n;
  do { } while (0);
  n = (duk_uarridx_t) duk_get_length(thr, comp_ctx->curr_func.decls_idx);
  duk_push_hstring(thr, h_varname);
  duk_put_prop_index(thr, comp_ctx->curr_func.decls_idx, n);
  duk_push_int(thr, 0 + (0 << 8));
  duk_put_prop_index(thr, comp_ctx->curr_func.decls_idx, n + 1);
 }

 duk_push_hstring(thr, h_varname);


 duk_dup_top(thr);
 (void) duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname);

 duk__advance(comp_ctx);

 if (comp_ctx->curr_token.t == 86) {
  duk__advance(comp_ctx);

  do { } while (0)


                                          ;

  duk__exprtop(comp_ctx, res, 6 | expr_flags );

  if (reg_varbind >= 0) {
   duk__ivalue_toforcedreg(comp_ctx, res, reg_varbind);
  } else {
   duk_regconst_t reg_val;
   reg_val = duk__ivalue_toreg(comp_ctx, res);
   duk__emit_a_bc(comp_ctx, 155 | (1 << 11), reg_val, rc_varname);
  }
 } else {
  if (expr_flags & (1 << 10)) {

   goto syntax_error;
  }
 }

 duk_pop(thr);

 *out_rc_varname = rc_varname;
 *out_reg_varbind = reg_varbind;

 return;

syntax_error:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 5194; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid variable declaration"))); } while (0); } while (0);
 do { return; } while (0);
}

static void duk__parse_var_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_small_uint_t expr_flags) {
 duk_regconst_t reg_varbind;
 duk_regconst_t rc_varname;

 duk__advance(comp_ctx);

 for (;;) {

  duk__parse_var_decl(comp_ctx, res, 0 | expr_flags, &reg_varbind, &rc_varname);

  if (comp_ctx->curr_token.t != 57) {
   break;
  }
  duk__advance(comp_ctx);
 }
}

static void duk__parse_for_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_int_t pc_label_site) {
 duk_hthread *thr = comp_ctx->thr;
 duk_int_t pc_v34_lhs;
 duk_regconst_t temp_reset;
 duk_regconst_t reg_temps;

 do { } while (0);







 reg_temps = duk__alloctemps((comp_ctx), (2));

 temp_reset = ((comp_ctx)->curr_func.temp_next);
# 5248 "duk_js_compiler.c"
 duk__advance(comp_ctx);
 duk__advance_expect(comp_ctx, 53);

 do { } while (0);





 if (comp_ctx->curr_token.t == 24) {




  duk_regconst_t reg_varbind;
  duk_regconst_t rc_varname;

  duk__advance(comp_ctx);
  duk__parse_var_decl(comp_ctx, res, (1 << 8), &reg_varbind, &rc_varname);
  ((comp_ctx)->curr_func.temp_next = (temp_reset));

  if (comp_ctx->curr_token.t == 15) {




   do { } while (0);
   pc_v34_lhs = duk__get_current_pc(comp_ctx);
   if (reg_varbind >= 0) {
    duk__emit_a_bc(comp_ctx, 0, reg_varbind, reg_temps + 0);
   } else {
    duk__emit_a_bc(comp_ctx, 155 | (1 << 11), reg_temps + 0, rc_varname);
   }
   goto parse_3_or_4;
  } else {




   do { } while (0)
                                                                                                              ;
   for (;;) {

    if (comp_ctx->curr_token.t != 57) {
     break;
    }
    do { } while (0);

    duk__advance(comp_ctx);
    duk__parse_var_decl(comp_ctx, res, (1 << 8), &reg_varbind, &rc_varname);
   }
   goto parse_1_or_2;
  }
 } else {




  pc_v34_lhs = duk__get_current_pc(comp_ctx);






  duk__exprtop(comp_ctx,
               res,
               4 | (1 << 8) |
                   (1 << 9) );
  if (comp_ctx->curr_token.t == 15) {





   do { } while (0);
   if (duk__expr_is_empty(comp_ctx)) {
    goto syntax_error;
   }

   if (res->t == 4) {
    duk_regconst_t reg_varbind;
    duk_regconst_t rc_varname;

    duk_dup(thr, res->x1.valstack_idx);
    if (duk__lookup_lhs(comp_ctx, &reg_varbind, &rc_varname)) {
     duk__emit_a_bc(comp_ctx, 0, reg_varbind, reg_temps + 0);
    } else {
     duk__emit_a_bc(comp_ctx,
                    155 | (1 << 11),
                    reg_temps + 0,
                    rc_varname);
    }
   } else if (res->t == 3) {



    duk_regconst_t reg_obj;
    duk_regconst_t rc_key;
    reg_obj = duk__ispec_toregconst_raw(comp_ctx,
                                        &res->x1,
                                        -1 ,
                                        0 );
    rc_key = duk__ispec_toregconst_raw(comp_ctx,
                                       &res->x2,
                                       -1 ,
                                       (1 << 0) );
    duk__emit_a_b_c(comp_ctx,
                    112 | (1 << 11) | (1 << 14),
                    reg_obj,
                    rc_key,
                    reg_temps + 0);
   } else {
    duk__ivalue_toplain_ignore(comp_ctx, res);
    duk__emit_op_only(comp_ctx, 170);
   }
   goto parse_3_or_4;
  } else {




   do { } while (0)
                                                                                                     ;
   duk__ivalue_toplain_ignore(comp_ctx, res);
   goto parse_1_or_2;
  }
 }

parse_1_or_2:







 {
  duk_regconst_t rc_cond;
  duk_int_t pc_l1, pc_l2, pc_l3, pc_l4;
  duk_int_t pc_jumpto_l3, pc_jumpto_l4;
  duk_bool_t expr_c_empty;

  do { } while (0);


  temp_reset = reg_temps + 0;
  ((comp_ctx)->curr_func.temp_next = (temp_reset));

  duk__advance_expect(comp_ctx, 56);

  pc_l1 = duk__get_current_pc(comp_ctx);
  duk__exprtop(comp_ctx, res, 4 | (1 << 9) );
  if (duk__expr_is_empty(comp_ctx)) {

   pc_jumpto_l3 = duk__emit_jump_empty(comp_ctx);
   pc_jumpto_l4 = -1;
  } else {
   rc_cond = duk__ivalue_toregconst(comp_ctx, res);
   duk__emit_if_false_skip(comp_ctx, rc_cond);
   pc_jumpto_l3 = duk__emit_jump_empty(comp_ctx);
   pc_jumpto_l4 = duk__emit_jump_empty(comp_ctx);
  }
  ((comp_ctx)->curr_func.temp_next = (temp_reset));

  duk__advance_expect(comp_ctx, 56);

  pc_l2 = duk__get_current_pc(comp_ctx);
  duk__exprtop(comp_ctx, res, 4 | (1 << 9) );
  if (duk__expr_is_empty(comp_ctx)) {

   expr_c_empty = 1;

  } else {
   duk__ivalue_toplain_ignore(comp_ctx, res);
   expr_c_empty = 0;
   duk__emit_jump(comp_ctx, pc_l1);
  }
  ((comp_ctx)->curr_func.temp_next = (temp_reset));

  comp_ctx->curr_func.allow_regexp_in_adv = 1;
  duk__advance_expect(comp_ctx, 54);

  pc_l3 = duk__get_current_pc(comp_ctx);
  duk__parse_stmt(comp_ctx, res, 0 );
  if (expr_c_empty) {
   duk__emit_jump(comp_ctx, pc_l1);
  } else {
   duk__emit_jump(comp_ctx, pc_l2);
  }


  pc_l4 = duk__get_current_pc(comp_ctx);

  do { } while (0)
# 5451 "duk_js_compiler.c"
                                     ;

  duk__patch_jump(comp_ctx, pc_jumpto_l3, pc_l3);
  duk__patch_jump(comp_ctx, pc_jumpto_l4, pc_l4);
  duk__patch_jump(comp_ctx, pc_label_site + 1, pc_l4);
  duk__patch_jump(comp_ctx, pc_label_site + 2, expr_c_empty ? pc_l1 : pc_l2);
 }
 goto finished;

parse_3_or_4:
# 5479 "duk_js_compiler.c"
 {
  duk_int_t pc_l1, pc_l2, pc_l3, pc_l4, pc_l5;
  duk_int_t pc_jumpto_l2, pc_jumpto_l3, pc_jumpto_l4, pc_jumpto_l5;
  duk_regconst_t reg_target;

  do { } while (0);

  ((comp_ctx)->curr_func.temp_next = (temp_reset));
# 5495 "duk_js_compiler.c"
  duk__insert_jump_entry(comp_ctx, pc_v34_lhs);
  pc_jumpto_l2 = pc_v34_lhs;
  pc_l1 = pc_v34_lhs + 1;





  pc_jumpto_l3 = duk__emit_jump_empty(comp_ctx);

  duk__advance(comp_ctx);







  pc_l2 = duk__get_current_pc(comp_ctx);
  reg_target = duk__exprtop_toreg(comp_ctx, res, 4 );
  duk__emit_b_c(comp_ctx, 201 | (1 << 12), reg_temps + 1, reg_target);
  pc_jumpto_l4 = duk__emit_jump_empty(comp_ctx);
  ((comp_ctx)->curr_func.temp_next = (temp_reset));

  comp_ctx->curr_func.allow_regexp_in_adv = 1;
  duk__advance_expect(comp_ctx, 54);

  pc_l3 = duk__get_current_pc(comp_ctx);
  duk__parse_stmt(comp_ctx, res, 0 );
# 5532 "duk_js_compiler.c"
  pc_l4 = duk__get_current_pc(comp_ctx);
  duk__emit_b_c(comp_ctx,
                202 | (1 << 12) | (1 << 15),
                reg_temps + 0,
                reg_temps + 1);
  pc_jumpto_l5 = comp_ctx->emit_jumpslot_pc;
  duk__emit_jump(comp_ctx, pc_l1);

  pc_l5 = duk__get_current_pc(comp_ctx);






  do { } while (0)
# 5561 "duk_js_compiler.c"
                                     ;

  duk__patch_jump(comp_ctx, pc_jumpto_l2, pc_l2);
  duk__patch_jump(comp_ctx, pc_jumpto_l3, pc_l3);
  duk__patch_jump(comp_ctx, pc_jumpto_l4, pc_l4);
  duk__patch_jump(comp_ctx, pc_jumpto_l5, pc_l5);
  duk__patch_jump(comp_ctx, pc_label_site + 1, pc_l5);
  duk__patch_jump(comp_ctx, pc_label_site + 2, pc_l4);
 }
 goto finished;

finished:
 do { } while (0);
 return;

syntax_error:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 5577; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid for statement"))); } while (0); } while (0);
 do { return; } while (0);
}

static void duk__parse_switch_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_int_t pc_label_site) {
 duk_hthread *thr = comp_ctx->thr;
 duk_regconst_t temp_at_loop;
 duk_regconst_t rc_switch;
 duk_regconst_t rc_case;
 duk_regconst_t reg_temp;
 duk_int_t pc_prevcase = -1;
 duk_int_t pc_prevstmt = -1;
 duk_int_t pc_default = -1;
# 5617 "duk_js_compiler.c"
 duk__advance(comp_ctx);
 duk__advance_expect(comp_ctx, 53);
 rc_switch = duk__exprtop_toregconst(comp_ctx, res, 4 );
 duk__advance_expect(comp_ctx, 54);
 duk__advance_expect(comp_ctx, 49);

 do { } while (0);

 temp_at_loop = ((comp_ctx)->curr_func.temp_next);

 for (;;) {
  duk_int_t num_stmts;
  duk_small_uint_t tok;


  ((comp_ctx)->curr_func.temp_next = (temp_at_loop));

  if (comp_ctx->curr_token.t == 50) {
   break;
  }





  if (comp_ctx->curr_token.t == 3) {







   duk__patch_jump_here(comp_ctx, pc_prevcase);



   duk__advance(comp_ctx);
   rc_case = duk__exprtop_toregconst(comp_ctx, res, 4 );
   duk__advance_expect(comp_ctx, 85);

   reg_temp = duk__alloctemp((comp_ctx));
   duk__emit_a_b_c(comp_ctx, 24 | (1 << 14), reg_temp, rc_switch, rc_case);
   duk__emit_if_true_skip(comp_ctx, reg_temp);


   pc_prevcase = duk__emit_jump_empty(comp_ctx);


  } else if (comp_ctx->curr_token.t == 7) {




   if (pc_default >= 0) {
    goto syntax_error;
   }
   duk__advance(comp_ctx);
   duk__advance_expect(comp_ctx, 85);





   if (pc_prevcase < 0) {
    do { } while (0);
    pc_prevcase = duk__emit_jump_empty(comp_ctx);
   }


   pc_default = -2;
  } else {

   goto syntax_error;
  }
# 5703 "duk_js_compiler.c"
  num_stmts = 0;
  if (pc_default == -2) {
   pc_default = duk__get_current_pc(comp_ctx);
  }





  duk__patch_jump_here(comp_ctx, pc_prevstmt);



  for (;;) {
   tok = comp_ctx->curr_token.t;
   if (tok == 3 || tok == 7 || tok == 50) {
    break;
   }
   num_stmts++;
   duk__parse_stmt(comp_ctx, res, 0 );
  }


  pc_prevstmt = duk__emit_jump_empty(comp_ctx);
# 5737 "duk_js_compiler.c"
 }

 do { } while (0);
 comp_ctx->curr_func.allow_regexp_in_adv = 1;
 duk__advance(comp_ctx);




 if (pc_default >= 0) {

  duk__patch_jump(comp_ctx, pc_prevcase, pc_default);
 } else {



  duk__patch_jump_here(comp_ctx, pc_prevcase);
 }




 duk__patch_jump_here(comp_ctx, pc_prevstmt);


 duk__patch_jump_here(comp_ctx, pc_label_site + 1);







 return;

syntax_error:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 5773; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid switch statement"))); } while (0); } while (0);
 do { return; } while (0);
}

static void duk__parse_if_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 duk_regconst_t temp_reset;
 duk_regconst_t rc_cond;
 duk_int_t pc_jump_false;

 do { } while (0);

 temp_reset = ((comp_ctx)->curr_func.temp_next);

 duk__advance(comp_ctx);
 duk__advance_expect(comp_ctx, 53);

 rc_cond = duk__exprtop_toregconst(comp_ctx, res, 4 );
 duk__emit_if_true_skip(comp_ctx, rc_cond);
 pc_jump_false = duk__emit_jump_empty(comp_ctx);
 ((comp_ctx)->curr_func.temp_next = (temp_reset));

 comp_ctx->curr_func.allow_regexp_in_adv = 1;
 duk__advance_expect(comp_ctx, 54);

 duk__parse_stmt(comp_ctx, res, 0 );





 if (comp_ctx->curr_token.t == 10) {
  duk_int_t pc_jump_end;

  do { } while (0);

  duk__advance(comp_ctx);

  pc_jump_end = duk__emit_jump_empty(comp_ctx);
  duk__patch_jump_here(comp_ctx, pc_jump_false);

  duk__parse_stmt(comp_ctx, res, 0 );

  duk__patch_jump_here(comp_ctx, pc_jump_end);
 } else {
  do { } while (0);

  duk__patch_jump_here(comp_ctx, pc_jump_false);
 }

 do { } while (0);
}

static void duk__parse_do_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_int_t pc_label_site) {
 duk_regconst_t rc_cond;
 duk_int_t pc_start;

 do { } while (0);

 duk__advance(comp_ctx);

 pc_start = duk__get_current_pc(comp_ctx);
 duk__parse_stmt(comp_ctx, res, 0 );
 duk__patch_jump_here(comp_ctx, pc_label_site + 2);

 duk__advance_expect(comp_ctx, 27);
 duk__advance_expect(comp_ctx, 53);

 rc_cond = duk__exprtop_toregconst(comp_ctx, res, 4 );
 duk__emit_if_false_skip(comp_ctx, rc_cond);
 duk__emit_jump(comp_ctx, pc_start);


 comp_ctx->curr_func.allow_regexp_in_adv = 1;
 duk__advance_expect(comp_ctx, 54);

 duk__patch_jump_here(comp_ctx, pc_label_site + 1);

 do { } while (0);
}

static void duk__parse_while_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_int_t pc_label_site) {
 duk_regconst_t temp_reset;
 duk_regconst_t rc_cond;
 duk_int_t pc_start;
 duk_int_t pc_jump_false;

 do { } while (0);

 temp_reset = ((comp_ctx)->curr_func.temp_next);

 duk__advance(comp_ctx);

 duk__advance_expect(comp_ctx, 53);

 pc_start = duk__get_current_pc(comp_ctx);
 duk__patch_jump_here(comp_ctx, pc_label_site + 2);

 rc_cond = duk__exprtop_toregconst(comp_ctx, res, 4 );
 duk__emit_if_true_skip(comp_ctx, rc_cond);
 pc_jump_false = duk__emit_jump_empty(comp_ctx);
 ((comp_ctx)->curr_func.temp_next = (temp_reset));

 comp_ctx->curr_func.allow_regexp_in_adv = 1;
 duk__advance_expect(comp_ctx, 54);

 duk__parse_stmt(comp_ctx, res, 0 );
 duk__emit_jump(comp_ctx, pc_start);

 duk__patch_jump_here(comp_ctx, pc_jump_false);
 duk__patch_jump_here(comp_ctx, pc_label_site + 1);

 do { } while (0);
}

static void duk__parse_break_or_continue_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 duk_hthread *thr = comp_ctx->thr;
 duk_bool_t is_break = (comp_ctx->curr_token.t == 2);
 duk_int_t label_id;
 duk_int_t label_catch_depth;
 duk_int_t label_pc;
 duk_bool_t label_is_closest;

 do { (void) (res); } while (0);

 duk__advance(comp_ctx);

 if (comp_ctx->curr_token.t == 56 ||
     comp_ctx->curr_token.lineterm ||
     comp_ctx->curr_token.allow_auto_semi) {


  duk__lookup_active_label(comp_ctx,
                           (((thr))->strs[(15)]),
                           is_break,
                           &label_id,
                           &label_catch_depth,
                           &label_pc,
                           &label_is_closest);
 } else if (comp_ctx->curr_token.t == 1) {

  do { } while (0);
  duk__lookup_active_label(comp_ctx,
                           comp_ctx->curr_token.str1,
                           is_break,
                           &label_id,
                           &label_catch_depth,
                           &label_pc,
                           &label_is_closest);
  duk__advance(comp_ctx);
 } else {
  do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 5923; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid break/continue label"))); } while (0); } while (0);
  do { return; } while (0);
 }







 if (label_catch_depth == comp_ctx->curr_func.catch_depth && label_is_closest) {
  do { } while (0)






                                                               ;

  duk__emit_jump(comp_ctx, label_pc + (is_break ? 1 : 2));
 } else {
  do { } while (0)






                                                               ;

  duk__emit_bc(comp_ctx, is_break ? 163 : 164, (duk_regconst_t) label_id);
 }
}

static void duk__parse_return_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 duk_hthread *thr = comp_ctx->thr;
 duk_regconst_t rc_val;

 duk__advance(comp_ctx);




 if (!comp_ctx->curr_func.is_function) {
  do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 5968; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid return"))); } while (0); } while (0);
  do { return; } while (0);
 }

 if (comp_ctx->curr_token.t == 56 ||
     comp_ctx->curr_token.lineterm ||
     comp_ctx->curr_token.allow_auto_semi) {
  do { } while (0);
  duk__emit_op_only(comp_ctx, 158);
 } else {
  duk_int_t pc_before_expr;
  duk_int_t pc_after_expr;

  do { } while (0);

  do { (void) (pc_before_expr); } while (0);
  do { (void) (pc_after_expr); } while (0);

  pc_before_expr = duk__get_current_pc(comp_ctx);
  rc_val = duk__exprtop_toregconst(comp_ctx, res, 4 );
  pc_after_expr = duk__get_current_pc(comp_ctx);
# 6026 "duk_js_compiler.c"
  if (comp_ctx->curr_func.catch_depth == 0 &&
      pc_after_expr > pc_before_expr) {
   duk_compiler_instr *instr;
   duk_instr_t ins;
   duk_small_uint_t op;

   instr = duk__get_instr_ptr(comp_ctx, pc_after_expr - 1);
   do { } while (0);

   ins = instr->ins;
   op = (duk_small_uint_t) ((ins) &0xffUL);
   if ((op & ~0x0fU) == 176 && ((duk_int32_t) (rc_val) >= (duk_int32_t) ((comp_ctx)->curr_func.temp_first)) ) {
    do { } while (0)


                                                  ;
    ins |= ((duk_instr_t) ((1U << 0)));
    instr->ins = ins;
   }
  }


  if (((rc_val) >= 0)) {
   duk__emit_bc(comp_ctx, 157, rc_val);
  } else {
   rc_val = ((rc_val) & ~
# 6051 "duk_js_compiler.c" 3 4
           (-2147483647-1)
# 6051 "duk_js_compiler.c"
           );
   if (duk__const_needs_refcount(comp_ctx, rc_val)) {
    duk__emit_bc(comp_ctx, 159, rc_val);
   } else {
    duk__emit_bc(comp_ctx, 160, rc_val);
   }
  }
 }
}

static void duk__parse_throw_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 duk_regconst_t reg_val;

 duk__advance(comp_ctx);



 if (comp_ctx->curr_token.lineterm) {
  do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 6069; do { } while (0); do { } while (0); duk_err_handle_error(((comp_ctx->thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid throw"))); } while (0); } while (0);
  do { return; } while (0);
 }

 reg_val = duk__exprtop_toreg(comp_ctx, res, 4 );
 duk__emit_bc(comp_ctx, 169, reg_val);
}

static void duk__parse_try_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 duk_hthread *thr = comp_ctx->thr;
 duk_regconst_t reg_catch;
 duk_regconst_t rc_varname = 0;
 duk_small_uint_t trycatch_flags = 0;
 duk_int_t pc_ldconst = -1;
 duk_int_t pc_trycatch = -1;
 duk_int_t pc_catch = -1;
 duk_int_t pc_finally = -1;

 do { (void) (res); } while (0);
# 6104 "duk_js_compiler.c"
 comp_ctx->curr_func.catch_depth++;

 duk__advance(comp_ctx);

 reg_catch = duk__alloctemps((comp_ctx), (2));






 pc_ldconst = duk__get_current_pc(comp_ctx);
 duk__emit_a_bc(comp_ctx, 3, reg_catch, 0 );

 pc_trycatch = duk__get_current_pc(comp_ctx);
 duk__emit_invalid(comp_ctx);
 duk__emit_invalid(comp_ctx);
 duk__emit_invalid(comp_ctx);


 duk__advance_expect(comp_ctx, 49);
 duk__parse_stmts(comp_ctx, 0 , 0 , 1 );

 duk__emit_op_only(comp_ctx, 166);

 if (comp_ctx->curr_token.t == 4) {
# 6149 "duk_js_compiler.c"
  duk_hstring *h_var;
  duk_int_t varmap_value;

  do { } while (0);

  trycatch_flags |= (1U << 0);

  pc_catch = duk__get_current_pc(comp_ctx);

  duk__advance(comp_ctx);
  duk__advance_expect(comp_ctx, 53);

  if (comp_ctx->curr_token.t != 1) {

   goto syntax_error;
  }
  h_var = comp_ctx->curr_token.str1;
  do { } while (0);

  duk_push_hstring(thr, h_var);

  if (comp_ctx->curr_func.is_strict &&
      ((h_var == (((thr))->strs[(33)])) || (h_var == (((thr))->strs[(67)])))) {
   do { } while (0);
   goto syntax_error;
  }

  duk_dup_top(thr);
  rc_varname = duk__getconst(comp_ctx);
  do { } while (0);

  duk__advance(comp_ctx);
  duk__advance_expect(comp_ctx, 54);

  duk__advance_expect(comp_ctx, 49);

  do { } while (0)
                                                                                       ;

  duk_dup_top(thr);
  duk_get_prop(thr, comp_ctx->curr_func.varmap_idx);
  if (duk_is_undefined(thr, -1)) {
   varmap_value = -2;
  } else if (duk_is_null(thr, -1)) {
   varmap_value = -1;
  } else {
   do { } while (0);
   varmap_value = duk_get_int(thr, -1);
   do { } while (0);
  }
  duk_pop(thr);
# 6209 "duk_js_compiler.c"
  duk_dup_top(thr);
  duk_push_null(thr);
  duk_put_prop(thr, comp_ctx->curr_func.varmap_idx);

  duk__emit_a_bc(comp_ctx,
                 155 | (1 << 11),
                 reg_catch + 0 ,
                 rc_varname );

  do { } while (0)
                                                                                       ;

  duk__parse_stmts(comp_ctx, 0 , 0 , 1 );


  if (varmap_value == -2) {

   duk_del_prop(thr, comp_ctx->curr_func.varmap_idx);
  } else {
   if (varmap_value == -1) {
    duk_push_null(thr);
   } else {
    do { } while (0);
    duk_push_int(thr, varmap_value);
   }
   duk_put_prop(thr, comp_ctx->curr_func.varmap_idx);
  }


  do { } while (0)
                                                                                       ;

  duk__emit_op_only(comp_ctx, 167);







  trycatch_flags |= (1U << 2);

  do { } while (0);
 }

 if (comp_ctx->curr_token.t == 11) {
  trycatch_flags |= (1U << 1);

  pc_finally = duk__get_current_pc(comp_ctx);

  duk__advance(comp_ctx);

  duk__advance_expect(comp_ctx, 49);
  duk__parse_stmts(comp_ctx, 0 , 0 , 1 );

  duk__emit_abc(comp_ctx, 168, reg_catch);
 }

 if (!(trycatch_flags & (1U << 0)) && !(trycatch_flags & (1U << 1))) {

  goto syntax_error;
 }






 duk__patch_trycatch(comp_ctx, pc_ldconst, pc_trycatch, reg_catch, rc_varname, trycatch_flags);

 if (trycatch_flags & (1U << 0)) {
  do { } while (0);
  duk__patch_jump(comp_ctx, pc_trycatch + 1, pc_catch);
 }

 if (trycatch_flags & (1U << 1)) {
  do { } while (0);
  duk__patch_jump(comp_ctx, pc_trycatch + 2, pc_finally);
 } else {

  duk__patch_jump_here(comp_ctx, pc_trycatch + 2);
 }

 comp_ctx->curr_func.catch_depth--;
 return;

syntax_error:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 6296; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid try"))); } while (0); } while (0);
 do { return; } while (0);
}

static void duk__parse_with_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res) {
 duk_int_t pc_trycatch;
 duk_int_t pc_finished;
 duk_regconst_t reg_catch;
 duk_small_uint_t trycatch_flags;

 if (comp_ctx->curr_func.is_strict) {
  do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 6307; do { } while (0); do { } while (0); duk_err_handle_error(((comp_ctx->thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("with in strict mode"))); } while (0); } while (0);
  do { return; } while (0);
 }

 comp_ctx->curr_func.catch_depth++;

 duk__advance(comp_ctx);

 reg_catch = duk__alloctemps((comp_ctx), (2));

 duk__advance_expect(comp_ctx, 53);
 duk__exprtop_toforcedreg(comp_ctx, res, 4 , reg_catch);
 comp_ctx->curr_func.allow_regexp_in_adv = 1;
 duk__advance_expect(comp_ctx, 54);

 pc_trycatch = duk__get_current_pc(comp_ctx);
 trycatch_flags = (1U << 3);
 duk__emit_a_bc(comp_ctx,
                165 | (1 << 8),
                (duk_regconst_t) trycatch_flags ,
                reg_catch );
 duk__emit_invalid(comp_ctx);
 duk__emit_invalid(comp_ctx);

 duk__parse_stmt(comp_ctx, res, 0 );
 duk__emit_op_only(comp_ctx, 166);

 pc_finished = duk__get_current_pc(comp_ctx);

 duk__patch_jump(comp_ctx, pc_trycatch + 2, pc_finished);

 comp_ctx->curr_func.catch_depth--;
}

static duk_int_t duk__stmt_label_site(duk_compiler_ctx *comp_ctx, duk_int_t label_id) {

 if (label_id >= 0) {
  return label_id;
 }

 label_id = comp_ctx->curr_func.label_next++;
 do { } while (0);

 duk__emit_bc(comp_ctx, 161, (duk_regconst_t) label_id);
 duk__emit_invalid(comp_ctx);
 duk__emit_invalid(comp_ctx);

 return label_id;
}






static void duk__parse_stmt(duk_compiler_ctx *comp_ctx, duk_ivalue *res, duk_bool_t allow_source_elem) {
 duk_hthread *thr = comp_ctx->thr;
 duk_bool_t dir_prol_at_entry;
 duk_regconst_t temp_at_entry;
 duk_size_t labels_len_at_entry;
 duk_int_t pc_at_entry;
 duk_int_t stmt_id;
 duk_small_uint_t stmt_flags = 0;
 duk_int_t label_id = -1;
 duk_small_uint_t tok;
 duk_bool_t test_func_decl;

 do { do { } while (0); duk__comp_recursion_increase((comp_ctx)); } while (0);

 temp_at_entry = ((comp_ctx)->curr_func.temp_next);
 pc_at_entry = duk__get_current_pc(comp_ctx);
 labels_len_at_entry = duk_get_length(thr, comp_ctx->curr_func.labelnames_idx);
 stmt_id = comp_ctx->curr_func.stmt_next++;
 dir_prol_at_entry = comp_ctx->curr_func.in_directive_prologue;

 do { (void) (stmt_id); } while (0);

 do { } while (0)






                                                              ;






 comp_ctx->curr_func.in_directive_prologue = 0;

retry_parse:

 do { } while (0)



                                                              ;






 tok = comp_ctx->curr_token.t;
 if (tok == 12 || tok == 9 || tok == 27 || tok == 19) {
  do { } while (0);

  label_id = duk__stmt_label_site(comp_ctx, label_id);
  duk__add_label(comp_ctx, (((thr))->strs[(15)]), pc_at_entry , label_id);
 }





 switch (comp_ctx->curr_token.t) {
 case 13: {
# 6439 "duk_js_compiler.c"
  test_func_decl = allow_source_elem;





  test_func_decl = test_func_decl || !comp_ctx->curr_func.is_strict || label_id < 0;


  if (test_func_decl) {
# 6457 "duk_js_compiler.c"
   duk_int_t fnum;




   do { } while (0);





   duk__advance(comp_ctx);
   fnum = duk__parse_func_like_fnum(comp_ctx, (1 << 0) | (1 << 3));





   if (comp_ctx->curr_func.in_scanning) {
    duk_uarridx_t n;




    do { } while (0)

                                      ;
    n = (duk_uarridx_t) duk_get_length(thr, comp_ctx->curr_func.decls_idx);

    duk_put_prop_index(thr, comp_ctx->curr_func.decls_idx, n);
    duk_push_int(thr, (duk_int_t) (1 + (fnum << 8)));
    duk_put_prop_index(thr, comp_ctx->curr_func.decls_idx, n + 1);
   } else {



   }


   stmt_flags = 0;
   break;
  } else {
   do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 6499; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("function statement not allowed"))); } while (0); } while (0);
   do { return; } while (0);
  }
  break;
 }
 case 49: {
  do { } while (0);
  duk__advance(comp_ctx);
  duk__parse_stmts(comp_ctx, 0 , 0 , 1 );

  if (label_id >= 0) {
   duk__patch_jump_here(comp_ctx, pc_at_entry + 1);
  }
  stmt_flags = 0;
  break;
 }
 case 25: {
  do { } while (0);
  duk__parse_var_stmt(comp_ctx, res, (1 << 10) );
  stmt_flags = (1 << 1);
  break;
 }
 case 24: {
  do { } while (0);
  duk__parse_var_stmt(comp_ctx, res, 0 );
  stmt_flags = (1 << 1);
  break;
 }
 case 56: {

  do { } while (0);
  stmt_flags = (1 << 1);
  break;
 }
 case 14: {
  do { } while (0);
  duk__parse_if_stmt(comp_ctx, res);
  if (label_id >= 0) {
   duk__patch_jump_here(comp_ctx, pc_at_entry + 1);
  }
  stmt_flags = 0;
  break;
 }
 case 9: {
# 6552 "duk_js_compiler.c"
  do { } while (0);
  do { } while (0);
  duk__update_label_flags(comp_ctx, label_id, (1U << 0) | (1U << 1));
  duk__parse_do_stmt(comp_ctx, res, pc_at_entry);
  stmt_flags = (1 << 1) | (1 << 2);
  break;
 }
 case 27: {
  do { } while (0);
  do { } while (0);
  duk__update_label_flags(comp_ctx, label_id, (1U << 0) | (1U << 1));
  duk__parse_while_stmt(comp_ctx, res, pc_at_entry);
  stmt_flags = 0;
  break;
 }
 case 12: {







  do { } while (0);
  do { } while (0);
  duk__update_label_flags(comp_ctx, label_id, (1U << 0) | (1U << 1));
  duk__parse_for_stmt(comp_ctx, res, pc_at_entry);
  stmt_flags = 0;
  break;
 }
 case 5:
 case 2: {
  do { } while (0);
  duk__parse_break_or_continue_stmt(comp_ctx, res);
  stmt_flags = (1 << 1) | (1 << 4);
  break;
 }
 case 18: {
  do { } while (0);
  duk__parse_return_stmt(comp_ctx, res);
  stmt_flags = (1 << 1) | (1 << 4);
  break;
 }
 case 28: {
  do { } while (0);
  comp_ctx->curr_func.with_depth++;
  duk__parse_with_stmt(comp_ctx, res);
  if (label_id >= 0) {
   duk__patch_jump_here(comp_ctx, pc_at_entry + 1);
  }
  comp_ctx->curr_func.with_depth--;
  stmt_flags = 0;
  break;
 }
 case 19: {




  do { } while (0);
  do { } while (0);
  duk__update_label_flags(comp_ctx, label_id, (1U << 0));
  duk__parse_switch_stmt(comp_ctx, res, pc_at_entry);
  stmt_flags = 0;
  break;
 }
 case 21: {
  do { } while (0);
  duk__parse_throw_stmt(comp_ctx, res);
  stmt_flags = (1 << 1) | (1 << 4);
  break;
 }
 case 22: {
  do { } while (0);
  duk__parse_try_stmt(comp_ctx, res);
  stmt_flags = 0;
  break;
 }
 case 6: {
  duk__advance(comp_ctx);




  do { } while (0);

  stmt_flags = (1 << 1);
  break;
 }
 default: {
# 6675 "duk_js_compiler.c"
  duk_bool_t single_token;

  do { } while (0);
  duk__exprtop(comp_ctx, res, 4 );

  single_token = (comp_ctx->curr_func.nud_count == 1 &&
                  comp_ctx->curr_func.led_count == 0);

  if (single_token && comp_ctx->prev_token.t == 1 && comp_ctx->curr_token.t == 85) {




   duk_hstring *h_lab;


   do { } while (0);
   do { } while (0);
   do { } while (0);
   h_lab = comp_ctx->prev_token.str1;
   do { } while (0);

   do { } while (0);

   duk__advance(comp_ctx);

   label_id = duk__stmt_label_site(comp_ctx, label_id);

   duk__add_label(comp_ctx, h_lab, pc_at_entry , label_id);




   allow_source_elem = 0;

   do { } while (0);
   goto retry_parse;
  }

  stmt_flags = 0;

  if (dir_prol_at_entry &&
      single_token &&
      comp_ctx->prev_token.t == 100) {



   duk_hstring *h_dir;


   do { } while (0);
   do { } while (0);
   do { } while (0);
   h_dir = comp_ctx->prev_token.str1;
   do { } while (0);

   do { } while (0);

   stmt_flags |= (1 << 3);



   if (comp_ctx->prev_token.num_escapes > 0) {
    do { } while (0)
                                                          ;
   } else {





    if (((h_dir)->blen) == 10 &&
        strcmp((const char *) ((const duk_uint8_t *) ((h_dir) + 1)), "use strict") == 0) {

     do { } while (0)

                                    ;
     comp_ctx->curr_func.is_strict = 1;



    } else if (((h_dir)->blen) == 14 &&
               strcmp((const char *) ((const duk_uint8_t *) ((h_dir) + 1)), "use duk notail") == 0) {
     do { } while (0)

                                    ;
     comp_ctx->curr_func.is_notail = 1;
    } else {
     do { } while (0)

                                               ;
    }
   }
  } else {
   do { } while (0)
                                                               ;
  }

  stmt_flags |= (1 << 0) | (1 << 1);
 }
 }
# 6797 "duk_js_compiler.c"
 if (stmt_flags & (1 << 0)) {
  duk_regconst_t reg_stmt_value = comp_ctx->curr_func.reg_stmt_value;
  if (reg_stmt_value >= 0) {
   duk__ivalue_toforcedreg(comp_ctx, res, reg_stmt_value);
  } else {
   duk__ivalue_toplain_ignore(comp_ctx, res);
  }
 } else {
  ;
 }







 if (stmt_flags & (1 << 1)) {
  if (comp_ctx->curr_token.t == 56) {
   do { } while (0);
   duk__advance(comp_ctx);
  } else {
   if (comp_ctx->curr_token.allow_auto_semi) {
    do { } while (0);
   } else if (stmt_flags & (1 << 2)) {

    do { } while (0)
                                                                               ;
   } else {
    do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 6826; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("unterminated statement"))); } while (0); } while (0);
    do { return; } while (0);
   }
  }
 } else {
  do { } while (0);
 }





 if (stmt_flags & (1 << 3)) {
  do { } while (0);
  comp_ctx->curr_func.in_directive_prologue = 1;
 }
# 6850 "duk_js_compiler.c"
 if (label_id >= 0) {
  duk__emit_bc(comp_ctx, 162, (duk_regconst_t) label_id);
 }

 ((comp_ctx)->curr_func.temp_next = (temp_at_entry));

 duk__reset_labels_to_length(comp_ctx, labels_len_at_entry);



 do { do { } while (0); duk__comp_recursion_decrease((comp_ctx)); } while (0);
}
# 6874 "duk_js_compiler.c"
static void duk__parse_stmts(duk_compiler_ctx *comp_ctx,
                                duk_bool_t allow_source_elem,
                                duk_bool_t expect_eof,
                                duk_bool_t regexp_after) {
 duk_hthread *thr = comp_ctx->thr;
 duk_ivalue res_alloc;
 duk_ivalue *res = &res_alloc;



 duk_require_stack(thr, 16);






 do { void *duk__dst = (&res_alloc); duk_size_t duk__len = (sizeof(res_alloc)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 res->t = 1;
 res->x1.t = 1;
 res->x1.valstack_idx = duk_get_top(thr);
 res->x2.valstack_idx = res->x1.valstack_idx + 1;
 duk_push_undefined(thr);
 duk_push_undefined(thr);



 for (;;) {


  if (expect_eof) {
   if (comp_ctx->curr_token.t == 0) {
    break;
   }
  } else {
   if (comp_ctx->curr_token.t == 50) {
    break;
   }
  }







  do { } while (0);

  duk__parse_stmt(comp_ctx, res, allow_source_elem);
 }







 if (regexp_after) {
  comp_ctx->curr_func.allow_regexp_in_adv = 1;
 }
 duk__advance(comp_ctx);



 duk_pop_2(thr);
}
# 6973 "duk_js_compiler.c"
static void duk__init_varmap_and_prologue_for_pass2(duk_compiler_ctx *comp_ctx, duk_regconst_t *out_stmt_value_reg) {
 duk_hthread *thr = comp_ctx->thr;
 duk_hstring *h_name;
 duk_bool_t configurable_bindings;
 duk_uarridx_t num_args;
 duk_uarridx_t num_decls;
 duk_regconst_t rc_name;
 duk_small_uint_t declvar_flags;
 duk_uarridx_t i;
# 6994 "duk_js_compiler.c"
 configurable_bindings = comp_ctx->curr_func.is_eval;
 do { } while (0);
# 7004 "duk_js_compiler.c"
 num_args = (duk_uarridx_t) duk_get_length(thr, comp_ctx->curr_func.argnames_idx);
 do { } while (0);


 for (i = 0; i < num_args; i++) {
  duk_get_prop_index(thr, comp_ctx->curr_func.argnames_idx, i);
  h_name = duk_known_hstring(thr, -1);

  if (comp_ctx->curr_func.is_strict) {
   if (duk__hstring_is_eval_or_arguments(comp_ctx, h_name)) {
    do { } while (0);
    goto error_argname;
   }
   duk_dup_top(thr);
   if (duk_has_prop(thr, comp_ctx->curr_func.varmap_idx)) {
    do { } while (0);
    goto error_argname;
   }
# 7032 "duk_js_compiler.c"
   if ((((&(h_name)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)) {
    goto error_argname;
   }
  }






  do { } while (0);
  duk_push_uint((thr), (duk_uint_t) (i));
  duk_put_prop(thr, comp_ctx->curr_func.varmap_idx);


 }


 duk__settemp_checkmax((comp_ctx), ((duk_regconst_t) num_args));





 if (out_stmt_value_reg) {
  *out_stmt_value_reg = duk__alloctemp((comp_ctx));
 }
 if (comp_ctx->curr_func.needs_shuffle) {
  duk_regconst_t shuffle_base = duk__alloctemps((comp_ctx), (3));
  comp_ctx->curr_func.shuffle1 = shuffle_base;
  comp_ctx->curr_func.shuffle2 = shuffle_base + 1;
  comp_ctx->curr_func.shuffle3 = shuffle_base + 2;
  do { } while (0)


                                                        ;
 }
 if (comp_ctx->curr_func.temp_next > 0x100) {
  do { } while (0);
  goto error_outofregs;
 }





 num_decls = (duk_uarridx_t) duk_get_length(thr, comp_ctx->curr_func.decls_idx);
 do { } while (0)
                                                                                                                           ;
 for (i = 0; i < num_decls; i += 2) {
  duk_int_t decl_type;
  duk_int_t fnum;

  duk_get_prop_index(thr, comp_ctx->curr_func.decls_idx, i + 1);
  decl_type = duk_to_int(thr, -1);
  fnum = decl_type >> 8;
  decl_type = decl_type & 0xff;
  duk_pop(thr);

  if (decl_type != 1) {
   continue;
  }

  duk_get_prop_index(thr, comp_ctx->curr_func.decls_idx, i);


  if (comp_ctx->curr_func.is_function) {
   duk_regconst_t reg_bind;
   duk_dup_top(thr);
   if (duk_has_prop(thr, comp_ctx->curr_func.varmap_idx)) {

    duk_dup_top(thr);
    duk_get_prop(thr, comp_ctx->curr_func.varmap_idx);
    reg_bind = duk_to_int(thr, -1);
    duk__emit_a_bc(comp_ctx, 152, reg_bind, (duk_regconst_t) fnum);
   } else {

    reg_bind = duk__alloctemp((comp_ctx));
    duk__emit_a_bc(comp_ctx, 152, reg_bind, (duk_regconst_t) fnum);
    duk_push_int(thr, (duk_int_t) reg_bind);
   }
  } else {
# 7122 "duk_js_compiler.c"
   duk_regconst_t reg_temp = duk__alloctemp((comp_ctx));
   duk_dup_top(thr);
   rc_name = duk__getconst(comp_ctx);
   duk_push_null(thr);

   duk__emit_a_bc(comp_ctx, 152, reg_temp, (duk_regconst_t) fnum);

   declvar_flags = (1U << 0) | (1U << 1) | (1U << 4);

   if (configurable_bindings) {
    declvar_flags |= (1U << 2);
   }

   duk__emit_a_b_c(comp_ctx,
                   144 | (1 << 8) | (1 << 14),
                   (duk_regconst_t) declvar_flags ,
                   rc_name ,
                   reg_temp );

   ((comp_ctx)->curr_func.temp_next = (reg_temp));
  }

  do { } while (0)

                                                           ;




  duk_put_prop(thr, comp_ctx->curr_func.varmap_idx);
 }
# 7161 "duk_js_compiler.c"
 if (duk_has_prop_stridx(thr, comp_ctx->curr_func.varmap_idx, 67)) {
  do { } while (0)
                                                                      ;
  comp_ctx->curr_func.is_arguments_shadowed = 1;
 }
# 7175 "duk_js_compiler.c"
 for (i = 0; i < num_decls; i += 2) {
  duk_int_t decl_type;

  duk_get_prop_index(thr, comp_ctx->curr_func.decls_idx, i + 1);
  decl_type = duk_to_int(thr, -1);
  decl_type = decl_type & 0xff;
  duk_pop(thr);

  if (decl_type != 0) {
   continue;
  }

  duk_get_prop_index(thr, comp_ctx->curr_func.decls_idx, i);

  if (duk_has_prop(thr, comp_ctx->curr_func.varmap_idx)) {

  } else {
   duk_get_prop_index(thr, comp_ctx->curr_func.decls_idx, i);
   h_name = duk_known_hstring(thr, -1);

   if (h_name == (((thr))->strs[(67)]) && !comp_ctx->curr_func.is_arguments_shadowed) {

    do { } while (0)

                                                                      ;
    duk_pop(thr);
    continue;
   }


   if (comp_ctx->curr_func.is_function) {
    duk_regconst_t reg_bind = duk__alloctemp((comp_ctx));

    duk_push_int(thr, (duk_int_t) reg_bind);
   } else {
    duk_dup_top(thr);
    rc_name = duk__getconst(comp_ctx);
    duk_push_null(thr);

    declvar_flags = (1U << 0) | (1U << 1);
    if (configurable_bindings) {
     declvar_flags |= (1U << 2);
    }

    duk__emit_a_b_c(comp_ctx,
                    144 | (1 << 8) | (1 << 14),
                    (duk_regconst_t) declvar_flags ,
                    rc_name ,
                    0 );
   }

   duk_put_prop(thr, comp_ctx->curr_func.varmap_idx);
  }
 }





 do { } while (0)

                                                                        ;

 do { } while (0);
 return;

error_outofregs:
 do { duk_err_range((thr), "duk_js_compiler.c", (duk_int_t) 7242, ("register limit")); } while (0);
 do { return; } while (0);

error_argname:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 7246; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid argument name"))); } while (0); } while (0);
 do { return; } while (0);
}
# 7284 "duk_js_compiler.c"
static void duk__parse_func_body(duk_compiler_ctx *comp_ctx,
                                    duk_bool_t expect_eof,
                                    duk_bool_t implicit_return_value,
                                    duk_bool_t regexp_after,
                                    duk_small_int_t expect_token) {
 duk_compiler_func *func;
 duk_hthread *thr;
 duk_regconst_t reg_stmt_value = -1;
 duk_lexer_point lex_pt;
 duk_regconst_t temp_first;
 duk_small_int_t compile_round = 1;

 do { } while (0);

 thr = comp_ctx->thr;
 do { } while (0);

 func = &comp_ctx->curr_func;
 do { } while (0);

 do { do { } while (0); duk__comp_recursion_increase((comp_ctx)); } while (0);

 duk_require_stack(thr, 16);





 duk_lexer_getpoint((&comp_ctx->lex), (&lex_pt));
# 7323 "duk_js_compiler.c"
 if (implicit_return_value) {
  reg_stmt_value = duk__alloctemp((comp_ctx));
# 7339 "duk_js_compiler.c"
 }
# 7348 "duk_js_compiler.c"
 func->in_directive_prologue = 1;
 func->in_scanning = 1;
 func->may_direct_eval = 0;
 func->id_access_arguments = 0;
 func->id_access_slow = 0;
 func->id_access_slow_own = 0;
 func->reg_stmt_value = reg_stmt_value;
# 7363 "duk_js_compiler.c"
 if (expect_token >= 0) {



  do { } while (0);
  duk__update_lineinfo_currtoken(comp_ctx);
  duk__advance_expect(comp_ctx, expect_token);
 } else {



  comp_ctx->curr_token.t = 0;
  duk__advance(comp_ctx);
 }

 do { } while (0);
 duk__parse_stmts(comp_ctx,
                  1,
                  expect_eof,
                  regexp_after);
 do { } while (0);
# 7394 "duk_js_compiler.c"
 for (;;) {
  duk_bool_t needs_shuffle_before = comp_ctx->curr_func.needs_shuffle;
  compile_round++;
# 7408 "duk_js_compiler.c"
  do { } while (0);
  duk_lexer_setpoint((&comp_ctx->lex), (&lex_pt));
  comp_ctx->curr_token.t = 0;
  comp_ctx->curr_token.start_line = 0;
  duk__advance(comp_ctx);
# 7426 "duk_js_compiler.c"
  duk__reset_func_for_pass2(comp_ctx);
  func->in_directive_prologue = 1;
  func->in_scanning = 0;



  duk__init_varmap_and_prologue_for_pass2(comp_ctx, (implicit_return_value ? &reg_stmt_value : 
# 7432 "duk_js_compiler.c" 3 4
                                                                                              ((void *)0)
# 7432 "duk_js_compiler.c"
                                                                                                  ));
  func->reg_stmt_value = reg_stmt_value;

  temp_first = ((comp_ctx)->curr_func.temp_next);

  func->temp_first = temp_first;
  func->temp_next = temp_first;
  func->stmt_next = 0;
  func->label_next = 0;


  func->id_access_arguments = 0;
  func->id_access_slow = 0;
  func->id_access_slow_own = 0;
# 7455 "duk_js_compiler.c"
  if (func->is_function && !func->is_setget && func->h_name != 
# 7455 "duk_js_compiler.c" 3 4
                                                              ((void *)0)
# 7455 "duk_js_compiler.c"
                                                                  ) {
   if (func->is_strict) {
    if (duk__hstring_is_eval_or_arguments(comp_ctx, func->h_name)) {
     do { } while (0);
     goto error_funcname;
    }
    if ((((&(func->h_name)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)) {
     do { } while (0);
     goto error_funcname;
    }
   } else {
    if ((((&(func->h_name)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0) &&
        !(((&(func->h_name)->hdr)->h_flags & ((1UL << (7 + (5))))) != 0)) {
     do { } while (0);
     goto error_funcname;
    }
   }
  }





  if (implicit_return_value) {

   duk__emit_bc(comp_ctx, 7, 0);
  }

  do { } while (0);
  duk__parse_stmts(comp_ctx,
                   1,
                   expect_eof,
                   regexp_after);
  do { } while (0);

  duk__update_lineinfo_currtoken(comp_ctx);

  if (needs_shuffle_before == comp_ctx->curr_func.needs_shuffle) {

   break;
  }
  if (compile_round >= 3) {

   do { } while (0);
   do { duk_err_error_internal((thr), "duk_js_compiler.c", (duk_int_t) 7499); } while (0);
   do { return; } while (0);
  }
  do { } while (0);
 }
# 7520 "duk_js_compiler.c"
 do { } while (0);
 if (reg_stmt_value >= 0) {
  do { } while (0);
  duk__emit_bc(comp_ctx, 157, reg_stmt_value );
 } else {
  duk__emit_op_only(comp_ctx, 158);
 }





 duk__peephole_optimize_bytecode(comp_ctx);






 do { do { } while (0); duk__comp_recursion_decrease((comp_ctx)); } while (0);
 return;

error_funcname:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 7543; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid function name"))); } while (0); } while (0);
 do { return; } while (0);
}
# 7565 "duk_js_compiler.c"
static void duk__parse_func_formals(duk_compiler_ctx *comp_ctx) {
 duk_hthread *thr = comp_ctx->thr;
 duk_bool_t first = 1;
 duk_uarridx_t n;

 for (;;) {
  if (comp_ctx->curr_token.t == 54) {
   break;
  }

  if (first) {

   first = 0;
  } else {
   duk__advance_expect(comp_ctx, 57);
  }
# 7591 "duk_js_compiler.c"
  if (comp_ctx->curr_token.t != 1) {
   do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 7592; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("expected identifier"))); } while (0); } while (0);
   do { return; } while (0);
  }
  do { } while (0);
  do { } while (0);
  do { } while (0);


  duk_push_hstring(thr, comp_ctx->curr_token.str1);
  n = (duk_uarridx_t) duk_get_length(thr, comp_ctx->curr_func.argnames_idx);
  duk_put_prop_index(thr, comp_ctx->curr_func.argnames_idx, n);

  duk__advance(comp_ctx);
 }
}





static void duk__parse_func_like_raw(duk_compiler_ctx *comp_ctx, duk_small_uint_t flags) {
 duk_hthread *thr = comp_ctx->thr;
 duk_token *tok;
 duk_bool_t no_advance;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 duk__update_lineinfo_currtoken(comp_ctx);
# 7642 "duk_js_compiler.c"
 no_advance = (flags & (1 << 4));
 if (no_advance) {
  tok = &comp_ctx->prev_token;
 } else {
  tok = &comp_ctx->curr_token;
 }

 if (flags & (1 << 1)) {

  if (tok->t_nores == 1 || tok->t == 100) {
   duk_push_hstring(thr, tok->str1);
  } else if (tok->t == 99) {
   duk_push_number(thr, tok->num);
   duk_to_string(thr, -1);
  } else {
   do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 7657; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid getter/setter name"))); } while (0); } while (0);
   do { return; } while (0);
  }
  comp_ctx->curr_func.h_name = duk_known_hstring(thr, -1);
 } else {




  if (tok->t_nores == 1) {
   duk_push_hstring(thr, tok->str1);
   comp_ctx->curr_func.h_name = duk_known_hstring(thr, -1);
  } else {

   do { } while (0);
   do { } while (0);
   no_advance = 1;
   if (flags & (1 << 0)) {
    do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 7675; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("function name required"))); } while (0); } while (0);
    do { return; } while (0);
   }
  }
 }

 do { } while (0);

 if (!no_advance) {
  duk__advance(comp_ctx);
 }
# 7695 "duk_js_compiler.c"
 duk__advance_expect(comp_ctx, 53);

 duk__parse_func_formals(comp_ctx);

 do { } while (0);
 duk__advance(comp_ctx);





 duk__parse_func_body(comp_ctx,
                      0,
                      0,
                      flags & (1 << 0),
                      49);






 duk__convert_to_func_template(comp_ctx);
}
# 7734 "duk_js_compiler.c"
static duk_int_t duk__parse_func_like_fnum(duk_compiler_ctx *comp_ctx, duk_small_uint_t flags) {
 duk_hthread *thr = comp_ctx->thr;
 duk_compiler_func old_func;
 duk_idx_t entry_top;
 duk_int_t fnum;





 if (!comp_ctx->curr_func.in_scanning) {
  duk_lexer_point lex_pt;

  fnum = comp_ctx->curr_func.fnum_next++;
  duk_get_prop_index(thr, comp_ctx->curr_func.funcs_idx, (duk_uarridx_t) (fnum * 3 + 1));
  lex_pt.offset = (duk_size_t) duk_to_uint(thr, -1);
  duk_pop(thr);
  duk_get_prop_index(thr, comp_ctx->curr_func.funcs_idx, (duk_uarridx_t) (fnum * 3 + 2));
  lex_pt.line = duk_to_int(thr, -1);
  duk_pop(thr);

  do { } while (0)


                                       ;

  duk_lexer_setpoint((&comp_ctx->lex), (&lex_pt));
  comp_ctx->curr_token.t = 0;
  comp_ctx->curr_token.start_line = 0;
  duk__advance(comp_ctx);





  if (flags & (1 << 0)) {
   comp_ctx->curr_func.allow_regexp_in_adv = 1;
  }
  duk__advance_expect(comp_ctx, 50);

  return fnum;
 }






 entry_top = duk_get_top(thr);
 do { } while (0)

                                                                ;

 do { void *duk__dst = (&old_func); const void *duk__src = (&comp_ctx->curr_func); duk_size_t duk__len = (sizeof(duk_compiler_func)); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);

 do { void *duk__dst = (&comp_ctx->curr_func); duk_size_t duk__len = (sizeof(duk_compiler_func)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 duk__init_func_valstack_slots(comp_ctx);
 do { } while (0);


 comp_ctx->curr_func.is_strict = old_func.is_strict;





 do { } while (0);
 comp_ctx->curr_func.is_function = 1;
 do { } while (0);
 do { } while (0);
 comp_ctx->curr_func.is_setget = ((flags & (1 << 1)) != 0);
 comp_ctx->curr_func.is_namebinding =
     !(flags & ((1 << 1) | (1 << 2) |
                (1 << 0)));
 comp_ctx->curr_func.is_constructable =
     !(flags & ((1 << 1) | (1 << 2)));





 duk__parse_func_like_raw(comp_ctx, flags);





 do { } while (0)

                                                                ;
 do { } while (0);


 do { } while (0);
 fnum = old_func.fnum_next++;

 if (fnum > 0xffffL) {
  do { duk_err_range((comp_ctx->thr), "duk_js_compiler.c", (duk_int_t) 7831, ("function limit")); } while (0);
  do { return 0; } while (0);
 }


 (void) duk_put_prop_index(thr, old_func.funcs_idx, (duk_uarridx_t) (fnum * 3));
 duk_push_uint((thr), (duk_uint_t) (comp_ctx->prev_token.start_offset));
 (void) duk_put_prop_index(thr, old_func.funcs_idx, (duk_uarridx_t) (fnum * 3 + 1));
 duk_push_int(thr, comp_ctx->prev_token.start_line);
 (void) duk_put_prop_index(thr, old_func.funcs_idx, (duk_uarridx_t) (fnum * 3 + 2));
# 7849 "duk_js_compiler.c"
 if (flags & (1 << 3)) {
  do { } while (0);
  duk_push_hstring(thr, comp_ctx->curr_func.h_name);
  duk_replace(thr, entry_top);
  duk_set_top(thr, entry_top + 1);
 } else {
  duk_set_top(thr, entry_top);
 }
 do { void *duk__dst = ((void *) &comp_ctx->curr_func); const void *duk__src = ((void *) &old_func); duk_size_t duk__len = (sizeof(duk_compiler_func)); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);

 return fnum;
}
# 7876 "duk_js_compiler.c"
static duk_ret_t duk__js_compile_raw(duk_hthread *thr, void *udata) {
 duk_hstring *h_filename;
 duk__compiler_stkstate *comp_stk;
 duk_compiler_ctx *comp_ctx;
 duk_lexer_point *lex_pt;
 duk_compiler_func *func;
 duk_idx_t entry_top;
 duk_bool_t is_strict;
 duk_bool_t is_eval;
 duk_bool_t is_funcexpr;
 duk_small_uint_t flags;

 do { } while (0);
 do { } while (0);





 entry_top = duk_get_top(thr);
 do { } while (0);

 comp_stk = (duk__compiler_stkstate *) udata;
 comp_ctx = &comp_stk->comp_ctx_alloc;
 lex_pt = &comp_stk->lex_pt_alloc;
 do { } while (0);
 do { } while (0);

 flags = comp_stk->flags;
 is_eval = (flags & (1U << 3) ? 1 : 0);
 is_strict = (flags & (1U << 5) ? 1 : 0);
 is_funcexpr = (flags & (1U << 12) ? 1 : 0);

 h_filename = duk_get_hstring(thr, -1);





 func = &comp_ctx->curr_func;
# 7925 "duk_js_compiler.c"
 duk_require_stack(thr, 8);

 duk_push_buffer_raw((thr), (0), (1 << 0) );
 duk_push_undefined(thr);
 duk_push_undefined(thr);
 duk_push_undefined(thr);
 duk_push_undefined(thr);

 comp_ctx->thr = thr;
 comp_ctx->h_filename = h_filename;
 comp_ctx->tok11_idx = entry_top + 1;
 comp_ctx->tok12_idx = entry_top + 2;
 comp_ctx->tok21_idx = entry_top + 3;
 comp_ctx->tok22_idx = entry_top + 4;
 comp_ctx->recursion_limit = 2500;




 comp_ctx->lex.thr = thr;

 comp_ctx->lex.slot1_idx = comp_ctx->tok11_idx;
 comp_ctx->lex.slot2_idx = comp_ctx->tok12_idx;
 comp_ctx->lex.buf_idx = entry_top + 0;
 comp_ctx->lex.buf = (duk_hbuffer_dynamic *) duk_known_hbuffer(thr, entry_top + 0);
 do { } while (0);
 comp_ctx->lex.token_limit = 100000000L;

 lex_pt->offset = 0;
 lex_pt->line = 1;
 duk_lexer_setpoint((&comp_ctx->lex), (lex_pt));
 comp_ctx->curr_token.start_line = 0;





 duk__init_func_valstack_slots(comp_ctx);
 do { } while (0);

 if (is_funcexpr) {




  do { } while (0);
 } else {
  duk_push_hstring_stridx(thr, (is_eval ? 33 : 27));
  func->h_name = duk_get_hstring(thr, -1);
 }






 do { } while (0);
 func->is_strict = (duk_uint8_t) is_strict;
 do { } while (0);

 if (is_funcexpr) {
  func->is_function = 1;
  do { } while (0);
  do { } while (0);
  func->is_namebinding = 1;
  func->is_constructable = 1;

  duk__advance(comp_ctx);
  duk__advance_expect(comp_ctx, 13);
  (void) duk__parse_func_like_raw(comp_ctx, 0 );
 } else {
  do { } while (0);
  do { } while (0);
  func->is_eval = (duk_uint8_t) is_eval;
  func->is_global = (duk_uint8_t) !is_eval;
  do { } while (0);
  do { } while (0);

  duk__parse_func_body(comp_ctx,
                       1,
                       1,
                       1,
                       -1);
 }





 duk__convert_to_func_template(comp_ctx);







 return 1;
}

static __attribute__ ((unused)) void duk_js_compile(duk_hthread *thr, const duk_uint8_t *src_buffer, duk_size_t src_length, duk_small_uint_t flags) {
 duk__compiler_stkstate comp_stk;
 duk_compiler_ctx *prev_ctx;
 duk_ret_t safe_rc;

 do { } while (0);
 do { } while (0);


 do { void *duk__dst = (&comp_stk); duk_size_t duk__len = (sizeof(comp_stk)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 comp_stk.flags = flags;
 duk_lexer_initctx((&comp_stk.comp_ctx_alloc.lex));
 comp_stk.comp_ctx_alloc.lex.input = src_buffer;
 comp_stk.comp_ctx_alloc.lex.input_length = src_length;
 comp_stk.comp_ctx_alloc.lex.flags = flags;



 prev_ctx = thr->compile_ctx;
 thr->compile_ctx = &comp_stk.comp_ctx_alloc;
 safe_rc = duk_safe_call(thr, duk__js_compile_raw, (void *) &comp_stk , 1 , 1 );
 thr->compile_ctx = prev_ctx;

 if (safe_rc != 0) {
  do { } while (0);
  (void) (duk_throw_raw((thr)), (duk_ret_t) 0);
  do { return; } while (0);
 }


}
# 1 "duk_js_executor.c"
# 11 "duk_js_executor.c"
static void duk__js_execute_bytecode_inner(duk_hthread *entry_thread, duk_activation *entry_act);
# 69 "duk_js_executor.c"
static inline __attribute__((always_inline)) duk_double_t duk__compute_mod(duk_double_t d1, duk_double_t d2) {
 return (duk_double_t) duk_js_arith_mod((double) d1, (double) d2);
}


static inline __attribute__((always_inline)) duk_double_t duk__compute_exp(duk_double_t d1, duk_double_t d2) {
 return (duk_double_t) duk_js_arith_pow((double) d1, (double) d2);
}


static inline __attribute__((always_inline)) void duk__vm_arith_add(duk_hthread *thr,
                                                             duk_tval *tv_x,
                                                             duk_tval *tv_y,
                                                             duk_small_uint_fast_t idx_z) {
# 99 "duk_js_executor.c"
 duk_double_union du;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
# 136 "duk_js_executor.c"
 if (((tv_x)->t == 0) && ((tv_y)->t == 0)) {

  duk_tval *tv_z;


  du.d = ((tv_x)->v.d) + ((tv_y)->v.d);




  ;
  do { } while (0);
  tv_z = thr->valstack_bottom + idx_z;
  do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv_z); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((du.d)); ; duk__tv = (tv__dst); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);

  return;
 }





 duk_push_tval(thr, tv_x);
 duk_push_tval(thr, tv_y);
 duk_to_primitive(thr, -2, 0);
 duk_to_primitive(thr, -1, 0);


 if (duk_is_string(thr, -2) || duk_is_string(thr, -1)) {






  duk_concat_2(thr);
 } else {
  duk_double_t d1, d2;

  d1 = duk_to_number_m2(thr);
  d2 = duk_to_number_m1(thr);
  do { } while (0);
  do { } while (0);
  ;
  ;

  du.d = d1 + d2;
  duk_pop_2_unsafe(thr);
  duk_push_number(thr, du.d);
 }
 duk_replace(thr, (duk_idx_t) idx_z);
}

static inline __attribute__((always_inline)) void duk__vm_arith_binary_op(duk_hthread *thr,
                                                                   duk_tval *tv_x,
                                                                   duk_tval *tv_y,
                                                                   duk_uint_fast_t idx_z,
                                                                   duk_small_uint_fast_t opcode) {
# 202 "duk_js_executor.c"
 duk_double_t d1, d2;
 duk_double_union du;
 duk_small_uint_fast_t opcode_shifted;

 duk_tval *tv_z;


 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 opcode_shifted = opcode >> 2;
# 290 "duk_js_executor.c"
 if (((tv_x)->t == 0) && ((tv_y)->t == 0)) {

  d1 = ((tv_x)->v.d);
  d2 = ((tv_y)->v.d);
 } else {
  duk_push_tval(thr, tv_x);
  duk_push_tval(thr, tv_y);
  d1 = duk_to_number_m2(thr);
  d2 = duk_to_number_m1(thr);
  do { } while (0);
  do { } while (0);
  ;
  ;
  duk_pop_2_unsafe(thr);
 }

 switch (opcode_shifted) {
 case 56 >> 2: {
  du.d = d1 - d2;
  break;
 }
 case 60 >> 2: {
  du.d = d1 * d2;
  break;
 }
 case 64 >> 2: {



  du.d = duk_double_div(d1, d2);
  break;
 }
 case 68 >> 2: {
  du.d = duk__compute_mod(d1, d2);
  break;
 }

 case 72 >> 2: {
  du.d = duk__compute_exp(d1, d2);
  break;
 }

 default: {
  do { __builtin_unreachable(); } while (0);
  du.d = 
# 334 "duk_js_executor.c" 3 4
        (__builtin_nanf (""))
# 334 "duk_js_executor.c"
                      ;
  break;
 }
 }






 ;
 do { } while (0);
 tv_z = thr->valstack_bottom + idx_z;
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv_z); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((du.d)); ; duk__tv = (tv__dst); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);

}

static inline __attribute__((always_inline)) void duk__vm_bitwise_binary_op(duk_hthread *thr,
                                                                     duk_tval *tv_x,
                                                                     duk_tval *tv_y,
                                                                     duk_small_uint_fast_t idx_z,
                                                                     duk_small_uint_fast_t opcode) {
# 366 "duk_js_executor.c"
 duk_int32_t i1, i2, i3;
 duk_uint32_t u1, u2, u3;



 duk_double_t d3;

 duk_small_uint_fast_t opcode_shifted;

 duk_tval *tv_z;


 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 opcode_shifted = opcode >> 2;







 {
  duk_push_tval(thr, tv_x);
  duk_push_tval(thr, tv_y);
  i1 = duk_to_int32(thr, -2);
  i2 = duk_to_int32(thr, -1);
  duk_pop_2_unsafe(thr);
 }

 switch (opcode_shifted) {
 case 76 >> 2: {
  i3 = i1 & i2;
  break;
 }
 case 80 >> 2: {
  i3 = i1 | i2;
  break;
 }
 case 84 >> 2: {
  i3 = i1 ^ i2;
  break;
 }
 case 88 >> 2: {





  u2 = ((duk_uint32_t) i2) & 0xffffffffUL;
  i3 = (duk_int32_t) (((duk_uint32_t) i1) << (u2 & 0x1fUL));
  i3 = i3 & ((duk_int32_t) 0xffffffffUL);
  break;
 }
 case 96 >> 2: {


  u2 = ((duk_uint32_t) i2) & 0xffffffffUL;
  i3 = i1 >> (u2 & 0x1fUL);
  break;
 }
 case 92 >> 2: {


  u1 = ((duk_uint32_t) i1) & 0xffffffffUL;
  u2 = ((duk_uint32_t) i2) & 0xffffffffUL;


  u3 = u1 >> (u2 & 0x1fUL);




  d3 = (duk_double_t) u3;
  goto result_set;

 }
 default: {
  do { __builtin_unreachable(); } while (0);
  i3 = 0;
  break;
 }
 }
# 465 "duk_js_executor.c"
 d3 = (duk_double_t) i3;

result_set:
 do { } while (0);
 ;





 tv_z = thr->valstack_bottom + idx_z;
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv_z); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((d3)); ; duk__tv = (tv__dst); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);


}


static inline __attribute__((always_inline)) void duk__vm_arith_unary_op(duk_hthread *thr,
                                                                  duk_uint_fast_t idx_src,
                                                                  duk_uint_fast_t idx_dst,
                                                                  duk_small_uint_fast_t opcode) {
# 494 "duk_js_executor.c"
 duk_tval *tv;
 duk_double_t d1;
 duk_double_union du;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + ((duk_idx_t) idx_src));
# 533 "duk_js_executor.c"
 if (((tv)->t == 0)) {
  d1 = ((tv)->v.d);
 } else {
  d1 = duk_to_number_tval(thr, tv);
 }

 if (opcode == 15) {



  du.d = d1;
  do { } while (0);





 } else {
  do { } while (0);
  du.d = -d1;
  ;
  do { } while (0);
 }


 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + ((duk_idx_t) idx_dst));
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((du.d)); ; duk__tv = (tv__dst); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
}

static inline __attribute__((always_inline)) void duk__vm_bitwise_not(duk_hthread *thr, duk_uint_fast_t idx_src, duk_uint_fast_t idx_dst) {




 duk_tval *tv;
 duk_int32_t i1, i2;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + ((duk_idx_t) idx_src));






 {
  duk_push_tval(thr, tv);
  i1 = duk_to_int32(thr, -1);
  duk_pop_unsafe(thr);
 }


 i2 = ~i1;
 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + ((duk_idx_t) idx_dst));
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = ((tv)); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((((duk_double_t) (i2)))); ; duk__tv = ((tv__dst)); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((((thr)))), duk__h); } } } while (0); } while (0);
}

static inline __attribute__((always_inline)) void duk__vm_logical_not(duk_hthread *thr, duk_uint_fast_t idx_src, duk_uint_fast_t idx_dst) {




 duk_tval *tv;
 duk_bool_t res;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);





 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + ((duk_idx_t) idx_src));
 res = duk_js_toboolean(tv);
 do { } while (0);
 res ^= 1;
 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + ((duk_idx_t) idx_dst));

 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((res)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
}


static inline __attribute__((always_inline)) void duk__prepost_incdec_reg_helper(duk_hthread *thr,
                                                                          duk_tval *tv_dst,
                                                                          duk_tval *tv_src,
                                                                          duk_small_uint_t op) {
 duk_double_t x, y, z;




 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
# 661 "duk_js_executor.c"
 if (((tv_src)->t == 0)) {




  x = ((tv_src)->v.d);
  if (op & 0x01) {
   y = x - 1.0;
  } else {
   y = x + 1.0;
  }

  do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = (y); ; duk__tv = (tv_src); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0);
 } else {



  duk_idx_t bc;
  duk_size_t off_dst;

  off_dst = (duk_size_t) ((duk_uint8_t *) tv_dst - (duk_uint8_t *) thr->valstack_bottom);
  bc = (duk_idx_t) (tv_src - thr->valstack_bottom);
  tv_src = 
# 683 "duk_js_executor.c" 3 4
          ((void *)0)
# 683 "duk_js_executor.c"
              ;

  x = duk_to_number(thr, bc);
  if (op & 0x01) {
   y = x - 1.0;
  } else {
   y = x + 1.0;
  }

  duk_push_number(thr, y);
  duk_replace(thr, bc);

  tv_dst = (duk_tval *) (void *) (((duk_uint8_t *) thr->valstack_bottom) + off_dst);
 }

 z = (op & 0x02) ? x : y;
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv_dst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((z)); ; duk__tv = (tv__dst); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
}

static inline __attribute__((always_inline)) void duk__prepost_incdec_var_helper(duk_hthread *thr,
                                                                          duk_small_uint_t idx_dst,
                                                                          duk_tval *tv_id,
                                                                          duk_small_uint_t op,
                                                                          duk_small_uint_t is_strict) {
 duk_activation *act;
 duk_double_t x, y;
 duk_hstring *name;
# 723 "duk_js_executor.c"
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);
 name = ((tv_id)->v.hstring);
 do { } while (0);
 act = thr->callstack_curr;
 (void) duk_js_getvar_activation(thr, act, name, 1 );






 x = duk_to_number_m2(thr);
 if (op & 0x01) {
  y = x - 1.0;
 } else {
  y = x + 1.0;
 }



 if (op & 0x02) {
  duk_push_number(thr, y);
  do { } while (0);
  duk_js_putvar_activation(thr, act, name, ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)), is_strict);
  duk_pop_2_unsafe(thr);
 } else {
  duk_pop_2_unsafe(thr);
  duk_push_number(thr, y);
  do { } while (0);
  duk_js_putvar_activation(thr, act, name, ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)), is_strict);
 }




 do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_bottom + ((duk_idx_t) idx_dst))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { duk_tval *duk__tv; duk__tv = (duk__tvsrc); duk__tv->t = 2; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0);

}
# 791 "duk_js_executor.c"
static void duk__reconfig_valstack_ecma_return(duk_hthread *thr) {
 duk_activation *act;
 duk_hcompfunc *h_func;
 duk_idx_t clamp_top;

 do { } while (0);
 act = thr->callstack_curr;
 do { } while (0);
 do { } while (0);
 do { } while (0);






 h_func = (duk_hcompfunc *) ((act)->func);

 thr->valstack_bottom = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + act->bottom_byteoff);
 do { } while (0);
 clamp_top =
     (duk_idx_t) ((act->retval_byteoff - act->bottom_byteoff + sizeof(duk_tval)) / sizeof(duk_tval));
 duk_set_top_and_wipe(thr, h_func->nregs, clamp_top);

 do { } while (0);
 thr->valstack_end = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + act->reserve_byteoff);


}




static void duk__reconfig_valstack_ecma_catcher(duk_hthread *thr, duk_activation *act) {
 duk_catcher *cat;
 duk_hcompfunc *h_func;
 duk_size_t idx_bottom;
 duk_idx_t clamp_top;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 cat = act->cat;
 do { } while (0);

 h_func = (duk_hcompfunc *) ((act)->func);

 thr->valstack_bottom = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + act->bottom_byteoff);
 idx_bottom = (duk_size_t) (thr->valstack_bottom - thr->valstack);
 do { } while (0);
 clamp_top = (duk_idx_t) (cat->idx_base - idx_bottom + 2);
 duk_set_top_and_wipe(thr, h_func->nregs, clamp_top);

 do { } while (0);
 thr->valstack_end = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + act->reserve_byteoff);


}




static void duk__set_catcher_regs_norz(duk_hthread *thr, duk_catcher *cat, duk_tval *tv_val_unstable, duk_small_uint_t lj_type) {
 duk_tval *tv1;

 do { } while (0);
 do { } while (0);

 tv1 = thr->valstack + cat->idx_base;
 do { } while (0);
 do { duk_hthread *duk__thr = (thr); duk_tval *duk__dst = (tv1); duk_tval *duk__src = (tv_val_unstable); do { (void) (duk__thr); } while (0); do { duk_tval *duk__tv = ((duk__dst)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz(((thr)), duk__h); } } } while (0); do { *(duk__dst) = *(duk__src); } while (0); do { duk_tval *duk__tv = ((duk__dst)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); } while (0);

 tv1++;
 do { } while (0);
 do { } while (0);
 do { duk_hthread *duk__thr = (thr); duk_tval *duk__dst = (tv1); duk_uint32_t duk__val = (duk_uint32_t) ((duk_uint32_t) lj_type); do { (void) (duk__thr); } while (0); do { duk_tval *duk__tv = ((duk__dst)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero_norz(((thr)), duk__h); } } } while (0); do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((duk_double_t) (duk__val)); ; duk__tv = ((duk__dst)); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0); } while (0);
}

static void duk__handle_catch_part1(duk_hthread *thr,
                                       duk_tval *tv_val_unstable,
                                       duk_small_uint_t lj_type,
                                       volatile duk_bool_t *out_delayed_catch_setup) {
 duk_activation *act;
 duk_catcher *cat;

 do { } while (0);
 do { } while (0);

 act = thr->callstack_curr;
 do { } while (0);
 do { } while (0);

 do { } while (0);
 do { } while (0);







 duk__set_catcher_regs_norz(thr, act->cat, tv_val_unstable, lj_type);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 duk__reconfig_valstack_ecma_catcher(thr, act);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 cat = act->cat;
 do { } while (0);

 act->curr_pc = cat->pc_base + 0;
# 921 "duk_js_executor.c"
 if (((cat)->flags & (1U << 6))) {
  do { } while (0);
  *out_delayed_catch_setup = 1;
 } else {
  do { } while (0);
 }

 do { (cat)->flags &= ~(1U << 4); } while (0);
}

static void duk__handle_catch_part2(duk_hthread *thr) {
 duk_activation *act;
 duk_catcher *cat;
 duk_hdecenv *new_env;

 do { } while (0);

 act = thr->callstack_curr;
 do { } while (0);
 do { } while (0);

 do { } while (0);
 cat = act->cat;
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
# 959 "duk_js_executor.c"
 if (act->lex_env == 
# 959 "duk_js_executor.c" 3 4
                    ((void *)0)
# 959 "duk_js_executor.c"
                        ) {
  do { } while (0);
  do { } while (0);

  duk_js_init_activation_environment_records_delayed(thr, act);
  do { } while (0);
  do { } while (0);
 }
 do { } while (0);
 do { } while (0);
 do { } while (0);

 new_env = duk_hdecenv_alloc(thr, (1UL << (7 + (0))) | (((duk_uint_t) (16)) << (7 + (20))));
 do { } while (0);
 duk_push_hobject(thr, (duk_hobject *) new_env);
 do { } while (0);
 do { } while (0);
# 985 "duk_js_executor.c"
 do { } while (0);
 duk_push_hstring(thr, cat->h_varname);
 do { } while (0);
 duk_push_tval(thr, thr->valstack + cat->idx_base);
 duk_xdef_prop(thr, -3, ((1U << 0)));



 do { } while (0);
 do { } while (0);
 do { ((duk_hobject *) new_env)->prototype = (act->lex_env); } while (0);
 act->lex_env = (duk_hobject *) new_env;
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk_hobject *) new_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);




 do { (cat)->flags |= (1U << 7); } while (0);

 duk_pop_unsafe(thr);

 do { } while (0);
}

static void duk__handle_finally(duk_hthread *thr, duk_tval *tv_val_unstable, duk_small_uint_t lj_type) {
 duk_activation *act;
 duk_catcher *cat;

 do { } while (0);
 do { } while (0);

 act = thr->callstack_curr;
 do { } while (0);
 do { } while (0);
 do { } while (0);

 duk__set_catcher_regs_norz(thr, act->cat, tv_val_unstable, lj_type);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 duk__reconfig_valstack_ecma_catcher(thr, act);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 cat = act->cat;
 do { } while (0);

 act->curr_pc = cat->pc_base + 1;

 do { (cat)->flags &= ~(1U << 5); } while (0);
}

static void duk__handle_label(duk_hthread *thr, duk_small_uint_t lj_type) {
 duk_activation *act;
 duk_catcher *cat;

 do { } while (0);

 do { } while (0);
 act = thr->callstack_curr;
 do { } while (0);
 do { } while (0);
 do { } while (0);


 cat = act->cat;
 do { } while (0);
 do { } while (0);

 act->curr_pc = cat->pc_base + (lj_type == 5 ? 1 : 0);
# 1071 "duk_js_executor.c"
}






static void duk__handle_yield(duk_hthread *thr, duk_hthread *resumer, duk_tval *tv_val_unstable) {
 duk_activation *act_resumer;
 duk_tval *tv1;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 act_resumer = resumer->callstack_curr;
 do { } while (0);
 do { } while (0);
 do { } while (0);

 tv1 = (duk_tval *) (void *) ((duk_uint8_t *) resumer->valstack +
                              act_resumer->retval_byteoff);
 do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv1); tv__src = (tv_val_unstable); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((tv__dst))->t & 0x08)) { h__obj = ((tv__dst)->v.heaphdr); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);

 duk__reconfig_valstack_ecma_return(resumer);


}


static duk_small_uint_t duk__handle_longjmp(duk_hthread *thr,
                                               duk_activation *entry_act,
                                               volatile duk_bool_t *out_delayed_catch_setup) {
 duk_small_uint_t retval = 0;

 do { } while (0);
 do { } while (0);




 do { } while (0);
# 1123 "duk_js_executor.c"
check_longjmp:

 do { } while (0)




                                             ;

 switch (thr->heap->lj.type) {

 case 3: {





  duk_tval *tv;
  duk_tval *tv2;
  duk_hthread *resumee;



  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0)

                                                                                                    ;

  tv = &thr->heap->lj.value2;
  do { } while (0);
  do { } while (0);
  do { } while (0);
  resumee = (duk_hthread *) ((tv)->v.hobject);

  do { } while (0);
  do { } while (0);
  do { } while (0)
                                                         ;
  do { } while (0)
                                         ;
  do { } while (0)


                                                                                                         ;
  do { } while (0)
                                         ;

  if (thr->heap->lj.iserror) {
# 1184 "duk_js_executor.c"
   do { } while (0);
   resumee->resumer = thr;
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) &(thr)->obj)); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   resumee->state = 2;
   thr->state = 3;
   do { (thr->heap)->curr_thread = (resumee); } while (0);
   thr = resumee;

   thr->heap->lj.type = 1;




   do { } while (0);

   do { } while (0);
   goto check_longjmp;
  } else if (resumee->state == 4) {





   duk_activation *act_resumee;

   do { } while (0);
   act_resumee = resumee->callstack_curr;
   do { } while (0);
   act_resumee = act_resumee->parent;
   do { } while (0);

   tv = (duk_tval *) (void *) ((duk_uint8_t *) resumee->valstack +
                               act_resumee->retval_byteoff);
   do { } while (0);
   tv2 = &thr->heap->lj.value1;
   do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv); tv__src = (tv2); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((tv__dst))->t & 0x08)) { h__obj = ((tv__dst)->v.heaphdr); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);

   duk_hthread_activation_unwind_norz(resumee);


   duk__reconfig_valstack_ecma_return(resumee);

   do { } while (0);
   resumee->resumer = thr;
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) &(thr)->obj)); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   resumee->state = 2;
   thr->state = 3;
   do { (thr->heap)->curr_thread = (resumee); } while (0);



   do { } while (0);
   retval = 0;
   goto wipe_and_return;
  } else {

   duk_small_uint_t call_flags;
   duk_int_t setup_rc;



   duk_push_undefined(resumee);
   tv = &thr->heap->lj.value1;
   duk_push_tval(resumee, tv);



   call_flags = (1U << 3);

   setup_rc = duk_handle_call_unprotected_nargs(resumee, 1 , call_flags);
   if (setup_rc == 0) {





    do { duk_err_error_internal((thr), "duk_js_executor.c", (duk_int_t) 1260); } while (0);
    do { return 0; } while (0);
   }

   do { } while (0);
   resumee->resumer = thr;
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) &(thr)->obj)); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   resumee->state = 2;
   thr->state = 3;
   do { (thr->heap)->curr_thread = (resumee); } while (0);



   do { } while (0);
   retval = 0;
   goto wipe_and_return;
  }
  do { __builtin_unreachable(); } while (0);
  break;
 }

 case 2: {
# 1292 "duk_js_executor.c"
  duk_hthread *resumer;






  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0)

                                                                                                   ;
  do { } while (0)
                                                                                    ;

  resumer = thr->resumer;

  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0)

                                                                                                        ;
  do { } while (0)
                                                                                        ;

  if (thr->heap->lj.iserror) {
   thr->state = 4;
   thr->resumer = 
# 1324 "duk_js_executor.c" 3 4
                 ((void *)0)
# 1324 "duk_js_executor.c"
                     ;
   do { duk_heaphdr *duk__h = (duk_heaphdr *) ((resumer)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)(((thr)), (duk_hobject *) duk__h); } } } while (0);
   resumer->state = 2;
   do { (thr->heap)->curr_thread = (resumer); } while (0);
   thr = resumer;

   thr->heap->lj.type = 1;

   do { } while (0);

   do { } while (0);
   goto check_longjmp;
  } else {




   do { } while (0);
   duk_hthread_activation_unwind_norz(resumer);
   do { } while (0);
   thr->state = 4;
   thr->resumer = 
# 1345 "duk_js_executor.c" 3 4
                 ((void *)0)
# 1345 "duk_js_executor.c"
                     ;
   do { duk_heaphdr *duk__h = (duk_heaphdr *) ((resumer)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)(((thr)), (duk_hobject *) duk__h); } } } while (0);
   resumer->state = 2;
   do { (thr->heap)->curr_thread = (resumer); } while (0);
   duk__handle_yield(thr, resumer, &thr->heap->lj.value1);
   thr = resumer;
   do { } while (0);

   do { } while (0);
   retval = 0;
   goto wipe_and_return;
  }
  do { __builtin_unreachable(); } while (0);
  break;
 }


 case 1: {
# 1381 "duk_js_executor.c"
  duk_activation *act;
  duk_catcher *cat;
  duk_hthread *resumer;

  for (;;) {
   act = thr->callstack_curr;
   if (act == 
# 1387 "duk_js_executor.c" 3 4
             ((void *)0)
# 1387 "duk_js_executor.c"
                 ) {
    break;
   }

   for (;;) {
    cat = act->cat;
    if (cat == 
# 1393 "duk_js_executor.c" 3 4
              ((void *)0)
# 1393 "duk_js_executor.c"
                  ) {
     break;
    }

    if (((cat)->flags & (1U << 4))) {
     do { } while (0);

     do { } while (0)


                                             ;
     duk__handle_catch_part1(thr,
                             &thr->heap->lj.value1,
                             1,
                             out_delayed_catch_setup);

     do { } while (0);
     retval = 0;
     goto wipe_and_return;
    }

    if (((cat)->flags & (1U << 5))) {
     do { } while (0);
     do { } while (0);

     duk__handle_finally(thr, &thr->heap->lj.value1, 1);

     do { } while (0);
     retval = 0;
     goto wipe_and_return;
    }

    duk_hthread_catcher_unwind_norz(thr, act);
   }

   if (act == entry_act) {



    do { } while (0);
    retval = 1;
    goto just_return;
   }

   duk_hthread_activation_unwind_norz(thr);
  }

  do { } while (0);






  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { } while (0)

                                                                                      ;

  resumer = thr->resumer;



  do { } while (0);


  duk_hthread_terminate(thr);
  do { } while (0);

  thr->resumer = 
# 1465 "duk_js_executor.c" 3 4
                ((void *)0)
# 1465 "duk_js_executor.c"
                    ;
  do { duk_heaphdr *duk__h = (duk_heaphdr *) ((resumer)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)(((thr)), (duk_hobject *) duk__h); } } } while (0);
  resumer->state = 2;
  do { (thr->heap)->curr_thread = (resumer); } while (0);
  thr = resumer;
  goto check_longjmp;
 }

 case 4:
 case 5:
 case 6:
 case 7:
 default: {

  do { } while (0);
  goto convert_to_internal_error;
 }

 }

 do { __builtin_unreachable(); } while (0);

wipe_and_return:
 do { } while (0);
 thr->heap->lj.type = 0;
 thr->heap->lj.iserror = 0;

 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (&thr->heap->lj.value1); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 2; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
 do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (&thr->heap->lj.value2); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 2; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);

 do { } while (0);

just_return:
 return retval;

convert_to_internal_error:




 do { duk_err_error_internal((thr), "duk_js_executor.c", (duk_int_t) 1505); } while (0);
 do { return 0; } while (0);
}





static __attribute__((noinline)) void duk__handle_break_or_continue(duk_hthread *thr,
                                                                    duk_uint_t label_id,
                                                                    duk_small_uint_t lj_type) {
 duk_activation *act;
 duk_catcher *cat;

 do { } while (0);
# 1530 "duk_js_executor.c"
 act = thr->callstack_curr;
 do { } while (0);

 for (;;) {
  cat = act->cat;
  if (cat == 
# 1535 "duk_js_executor.c" 3 4
            ((void *)0)
# 1535 "duk_js_executor.c"
                ) {
   break;
  }

  do { } while (0)


                                                      ;



  if (((cat)->flags & 0x0000000fUL) == 1 && ((cat)->flags & (1U << 5))) {
   duk_tval tv_tmp;

   do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((duk_double_t) ((duk_uint32_t) label_id)); ; duk__tv = ((&tv_tmp)); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0);
   duk__handle_finally(thr, &tv_tmp, lj_type);

   do { } while (0);
   return;
  }
  if (((cat)->flags & 0x0000000fUL) == 2 && (duk_uint_t) (((cat)->flags & 0xffffff00UL) >> 8) == label_id) {
   duk__handle_label(thr, lj_type);

   do { } while (0)
                                                                                                            ;
   return;
  }

  duk_hthread_catcher_unwind_norz(thr, act);
 }


 do { } while (0)
                                                                                                                     ;
 do { duk_err_error_internal((thr), "duk_js_executor.c", (duk_int_t) 1569); } while (0);
 do { return; } while (0);
}





static duk_small_uint_t duk__handle_return(duk_hthread *thr, duk_activation *entry_act) {
 duk_tval *tv1;
 duk_tval *tv2;

 duk_hthread *resumer;

 duk_activation *act;
 duk_catcher *cat;



 do { } while (0);
 do { } while (0);
 do { } while (0);
 tv1 = thr->valstack_top - 1;
 do { } while (0);
# 1615 "duk_js_executor.c"
 do { } while (0);
 do { } while (0);

 act = thr->callstack_curr;
 do { } while (0);

 for (;;) {
  cat = act->cat;
  if (cat == 
# 1623 "duk_js_executor.c" 3 4
            ((void *)0)
# 1623 "duk_js_executor.c"
                ) {
   break;
  }

  if (((cat)->flags & 0x0000000fUL) == 1 && ((cat)->flags & (1U << 5))) {
   do { } while (0);
   duk__handle_finally(thr, thr->valstack_top - 1, 6);

   do { } while (0);
   return 0;
  }

  duk_hthread_catcher_unwind_norz(thr, act);
 }

 if (act == entry_act) {





  do { } while (0);
  return 1;
 }

 if (thr->callstack_top >= 2) {



  do { } while (0)

                                                           ;

  do { } while (0);
  do { } while (0);
  do { } while (0);


  if (thr->callstack_curr->flags & ((1U << 2) | (1U << 5))) {
   duk_call_construct_postprocess(thr,
                                  thr->callstack_curr->flags &
                                      (1U << 5));
  }






  tv1 = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + thr->callstack_curr->parent->retval_byteoff);
  do { } while (0);
  tv2 = thr->valstack_top - 1;
  do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv1); tv__src = (tv2); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((tv__dst))->t & 0x08)) { h__obj = ((tv__dst)->v.heaphdr); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);


  duk_hthread_activation_unwind_norz(thr);

  duk__reconfig_valstack_ecma_return(thr);

  do { } while (0);
  return 0;
 }


 do { } while (0);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0)


                                     ;
 do { } while (0)
                                                                                            ;
 do { } while (0);
 do { } while (0);

 resumer = thr->resumer;
# 1719 "duk_js_executor.c"
 do { } while (0);
 duk_hthread_activation_unwind_norz(resumer);
 duk_push_tval(resumer, thr->valstack_top - 1);
 duk_push_hobject((resumer), (duk_hobject *) (thr));

 duk_hthread_terminate(thr);
 thr->resumer = 
# 1725 "duk_js_executor.c" 3 4
               ((void *)0)
# 1725 "duk_js_executor.c"
                   ;
 do { duk_heaphdr *duk__h = (duk_heaphdr *) ((resumer)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero)(((thr)), (duk_hobject *) duk__h); } } } while (0);
 do { } while (0);

 resumer->state = 2;
 do { (thr->heap)->curr_thread = (resumer); } while (0);

 do { } while (0);
 duk__handle_yield(thr, resumer, resumer->valstack_top - 2);
 thr = 
# 1734 "duk_js_executor.c" 3 4
      ((void *)0)
# 1734 "duk_js_executor.c"
          ;





 do { } while (0);
 return 0;





}
# 2215 "duk_js_executor.c"
static __attribute__((noinline)) void duk__handle_op_initset_initget(duk_hthread *thr, duk_uint_fast32_t ins) {
 duk_bool_t is_set = (((ins) &0xffUL) == 196);
 duk_uint_fast_t idx;
 duk_uint_t defprop_flags;
# 2231 "duk_js_executor.c"
 idx = (duk_uint_fast_t) (((ins) >> 16) & 0xffffUL);
 duk_dup(thr, (duk_idx_t) (idx + 0));
 duk_dup(thr, (duk_idx_t) (idx + 1));
 if (is_set) {
  defprop_flags =
      (1U << 8) | (1U << 9) | ((1U << 4) | (1U << 1)) | ((1U << 5) | (1U << 2));
 } else {
  defprop_flags =
      (1U << 7) | (1U << 9) | ((1U << 4) | (1U << 1)) | ((1U << 5) | (1U << 2));
 }
 duk_def_prop(thr, (duk_idx_t) (((ins) >> 8) & 0xffUL), defprop_flags);
}

static __attribute__((noinline)) void duk__handle_op_trycatch(duk_hthread *thr, duk_uint_fast32_t ins, duk_instr_t *curr_pc) {
 duk_activation *act;
 duk_catcher *cat;
 duk_tval *tv1;
 duk_small_uint_fast_t a;
 duk_small_uint_fast_t bc;
# 2280 "duk_js_executor.c"
 do { } while (0)






                                                      ;

 a = (((ins) >> 8) & 0xffUL);
 bc = (((ins) >> 16) & 0xffffUL);
# 2304 "duk_js_executor.c"
 duk_dup(thr, (duk_idx_t) bc);
 duk_to_undefined(thr, (duk_idx_t) bc);
 duk_to_undefined(thr, (duk_idx_t) (bc + 1));







 cat = duk_hthread_catcher_alloc(thr);
 do { } while (0);

 cat->flags = 1;
 cat->h_varname = 
# 2318 "duk_js_executor.c" 3 4
                 ((void *)0)
# 2318 "duk_js_executor.c"
                     ;
 cat->pc_base = (duk_instr_t *) curr_pc;
 cat->idx_base = (duk_size_t) (thr->valstack_bottom - thr->valstack) + bc;

 act = thr->callstack_curr;
 do { } while (0);
 cat->parent = act->cat;
 act->cat = cat;

 if (a & (1U << 0)) {
  cat->flags |= (1U << 4);
 }
 if (a & (1U << 1)) {
  cat->flags |= (1U << 5);
 }
 if (a & (1U << 2)) {
  do { } while (0);
  cat->flags |= (1U << 6);
  tv1 = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));
  do { } while (0);





  cat->h_varname = ((tv1)->v.hstring);
 } else if (a & (1U << 3)) {
  duk_hobjenv *env;
  duk_hobject *target;


  do { } while (0);
  do { } while (0);
  do { } while (0);
  if (act->lex_env == 
# 2352 "duk_js_executor.c" 3 4
                     ((void *)0)
# 2352 "duk_js_executor.c"
                         ) {
   do { } while (0);
   do { } while (0);

   duk_js_init_activation_environment_records_delayed(thr, act);
   do { } while (0);
   do { (void) (act); } while (0);
  }
  do { } while (0);
  do { } while (0);


  target = duk_to_hobject(thr, -1);
  do { } while (0);





  env = duk_hobjenv_alloc(thr, (1UL << (7 + (0))) | (((duk_uint_t) (15)) << (7 + (20))));
  do { } while (0);
  do { } while (0);
  env->target = target;
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (target))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  env->has_this = 1;
  do { } while (0);
  do { } while (0);

  do { } while (0);
  do { } while (0);
  do { } while (0);
  do { ((duk_hobject *) env)->prototype = (act->lex_env); } while (0);
  act->lex_env = (duk_hobject *) env;
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk_hobject *) env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);







  cat = act->cat;
  cat->flags |= (1U << 7);
 } else {
  ;
 }

 do { } while (0)




                                                      ;

 duk_pop_unsafe(thr);
}

static __attribute__((noinline)) duk_instr_t *duk__handle_op_endtry(duk_hthread *thr, duk_uint_fast32_t ins) {
 duk_activation *act;
 duk_catcher *cat;
 duk_tval *tv1;
 duk_instr_t *pc_base;

 do { (void) (ins); } while (0);

 do { } while (0);
 act = thr->callstack_curr;
 do { } while (0);
 cat = act->cat;
 do { } while (0);
 do { } while (0);

 do { } while (0);
 do { (cat)->flags &= ~(1U << 4); } while (0);

 pc_base = cat->pc_base;

 if (((cat)->flags & (1U << 5))) {
  do { } while (0);

  tv1 = thr->valstack + cat->idx_base;
  do { } while (0);
  do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv1); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 2; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
  tv1 = 
# 2435 "duk_js_executor.c" 3 4
       ((void *)0)
# 2435 "duk_js_executor.c"
           ;

  tv1 = thr->valstack + cat->idx_base + 1;
  do { } while (0);
  do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = ((tv1)); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((((duk_double_t) ((duk_uint32_t) 7)))); ; duk__tv = ((tv__dst)); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((((thr)))), duk__h); } } } while (0); } while (0);
  tv1 = 
# 2440 "duk_js_executor.c" 3 4
       ((void *)0)
# 2440 "duk_js_executor.c"
           ;

  do { (cat)->flags &= ~(1U << 5); } while (0);
 } else {
  do { } while (0)
                                                                                                                   ;

  duk_hthread_catcher_unwind_norz(thr, act);

 }

 return pc_base + 1;
}

static __attribute__((noinline)) duk_instr_t *duk__handle_op_endcatch(duk_hthread *thr, duk_uint_fast32_t ins) {
 duk_activation *act;
 duk_catcher *cat;
 duk_tval *tv1;
 duk_instr_t *pc_base;

 do { (void) (ins); } while (0);

 do { } while (0);
 act = thr->callstack_curr;
 do { } while (0);
 cat = act->cat;
 do { } while (0);
 do { } while (0);

 if (((cat)->flags & (1U << 7))) {
  duk_hobject *prev_env;


  do { } while (0);
  do { } while (0);

  do { } while (0);

  prev_env = act->lex_env;
  do { } while (0);
  act->lex_env = ((prev_env)->prototype);
  do { (cat)->flags &= ~(1U << 7); } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (act->lex_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) ((prev_env)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero)(((thr)), (duk_hobject *) duk__h); } } } while (0);

  do { } while (0);
  do { } while (0);
 }

 pc_base = cat->pc_base;

 if (((cat)->flags & (1U << 5))) {
  do { } while (0);

  tv1 = thr->valstack + cat->idx_base;
  do { } while (0);
  do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv1); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 2; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
  tv1 = 
# 2497 "duk_js_executor.c" 3 4
       ((void *)0)
# 2497 "duk_js_executor.c"
           ;

  tv1 = thr->valstack + cat->idx_base + 1;
  do { } while (0);
  do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = ((tv1)); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((((duk_double_t) ((duk_uint32_t) 7)))); ; duk__tv = ((tv__dst)); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((((thr)))), duk__h); } } } while (0); } while (0);
  tv1 = 
# 2502 "duk_js_executor.c" 3 4
       ((void *)0)
# 2502 "duk_js_executor.c"
           ;

  do { (cat)->flags &= ~(1U << 5); } while (0);
 } else {
  do { } while (0)
                                                                                                                     ;

  duk_hthread_catcher_unwind_norz(thr, act);

 }

 return pc_base + 1;
}

static __attribute__((noinline)) duk_small_uint_t duk__handle_op_endfin(duk_hthread *thr,
                                                                        duk_uint_fast32_t ins,
                                                                        duk_activation *entry_act) {
 duk_activation *act;
 duk_tval *tv1;
 duk_uint_t reg_catch;
 duk_small_uint_t cont_type;
 duk_small_uint_t ret_result;

 do { } while (0);
 do { } while (0);
 act = thr->callstack_curr;
 do { } while (0);
 reg_catch = (((ins) >> 8) & 0xffffffUL);






 do { } while (0)

                                                                           ;

 tv1 = thr->valstack_bottom + reg_catch + 1;
 do { } while (0);




 cont_type = (duk_small_uint_t) ((tv1)->v.d);


 tv1--;

 switch (cont_type) {
 case 7: {
  do { } while (0)
                                                                           ;

  duk_hthread_catcher_unwind_norz(thr, act);

  return 0;
 }
 case 6: {
  do { } while (0)

                            ;






  duk_push_tval(thr, tv1);
  ret_result = duk__handle_return(thr, entry_act);
  if (ret_result == 0) {
   return 0;
  }
  do { } while (0);

  do { } while (0);
  return 1;
 }
 case 4:
 case 5: {
  duk_uint_t label_id;
  duk_small_uint_t lj_type;







  do { } while (0);




  label_id = (duk_small_uint_t) ((tv1)->v.d);

  lj_type = cont_type;
  duk__handle_break_or_continue(thr, label_id, lj_type);
  return 0;
 }
 default: {
  do { } while (0)

                                         ;

  duk_err_setup_ljstate1(thr, (duk_small_uint_t) cont_type, tv1);


  do { } while (0);
  duk_err_longjmp(thr);
  do { __builtin_unreachable(); } while (0);
 }
 }

 do { __builtin_unreachable(); } while (0);
 return 0;
}

static __attribute__((noinline)) void duk__handle_op_initenum(duk_hthread *thr, duk_uint_fast32_t ins) {
 duk_small_uint_t b;
 duk_small_uint_t c;
# 2634 "duk_js_executor.c"
 b = (((ins) >> 16) & 0xffUL);
 c = (((ins) >> 24) & 0xffUL);

 if (((duk_get_type_mask((thr), ((duk_idx_t) c)) & ((1U << 2U) | (1U << 1U))) ? 1 : 0)) {
  duk_push_null(thr);
  duk_replace(thr, (duk_idx_t) b);
 } else {
  duk_dup(thr, (duk_idx_t) c);
  duk_to_object(thr, -1);
  duk_hobject_enumerator_create(thr, 0 );
  duk_replace(thr, (duk_idx_t) b);
 }
}

static __attribute__((noinline)) duk_small_uint_t duk__handle_op_nextenum(duk_hthread *thr, duk_uint_fast32_t ins) {
 duk_small_uint_t b;
 duk_small_uint_t c;
 duk_small_uint_t pc_skip = 0;
# 2663 "duk_js_executor.c"
 b = (((ins) >> 16) & 0xffUL);
 c = (((ins) >> 24) & 0xffUL);

 do { } while (0)

                                                                     ;

 if (duk_is_object(thr, (duk_idx_t) c)) {

  duk_dup(thr, (duk_idx_t) c);
  if (duk_hobject_enumerator_next(thr, 0 )) {

   do { } while (0);
   pc_skip = 1;
  } else {

   do { } while (0);
   do { } while (0);
   thr->valstack_top++;
  }
  duk_replace(thr, (duk_idx_t) b);
 } else {

  do { } while (0);
  do { } while (0);
 }

 return pc_skip;
}





static duk_bool_t duk__executor_handle_call(duk_hthread *thr, duk_idx_t idx, duk_idx_t nargs, duk_small_uint_t call_flags) {
 duk_bool_t rc;

 duk_set_top_unsafe(thr, (duk_idx_t) (idx + nargs + 2));





 rc = (duk_bool_t) duk_handle_call_unprotected(thr, idx, call_flags);
 if (rc != 0) {




  do { } while (0);

  do { } while (0);
  return rc;
 } else {

 }
 do { } while (0);
 return rc;
}
# 2876 "duk_js_executor.c"
static void duk__handle_executor_error(duk_heap *heap,
                                          duk_activation *entry_act,
                                          duk_int_t entry_call_recursion_depth,
                                          duk_jmpbuf *entry_jmpbuf_ptr,
                                          volatile duk_bool_t *out_delayed_catch_setup) {
 duk_small_uint_t lj_ret;




 do { } while (0);
 do { } while (0);




 heap->call_recursion_depth = entry_call_recursion_depth;





 heap->lj.jmpbuf_ptr = (duk_jmpbuf *) entry_jmpbuf_ptr;

 lj_ret = duk__handle_longjmp(heap->curr_thread, entry_act, out_delayed_catch_setup);







 do { } while (0);
 heap->pf_prevent_count--;
 do { } while (0);

 if (lj_ret == 0) {

  do { duk_refzero_check_slow((heap->curr_thread)); } while (0);
 } else {





  do { } while (0);
  do { } while (0);


  duk_err_longjmp(heap->curr_thread);
  do { __builtin_unreachable(); } while (0);
 }
}


static __attribute__ ((unused)) void duk_js_execute_bytecode(duk_hthread *exec_thr) {

 duk_hthread *entry_thread;
 duk_activation *entry_act;
 duk_int_t entry_call_recursion_depth;
 duk_jmpbuf *entry_jmpbuf_ptr;
 duk_jmpbuf our_jmpbuf;
 duk_heap *heap;
 volatile duk_bool_t delayed_catch_setup = 0;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 ;
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);

 entry_thread = exec_thr;
 heap = entry_thread->heap;
 entry_act = entry_thread->callstack_curr;
 do { } while (0);
 entry_call_recursion_depth = entry_thread->heap->call_recursion_depth;
 entry_jmpbuf_ptr = entry_thread->heap->lj.jmpbuf_ptr;
# 2968 "duk_js_executor.c"
 for (;;) {
  heap->lj.jmpbuf_ptr = &our_jmpbuf;
  do { } while (0);




  do { } while (0);
  if (
# 2976 "duk_js_executor.c" 3 4
     _setjmp (
# 2976 "duk_js_executor.c"
     (our_jmpbuf.jb)
# 2976 "duk_js_executor.c" 3 4
     ) 
# 2976 "duk_js_executor.c"
                               == 0) {

   do { } while (0);

   if (__builtin_expect((delayed_catch_setup != 0), 0)) {
    duk_hthread *thr = entry_thread->heap->curr_thread;

    delayed_catch_setup = 0;
    duk__handle_catch_part2(thr);
    do { } while (0);
    do { } while (0);
   }


   duk__js_execute_bytecode_inner(entry_thread, entry_act);


   heap->lj.jmpbuf_ptr = entry_jmpbuf_ptr;

   return;



  } else {




   do { } while (0);
   do { } while (0);

   duk__handle_executor_error(heap,
                              entry_act,
                              entry_call_recursion_depth,
                              entry_jmpbuf_ptr,
                              &delayed_catch_setup);
  }
# 3059 "duk_js_executor.c"
 }

 do { return; } while (0);
}


static __attribute__((noinline)) __attribute__((hot)) void duk__js_execute_bytecode_inner(duk_hthread *entry_thread, duk_activation *entry_act) {





 duk_instr_t *curr_pc;




 duk_hthread *thr;
 duk_tval *consts;
 duk_uint_fast32_t ins;
# 3102 "duk_js_executor.c"
 do { } while (0);



 do { } while (0);
# 3147 "duk_js_executor.c"
restart_execution:





 thr = entry_thread->heap->curr_thread;
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);

 thr->ptr_curr_pc = &curr_pc;


 {
  duk_activation *act;

  duk_hcompfunc *fun;





  act = thr->callstack_curr;
  do { } while (0);
  fun = (duk_hcompfunc *) ((act)->func);
  do { } while (0);
  do { } while (0);
  consts = ((duk_tval *) (void *) ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) (((duk_hbuffer_fixed *) (void *) (((fun)))->data))) + 1)));
  do { } while (0);
# 3195 "duk_js_executor.c"
  curr_pc = act->curr_pc;
 }

 do { } while (0)
# 3209 "duk_js_executor.c"
                                                        ;



 for (;;) {
  duk_uint8_t op;

  do { } while (0);
  do { } while (0);
  do { } while (0);
# 3307 "duk_js_executor.c"
  ins = *curr_pc++;
  do { } while (0);
# 3323 "duk_js_executor.c"
  op = (duk_uint8_t) ((ins) &0xffUL);
  switch (op) {
# 3372 "duk_js_executor.c"
  case 0: {
   duk_tval *tv1, *tv2;

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))));
   tv2 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffffUL << 4))));
   do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv1); tv__src = (tv2); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((tv__dst))->t & 0x08)) { h__obj = ((tv__dst)->v.heaphdr); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);
   break;
  }

  case 1: {
   duk_tval *tv1, *tv2;

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))));
   tv2 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffffUL << 4))));
   do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv2); tv__src = (tv1); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((tv__dst))->t & 0x08)) { h__obj = ((tv__dst)->v.heaphdr); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);
   break;
  }

  case 3: {
   duk_tval *tv1, *tv2;

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))));
   tv2 = ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffffUL << 4))));
   do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv1); tv__src = (tv2); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((tv__dst))->t & 0x08)) { h__obj = ((tv__dst)->v.heaphdr); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);
   break;
  }
# 3420 "duk_js_executor.c"
  case 4: {
   duk_tval *tv1;
   duk_int32_t val;

   val = (duk_int32_t) (((ins) >> 16) & 0xffffUL) - (duk_int32_t) (1L << 15);
   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))));
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = ((tv1)); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((((duk_double_t) (val)))); ; duk__tv = ((tv__dst)); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((((thr)))), duk__h); } } } while (0); } while (0);
   break;
  }
  case 5: {
   duk_tval *tv1;
   duk_int32_t val;

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))));
   do { } while (0);





   val = (duk_int32_t) ((tv1)->v.d);

   val =
       (duk_int32_t) ((duk_uint32_t) val << 16) + (duk_int32_t) (((ins) >> 16) & 0xffffUL);
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = ((tv1)); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((((duk_double_t) (val)))); ; duk__tv = ((tv__dst)); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((((thr)))), duk__h); } } } while (0); } while (0);
   break;
  }
# 3471 "duk_js_executor.c"
  case 6: {

   duk_tval *tv1, *tv2;

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffffUL << 4))));
   tv2 = thr->valstack_bottom - 1;
   do { } while (0);
   do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv1); tv__src = (tv2); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((tv__dst))->t & 0x08)) { h__obj = ((tv__dst)->v.heaphdr); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);
   break;
  }
  case 7: {
   duk_tval *tv1;

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffffUL << 4))));
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv1); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 2; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
   break;
  }
  case 8: {
   duk_tval *tv1;

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffffUL << 4))));
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv1); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 3; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
   break;
  }
  case 9: {
   duk_tval *tv1;

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffffUL << 4))));
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv1); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((1)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
   break;
  }
  case 10: {
   duk_tval *tv1;

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffffUL << 4))));
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv1); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((0)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
   break;
  }


  case 12: {
   duk__vm_bitwise_not(thr, (((ins) >> 16) & 0xffffUL), (((ins) >> 8) & 0xffUL));
   break;
  }

  case 13: {
   duk__vm_logical_not(thr, (((ins) >> 16) & 0xffffUL), (((ins) >> 8) & 0xffUL));
   break;
  }
# 3528 "duk_js_executor.c"
  case 14: {
   duk__vm_arith_unary_op(thr, (((ins) >> 16) & 0xffffUL), (((ins) >> 8) & 0xffUL), 14);
   break;
  }
  case 15: {
   duk__vm_arith_unary_op(thr, (((ins) >> 16) & 0xffffUL), (((ins) >> 8) & 0xffUL), 15);
   break;
  }
# 3548 "duk_js_executor.c"
  case 153: {
   duk_tval *tv;
   duk_small_uint_t stridx;
   duk_hstring *h_str;

   tv = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffffUL << 4))));
   stridx = duk_js_typeof_stridx(tv);
   do { } while (0);
   h_str = ((thr)->strs[(stridx)]);
   tv = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))));
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 8; duk__tv->v.hstring = ((h_str)); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((h_str)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
   break;
  }


  case 154: {
   duk_small_uint_t stridx;

   duk_hstring *h_str;

   duk_activation *act;
   duk_hstring *name;
   duk_tval *tv;





   tv = ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffffUL << 4))));
   do { } while (0);
   name = ((tv)->v.hstring);
   tv = 
# 3579 "duk_js_executor.c" 3 4
       ((void *)0)
# 3579 "duk_js_executor.c"
           ;
   act = thr->callstack_curr;
   if (duk_js_getvar_activation(thr, act, name, 0 )) {

    tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-2));
    stridx = duk_js_typeof_stridx(tv);
    tv = 
# 3585 "duk_js_executor.c" 3 4
        ((void *)0)
# 3585 "duk_js_executor.c"
            ;
    duk_pop_2_unsafe(thr);
   } else {

    stridx = 58;
   }
   do { } while (0);




   h_str = ((thr)->strs[(stridx)]);
   tv = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))));
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 8; duk__tv->v.hstring = ((h_str)); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((h_str)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
   break;

  }
# 3657 "duk_js_executor.c"
  case 16:
   { duk_bool_t tmp; tmp = duk_js_equals_helper((thr), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), 0); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 17:
   { duk_bool_t tmp; tmp = duk_js_equals_helper((thr), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), 0); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 18:
   { duk_bool_t tmp; tmp = duk_js_equals_helper((thr), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), 0); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 19:
   { duk_bool_t tmp; tmp = duk_js_equals_helper((thr), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), 0); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 20:
   { duk_bool_t tmp; tmp = duk_js_equals_helper((thr), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), 0); do { } while (0); tmp ^= 1; { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 21:
   { duk_bool_t tmp; tmp = duk_js_equals_helper((thr), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), 0); do { } while (0); tmp ^= 1; { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 22:
   { duk_bool_t tmp; tmp = duk_js_equals_helper((thr), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), 0); do { } while (0); tmp ^= 1; { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 23:
   { duk_bool_t tmp; tmp = duk_js_equals_helper((thr), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), 0); do { } while (0); tmp ^= 1; { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 24:
   { duk_bool_t tmp; tmp = duk_js_equals_helper(
# 3674 "duk_js_executor.c" 3 4
  ((void *)0)
# 3674 "duk_js_executor.c"
  , ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), (1U << 1)); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 25:
   { duk_bool_t tmp; tmp = duk_js_equals_helper(
# 3676 "duk_js_executor.c" 3 4
  ((void *)0)
# 3676 "duk_js_executor.c"
  , ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), (1U << 1)); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 26:
   { duk_bool_t tmp; tmp = duk_js_equals_helper(
# 3678 "duk_js_executor.c" 3 4
  ((void *)0)
# 3678 "duk_js_executor.c"
  , ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), (1U << 1)); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 27:
   { duk_bool_t tmp; tmp = duk_js_equals_helper(
# 3680 "duk_js_executor.c" 3 4
  ((void *)0)
# 3680 "duk_js_executor.c"
  , ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), (1U << 1)); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 28:
   { duk_bool_t tmp; tmp = duk_js_equals_helper(
# 3682 "duk_js_executor.c" 3 4
  ((void *)0)
# 3682 "duk_js_executor.c"
  , ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), (1U << 1)); do { } while (0); tmp ^= 1; { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 29:
   { duk_bool_t tmp; tmp = duk_js_equals_helper(
# 3684 "duk_js_executor.c" 3 4
  ((void *)0)
# 3684 "duk_js_executor.c"
  , ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), (1U << 1)); do { } while (0); tmp ^= 1; { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 30:
   { duk_bool_t tmp; tmp = duk_js_equals_helper(
# 3686 "duk_js_executor.c" 3 4
  ((void *)0)
# 3686 "duk_js_executor.c"
  , ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), (1U << 1)); do { } while (0); tmp ^= 1; { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 31:
   { duk_bool_t tmp; tmp = duk_js_equals_helper(
# 3688 "duk_js_executor.c" 3 4
  ((void *)0)
# 3688 "duk_js_executor.c"
  , ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), (1U << 1)); do { } while (0); tmp ^= 1; { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
# 3724 "duk_js_executor.c"
  case 32:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), (0)); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 33:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), (0)); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 34:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), (0)); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 35:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), (0)); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 36:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), ((1U << 1) | (1U << 0))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 37:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), ((1U << 1) | (1U << 0))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 38:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), ((1U << 1) | (1U << 0))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 39:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), ((1U << 1) | (1U << 0))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 40:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), ((1U << 1))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 41:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), ((1U << 1))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 42:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), ((1U << 1))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 43:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), ((1U << 1))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 44:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((1U << 0))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 45:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((1U << 0))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 46:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((1U << 0))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 47:
   { duk_bool_t tmp; tmp = duk_js_compare_helper(thr, ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))), ((((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))))), ((1U << 0))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };



  case 48: {
   if (duk_js_toboolean(((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffffUL << 4))))) != 0) {
    curr_pc++;
   }
   break;
  }
  case 49: {
   if (duk_js_toboolean(((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffffUL << 4))))) != 0) {
    curr_pc++;
   }
   break;
  }
  case 50: {
   if (duk_js_toboolean(((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffffUL << 4))))) == 0) {
    curr_pc++;
   }
   break;
  }
  case 51: {
   if (duk_js_toboolean(((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffffUL << 4))))) == 0) {
    curr_pc++;
   }
   break;
  }
# 3794 "duk_js_executor.c"
  case 52: {
   duk__vm_arith_add(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL));
   break;
  }
  case 53: {
   duk__vm_arith_add(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL));
   break;
  }
  case 54: {
   duk__vm_arith_add(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL));
   break;
  }
  case 55: {
   duk__vm_arith_add(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL));
   break;
  }
# 3841 "duk_js_executor.c"
  case 56: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 56);
   break;
  }
  case 57: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 56);
   break;
  }
  case 58: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 56);
   break;
  }
  case 59: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 56);
   break;
  }
  case 60: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 60);
   break;
  }
  case 61: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 60);
   break;
  }
  case 62: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 60);
   break;
  }
  case 63: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 60);
   break;
  }
  case 64: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 64);
   break;
  }
  case 65: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 64);
   break;
  }
  case 66: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 64);
   break;
  }
  case 67: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 64);
   break;
  }
  case 68: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 68);
   break;
  }
  case 69: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 68);
   break;
  }
  case 70: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 68);
   break;
  }
  case 71: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 68);
   break;
  }

  case 72: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 72);
   break;
  }
  case 73: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 72);
   break;
  }
  case 74: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 72);
   break;
  }
  case 75: {
   duk__vm_arith_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 72);
   break;
  }
# 3955 "duk_js_executor.c"
  case 76: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 76);
   break;
  }
  case 77: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 76);
   break;
  }
  case 78: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 76);
   break;
  }
  case 79: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 76);
   break;
  }
  case 80: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 80);
   break;
  }
  case 81: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 80);
   break;
  }
  case 82: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 80);
   break;
  }
  case 83: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 80);
   break;
  }
  case 84: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 84);
   break;
  }
  case 85: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 84);
   break;
  }
  case 86: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 84);
   break;
  }
  case 87: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 84);
   break;
  }
  case 88: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 88);
   break;
  }
  case 89: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 88);
   break;
  }
  case 90: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 88);
   break;
  }
  case 91: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 88);
   break;
  }
  case 92: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 92);
   break;
  }
  case 93: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 92);
   break;
  }
  case 94: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 92);
   break;
  }
  case 95: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 92);
   break;
  }
  case 96: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 96);
   break;
  }
  case 97: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 96);
   break;
  }
  case 98: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 96);
   break;
  }
  case 99: {
   duk__vm_bitwise_binary_op(thr, ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))), (((ins) >> 8) & 0xffUL), 96);
   break;
  }
# 4080 "duk_js_executor.c"
  case 100:
   { duk_bool_t tmp; tmp = duk_js_instanceof(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 101:
   { duk_bool_t tmp; tmp = duk_js_instanceof(thr, (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 102:
   { duk_bool_t tmp; tmp = duk_js_instanceof(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 103:
   { duk_bool_t tmp; tmp = duk_js_instanceof(thr, (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 104:
   { duk_bool_t tmp; tmp = duk_js_in(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 105:
   { duk_bool_t tmp; tmp = duk_js_in(thr, (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 106:
   { duk_bool_t tmp; tmp = duk_js_in(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 107:
   { duk_bool_t tmp; tmp = duk_js_in(thr, (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (tmp); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
# 4115 "duk_js_executor.c"
  case 120: {
   duk__prepost_incdec_reg_helper(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffffUL << 4)))), 120);
   break;
  }
  case 121: {
   duk__prepost_incdec_reg_helper(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffffUL << 4)))), 121);
   break;
  }
  case 122: {
   duk__prepost_incdec_reg_helper(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffffUL << 4)))), 122);
   break;
  }
  case 123: {
   duk__prepost_incdec_reg_helper(thr, ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))), ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffffUL << 4)))), 123);
   break;
  }
  case 124: {
   duk__prepost_incdec_var_helper(thr, (((ins) >> 8) & 0xffUL), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffffUL << 4)))), 124, ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)));
   break;
  }
  case 125: {
   duk__prepost_incdec_var_helper(thr, (((ins) >> 8) & 0xffUL), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffffUL << 4)))), 125, ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)));
   break;
  }
  case 126: {
   duk__prepost_incdec_var_helper(thr, (((ins) >> 8) & 0xffUL), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffffUL << 4)))), 126, ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)));
   break;
  }
  case 127: {
   duk__prepost_incdec_var_helper(thr, (((ins) >> 8) & 0xffUL), ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffffUL << 4)))), 127, ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)));
   break;
  }




  case 128:
  case 129:
  case 130:
  case 131:
  case 132:
  case 133:
  case 134:
  case 135:
  case 136:
  case 137:
  case 138:
  case 139:
  case 140:
  case 141:
  case 142:
  case 143: {
   duk_tval *tv_obj;
   duk_tval *tv_key;
   duk_tval *tv_val;
   duk_bool_t rc;
   duk_double_t x, y, z;

   duk_tval *tv_dst;
# 4185 "duk_js_executor.c"
   do { } while (0);
   do { } while (0);
   do { } while (0);
   do { } while (0);

   tv_obj = ((duk_tval *) (void *) ((duk_uint8_t *) (((ins) &(0x01UL)) ? consts : thr->valstack_bottom) + ((((ins)) >> (16 - 4)) & (0xffUL << 4))));
   tv_key = ((duk_tval *) (void *) ((duk_uint8_t *) (((ins) &(0x02UL)) ? consts : thr->valstack_bottom) + ((((ins)) >> (24 - 4)) & (0xffUL << 4))));
   rc = duk_hobject_getprop(thr, tv_obj, tv_key);
   do { (void) (rc); } while (0);
   tv_obj = 
# 4194 "duk_js_executor.c" 3 4
           ((void *)0)
# 4194 "duk_js_executor.c"
               ;
   tv_key = 
# 4195 "duk_js_executor.c" 3 4
           ((void *)0)
# 4195 "duk_js_executor.c"
               ;






   x = duk_to_number_m1(thr);
   duk_pop_unsafe(thr);
   if (ins & (0x04UL)) {
    y = x - 1.0;
   } else {
    y = x + 1.0;
   }

   duk_push_number(thr, y);
   tv_val = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));
   do { } while (0);
   tv_obj = ((duk_tval *) (void *) ((duk_uint8_t *) (((ins) &(0x01UL)) ? consts : thr->valstack_bottom) + ((((ins)) >> (16 - 4)) & (0xffUL << 4))));
   tv_key = ((duk_tval *) (void *) ((duk_uint8_t *) (((ins) &(0x02UL)) ? consts : thr->valstack_bottom) + ((((ins)) >> (24 - 4)) & (0xffUL << 4))));
   rc = duk_hobject_putprop(thr, tv_obj, tv_key, tv_val, ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)));
   do { (void) (rc); } while (0);
   tv_obj = 
# 4217 "duk_js_executor.c" 3 4
           ((void *)0)
# 4217 "duk_js_executor.c"
               ;
   tv_key = 
# 4218 "duk_js_executor.c" 3 4
           ((void *)0)
# 4218 "duk_js_executor.c"
               ;
   duk_pop_unsafe(thr);

   z = (ins & (0x08UL)) ? x : y;




   tv_dst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))));
   do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv_dst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk_double_t duk__dblval; duk__dblval = ((z)); ; duk__tv = (tv__dst); duk__tv->t = 0; duk__tv->v.d = duk__dblval; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
   break;

  }
# 4306 "duk_js_executor.c"
  case 108:
   { (void) duk_hobject_getprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))); { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { duk_tval *duk__tv; duk__tv = (duk__tvsrc); duk__tv->t = 2; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; }; };
  case 109:
   { (void) duk_hobject_getprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))); { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { duk_tval *duk__tv; duk__tv = (duk__tvsrc); duk__tv->t = 2; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; }; };
  case 110:
   { (void) duk_hobject_getprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))); { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { duk_tval *duk__tv; duk__tv = (duk__tvsrc); duk__tv->t = 2; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; }; };
  case 111:
   { (void) duk_hobject_getprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))); { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { duk_tval *duk__tv; duk__tv = (duk__tvsrc); duk__tv->t = 2; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; }; };

  case 208:
   { duk_tval *tv__targ; (void) duk_hobject_getprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))); do { } while (0); tv__targ = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)); if (__builtin_expect((!duk_is_callable_tval(thr, tv__targ)), 0)) { duk_call_setup_propcall_error(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))); } { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { duk_tval *duk__tv; duk__tv = (duk__tvsrc); duk__tv->t = 2; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; }; };
  case 209:
   { duk_tval *tv__targ; (void) duk_hobject_getprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))); do { } while (0); tv__targ = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)); if (__builtin_expect((!duk_is_callable_tval(thr, tv__targ)), 0)) { duk_call_setup_propcall_error(thr, (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))); } { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { duk_tval *duk__tv; duk__tv = (duk__tvsrc); duk__tv->t = 2; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; }; };
  case 210:
   { duk_tval *tv__targ; (void) duk_hobject_getprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))); do { } while (0); tv__targ = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)); if (__builtin_expect((!duk_is_callable_tval(thr, tv__targ)), 0)) { duk_call_setup_propcall_error(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))); } { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { duk_tval *duk__tv; duk__tv = (duk__tvsrc); duk__tv->t = 2; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; }; };
  case 211:
   { duk_tval *tv__targ; (void) duk_hobject_getprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))); do { } while (0); tv__targ = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)); if (__builtin_expect((!duk_is_callable_tval(thr, tv__targ)), 0)) { duk_call_setup_propcall_error(thr, (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))))); } { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { duk_tval *duk__tv; duk__tv = (duk__tvsrc); duk__tv->t = 2; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; }; };

  case 112:
   { (void) duk_hobject_putprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4))))), ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0))); break; };
  case 113:
   { (void) duk_hobject_putprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4))))), ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0))); break; };
  case 114:
   { (void) duk_hobject_putprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4))))), ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0))); break; };
  case 115:
   { (void) duk_hobject_putprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4))))), ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0))); break; };
  case 116:
   { duk_bool_t rc; rc = duk_hobject_delprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (24 - 4)) & (0xffUL << 4))))), ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (rc); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };
  case 118:
   { duk_bool_t rc; rc = duk_hobject_delprop(thr, (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffUL << 4))))), (((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (24 - 4)) & (0xffUL << 4))))), ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0))); do { } while (0); { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (rc); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; }; };



  case 144:
  case 145:
  case 146:
  case 147: {
   duk_activation *act;
   duk_small_uint_fast_t a = (((ins) >> 8) & 0xffUL);
   duk_tval *tv1;
   duk_hstring *name;
   duk_small_uint_t prop_flags;
   duk_bool_t is_func_decl;

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) (((ins) &(0x01UL)) ? consts : thr->valstack_bottom) + ((((ins)) >> (16 - 4)) & (0xffUL << 4))));
   do { } while (0);
   name = ((tv1)->v.hstring);
   do { } while (0);

   is_func_decl = ((a & (1U << 4)) != 0);
# 4364 "duk_js_executor.c"
   prop_flags = a & ((1U << 0) | (1U << 1) | (1U << 2) | (1U << 3));

   if (is_func_decl) {
    duk_push_tval(thr, ((duk_tval *) (void *) ((duk_uint8_t *) (((ins) &(0x02UL)) ? consts : thr->valstack_bottom) + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))));
   } else {
    do { } while (0);
    thr->valstack_top++;
   }
   tv1 = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));

   act = thr->callstack_curr;
   if (duk_js_declvar_activation(thr, act, name, tv1, prop_flags, is_func_decl)) {
    if (is_func_decl) {

     tv1 = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));
     duk_js_putvar_activation(thr, act, name, tv1, ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)));
    } else {



    }
   }

   duk_pop_unsafe(thr);
   break;
  }





  case 148:
  case 149:
  case 150:
  case 151: {





   duk_push_tval(thr, ((duk_tval *) (void *) ((duk_uint8_t *) (((ins) &(0x02UL)) ? consts : thr->valstack_bottom) + ((((ins)) >> (24 - 4)) & (0xffUL << 4)))));
   duk_push_tval(thr, ((duk_tval *) (void *) ((duk_uint8_t *) (((ins) &(0x01UL)) ? consts : thr->valstack_bottom) + ((((ins)) >> (16 - 4)) & (0xffUL << 4)))));
   duk_regexp_create_instance(thr);
   { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { duk_tval *duk__tv; duk__tv = (duk__tvsrc); duk__tv->t = 2; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; };
  }



  case 172:
  case 173:
  case 174:
  case 175: {
# 4424 "duk_js_executor.c"
   duk_activation *act;
   duk_uint_fast_t idx;
   duk_tval *tv1;
   duk_hstring *name;





   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) (((ins) &(0x01UL)) ? consts : thr->valstack_bottom) + ((((ins)) >> (16 - 4)) & (0xffUL << 4))));
   do { } while (0);
   name = ((tv1)->v.hstring);
   do { } while (0);
   act = thr->callstack_curr;
   (void) duk_js_getvar_activation(thr, act, name, 1 );

   idx = (duk_uint_fast_t) (((ins) >> 8) & 0xffUL);


   duk_replace(thr, (duk_idx_t) (idx + 1));
   duk_replace(thr, (duk_idx_t) idx);
   break;
  }

  case 152: {
   duk_activation *act;
   duk_hcompfunc *fun_act;
   duk_small_uint_fast_t bc = (((ins) >> 16) & 0xffffUL);
   duk_hobject *fun_temp;





   do { } while (0)


                                                                                     ;

   do { } while (0);
   do { } while (0);

   act = thr->callstack_curr;
   fun_act = (duk_hcompfunc *) ((act)->func);
   fun_temp = (((fun_act))->funcs)[bc];
   do { } while (0);
   do { } while (0);

   do { } while (0)
                                                                                                             ;

   if (act->lex_env == 
# 4475 "duk_js_executor.c" 3 4
                      ((void *)0)
# 4475 "duk_js_executor.c"
                          ) {
    do { } while (0);
    duk_js_init_activation_environment_records_delayed(thr, act);
    act = thr->callstack_curr;
   }
   do { } while (0);
   do { } while (0);





   duk_js_push_closure(thr, (duk_hcompfunc *) fun_temp, act->var_env, act->lex_env, 1 );
   { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { duk_tval *duk__tv; duk__tv = (duk__tvsrc); duk__tv->t = 2; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; };
  }

  case 11: {
   duk_activation *act;
   duk_tval *tv1;
   duk_hstring *name;

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffffUL << 4))));
   do { } while (0);
   name = ((tv1)->v.hstring);
   do { } while (0);
   act = thr->callstack_curr;
   do { } while (0);
   (void) duk_js_getvar_activation(thr, act, name, 1 );
   duk_pop_unsafe(thr);
   { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { duk_tval *duk__tv; duk__tv = (duk__tvsrc); duk__tv->t = 2; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; };
  }

  case 155: {
   duk_activation *act;
   duk_tval *tv1;
   duk_hstring *name;

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffffUL << 4))));
   do { } while (0);
   name = ((tv1)->v.hstring);
   do { } while (0);





   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))));
   act = thr->callstack_curr;
   duk_js_putvar_activation(thr, act, name, tv1, ((duk_small_uint_t) (((&((duk_hobject *) ((duk_hcompfunc *) (((thr)->callstack_curr)->func)))->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)));
   break;
  }

  case 156: {
   duk_activation *act;
   duk_tval *tv1;
   duk_hstring *name;
   duk_bool_t rc;

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffffUL << 4))));
   do { } while (0);
   name = ((tv1)->v.hstring);
   do { } while (0);
   act = thr->callstack_curr;
   rc = duk_js_delvar_activation(thr, act, name);
   { duk_bool_t duk__bval; duk_tval *duk__tvdst; duk__bval = (rc); do { } while (0); duk__tvdst = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4)))); do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (duk__tvdst); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 4; duk__tv->v.i = (duk_small_int_t) ((duk__bval)); } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0); break; };
  }

  case 2: {




   curr_pc += (duk_int_fast_t) (((ins) >> 8) & 0xffffffUL) - (duk_int_fast_t) (1L << 23);
   break;
  }
# 4588 "duk_js_executor.c"
  case 157: {
   duk_tval *tv;

   do { duk_activation *duk__act; duk__act = thr->callstack_curr; duk__act->curr_pc = curr_pc; thr->ptr_curr_pc = 
# 4591 "duk_js_executor.c" 3 4
  ((void *)0)
# 4591 "duk_js_executor.c"
  ; } while (0);
   tv = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffffUL << 4))));
   do { *(thr->valstack_top) = *(tv); } while (0);
   do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   thr->valstack_top++;
   do { duk_small_uint_t ret_result; do { } while (0); ret_result = duk__handle_return(thr, entry_act); if (ret_result == 0) { goto restart_execution; } do { } while (0); return; } while (0);
  }

  case 159: {
   duk_tval *tv;

   do { duk_activation *duk__act; duk__act = thr->callstack_curr; duk__act->curr_pc = curr_pc; thr->ptr_curr_pc = 
# 4602 "duk_js_executor.c" 3 4
  ((void *)0)
# 4602 "duk_js_executor.c"
  ; } while (0);
   tv = ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffffUL << 4))));
   do { *(thr->valstack_top) = *(tv); } while (0);
   do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   thr->valstack_top++;
   do { duk_small_uint_t ret_result; do { } while (0); ret_result = duk__handle_return(thr, entry_act); if (ret_result == 0) { goto restart_execution; } do { } while (0); return; } while (0);
  }
  case 160: {
   duk_tval *tv;

   do { duk_activation *duk__act; duk__act = thr->callstack_curr; duk__act->curr_pc = curr_pc; thr->ptr_curr_pc = 
# 4612 "duk_js_executor.c" 3 4
  ((void *)0)
# 4612 "duk_js_executor.c"
  ; } while (0);
   tv = ((duk_tval *) (void *) ((duk_uint8_t *) consts + ((((ins)) >> (16 - 4)) & (0xffffUL << 4))));
   do { *(thr->valstack_top) = *(tv); } while (0);


   do { } while (0);

   thr->valstack_top++;
   do { duk_small_uint_t ret_result; do { } while (0); ret_result = duk__handle_return(thr, entry_act); if (ret_result == 0) { goto restart_execution; } do { } while (0); return; } while (0);
  }
  case 158: {
   do { duk_activation *duk__act; duk__act = thr->callstack_curr; duk__act->curr_pc = curr_pc; thr->ptr_curr_pc = 
# 4623 "duk_js_executor.c" 3 4
  ((void *)0)
# 4623 "duk_js_executor.c"
  ; } while (0);
   thr->valstack_top++;
   do { } while (0);
   do { duk_small_uint_t ret_result; do { } while (0); ret_result = duk__handle_return(thr, entry_act); if (ret_result == 0) { goto restart_execution; } do { } while (0); return; } while (0);
  }


  case 161: {
   duk_activation *act;
   duk_catcher *cat;
   duk_small_uint_fast_t bc = (((ins) >> 16) & 0xffffUL);



   cat = duk_hthread_catcher_alloc(thr);
   do { } while (0);

   cat->flags = (duk_uint32_t) (2 | (bc << 8));
   cat->pc_base = (duk_instr_t *) curr_pc;
   cat->idx_base = 0;
   cat->h_varname = 
# 4643 "duk_js_executor.c" 3 4
                   ((void *)0)
# 4643 "duk_js_executor.c"
                       ;

   act = thr->callstack_curr;
   do { } while (0);
   cat->parent = act->cat;
   act->cat = cat;

   do { } while (0)





                                                       ;

   curr_pc += 2;
   break;
  }

  case 162: {
   duk_activation *act;







   act = thr->callstack_curr;
   do { } while (0);
   do { } while (0);
   do { } while (0);
   duk_hthread_catcher_unwind_nolexenv_norz(thr, act);


   break;
  }

  case 163: {
   duk_small_uint_fast_t bc = (((ins) >> 16) & 0xffffUL);

   do { duk_activation *duk__act; duk__act = thr->callstack_curr; duk__act->curr_pc = curr_pc; thr->ptr_curr_pc = 
# 4684 "duk_js_executor.c" 3 4
  ((void *)0)
# 4684 "duk_js_executor.c"
  ; } while (0);
   duk__handle_break_or_continue(thr, (duk_uint_t) bc, 4);
   goto restart_execution;
  }

  case 164: {
   duk_small_uint_fast_t bc = (((ins) >> 16) & 0xffffUL);

   do { duk_activation *duk__act; duk__act = thr->callstack_curr; duk__act->curr_pc = curr_pc; thr->ptr_curr_pc = 
# 4692 "duk_js_executor.c" 3 4
  ((void *)0)
# 4692 "duk_js_executor.c"
  ; } while (0);
   duk__handle_break_or_continue(thr, (duk_uint_t) bc, 5);
   goto restart_execution;
  }


  case 165: {
   duk__handle_op_trycatch(thr, ins, curr_pc);
   curr_pc += 2;
   break;
  }

  case 166: {
   curr_pc = duk__handle_op_endtry(thr, ins);
   break;
  }

  case 167: {
   duk__handle_op_endcatch(thr, ins);
   break;
  }

  case 168: {

   do { duk_activation *duk__act; duk__act = thr->callstack_curr; duk__act->curr_pc = curr_pc; thr->ptr_curr_pc = 
# 4716 "duk_js_executor.c" 3 4
  ((void *)0)
# 4716 "duk_js_executor.c"
  ; } while (0);

   if (duk__handle_op_endfin(thr, ins, entry_act) != 0) {
    return;
   }


   goto restart_execution;
  }

  case 169: {
   duk_small_uint_fast_t bc = (((ins) >> 16) & 0xffffUL);
# 4738 "duk_js_executor.c"
   do { duk_activation *duk__act; duk__act = thr->callstack_curr; duk__act->curr_pc = curr_pc; thr->ptr_curr_pc = 
# 4738 "duk_js_executor.c" 3 4
  ((void *)0)
# 4738 "duk_js_executor.c"
  ; } while (0);

   duk_dup(thr, (duk_idx_t) bc);
   do { } while (0)
                                                            ;

   duk_err_augment_error_throw(thr);
   do { } while (0)
                                                                                                              ;


   duk_err_setup_ljstate1(thr, 1, ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)));




   do { } while (0);
   duk_err_longjmp(thr);
   do { __builtin_unreachable(); } while (0);
   break;
  }

  case 171: {






   duk_small_uint_fast_t a = (((ins) >> 8) & 0xffUL);
   duk_small_uint_fast_t bc = (((ins) >> 16) & 0xffffUL);
# 4779 "duk_js_executor.c"
   duk_tval *tv1;
   duk_tval *tv2;
   duk_tval *tv3;
   duk_tval tv_tmp1;
   duk_tval tv_tmp2;

   tv1 = (thr->valstack_bottom + (bc));
   tv2 = tv1 + 1;
   do { *(&tv_tmp1) = *(tv1); } while (0);
   do { *(&tv_tmp2) = *(tv2); } while (0);
   tv3 = (thr->valstack_bottom + (a));
   do { *(tv1) = *(tv3); } while (0);
   do { duk_tval *duk__tv = ((tv1)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   do { duk_tval *duk__tv; duk__tv = (tv2); duk__tv->t = 2; } while (0);
   do { duk_tval *duk__tv = ((&tv_tmp1)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((thr)), duk__h); } } } while (0);
   do { duk_tval *duk__tv = ((&tv_tmp2)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((thr)), duk__h); } } } while (0);

   break;
  }







  case 176:
  case 177:
  case 178:
  case 179:
  case 180:
  case 181:
  case 182:
  case 183: {







   duk_idx_t nargs;
   duk_idx_t idx;
   duk_small_uint_t call_flags;

   duk_hcompfunc *fun;


   do { } while (0);
   do { } while (0);

   nargs = (duk_idx_t) (((ins) >> 8) & 0xffUL);
   call_flags = (ins & 0x07U) | (1U << 3);
   idx = (duk_idx_t) (((ins) >> 16) & 0xffffUL);

   if (duk__executor_handle_call(thr, idx, nargs, call_flags)) {

    do { } while (0);
    goto restart_execution;
   }
   do { } while (0);





   fun = ((duk_hcompfunc *) (((thr)->callstack_curr)->func));

   duk_set_top_unsafe(thr, (duk_idx_t) fun->nregs);
# 4856 "duk_js_executor.c"
   break;
  }

  case 184:
  case 185:
  case 186:
  case 187:
  case 188:
  case 189:
  case 190:
  case 191: {

   duk_uint_fast_t nargs;
   duk_idx_t idx;
   duk_small_uint_t call_flags;

   duk_hcompfunc *fun;


   do { } while (0);
   do { } while (0);

   nargs = (duk_uint_fast_t) (((ins) >> 8) & 0xffUL);
   do { duk_tval *tv_ind; tv_ind = (thr->valstack_bottom + (nargs)); do { } while (0); nargs = (duk_uint_fast_t) ((tv_ind)->v.d); } while (0);
   call_flags = (ins & 0x07U) | (1U << 3);
   idx = (duk_idx_t) (((ins) >> 16) & 0xffffUL);

   if (duk__executor_handle_call(thr, idx, (duk_idx_t) nargs, call_flags)) {
    do { } while (0);
    goto restart_execution;
   }
   do { } while (0);


   fun = ((duk_hcompfunc *) (((thr)->callstack_curr)->func));

   duk_set_top_unsafe(thr, (duk_idx_t) fun->nregs);
   break;
  }

  case 192: {
   duk_push_object(thr);
# 4910 "duk_js_executor.c"
   duk_hobject_resize_entrypart(thr, duk_known_hobject(thr, -1), (((ins) >> 8) & 0xffUL));

   { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffffUL << 4))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { duk_tval *duk__tv; duk__tv = (duk__tvsrc); duk__tv->t = 2; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; };
  }

  case 193: {
   duk_push_array(thr);
# 4929 "duk_js_executor.c"
   duk_hobject_realloc_props(thr,
                             duk_known_hobject(thr, -1),
                             0 ,
                             (((ins) >> 8) & 0xffUL) ,
                             0 ,
                             0 );




   { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffffUL << 4))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { duk_tval *duk__tv; duk__tv = (duk__tvsrc); duk__tv->t = 2; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; };
  }

  case 194:
  case 195: {
   duk_idx_t obj_idx;
   duk_uint_fast_t idx, idx_end;
   duk_small_uint_fast_t count;
# 4955 "duk_js_executor.c"
   obj_idx = (((ins) >> 8) & 0xffUL);
   do { } while (0);

   idx = (duk_uint_fast_t) (((ins) >> 16) & 0xffUL);
   if (((ins) &0xffUL) == 195) {
    do { duk_tval *tv_ind; tv_ind = (thr->valstack_bottom + (idx)); do { } while (0); idx = (duk_uint_fast_t) ((tv_ind)->v.d); } while (0);
   }

   count = (duk_small_uint_fast_t) (((ins) >> 24) & 0xffUL);
   do { } while (0);
   idx_end = idx + count;
# 4984 "duk_js_executor.c"
   do {

    duk_dup(thr, (duk_idx_t) idx);
    duk_dup(thr, (duk_idx_t) (idx + 1));
    duk_def_prop(thr,
                 obj_idx,
                 (1U << 6) | (1U << 9) | ((1U << 3) | (1U << 0)) |
                     ((1U << 4) | (1U << 1)) | ((1U << 5) | (1U << 2)));
    idx += 2;
   } while (idx < idx_end);
   break;
  }

  case 196:
  case 197: {
   duk__handle_op_initset_initget(thr, ins);
   break;
  }

  case 198:
  case 199: {
   duk_idx_t obj_idx;
   duk_uint_fast_t idx, idx_end;
   duk_small_uint_fast_t count;
   duk_tval *tv1;
   duk_uint32_t arr_idx;







   obj_idx = (((ins) >> 8) & 0xffUL);
   do { } while (0);

   idx = (duk_uint_fast_t) (((ins) >> 16) & 0xffUL);
   if (((ins) &0xffUL) == 199) {
    do { duk_tval *tv_ind; tv_ind = (thr->valstack_bottom + (idx)); do { } while (0); idx = (duk_uint_fast_t) ((tv_ind)->v.d); } while (0);
   }

   count = (duk_small_uint_fast_t) (((ins) >> 24) & 0xffUL);
   do { } while (0);
   idx_end = idx + count;
# 5037 "duk_js_executor.c"
   tv1 = (thr->valstack_bottom + (idx));
   do { } while (0);




   arr_idx = (duk_uint32_t) ((tv1)->v.d);

   idx++;

   do {
# 5060 "duk_js_executor.c"
    duk_dup(thr, (duk_idx_t) idx);
    duk_xdef_prop_index((thr), (obj_idx), (arr_idx), ((1U << 0) | (1U << 1) | (1U << 2)));

    idx++;
    arr_idx++;
   } while (idx < idx_end);





   duk_set_length(thr, obj_idx, (duk_size_t) (duk_uarridx_t) arr_idx);
   break;
  }

  case 200: {
   duk_tval *tv1;
   duk_hobject *h;
   duk_uint32_t len;

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (8 - 4)) & (0xffUL << 4))));
   do { } while (0);
   h = ((tv1)->v.hobject);
   do { } while (0);

   tv1 = ((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffffUL << 4))));
   do { } while (0);




   len = (duk_uint32_t) ((tv1)->v.d);

   ((duk_harray *) h)->length = len;
   break;
  }

  case 201: {
   duk__handle_op_initenum(thr, ins);
   break;
  }

  case 202: {
   curr_pc += duk__handle_op_nextenum(thr, ins);
   break;
  }

  case 170: {
   do { do { duk_errcode_t duk__err = (4); duk_int_t duk__line = (duk_int_t) 5108; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_executor.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid lvalue"))); } while (0); } while (0);
   do { return; } while (0);
   break;
  }

  case 204: {
# 5130 "duk_js_executor.c"
   do { } while (0);

   break;
  }

  case 205: {



   break;
  }

  case 206: {
   do { duk_errcode_t duk__err = (1); duk_int_t duk__line = (duk_int_t) 5143; do { } while (0); do { } while (0); duk_err_handle_error_fmt((thr), "duk_js_executor.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("INVALID opcode (%ld)"), ((long) (((ins) >> 8) & 0xffffffUL))); } while (0);
   do { return; } while (0);
   break;
  }


  case 203: {
   duk_push_new_target(thr);
   { do { duk_hthread *duk__thr; duk_tval *duk__tvsrc; duk_tval *duk__tvdst; duk_tval duk__tvtmp; duk__thr = (thr); duk__tvsrc = ((((void) 0), ((void) 0)), ((duk_hthread *) (duk__thr))->valstack_top + (-1)); duk__tvdst = (((duk_tval *) (void *) ((duk_uint8_t *) thr->valstack_bottom + ((((ins)) >> (16 - 4)) & (0xffffUL << 4))))); do { *(&duk__tvtmp) = *(duk__tvdst); } while (0); do { *(duk__tvdst) = *(duk__tvsrc); } while (0); do { duk_tval *duk__tv; duk__tv = (duk__tvsrc); duk__tv->t = 2; } while (0); duk__thr->valstack_top = duk__tvsrc; do { duk_tval *duk__tv = ((&duk__tvtmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero(((duk__thr)), duk__h); } } } while (0); } while (0); break; };
  }
# 5171 "duk_js_executor.c"
  case 207:
  case 212:
  case 213:
  case 214:
  case 215:
  case 216:
  case 217:
  case 218:
  case 219:
  case 220:
  case 221:
  case 222:
  case 223:
  case 224:
  case 225:
  case 226:
  case 227:
  case 228:
  case 229:
  case 230:
  case 231:
  case 232:
  case 233:
  case 234:
  case 235:
  case 236:
  case 237:
  case 238:
  case 239:
  case 240:
  case 241:
  case 242:
  case 243:
  case 244:
  case 245:
  case 246:
  case 247:
  case 248:
  case 249:
  case 250:
  case 251:
  case 252:
  case 253:
  case 254:
  case 255:
# 5226 "duk_js_executor.c"
  {

   do { } while (0);
   do { do { duk_err_error((thr), "duk_js_executor.c", (duk_int_t) 5229, (("invalid opcode"))); } while (0); do { return; } while (0); } while (0);
   break;
  }

  }

  continue;
# 5251 "duk_js_executor.c"
 }
 do { return; } while (0);






}
# 1 "duk_js_ops.c"
# 58 "duk_js_ops.c"
static __attribute__ ((unused)) duk_bool_t duk_js_toboolean(duk_tval *tv) {
 switch (((tv)->t)) {
 case 2:
 case 3:
  return 0;
 case 4:
  do { } while (0);
  return ((duk_small_uint_t) (tv)->v.i);
 case 8: {




  duk_hstring *h = ((tv)->v.hstring);
  do { } while (0);
  return (((h)->blen) > 0 ? 1 : 0);
 }
 case 9: {
  return 1;
 }
 case 10: {



  return 1;
 }
 case 5: {
  void *p = ((tv)->v.voidptr);
  return (p != 
# 86 "duk_js_ops.c" 3 4
              ((void *)0) 
# 86 "duk_js_ops.c"
                   ? 1 : 0);
 }
 case 6: {
  return 1;
 }
# 99 "duk_js_ops.c"
 default: {

  duk_double_t d;



  do { } while (0);
  do { } while (0);
  d = ((tv)->v.d);
# 116 "duk_js_ops.c"
  do { } while (0);
  return duk_double_is_nan_or_zero(d) ^ 1;

 }
 }
 do { __builtin_unreachable(); } while (0);
 do { } while (0);
}
# 155 "duk_js_ops.c"
static duk_double_t duk__tonumber_string_raw(duk_hthread *thr) {
 duk_small_uint_t s2n_flags;
 duk_double_t d;

 do { } while (0);




 s2n_flags = (1U << 0) | (1U << 1) | (1U << 3) | (1U << 4) |
             (1U << 5) | (1U << 6) | (1U << 7) |
             (1U << 8) | (1U << 9) | (1U << 10) |
             (1U << 11) | (1U << 13) | (1U << 14);

 duk_numconv_parse(thr, 10 , s2n_flags);





 thr->valstack_top--;
 do { } while (0);
 do { } while (0);
 do { } while (0);
 d = ((thr->valstack_top)->v.d);
 do { duk_tval *duk__tv; duk__tv = (thr->valstack_top); duk__tv->t = 2; } while (0);


 return d;
}

static __attribute__ ((unused)) duk_double_t duk_js_tonumber(duk_hthread *thr, duk_tval *tv) {
 do { } while (0);
 do { } while (0);

 switch (((tv)->t)) {
 case 2: {

  duk_double_union du;
  do { (&du)->d = 
# 194 "duk_js_ops.c" 3 4
 (__builtin_nanf (""))
# 194 "duk_js_ops.c"
 ; } while (0);
  do { } while (0);
  return du.d;
 }
 case 3: {

  return 0.0;
 }
 case 4: {
  if ((((tv)->t == 4) && ((tv)->v.i != 0))) {
   return 1.0;
  }
  return 0.0;
 }
 case 8: {

  duk_hstring *h = ((tv)->v.hstring);
  if (__builtin_expect(((((&(h)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
   do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 212; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_ops.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("cannot number coerce Symbol"))); } while (0); } while (0);
   do { return 0.0; } while (0);
  }
  duk_push_hstring(thr, h);
  return duk__tonumber_string_raw(thr);
 }
 case 10:
 case 9: {
  duk_double_t d;
  duk_push_tval(thr, tv);
  duk_to_primitive(thr, -1, 2);




  do { } while (0);
  d = duk_js_tonumber(thr, duk_get_tval(thr, -1));

  duk_pop_unsafe(thr);
  return d;
 }
 case 5: {

  void *p = ((tv)->v.voidptr);
  return (p != 
# 236 "duk_js_ops.c" 3 4
              ((void *)0) 
# 236 "duk_js_ops.c"
                   ? 1.0 : 0.0);
 }
 case 6: {

  return 
# 240 "duk_js_ops.c" 3 4
        (__builtin_nanf (""))
# 240 "duk_js_ops.c"
                      ;
 }




 default: {

  do { } while (0);
  do { } while (0);
  return ((tv)->v.d);
 }
 }

 do { __builtin_unreachable(); } while (0);
 do { } while (0);
}






static __attribute__ ((unused)) duk_double_t duk_js_tointeger_number(duk_double_t x) {
# 281 "duk_js_ops.c"
 if (__builtin_expect((duk_double_is_nan_or_inf(x) != 0U), 0)) {
  if (duk_double_is_nan(x)) {
   return 0.0;
  } else {
   return x;
  }
 } else {
  return duk_double_trunc_towards_zero(x);
 }

}

static __attribute__ ((unused)) duk_double_t duk_js_tointeger(duk_hthread *thr, duk_tval *tv) {

 duk_double_t d = duk_js_tonumber(thr, tv);
 return duk_js_tointeger_number(d);
}






static duk_double_t duk__toint32_touint32_helper(duk_double_t x, duk_bool_t is_toint32) {
# 315 "duk_js_ops.c"
 if (duk_double_is_nan_zero_inf(x)) {
  return 0.0;
 }



 x = duk_double_trunc_towards_zero(x);





 x = fmod(x, 4294967296.0);

 if (x < 0.0) {
  x += 4294967296.0;
 }
 do { } while (0);

 if (is_toint32) {
  if (x >= 2147483648.0) {


   x -= 4294967296.0;
  }
 }

 return x;
}

static __attribute__ ((unused)) duk_int32_t duk_js_toint32(duk_hthread *thr, duk_tval *tv) {
 duk_double_t d;







 d = duk_js_tonumber(thr, tv);
 d = duk__toint32_touint32_helper(d, 1);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 return (duk_int32_t) d;
}

static __attribute__ ((unused)) duk_uint32_t duk_js_touint32(duk_hthread *thr, duk_tval *tv) {
 duk_double_t d;







 d = duk_js_tonumber(thr, tv);
 d = duk__toint32_touint32_helper(d, 0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 return (duk_uint32_t) d;
}

static __attribute__ ((unused)) duk_uint16_t duk_js_touint16(duk_hthread *thr, duk_tval *tv) {

 return (duk_uint16_t) (duk_js_touint32(thr, tv) & 0x0000ffffU);
}
# 411 "duk_js_ops.c"
static duk_bool_t duk__js_equals_number(duk_double_t x, duk_double_t y) {
# 433 "duk_js_ops.c"
 if (duk_double_equals(x, y)) {

  do { } while (0);
  do { } while (0);
  return 1;
 } else {




  do { } while (0);
  return 0;
 }

}

static duk_bool_t duk__js_samevalue_number(duk_double_t x, duk_double_t y) {
# 477 "duk_js_ops.c"
 duk_small_int_t cx = (duk_small_int_t) 
# 477 "duk_js_ops.c" 3 4
                                       __builtin_fpclassify (0, 1, 4, 3, 2, 
# 477 "duk_js_ops.c"
                                       x
# 477 "duk_js_ops.c" 3 4
                                       )
# 477 "duk_js_ops.c"
                                                        ;
 duk_small_int_t cy = (duk_small_int_t) 
# 478 "duk_js_ops.c" 3 4
                                       __builtin_fpclassify (0, 1, 4, 3, 2, 
# 478 "duk_js_ops.c"
                                       y
# 478 "duk_js_ops.c" 3 4
                                       )
# 478 "duk_js_ops.c"
                                                        ;

 if (duk_double_equals(x, y)) {

  do { } while (0);
  do { } while (0);


  if (__builtin_expect((cx == 
# 486 "duk_js_ops.c" 3 4
     2 
# 486 "duk_js_ops.c"
     && cy == 
# 486 "duk_js_ops.c" 3 4
     2
# 486 "duk_js_ops.c"
     ), 0)) {





   return duk_double_same_sign(x, y);
  }
  return 1;
 } else {




  do { } while (0);




  if (__builtin_expect((cx == 
# 505 "duk_js_ops.c" 3 4
     0 
# 505 "duk_js_ops.c"
     && cy == 
# 505 "duk_js_ops.c" 3 4
     0
# 505 "duk_js_ops.c"
     ), 0)) {

   return 1;
  }
  return 0;
 }

}

static __attribute__ ((unused)) duk_bool_t duk_js_equals_helper(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y, duk_small_uint_t flags) {
 duk_uint_t type_mask_x;
 duk_uint_t type_mask_y;




 do { } while (0);
# 539 "duk_js_ops.c"
     if (((tv_x)->t == 0) && ((tv_y)->t == 0)) {
  duk_double_t d1, d2;




  d1 = ((tv_x)->v.d);
  d2 = ((tv_y)->v.d);
  if (__builtin_expect(((flags & (1U << 0)) != 0), 0)) {

   return duk__js_samevalue_number(d1, d2);
  } else {

   return duk__js_equals_number(d1, d2);
  }
 } else if (((tv_x)->t) == ((tv_y)->t)) {
  switch (((tv_x)->t)) {
  case 2:
  case 3: {
   return 1;
  }
  case 4: {
   return ((duk_small_uint_t) (tv_x)->v.i) == ((duk_small_uint_t) (tv_y)->v.i);
  }
  case 5: {
   return ((tv_x)->v.voidptr) == ((tv_y)->v.voidptr);
  }
  case 8:
  case 9: {




   return ((tv_x)->v.heaphdr) == ((tv_y)->v.heaphdr);
  }
  case 10: {





   return ((tv_x)->v.heaphdr) == ((tv_y)->v.heaphdr);
  }
  case 6: {



   duk_small_uint_t lf_flags_x;
   duk_small_uint_t lf_flags_y;
   duk_c_function func_x;
   duk_c_function func_y;

   do { (lf_flags_x) = (duk_uint32_t) (tv_x)->v_extra; (func_x) = (tv_x)->v.lightfunc; } while (0);
   do { (lf_flags_y) = (duk_uint32_t) (tv_y)->v_extra; (func_y) = (tv_y)->v.lightfunc; } while (0);
   return ((func_x == func_y) && (lf_flags_x == lf_flags_y)) ? 1 : 0;
  }



  default: {
   do { } while (0);
   do { } while (0);
   do { } while (0);
   do { } while (0);
   do { __builtin_unreachable(); } while (0);
   do { } while (0);
  }
  }
 }

 if ((flags & ((1U << 1) | (1U << 0))) != 0) {
  return 0;
 }

 do { } while (0);
# 622 "duk_js_ops.c"
 type_mask_x = duk_get_type_mask_tval(tv_x);
 type_mask_y = duk_get_type_mask_tval(tv_y);


 if ((type_mask_x & ((1U << 1U) | (1U << 2U))) &&
     (type_mask_y & ((1U << 2U) | (1U << 1U)))) {
  return 1;
 }


 if ((type_mask_x & (1U << 4U)) && (type_mask_y & (1U << 5U))) {
  if (!(((&((((tv_y))->v.hstring))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)) {
   duk_double_t d1, d2;
   d1 = ((tv_x)->v.d);
   d2 = duk_to_number_tval(thr, tv_y);
   return duk__js_equals_number(d1, d2);
  }
 }
 if ((type_mask_x & (1U << 5U)) && (type_mask_y & (1U << 4U))) {
  if (!(((&((((tv_x))->v.hstring))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)) {
   duk_double_t d1, d2;
   d1 = ((tv_y)->v.d);
   d2 = duk_to_number_tval(thr, tv_x);
   return duk__js_equals_number(d1, d2);
  }
 }
# 656 "duk_js_ops.c"
 if (type_mask_x & (1U << 3U)) {
  do { } while (0);
  duk_push_uint(thr, ((duk_small_uint_t) (tv_x)->v.i));
  duk_push_tval(thr, tv_y);
  goto recursive_call;
 }
 if (type_mask_y & (1U << 3U)) {
  do { } while (0);
  duk_push_tval(thr, tv_x);
  duk_push_uint(thr, ((duk_small_uint_t) (tv_y)->v.i));
  goto recursive_call;
 }


 if ((type_mask_x & ((1U << 5U) | (1U << 4U))) && (type_mask_y & (1U << 6U))) {

  duk_push_tval(thr, tv_x);
  duk_push_tval(thr, tv_y);
  duk_to_primitive(thr, -1, 0);
  goto recursive_call;
 }
 if ((type_mask_x & (1U << 6U)) && (type_mask_y & ((1U << 5U) | (1U << 4U)))) {

  duk_push_tval(thr, tv_x);
  duk_push_tval(thr, tv_y);
  duk_to_primitive(thr, -2, 0);
  goto recursive_call;
 }


 return 0;

recursive_call:

 {
  duk_bool_t rc;
  rc = duk_js_equals_helper(thr, ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-2)), ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)), 0 );
  duk_pop_2_unsafe(thr);
  return rc;
 }
}
# 709 "duk_js_ops.c"
static __attribute__ ((unused)) duk_small_int_t duk_js_data_compare(const duk_uint8_t *buf1,
                                                 const duk_uint8_t *buf2,
                                                 duk_size_t len1,
                                                 duk_size_t len2) {
 duk_size_t prefix_len;
 duk_small_int_t rc;

 prefix_len = (len1 <= len2 ? len1 : len2);




 rc = duk_memcmp_unsafe((const void *) buf1, (const void *) buf2, (size_t) prefix_len);

 if (rc < 0) {
  return -1;
 } else if (rc > 0) {
  return 1;
 }


 if (len1 < len2) {

  return -1;
 } else if (len1 > len2) {
  return 1;
 }

 return 0;
}

static __attribute__ ((unused)) duk_small_int_t duk_js_string_compare(duk_hstring *h1, duk_hstring *h2) {
# 754 "duk_js_ops.c"
 do { } while (0);
 do { } while (0);

 return duk_js_data_compare((const duk_uint8_t *) ((const duk_uint8_t *) ((h1) + 1)),
                            (const duk_uint8_t *) ((const duk_uint8_t *) ((h2) + 1)),
                            (duk_size_t) ((h1)->blen),
                            (duk_size_t) ((h2)->blen));
}
# 841 "duk_js_ops.c"
static duk_bool_t duk__compare_number(duk_bool_t retval, duk_double_t d1, duk_double_t d2) {





 do { } while (0);
 if (d1 < d2) {




  do { } while (0);





  return retval ^ 1;
 } else {
  if (d2 < d1) {




   return retval;
  } else {




   if (duk_double_is_nan(d1) || duk_double_is_nan(d2)) {




    return 0;
   } else {
    return retval;
   }
  }
 }
}


static __attribute__ ((unused)) duk_bool_t duk_js_compare_helper(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y, duk_small_uint_t flags) {
 duk_double_t d1, d2;
 duk_small_int_t rc;
 duk_bool_t retval;

 do { } while (0);
 retval = flags & (1U << 0);
 do { } while (0);
# 904 "duk_js_ops.c"
 if (__builtin_expect((((tv_x)->t == 0) && ((tv_y)->t == 0)), 1)) {
  return duk__compare_number(retval, ((tv_x)->v.d), ((tv_y)->v.d));
 }




 duk_push_tval(thr, tv_x);
 duk_push_tval(thr, tv_y);

 if (flags & (1U << 1)) {
  duk_to_primitive(thr, -2, 2);
  duk_to_primitive(thr, -1, 2);
 } else {
  duk_to_primitive(thr, -1, 2);
  duk_to_primitive(thr, -2, 2);
 }


 tv_x = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-2));
 tv_y = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1));

 if (((tv_x)->t == 8) && ((tv_y)->t == 8)) {
  duk_hstring *h1 = ((tv_x)->v.hstring);
  duk_hstring *h2 = ((tv_y)->v.hstring);
  do { } while (0);
  do { } while (0);

  if (__builtin_expect((!(((&(h1)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0) && !(((&(h2)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 1)) {
   rc = duk_js_string_compare(h1, h2);
   duk_pop_2_unsafe(thr);
   if (rc < 0) {
    return retval ^ 1;
   } else {
    return retval;
   }
  }




 }
# 957 "duk_js_ops.c"
 d1 = duk_to_number_m2(thr);
 d2 = duk_to_number_m1(thr);







 do { } while (0);
 do { } while (0);
 do { } while (0);
 thr->valstack_top -= 2;
 tv_x = thr->valstack_top;
 tv_y = tv_x + 1;
 do { duk_tval *duk__tv; duk__tv = (tv_x); duk__tv->t = 2; } while (0);
 do { duk_tval *duk__tv; duk__tv = (tv_y); duk__tv->t = 2; } while (0);


 return duk__compare_number(retval, d1, d2);
}
# 996 "duk_js_ops.c"
static duk_bool_t duk__js_instanceof_helper(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y, duk_bool_t skip_sym_check) {
 duk_hobject *func;
 duk_hobject *val;
 duk_hobject *proto;
 duk_tval *tv;
 duk_bool_t skip_first;
 duk_uint_t sanity;
# 1014 "duk_js_ops.c"
 duk_push_tval(thr, tv_x);
 duk_push_tval(thr, tv_y);
 func = duk_require_hobject(thr, -1);
 do { } while (0);





 if (!skip_sym_check) {
  if (duk_get_method_stridx(thr, -1, 77)) {

   duk_insert(thr, -3);
   duk_swap_top(thr, -2);
   duk_call_method(thr, 1);
   return duk_to_boolean_top_pop(thr);
  }
 }
# 1045 "duk_js_ops.c"
 if (!(((&((func))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)) {







  goto error_invalid_rval;
 }

 if ((((&(func)->hdr)->h_flags & ((1UL << (7 + (3))))) != 0)) {
  duk_push_tval(thr, &((duk_hboundfunc *) (void *) func)->target);
  duk_replace(thr, -2);
  func = duk_require_hobject(thr, -1);




  do { } while (0);
  do { } while (0);
 }







 do { } while (0);
 do { } while (0);
 do { } while (0);






 skip_first = 0;
 tv = ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-2));
 switch (((tv)->t)) {
 case 6:
  val = thr->builtins[5];
  do { } while (0);
  break;
 case 10:
  val = thr->builtins[42];
  do { } while (0);
  break;
 case 5:
  val = thr->builtins[36];
  do { } while (0);
  break;
 case 9:
  skip_first = 1;
  val = ((tv)->v.hobject);
  do { } while (0);
  break;
 default:
  goto pop2_and_false;
 }
 do { } while (0);




 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (50))));

 proto = duk_get_hobject(thr, -1);
 if (proto == 
# 1114 "duk_js_ops.c" 3 4
             ((void *)0)
# 1114 "duk_js_ops.c"
                 ) {
  goto error_invalid_rval_noproto;
 }




 sanity = 10000L;
 do {
# 1141 "duk_js_ops.c"
  if (!val) {
   goto pop3_and_false;
  }

  do { } while (0);

  val = duk_hobject_resolve_proxy_target(val);


  if (skip_first) {
   skip_first = 0;
  } else if (val == proto) {
   goto pop3_and_true;
  }

  do { } while (0);
  val = ((val)->prototype);
 } while (--sanity > 0);

 do { } while (0);
 do { duk_err_range((thr), "duk_js_ops.c", (duk_int_t) 1161, ("prototype chain limit")); } while (0);
 do { return 0; } while (0);

pop2_and_false:
 duk_pop_2_unsafe(thr);
 return 0;

pop3_and_false:
 duk_pop_3_unsafe(thr);
 return 0;

pop3_and_true:
 duk_pop_3_unsafe(thr);
 return 1;

error_invalid_rval:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 1177; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_ops.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid instanceof rval"))); } while (0); } while (0);
 do { return 0; } while (0);


error_invalid_rval_noproto:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 1182; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_ops.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("instanceof rval has no .prototype"))); } while (0); } while (0);
 do { return 0; } while (0);

}


static __attribute__ ((unused)) duk_bool_t duk_js_instanceof_ordinary(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y) {
 return duk__js_instanceof_helper(thr, tv_x, tv_y, 1 );
}


static __attribute__ ((unused)) duk_bool_t duk_js_instanceof(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y) {
 return duk__js_instanceof_helper(thr, tv_x, tv_y, 0 );
}
# 1207 "duk_js_ops.c"
static __attribute__ ((unused)) duk_bool_t duk_js_in(duk_hthread *thr, duk_tval *tv_x, duk_tval *tv_y) {
 duk_bool_t retval;
# 1227 "duk_js_ops.c"
 duk_push_tval(thr, tv_x);
 duk_push_tval(thr, tv_y);
 ((void) duk_check_type_mask((thr), (-1), ((1U << 6U) | (1U << 9U) | (1U << 7U)) | (1U << 10)));

 (void) duk_to_property_key_hstring(thr, -2);

 retval = duk_hobject_hasprop(thr, ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-1)), ((((void) 0), ((void) 0)), ((duk_hthread *) (thr))->valstack_top + (-2)));

 duk_pop_2_unsafe(thr);
 return retval;
}
# 1253 "duk_js_ops.c"
static __attribute__ ((unused)) duk_small_uint_t duk_js_typeof_stridx(duk_tval *tv_x) {
 duk_small_uint_t stridx = 0;

 switch (((tv_x)->t)) {
 case 2: {
  stridx = 58;
  break;
 }
 case 3: {

  stridx = 57;
  break;
 }
 case 4: {
  stridx = 53;
  break;
 }
 case 5: {

  stridx = 95;
  break;
 }
 case 8: {
  duk_hstring *str;


  str = ((tv_x)->v.hstring);
  do { } while (0);
  if (__builtin_expect(((((&(str)->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)), 0)) {
   stridx = 56;
  } else {
   stridx = 55;
  }
  break;
 }
 case 9: {
  duk_hobject *obj = ((tv_x)->v.hobject);
  do { } while (0);
  if ((((&((obj))->hdr)->h_flags & ((1UL << (7 + (2))))) != 0)) {
   stridx = 133;
  } else {
   stridx = 57;
  }
  break;
 }
 case 10: {




  stridx = 57;
  break;
 }
 case 6: {
  stridx = 133;
  break;
 }



 default: {

  do { } while (0);
  do { } while (0);
  stridx = 54;
  break;
 }
 }

 do { } while (0);
 return stridx;
}





static __attribute__ ((unused)) duk_bool_t duk_js_isarray_hobject(duk_hobject *h) {
 do { } while (0);

 h = duk_hobject_resolve_proxy_target(h);

 return ((((&(h)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 2 ? 1 : 0);
}

static __attribute__ ((unused)) duk_bool_t duk_js_isarray(duk_tval *tv) {
 do { } while (0);
 if (((tv)->t == 9)) {
  return duk_js_isarray_hobject(((tv)->v.hobject));
 }
 return 0;
}
# 1356 "duk_js_ops.c"
static __attribute__ ((unused)) duk_uarridx_t duk_js_to_arrayindex_string(const duk_uint8_t *str, duk_uint32_t blen) {
 duk_uarridx_t res;
# 1366 "duk_js_ops.c"
 res = 0;
 if (blen == 0) {
  goto parse_fail;
 }
 do {
  duk_uarridx_t dig;
  dig = (duk_uarridx_t) (*str++) - 0x30;

  if (dig <= 9U) {







   if (__builtin_expect((res >= 0x19999999UL), 0)) {
    if (res >= 0x1999999aUL) {

     goto parse_fail;
    }
    do { } while (0);
    if (dig >= 6U) {
     goto parse_fail;
    }
    res = 0xfffffffaUL + dig;
    do { } while (0);
    do { } while (0);
   } else {
    res = res * 10U + dig;
    if (__builtin_expect((res == 0), 0)) {





     if (blen == (duk_uint32_t) 1) {
      return 0;
     }
     goto parse_fail;
    }
   }
  } else {



   goto parse_fail;
  }
 } while (--blen > 0);

 return res;

parse_fail:
 return (0xffffffffUL);
}
# 1 "duk_js_var.c"
# 39 "duk_js_var.c"
typedef struct {
 duk_hobject *env;
 duk_hobject *holder;
 duk_tval *value;
 duk_uint_t attrs;
 duk_bool_t has_this;
} duk__id_lookup_result;
# 73 "duk_js_var.c"
static void duk__inc_data_inner_refcounts(duk_hthread *thr, duk_hcompfunc *f) {
 duk_tval *tv, *tv_end;
 duk_hobject **funcs, **funcs_end;

 do { (void) (thr); } while (0);






 do { } while (0);

 tv = ((duk_tval *) (void *) ((duk_uint8_t *) (((duk_hbuffer_fixed *) (void *) (((duk_hbuffer_fixed *) (void *) (((f)))->data))) + 1)));
 tv_end = ((duk_tval *) (void *) (((f))->funcs));
 while (tv < tv_end) {
  do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  tv++;
 }

 funcs = (((f))->funcs);
 funcs_end = ((duk_hobject **) (void *) (((f))->bytecode));
 while (funcs < funcs_end) {
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) *funcs)); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  funcs++;
 }
}
# 108 "duk_js_var.c"
static const duk_uint16_t duk__closure_copy_proplist[] = {

 100,
 99,

 102,


 94,




};

static __attribute__ ((unused))
void duk_js_push_closure(duk_hthread *thr,
                         duk_hcompfunc *fun_temp,
                         duk_hobject *outer_var_env,
                         duk_hobject *outer_lex_env,
                         duk_bool_t add_auto_proto) {
 duk_hcompfunc *fun_clos;
 duk_harray *formals;
 duk_small_uint_t i;
 duk_uint_t len_value;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { (void) (len_value); } while (0);

 do { } while (0);

 fun_clos = duk_push_hcompfunc(thr);
 do { } while (0);
 do { } while (0);

 duk_push_hobject(thr, &fun_temp->obj);

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { (fun_clos)->data = (duk_hbuffer *) (((duk_hbuffer_fixed *) (void *) (fun_temp)->data)); } while (0);
 do { (fun_clos)->funcs = (((fun_temp)->funcs)); } while (0);
 do { (fun_clos)->bytecode = (((fun_temp)->bytecode)); } while (0);






 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (((duk_hbuffer_fixed *) (void *) (fun_clos)->data)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 duk__inc_data_inner_refcounts(thr, fun_temp);

 fun_clos->nregs = fun_temp->nregs;
 fun_clos->nargs = fun_temp->nargs;





 do { } while (0);
 do { } while (0);
 do { } while (0);





 do { } while (0);
# 194 "duk_js_var.c"
 do { ((duk_heaphdr *) fun_clos)->h_flags = (((duk_heaphdr *) fun_clos)->h_flags & ~((~0x00000003UL))) | ((((duk_heaphdr *) fun_temp)->h_flags)); } while (0);
 do { } while (0)

                                                                                         ;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 do { } while (0);
 do { } while (0);
 do { } while (0);

 if (!(((&(&fun_clos->obj)->hdr)->h_flags & ((1UL << (7 + (1))))) != 0)) {




  add_auto_proto = 0;
 }
# 234 "duk_js_var.c"
 if ((((&(&fun_clos->obj)->hdr)->h_flags & ((1UL << (7 + (11))))) != 0)) {

  if ((((&(&fun_clos->obj)->hdr)->h_flags & ((1UL << (7 + (12))))) != 0)) {
   duk_hobject *proto;
   duk_hdecenv *new_env;
# 249 "duk_js_var.c"
   if (outer_lex_env) {
    proto = outer_lex_env;
   } else {
    proto = thr->builtins[1];
   }


   new_env =
       duk_hdecenv_alloc(thr,
                         (1UL << (7 + (0))) | (((duk_uint_t) (16)) << (7 + (20))));
   do { } while (0);
   duk_push_hobject(thr, (duk_hobject *) new_env);

   do { } while (0);
   do { ((duk_hobject *) new_env)->prototype = (proto); } while (0);
   do { if ((proto) != 
# 264 "duk_js_var.c" 3 4
  ((void *)0)
# 264 "duk_js_var.c"
  ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((proto)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0);

   do { } while (0);
   do { } while (0);
# 278 "duk_js_var.c"
   (void) (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (93))));

   duk_dup_m4(thr);
   duk_xdef_prop(thr, -3, 0);




   do { (fun_clos)->lex_env = ((duk_hobject *) new_env); } while (0);
   do { (fun_clos)->var_env = ((duk_hobject *) new_env); } while (0);
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk_hobject *) new_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((duk_hobject *) new_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   duk_pop_unsafe(thr);


  } else

  {






   do { (fun_clos)->lex_env = (outer_lex_env); } while (0);
   do { (fun_clos)->var_env = (outer_lex_env); } while (0);
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (outer_lex_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (outer_lex_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);


  }
 } else {
# 318 "duk_js_var.c"
  do { } while (0);

  do { (fun_clos)->lex_env = (outer_lex_env); } while (0);
  do { (fun_clos)->var_env = (outer_var_env); } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (outer_lex_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
  do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (outer_var_env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 }
 do { } while (0)

                                                         ;


 do { } while (0);
 do { } while (0);
# 347 "duk_js_var.c"
 do { } while (0)

                                                          ;

 for (i = 0; i < (duk_small_uint_t) (sizeof(duk__closure_copy_proplist) / sizeof(duk_uint16_t)); i++) {
  duk_small_int_t stridx = (duk_small_int_t) duk__closure_copy_proplist[i];
  if ((((void) 0), ((void) 0), duk_xget_owndataprop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (stridx))))) {

   do { } while (0);
   (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-3)) << 24) + (((duk_uint_t) (stridx)) << 8) + (duk_uint_t) (((1U << 2)))));
  } else {
   do { } while (0);
   duk_pop_unsafe(thr);
  }
 }
# 372 "duk_js_var.c"
 formals = duk_hobject_get_formals(thr, (duk_hobject *) fun_temp);
 if (formals) {
  len_value = (duk_uint_t) formals->length;
  do { } while (0);
 } else {
  len_value = fun_temp->nargs;
  do { } while (0);
 }

 duk_push_uint(thr, len_value);
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-3)) << 24) + (((duk_uint_t) (87)) << 8) + (duk_uint_t) (((1U << 2)))));
# 400 "duk_js_var.c"
 if (add_auto_proto) {
  duk_push_object(thr);
  duk_dup_m3(thr);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (51)) << 8) + (duk_uint_t) (((1U << 0) | (1U << 2)))))


                                                   ;
  duk_compact(thr, -1);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-3)) << 24) + (((duk_uint_t) (50)) << 8) + (duk_uint_t) (((1U << 0)))));
 }
# 421 "duk_js_var.c"
 if ((((&(&fun_clos->obj)->hdr)->h_flags & ((1UL << (7 + (9))))) != 0)) {
  duk_xdef_prop_stridx_thrower(thr, -2, 69);
  duk_xdef_prop_stridx_thrower(thr, -2, 67);
 } else {





  do { } while (0);

 }
# 445 "duk_js_var.c"
 if ((((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-1)) << 16) + ((duk_uint_t) (93))))) {

  do { } while (0);
  do { } while (0);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-3)) << 24) + (((duk_uint_t) (93)) << 8) + (duk_uint_t) (((1U << 2)))));
 } else {




  do { } while (0);
  duk_pop_unsafe(thr);
 }
# 469 "duk_js_var.c"
 duk_compact(thr, -2);





 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);
 do { } while (0);







 do { } while (0)

                                                          ;

 duk_pop_unsafe(thr);


}
# 506 "duk_js_var.c"
static void duk__preallocate_env_entries(duk_hthread *thr, duk_hobject *varmap, duk_hobject *env) {
 duk_uint_fast32_t i;

 for (i = 0; i < (duk_uint_fast32_t) ((varmap)->e_next); i++) {
  duk_hstring *key;

  key = (((duk_hstring **) (void *) (((((varmap)))->props) + ((((varmap)))->e_size) * sizeof(duk_propvalue)))[(i)]);
  do { } while (0);
  do { } while (0);
# 523 "duk_js_var.c"
  duk_push_undefined(thr);
  do { } while (0);
  duk_hobject_define_property_internal(thr, env, key, ((1U << 0) | (1U << 1)));
 }
}


static __attribute__ ((unused))
duk_hobject *duk_create_activation_environment_record(duk_hthread *thr, duk_hobject *func, duk_size_t bottom_byteoff) {
 duk_hdecenv *env;
 duk_hobject *parent;
 duk_hcompfunc *f;

 do { } while (0);
 do { } while (0);

 do { } while (0);

 f = (duk_hcompfunc *) func;
 parent = ((f)->lex_env);
 if (!parent) {
  parent = thr->builtins[1];
 }

 env = duk_hdecenv_alloc(thr, (1UL << (7 + (0))) | (((duk_uint_t) (16)) << (7 + (20))));
 do { } while (0);
 duk_push_hobject(thr, (duk_hobject *) env);

 do { } while (0);
 do { ((duk_hobject *) env)->prototype = (parent); } while (0);
 do { if ((parent) != 
# 553 "duk_js_var.c" 3 4
((void *)0)
# 553 "duk_js_var.c"
) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) ((parent)))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0); } } while (0);



 do { } while (0);
 do { } while (0);
 do { } while (0);
 if ((((&(func)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
  duk_hobject *varmap;

  varmap = duk_hobject_get_varmap(thr, func);
  if (varmap != 
# 564 "duk_js_var.c" 3 4
               ((void *)0)
# 564 "duk_js_var.c"
                   ) {
   env->varmap = varmap;
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (varmap))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   env->thread = thr;
   do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) &(thr)->obj)); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   env->regbase_byteoff = bottom_byteoff;




   duk__preallocate_env_entries(thr, varmap, (duk_hobject *) env);
  } else {

   do { } while (0);
   do { } while (0);
   do { } while (0);
  }
 }

 return (duk_hobject *) env;
}

static __attribute__ ((unused))
void duk_js_init_activation_environment_records_delayed(duk_hthread *thr, duk_activation *act) {
 duk_hobject *func;
 duk_hobject *env;

 do { } while (0);
 func = ((act)->func);
 do { } while (0);
 do { } while (0);





 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);

 env = duk_create_activation_environment_record(thr, func, act->bottom_byteoff);
 do { } while (0);


 do { } while (0);
# 621 "duk_js_var.c"
 act->lex_env = env;
 act->var_env = env;
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) (((duk_heaphdr *) (env))); do { } while (0); do { } while (0); if (1) { (++(duk__h)->h_refcount); do { } while (0); } } while (0);

 duk_pop_unsafe(thr);
}
# 637 "duk_js_var.c"
static __attribute__ ((unused)) void duk_js_close_environment_record(duk_hthread *thr, duk_hobject *env) {
 duk_uint_fast32_t i;
 duk_hobject *varmap;
 duk_hstring *key;
 duk_tval *tv;
 duk_uint_t regnum;

 do { } while (0);
 do { } while (0);

 if (__builtin_expect((!((((&((env))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 16)), 0)) {
  do { } while (0);
  return;
 }

 varmap = ((duk_hdecenv *) env)->varmap;
 if (varmap == 
# 653 "duk_js_var.c" 3 4
              ((void *)0)
# 653 "duk_js_var.c"
                  ) {
  do { } while (0);

  return;
 }
 do { } while (0);
 do { } while (0);

 do { } while (0);
 do { } while (0);


 do { } while (0);
# 678 "duk_js_var.c"
 do { } while (0);
# 689 "duk_js_var.c"
 for (i = 0; i < (duk_uint_fast32_t) ((varmap)->e_next); i++) {
  duk_size_t regbase_byteoff;

  key = (((duk_hstring **) (void *) (((((varmap)))->props) + ((((varmap)))->e_size) * sizeof(duk_propvalue)))[(i)]);
  do { } while (0);
  do { } while (0);

  tv = (&(((duk_propvalue *) (void *) ((((((varmap))))->props)))[((i))]).v);
  do { } while (0);
  do { } while (0);




  regnum = (duk_uint_t) ((tv)->v.d);


  regbase_byteoff = ((duk_hdecenv *) env)->regbase_byteoff;
  do { } while (0)
                                           ;
  do { } while (0)
                                               ;
# 724 "duk_js_var.c"
  duk_push_tval(thr,
                (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + regbase_byteoff + sizeof(duk_tval) * regnum));
  do { } while (0)


                                                           ;
  duk_hobject_define_property_internal(thr, env, key, ((1U << 0) | (1U << 1)));
 }


 do { duk_heaphdr *duk__h = (duk_heaphdr *) ((((duk_hdecenv *) env)->thread)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)(((thr)), (duk_hobject *) duk__h); } } } while (0);
 do { duk_heaphdr *duk__h = (duk_heaphdr *) ((((duk_hdecenv *) env)->varmap)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero_norz)(((thr)), (duk_hobject *) duk__h); } } } while (0);
 ((duk_hdecenv *) env)->thread = 
# 736 "duk_js_var.c" 3 4
                                ((void *)0)
# 736 "duk_js_var.c"
                                    ;
 ((duk_hdecenv *) env)->varmap = 
# 737 "duk_js_var.c" 3 4
                                ((void *)0)
# 737 "duk_js_var.c"
                                    ;

 do { } while (0);
}
# 766 "duk_js_var.c"
static
duk_bool_t duk__getid_open_decl_env_regs(duk_hthread *thr, duk_hstring *name, duk_hdecenv *env, duk__id_lookup_result *out) {
 duk_tval *tv;
 duk_size_t reg_rel;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);
 do { } while (0);

 if (env->thread == 
# 779 "duk_js_var.c" 3 4
                   ((void *)0)
# 779 "duk_js_var.c"
                       ) {

  return 0;
 }
 do { } while (0);

 tv = duk_hobject_find_entry_tval_ptr(thr->heap, env->varmap, name);
 if (__builtin_expect((tv == 
# 786 "duk_js_var.c" 3 4
    ((void *)0)
# 786 "duk_js_var.c"
    ), 0)) {
  return 0;
 }

 do { } while (0);
 do { } while (0);




 reg_rel = (duk_size_t) ((tv)->v.d);

 do { } while (0);

 tv = (duk_tval *) (void *) ((duk_uint8_t *) env->thread->valstack + env->regbase_byteoff + sizeof(duk_tval) * reg_rel);
 do { } while (0);

 out->value = tv;
 out->attrs = ((1U << 0));
 out->env = (duk_hobject *) env;
 out->holder = 
# 806 "duk_js_var.c" 3 4
              ((void *)0)
# 806 "duk_js_var.c"
                  ;
 out->has_this = 0;
 return 1;
}


static
duk_bool_t duk__getid_activation_regs(duk_hthread *thr, duk_hstring *name, duk_activation *act, duk__id_lookup_result *out) {
 duk_tval *tv;
 duk_hobject *func;
 duk_hobject *varmap;
 duk_size_t reg_rel;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 func = ((act)->func);
 do { } while (0);
 do { } while (0);

 if (!(((&(func)->hdr)->h_flags & ((1UL << (7 + (4))))) != 0)) {
  return 0;
 }


 varmap = duk_hobject_get_varmap(thr, func);
 if (!varmap) {
  return 0;
 }

 tv = duk_hobject_find_entry_tval_ptr(thr->heap, varmap, name);
 if (!tv) {
  return 0;
 }
 do { } while (0);
 reg_rel = (duk_size_t) ((tv)->v.d);
 do { } while (0);
 do { } while (0);

 tv = (duk_tval *) (void *) ((duk_uint8_t *) thr->valstack + act->bottom_byteoff);
 tv += reg_rel;

 out->value = tv;
 out->attrs = ((1U << 0));
 out->env = 
# 852 "duk_js_var.c" 3 4
           ((void *)0)
# 852 "duk_js_var.c"
               ;
 out->holder = 
# 853 "duk_js_var.c" 3 4
              ((void *)0)
# 853 "duk_js_var.c"
                  ;
 out->has_this = 0;
 return 1;
}

static
duk_bool_t duk__get_identifier_reference(duk_hthread *thr,
                                         duk_hobject *env,
                                         duk_hstring *name,
                                         duk_activation *act,
                                         duk_bool_t parents,
                                         duk__id_lookup_result *out) {
 duk_tval *tv;
 duk_uint_t sanity;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { } while (0);
 do { } while (0);
# 892 "duk_js_var.c"
 if (env == 
# 892 "duk_js_var.c" 3 4
           ((void *)0) 
# 892 "duk_js_var.c"
                && act != 
# 892 "duk_js_var.c" 3 4
                          ((void *)0)
# 892 "duk_js_var.c"
                              ) {
  duk_hobject *func;
  duk_hcompfunc *f;

  do { } while (0)
                                                                          ;





  if (duk__getid_activation_regs(thr, name, act, out)) {
   do { } while (0)







                                                     ;
   return 1;
  }

  do { } while (0);
# 933 "duk_js_var.c"
  if (!parents) {
   do { } while (0)
                                                                            ;
   goto fail_not_found;
  }

  func = ((act)->func);
  do { } while (0);
  do { } while (0);
  f = (duk_hcompfunc *) func;

  env = ((f)->lex_env);
  if (!env) {
   env = thr->builtins[1];
  }

  do { } while (0);
 }







 sanity = 10000L;
 while (env != 
# 959 "duk_js_var.c" 3 4
              ((void *)0)
# 959 "duk_js_var.c"
                  ) {
  duk_small_uint_t cl;
  duk_uint_t attrs;

  do { } while (0)


                                            ;

  do { } while (0);
  do { } while (0);
  do { } while (0);

  cl = (((&(env)->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL));
  do { } while (0);
  if (cl == 16) {
# 987 "duk_js_var.c"
   do { } while (0);
   if (duk__getid_open_decl_env_regs(thr, name, (duk_hdecenv *) env, out)) {
    do { } while (0)







                                                      ;
    return 1;
   }

   tv = duk_hobject_find_entry_tval_ptr_and_attrs(thr->heap, env, name, &attrs);
   if (tv) {
    out->value = tv;
    out->attrs = attrs;
    out->env = env;
    out->holder = env;
    out->has_this = 0;

    do { } while (0)







                                                      ;
    return 1;
   }
  } else {
# 1035 "duk_js_var.c"
   duk_hobject *target;
   duk_bool_t found;

   do { } while (0);
   do { } while (0);

   target = ((duk_hobjenv *) env)->target;
   do { } while (0);
# 1052 "duk_js_var.c"
   if (__builtin_expect(((((&((target))->hdr)->h_flags & ((1UL << (7 + (18))))) != 0)), 0)) {
    duk_tval tv_name;
    duk_tval tv_target_tmp;

    do { } while (0);
    do { duk_tval *duk__tv; duk__tv = (&tv_name); duk__tv->t = 8; duk__tv->v.hstring = (name); } while (0);
    do { duk_tval *duk__tv; duk__tv = (&tv_target_tmp); duk__tv->t = 9; duk__tv->v.hobject = (target); } while (0);

    found = duk_hobject_hasprop(thr, &tv_target_tmp, &tv_name);
   } else

   {





    found = duk_hobject_hasprop_raw(thr, target, name);
   }

   if (found) {
    out->value = 
# 1073 "duk_js_var.c" 3 4
                ((void *)0)
# 1073 "duk_js_var.c"
                    ;
    out->attrs = 0;
    out->env = env;
    out->holder = target;
    out->has_this = ((duk_hobjenv *) env)->has_this;

    do { } while (0)







                                                      ;
    return 1;
   }
  }

  if (!parents) {
   do { } while (0)
                                                                ;
   goto fail_not_found;
  }

  if (__builtin_expect((sanity-- == 0), 0)) {
   do { duk_err_range((thr), "duk_js_var.c", (duk_int_t) 1099, ("prototype chain limit")); } while (0);
   do { return 0; } while (0);
  }
  env = ((env)->prototype);
 }





fail_not_found:
 return 0;
}
# 1183 "duk_js_var.c"
static
duk_bool_t duk__getvar_helper(duk_hthread *thr, duk_hobject *env, duk_activation *act, duk_hstring *name, duk_bool_t throw_flag) {
 duk__id_lookup_result ref;
 duk_tval tv_tmp_obj;
 duk_tval tv_tmp_key;
 duk_bool_t parents;

 do { } while (0)





                                           ;

 do { } while (0);
 do { } while (0);


 do { } while (0);

 ;
 ;

 parents = 1;
 if (duk__get_identifier_reference(thr, env, name, act, parents, &ref)) {
  if (ref.value) {
   duk_push_tval(thr, ref.value);
   duk_push_undefined(thr);
  } else {
   do { } while (0);






   do { duk_tval *duk__tv; duk__tv = (&tv_tmp_obj); duk__tv->t = 9; duk__tv->v.hobject = (ref.holder); } while (0);
   do { duk_tval *duk__tv; duk__tv = (&tv_tmp_key); duk__tv->t = 8; duk__tv->v.hstring = (name); } while (0);
   (void) duk_hobject_getprop(thr, &tv_tmp_obj, &tv_tmp_key);

   if (ref.has_this) {
    duk_push_hobject(thr, ref.holder);
   } else {
    duk_push_undefined(thr);
   }


  }

  return 1;
 } else {
  if (throw_flag) {
   do { duk_errcode_t duk__err = (4); duk_int_t duk__line = (duk_int_t) 1236; do { } while (0); do { } while (0); duk_err_handle_error_fmt((thr), "duk_js_var.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("identifier '%s' undefined"), ((const char *) ((const duk_uint8_t *) ((name) + 1)))); } while (0)


                                                            ;
   do { return 0; } while (0);
  }

  return 0;
 }
}

static __attribute__ ((unused))
duk_bool_t duk_js_getvar_envrec(duk_hthread *thr, duk_hobject *env, duk_hstring *name, duk_bool_t throw_flag) {
 return duk__getvar_helper(thr, env, 
# 1249 "duk_js_var.c" 3 4
                                    ((void *)0)
# 1249 "duk_js_var.c"
                                        , name, throw_flag);
}

static __attribute__ ((unused))
duk_bool_t duk_js_getvar_activation(duk_hthread *thr, duk_activation *act, duk_hstring *name, duk_bool_t throw_flag) {
 do { } while (0);
 return duk__getvar_helper(thr, act->lex_env, act, name, throw_flag);
}
# 1273 "duk_js_var.c"
static
void duk__putvar_helper(duk_hthread *thr,
                        duk_hobject *env,
                        duk_activation *act,
                        duk_hstring *name,
                        duk_tval *val,
                        duk_bool_t strict) {
 duk__id_lookup_result ref;
 duk_tval tv_tmp_val;
 duk_tval tv_tmp_obj;
 duk_tval tv_tmp_key;
 duk_bool_t parents;

 do { } while (0);

 do { } while (0)
# 1297 "duk_js_var.c"
                                        ;

 do { } while (0);
 do { } while (0);
 do { } while (0);


 ;
 ;
 ;

 do { *(&tv_tmp_val) = *(val); } while (0);
 val = 
# 1309 "duk_js_var.c" 3 4
      ((void *)0)
# 1309 "duk_js_var.c"
          ;
# 1321 "duk_js_var.c"
 do { } while (0);





 parents = 1;

 if (duk__get_identifier_reference(thr, env, name, act, parents, &ref)) {
  if (ref.value && (ref.attrs & (1U << 0))) {





   duk_tval *tv_val;

   tv_val = ref.value;
   do { } while (0);
   do { duk_tval *tv__dst, *tv__src; duk_heaphdr *h__obj; tv__dst = (tv_val); tv__src = (&tv_tmp_val); do { duk_tval *duk__tv = (tv__src); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0); if ((((tv__dst))->t & 0x08)) { h__obj = ((tv__dst)->v.heaphdr); do { } while (0); do { *(tv__dst) = *(tv__src); } while (0); do { duk_heaphdr *duk__h = (duk_heaphdr *) ((h__obj)); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_heaphdr_refzero)((((thr))), (duk_heaphdr *) duk__h); } } } while (0); } else { do { *(tv__dst) = *(tv__src); } while (0); } } while (0);


  } else {
   do { } while (0);

   do { duk_tval *duk__tv; duk__tv = (&tv_tmp_obj); duk__tv->t = 9; duk__tv->v.hobject = (ref.holder); } while (0);
   do { duk_tval *duk__tv; duk__tv = (&tv_tmp_key); duk__tv->t = 8; duk__tv->v.hstring = (name); } while (0);
   (void) duk_hobject_putprop(thr, &tv_tmp_obj, &tv_tmp_key, &tv_tmp_val, strict);


  }

  return;
 }






 if (strict) {
  do { } while (0);
  do { duk_errcode_t duk__err = (4); duk_int_t duk__line = (duk_int_t) 1363; do { } while (0); do { } while (0); duk_err_handle_error_fmt((thr), "duk_js_var.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), ("identifier '%s' undefined"), ((const char *) ((const duk_uint8_t *) ((name) + 1)))); } while (0)


                                                           ;
  do { return; } while (0);
 }

 do { } while (0);

 do { duk_tval *duk__tv; duk__tv = (&tv_tmp_obj); duk__tv->t = 9; duk__tv->v.hobject = (thr->builtins[0]); } while (0);
 do { duk_tval *duk__tv; duk__tv = (&tv_tmp_key); duk__tv->t = 8; duk__tv->v.hstring = (name); } while (0);
 (void) duk_hobject_putprop(thr, &tv_tmp_obj, &tv_tmp_key, &tv_tmp_val, 0);




}

static __attribute__ ((unused))
void duk_js_putvar_envrec(duk_hthread *thr, duk_hobject *env, duk_hstring *name, duk_tval *val, duk_bool_t strict) {
 duk__putvar_helper(thr, env, 
# 1383 "duk_js_var.c" 3 4
                             ((void *)0)
# 1383 "duk_js_var.c"
                                 , name, val, strict);
}

static __attribute__ ((unused))
void duk_js_putvar_activation(duk_hthread *thr, duk_activation *act, duk_hstring *name, duk_tval *val, duk_bool_t strict) {
 do { } while (0);
 duk__putvar_helper(thr, act->lex_env, act, name, val, strict);
}
# 1411 "duk_js_var.c"
static
duk_bool_t duk__delvar_helper(duk_hthread *thr, duk_hobject *env, duk_activation *act, duk_hstring *name) {
 duk__id_lookup_result ref;
 duk_bool_t parents;

 do { } while (0)





                                           ;

 do { } while (0);
 do { } while (0);


 ;

 parents = 1;

 if (duk__get_identifier_reference(thr, env, name, act, parents, &ref)) {
  if (ref.value && !(ref.attrs & (1U << 2))) {



   return 0;
  }
  do { } while (0);

  return duk_hobject_delprop_raw(thr, ref.holder, name, 0);
 }
# 1452 "duk_js_var.c"
 do { } while (0)

                                            ;
 return 1;
}
# 1467 "duk_js_var.c"
static __attribute__ ((unused))
duk_bool_t duk_js_delvar_activation(duk_hthread *thr, duk_activation *act, duk_hstring *name) {
 do { } while (0);
 return duk__delvar_helper(thr, act->lex_env, act, name);
}
# 1523 "duk_js_var.c"
static
duk_bool_t duk__declvar_helper(duk_hthread *thr,
                               duk_hobject *env,
                               duk_hstring *name,
                               duk_tval *val,
                               duk_small_uint_t prop_flags,
                               duk_bool_t is_func_decl) {
 duk_hobject *holder;
 duk_bool_t parents;
 duk__id_lookup_result ref;
 duk_tval *tv;

 do { } while (0)







                                           ;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
# 1570 "duk_js_var.c"
 parents = 0;
 if (duk__get_identifier_reference(thr, env, name, 
# 1571 "duk_js_var.c" 3 4
                                                  ((void *)0)
# 1571 "duk_js_var.c"
                                                      , parents, &ref)) {
  duk_int_t e_idx;
  duk_int_t h_idx;
  duk_small_uint_t flags;
# 1583 "duk_js_var.c"
  if (!(is_func_decl && env == thr->builtins[1])) {
   do { } while (0);
   return 1;
  }
# 1605 "duk_js_var.c"
  do { } while (0)
                                                  ;

  do { } while (0);
  holder = ref.holder;




  do { } while (0);
  do { } while (0);



  for (;;) {
   do { } while (0);
   if (duk_hobject_find_entry(thr->heap, holder, name, &e_idx, &h_idx)) {
    do { } while (0);
    break;
   }



   holder = ((holder)->prototype);
  }
  do { } while (0);
  do { } while (0);
# 1641 "duk_js_var.c"
  flags = (((duk_uint8_t *) (void *) (((((holder)))->props) + ((((holder)))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))[(e_idx)]);
  if (!(flags & (1U << 2))) {
   if (flags & (1U << 3)) {
    do { } while (0)
                                               ;
    goto fail_existing_attributes;
   }
   if (!((flags & (1U << 0)) && (flags & (1U << 1)))) {
    do { } while (0)

                                                 ;
    goto fail_existing_attributes;
   }

   do { } while (0)

                                               ;
  }

  if (holder == ref.holder) {




   do { } while (0);

   if (flags & (1U << 3)) {
    duk_hobject *tmp;

    tmp = ((((duk_propvalue *) (void *) ((((((holder))))->props)))[((e_idx))]).a.get);
    do { (((duk_propvalue *) (void *) ((((((holder))))->props)))[((e_idx))]).a.get = (
# 1671 "duk_js_var.c" 3 4
   ((void *)0)
# 1671 "duk_js_var.c"
   ); } while (0);
    do { if ((tmp) != 
# 1672 "duk_js_var.c" 3 4
   ((void *)0)
# 1672 "duk_js_var.c"
   ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((tmp))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
    do { (void) (tmp); } while (0);
    tmp = ((((duk_propvalue *) (void *) ((((((holder))))->props)))[((e_idx))]).a.set);
    do { (((duk_propvalue *) (void *) ((((((holder))))->props)))[((e_idx))]).a.set = (
# 1675 "duk_js_var.c" 3 4
   ((void *)0)
# 1675 "duk_js_var.c"
   ); } while (0);
    do { if ((tmp) != 
# 1676 "duk_js_var.c" 3 4
   ((void *)0)
# 1676 "duk_js_var.c"
   ) { do { duk_heaphdr *duk__h = (duk_heaphdr *) (((tmp))); do { } while (0); do { } while (0); do { } while (0); if (1) { if ((--(duk__h)->h_refcount) == 0) { (duk_hobject_refzero)((((thr))), (duk_hobject *) duk__h); } } } while (0); } } while (0);
    do { (void) (tmp); } while (0);
   } else {
    tv = (&(((duk_propvalue *) (void *) ((((((holder))))->props)))[((e_idx))]).v);
    do { duk_tval *tv__dst; duk_tval tv__tmp; tv__dst = (tv); do { *(&tv__tmp) = *(tv__dst); } while (0); do { duk_tval *duk__tv; duk__tv = (tv__dst); duk__tv->t = 2; } while (0); do { duk_tval *duk__tv = ((&tv__tmp)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); do { } while (0); if ((--(duk__h)->h_refcount) == 0) { duk_heaphdr_refzero((((thr))), duk__h); } } } while (0); } while (0);
   }





   tv = (&(((duk_propvalue *) (void *) ((((((holder))))->props)))[((e_idx))]).v);
   do { *(tv) = *(val); } while (0);
   do { duk_tval *duk__tv = ((tv)); do { } while (0); if ((((duk__tv))->t & 0x08)) { duk_heaphdr *duk__h = ((duk__tv)->v.heaphdr); do { } while (0); do { } while (0); (++(duk__h)->h_refcount); do { } while (0); } } while (0);
   do { (((duk_uint8_t *) (void *) ((((((holder))))->props) + (((((holder))))->e_size) * (sizeof(duk_hstring *) + sizeof(duk_propvalue))))[((e_idx))]) = (duk_uint8_t) (prop_flags); } while (0);

   do { } while (0)


                                                    ;
  } else {
   do { } while (0);

   do { } while (0);
   duk_push_tval(thr, val);
   duk_hobject_define_property_internal(thr, ref.holder, name, prop_flags);
  }

  return 0;
 }
# 1716 "duk_js_var.c"
 if (((((&((env))->hdr)->h_flags >> ((7 + (20)))) & ((1UL << (5)) - 1UL)) == 16)) {
  do { } while (0);
  holder = env;
 } else {
  do { } while (0);
  holder = ((duk_hobjenv *) env)->target;
  do { } while (0);
 }
# 1736 "duk_js_var.c"
 if (!(((&(holder)->hdr)->h_flags & ((1UL << (7 + (0))))) != 0)) {
  goto fail_not_extensible;
 }

 duk_push_hobject(thr, holder);
 duk_push_hstring(thr, name);
 duk_push_tval(thr, val);
 duk_xdef_prop(thr, -3, prop_flags);
 duk_pop_unsafe(thr);

 return 0;

fail_existing_attributes:
fail_not_extensible:
 do { do { duk_errcode_t duk__err = (6); duk_int_t duk__line = (duk_int_t) 1750; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_js_var.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("declaration failed"))); } while (0); } while (0);
 do { return 0; } while (0);
}

static __attribute__ ((unused))
duk_bool_t duk_js_declvar_activation(duk_hthread *thr,
                                     duk_activation *act,
                                     duk_hstring *name,
                                     duk_tval *val,
                                     duk_small_uint_t prop_flags,
                                     duk_bool_t is_func_decl) {
 duk_hobject *env;
 duk_tval tv_val_copy;

 do { } while (0);






 do { *(&tv_val_copy) = *(val); } while (0);
 val = &tv_val_copy;





 if (!act->var_env) {
  do { } while (0);
  duk_js_init_activation_environment_records_delayed(thr, act);

 }
 do { } while (0);
 do { } while (0);

 env = act->var_env;
 do { } while (0);
 do { } while (0);

 return duk__declvar_helper(thr, env, name, val, prop_flags, is_func_decl);
}
# 1 "duk_lexer.c"
# 178 "duk_lexer.c"
static void duk__fill_lexer_buffer(duk_lexer_ctx *lex_ctx, duk_small_uint_t start_offset_bytes) {
 duk_lexer_codepoint *cp, *cp_end;
 duk_ucodepoint_t x;
 duk_small_uint_t contlen;
 const duk_uint8_t *p, *p_end;



 duk_int_t input_line;


 input_line = lex_ctx->input_line;
 p = lex_ctx->input + lex_ctx->input_offset;
 p_end = lex_ctx->input + lex_ctx->input_length;

 cp = (duk_lexer_codepoint *) (void *) ((duk_uint8_t *) lex_ctx->buffer + start_offset_bytes);
 cp_end = lex_ctx->buffer + 64;

 for (; cp != cp_end; cp++) {
  cp->offset = (duk_size_t) (p - lex_ctx->input);
  cp->line = input_line;


  if (__builtin_expect((p >= p_end), 0)) {





   cp->codepoint = -1;
   continue;
  }

  x = (duk_ucodepoint_t) (*p++);



  if (__builtin_expect((x < 0x80UL), 1)) {
   do { } while (0);
   if (__builtin_expect((x <= 0x000dUL), 0)) {
    if ((x == 0x000aUL) || ((x == 0x000dUL) && (p >= p_end || *p != 0x000aUL))) {
# 230 "duk_lexer.c"
     input_line++;
    }
   }

   cp->codepoint = (duk_codepoint_t) x;
   continue;
  }



  if (x < 0xc0UL) {

   goto error_encoding;
  } else if (x < 0xe0UL) {

   contlen = 1;



   x = x & 0x1fUL;
  } else if (x < 0xf0UL) {

   contlen = 2;



   x = x & 0x0fUL;
  } else if (x < 0xf8UL) {

   contlen = 3;



   x = x & 0x07UL;
  } else {

   goto error_encoding;
  }

  do { } while (0);
  if ((duk_size_t) contlen > (duk_size_t) (p_end - p)) {
   goto error_clipped;
  }

  while (contlen > 0) {
   duk_small_uint_t y;
   y = *p++;
   if ((y & 0xc0U) != 0x80U) {

    goto error_encoding;
   }
   x = x << 6;
   x += y & 0x3fUL;
   contlen--;
  }



  if (x > 0x10ffffUL) {
   goto error_encoding;
  }






  do { } while (0);
  if ((x == 0x2028UL) || (x == 0x2029UL)) {
   input_line++;
  }

  cp->codepoint = (duk_codepoint_t) x;
 }

 lex_ctx->input_offset = (duk_size_t) (p - lex_ctx->input);
 lex_ctx->input_line = input_line;
 return;

error_clipped:
error_encoding:
 lex_ctx->input_offset = (duk_size_t) (p - lex_ctx->input);
 lex_ctx->input_line = input_line;

 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 314; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("source decode failed"))); } while (0); } while (0);
 do { return; } while (0);
}

static void duk__advance_bytes(duk_lexer_ctx *lex_ctx, duk_small_uint_t count_bytes) {
 duk_small_uint_t used_bytes, avail_bytes;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0)
                                                                                                  ;





 lex_ctx->window = (duk_lexer_codepoint *) (void *) ((duk_uint8_t *) lex_ctx->window + count_bytes);
 used_bytes = (duk_small_uint_t) ((duk_uint8_t *) lex_ctx->window - (duk_uint8_t *) lex_ctx->buffer);
 avail_bytes = 64 * sizeof(duk_lexer_codepoint) - used_bytes;
 if (avail_bytes < (duk_small_uint_t) (6 * sizeof(duk_lexer_codepoint))) {



  do { void *duk__dst = ((void *) lex_ctx->buffer); const void *duk__src = ((const void *) lex_ctx->window); duk_size_t duk__len = ((size_t) avail_bytes); do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } while (0);
  lex_ctx->window = lex_ctx->buffer;
  duk__fill_lexer_buffer(lex_ctx, avail_bytes);
 }
}

static void duk__init_lexer_window(duk_lexer_ctx *lex_ctx) {
 lex_ctx->window = lex_ctx->buffer;
 duk__fill_lexer_buffer(lex_ctx, 0);
}
# 504 "duk_lexer.c"
static void duk__advance_chars(duk_lexer_ctx *lex_ctx, duk_small_uint_t count_chars) {
 duk__advance_bytes(lex_ctx, count_chars * sizeof(duk_lexer_codepoint));
}






static void duk__initbuffer(duk_lexer_ctx *lex_ctx) {

 if ((((duk_hbuffer *) ((duk_hbuffer *) (lex_ctx->buf)))->size) < 256) {

 } else {
  duk_hbuffer_resize(lex_ctx->thr, lex_ctx->buf, 256);
 }

 do { duk_bw_init((lex_ctx->thr), (&lex_ctx->bw), (lex_ctx->buf)); } while (0);
}







static void duk__appendbuffer(duk_lexer_ctx *lex_ctx, duk_codepoint_t x) {
# 540 "duk_lexer.c"
 do { } while (0);

 do { do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (6); duk__space = (duk_size_t) (((&lex_ctx->bw))->p_limit - ((&lex_ctx->bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((lex_ctx->thr)), ((&lex_ctx->bw)), duk__sz); } } while (0); do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) (((duk_ucodepoint_t) x)); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_cesu8(duk__cp, ((&lex_ctx->bw))->p); ((&lex_ctx->bw))->p += duk__enc_len; } while (0); } while (0);
}

static void duk__appendbuffer_ascii(duk_lexer_ctx *lex_ctx, duk_codepoint_t x) {



 do { } while (0);

 do { do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (1); duk__space = (duk_size_t) (((&lex_ctx->bw))->p_limit - ((&lex_ctx->bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((lex_ctx->thr)), ((&lex_ctx->bw)), duk__sz); } } while (0); do { do { (((void) 0), ((void) 0)); } while (0); *((&lex_ctx->bw))->p++ = (duk_uint8_t) (((duk_uint8_t) x)); } while (0); } while (0);
}






static duk_hstring *duk__internbuffer(duk_lexer_ctx *lex_ctx, duk_idx_t valstack_idx) {
 do { } while (0);

 do { duk_push_lstring((lex_ctx->thr), (const char *) (&lex_ctx->bw)->p_base, (duk_size_t) ((&lex_ctx->bw)->p - (&lex_ctx->bw)->p_base)); } while (0);
 duk_replace(lex_ctx->thr, valstack_idx);
 return duk_known_hstring(lex_ctx->thr, valstack_idx);
}





static __attribute__ ((unused)) void duk_lexer_initctx(duk_lexer_ctx *lex_ctx) {
 do { } while (0);

 do { void *duk__dst = (lex_ctx); duk_size_t duk__len = (sizeof(*lex_ctx)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
# 583 "duk_lexer.c"
}





static __attribute__ ((unused)) void duk_lexer_getpoint(duk_lexer_ctx *lex_ctx, duk_lexer_point *pt) {
 pt->offset = lex_ctx->window[0].offset;
 pt->line = lex_ctx->window[0].line;
}

static __attribute__ ((unused)) void duk_lexer_setpoint(duk_lexer_ctx *lex_ctx, duk_lexer_point *pt) {
 do { } while (0);
 do { } while (0);
 lex_ctx->input_offset = pt->offset;
 lex_ctx->input_line = pt->line;
 duk__init_lexer_window(lex_ctx);
}
# 609 "duk_lexer.c"
static duk_codepoint_t duk__hexval_validate(duk_codepoint_t x) {
 duk_small_int_t t;


 if (__builtin_expect((x >= 0 && x <= 0xff), 1)) {
  t = duk_hex_dectab[x];
  if (__builtin_expect((t >= 0), 1)) {
   return t;
  }
 }

 return -1;
}




static duk_codepoint_t duk__hexval(duk_codepoint_t x) {
 duk_codepoint_t ret;

 do { } while (0)
                                                     ;
 ret = duk__hexval_validate(x);
 do { } while (0);
 return ret;
}


static duk_bool_t duk__is_hex_digit(duk_codepoint_t x) {
 if (__builtin_expect((x >= 0 && x <= 0xff), 1)) {
  return (duk_hex_dectab[x] >= 0);
 }
 return 0;
}




static duk_codepoint_t duk__lexer_parse_escape(duk_lexer_ctx *lex_ctx, duk_bool_t allow_es6) {
 duk_small_int_t digits;
 duk_codepoint_t escval;
 duk_codepoint_t x;
 duk_small_uint_t adv;

 do { } while (0);
 do { } while (0);
 do { (void) (allow_es6); } while (0);

 adv = 2;
 digits = 2;
 if (((lex_ctx)->window[(1)].codepoint) == 0x75) {
  digits = 4;

  if (((lex_ctx)->window[(2)].codepoint) == 0x7b && allow_es6) {
   digits = 0;
   adv = 3;
  }

 }
 duk__advance_chars((lex_ctx), (adv));

 escval = 0;
 for (;;) {
# 691 "duk_lexer.c"
  duk_codepoint_t dig;

  x = ((lex_ctx)->window[(0)].codepoint);
  duk__advance_chars((lex_ctx), (1));

  dig = duk__hexval_validate(x);
  if (digits > 0) {
   digits--;
   if (dig < 0) {
    goto fail_escape;
   }
   do { } while (0);
   escval = (escval << 4) + dig;
   if (digits == 0) {
    do { } while (0);
    break;
   }
  } else {

   do { } while (0);
   if (dig >= 0) {
    do { } while (0);
    escval = (escval << 4) + dig;
    if (escval > 0x10ffffL) {
     goto fail_escape;
    }
   } else if (x == 0x7d) {
    if (digits == 0) {

     goto fail_escape;
    }
    do { } while (0);
    break;
   } else {
    goto fail_escape;
   }
   digits = -1;



  }
 }

 return escval;

fail_escape:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 737; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid escape"))); } while (0); } while (0);
 do { return 0; } while (0);
}






static duk_codepoint_t duk__lexer_parse_legacy_octal(duk_lexer_ctx *lex_ctx,
                                                        duk_small_uint_t *out_adv,
                                                        duk_bool_t reject_annex_b) {
 duk_codepoint_t cp;
 duk_small_uint_t lookup_idx;
 duk_small_uint_t adv;
 duk_codepoint_t tmp;

 do { } while (0);
 do { } while (0);
 do { } while (0);

 cp = 0;
 tmp = 0;
 for (lookup_idx = 1; lookup_idx <= 3; lookup_idx++) {
  do { } while (0);
  tmp = ((lex_ctx)->window[(lookup_idx)].codepoint);
  if (tmp < 0x30 || tmp > 0x37) {

   break;
  }
  tmp = (cp << 3) + (tmp - 0x30);
  if (tmp > 0xff) {



   break;
  }
  cp = tmp;
 }
 do { } while (0);

 adv = lookup_idx;
 if (lookup_idx == 1) {
  do { } while (0);
  do { } while (0);
  cp = tmp;
  adv++;
 } else if (lookup_idx == 2 && cp == 0) {



  do { } while (0);
 } else {

  if (reject_annex_b) {
   do { } while (0);
   cp = -1;
  } else {
   do { } while (0);
   do { } while (0);
  }
 }

 *out_adv = adv;

 do { } while (0);
 return cp;
}


static void duk__lexer_parse_string_literal(duk_lexer_ctx *lex_ctx,
                                               duk_token *out_token,
                                               duk_small_int_t quote,
                                               duk_bool_t strict_mode) {
 duk_small_uint_t adv;

 for (adv = 1 ;;) {
  duk_codepoint_t x;

  duk__advance_chars((lex_ctx), (adv));
  x = ((lex_ctx)->window[(0)].codepoint);

  adv = 1;
  if (x == quote) {
   duk__advance_chars((lex_ctx), (1));
   break;
  } else if (x == '\\') {



   duk_small_int_t emitcp = -1;

   x = ((lex_ctx)->window[(1)].codepoint);


   adv = 2;

   switch (x) {
   case '\'':
    emitcp = 0x0027;
    break;
   case '"':
    emitcp = 0x0022;
    break;
   case '\\':
    emitcp = 0x005c;
    break;
   case 'b':
    emitcp = 0x0008;
    break;
   case 'f':
    emitcp = 0x000c;
    break;
   case 'n':
    emitcp = 0x000a;
    break;
   case 'r':
    emitcp = 0x000d;
    break;
   case 't':
    emitcp = 0x0009;
    break;
   case 'v':
    emitcp = 0x000b;
    break;
   case 'x':
   case 'u': {
    duk_codepoint_t esc_cp;
    esc_cp = duk__lexer_parse_escape(lex_ctx, 1 );
    duk__appendbuffer((lex_ctx), (duk_codepoint_t) (esc_cp));
    adv = 0;
    break;
   }
   default: {
    if (duk_unicode_is_line_terminator(x)) {

     if (x == 0x000d && ((lex_ctx)->window[(2)].codepoint) == 0x000a) {

      adv = 3;
     }
    } else if (((x) >= 0x30 && (x) <= 0x39)) {
# 894 "duk_lexer.c"
     emitcp = duk__lexer_parse_legacy_octal(lex_ctx, &adv, strict_mode );
     if (emitcp < 0) {
      goto fail_escape;
     }
    } else if (x < 0) {
     goto fail_unterminated;
    } else {

     duk__appendbuffer((lex_ctx), (duk_codepoint_t) (x));
    }
   }
   }


   if (emitcp >= 0) {
    duk__appendbuffer((lex_ctx), (duk_codepoint_t) (emitcp));
   }





   out_token->num_escapes++;
  } else if (x >= 0x20 && x <= 0x7f) {



   do { } while (0);
   do { } while (0);
   do { } while (0);
   do { } while (0);
   duk__appendbuffer_ascii((lex_ctx), (duk_codepoint_t) (x));
  } else if (x < 0 || duk_unicode_is_line_terminator(x)) {
   goto fail_unterminated;
  } else {



   duk__appendbuffer((lex_ctx), (duk_codepoint_t) (x));
  }
 }

 return;

fail_escape:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 939; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid escape"))); } while (0); } while (0);
 do { return; } while (0);

fail_unterminated:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 943; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("unterminated string"))); } while (0); } while (0);
 do { return; } while (0);
}


static void duk__lexer_skip_to_endofline(duk_lexer_ctx *lex_ctx) {
 for (;;) {
  duk_codepoint_t x;

  x = ((lex_ctx)->window[(0)].codepoint);
  if (x < 0 || duk_unicode_is_line_terminator(x)) {
   break;
  }
  duk__advance_chars((lex_ctx), (1));
 }
}
# 1024 "duk_lexer.c"
static __attribute__ ((unused))
void duk_lexer_parse_js_input_element(duk_lexer_ctx *lex_ctx,
                                      duk_token *out_token,
                                      duk_bool_t strict_mode,
                                      duk_bool_t regexp_mode) {
 duk_codepoint_t x;
 duk_small_uint_t advtok = 0;


 duk_bool_t got_lineterm = 0;

 if (++lex_ctx->token_count >= lex_ctx->token_limit) {
  goto fail_token_limit;
 }

 out_token->t = 0;
 out_token->t_nores = 
# 1040 "duk_lexer.c" 3 4
                     (0x7fffffff * 2U + 1U)
# 1040 "duk_lexer.c"
                                    ;





 out_token->num_escapes = 0;
# 1081 "duk_lexer.c"
restart_lineupdate:
 out_token->start_line = lex_ctx->window[0].line;

restart:
 out_token->start_offset = lex_ctx->window[0].offset;

 x = ((lex_ctx)->window[(0)].codepoint);

 switch (x) {
 case 0x20:
 case 0x09:
  duk__advance_chars((lex_ctx), (1));
  goto restart;
 case 0x0a:
  duk__advance_chars((lex_ctx), (1));
  got_lineterm = 1;
  goto restart_lineupdate;

 case 0x23:
  if (((lex_ctx)->window[(1)].codepoint) == 0x21 && lex_ctx->window[0].offset == 0 && (lex_ctx->flags & (1U << 6))) {


   duk__lexer_skip_to_endofline(lex_ctx);
   goto restart;
  }
  goto fail_token;

 case 0x2f:
  if (((lex_ctx)->window[(1)].codepoint) == 0x2f) {






   duk__lexer_skip_to_endofline(lex_ctx);
   goto restart;
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x2a) {






   duk_bool_t last_asterisk = 0;
   duk__advance_chars((lex_ctx), (2));
   for (;;) {
    x = ((lex_ctx)->window[(0)].codepoint);
    if (x < 0) {
     goto fail_unterm_comment;
    }
    duk__advance_chars((lex_ctx), (1));
    if (last_asterisk && x == 0x2f) {
     break;
    }
    if (duk_unicode_is_line_terminator(x)) {
     got_lineterm = 1;
    }
    last_asterisk = (x == 0x2a);
   }
   goto restart_lineupdate;
  } else if (regexp_mode) {
# 1201 "duk_lexer.c"
   duk_small_int_t state = 0;

   duk__initbuffer((lex_ctx));
   for (;;) {
    duk__advance_chars((lex_ctx), (1));
    x = ((lex_ctx)->window[(0)].codepoint);
    if (x < 0 || duk_unicode_is_line_terminator(x)) {
     goto fail_unterm_regexp;
    }
    x = ((lex_ctx)->window[(0)].codepoint);
    if (state == 0) {
     if (x == 0x2f) {
      duk__advance_chars((lex_ctx), (1));
      break;
     } else if (x == 0x5c) {
      state = 1;
     } else if (x == 0x5b) {
      state = 2;
     }
    } else if (state == 1) {
     state = 0;
    } else if (state == 2) {
     if (x == 0x5d) {
      state = 0;
     } else if (x == 0x5c) {
      state = 3;
     }
    } else {
     state = 2;
    }
    duk__appendbuffer((lex_ctx), (duk_codepoint_t) (x));
   }
   out_token->str1 = duk__internbuffer(lex_ctx, lex_ctx->slot1_idx);



   duk__initbuffer((lex_ctx));
   for (;;) {
    x = ((lex_ctx)->window[(0)].codepoint);
    if (!duk_unicode_is_identifier_part(x)) {
     break;
    }
    x = ((lex_ctx)->window[(0)].codepoint);
    duk__appendbuffer((lex_ctx), (duk_codepoint_t) (x));
    duk__advance_chars((lex_ctx), (1));
   }
   out_token->str2 = duk__internbuffer(lex_ctx, lex_ctx->slot2_idx);

   duk__initbuffer((lex_ctx));



   advtok = ((((0) * sizeof(duk_lexer_codepoint)) << 8) + (101));



  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3d) {

   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (90));
  } else {

   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (69));
  }
  break;
 case 0x7b:
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (49));
  break;
 case 0x7d:
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (50));
  break;
 case 0x28:
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (53));
  break;
 case 0x29:
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (54));
  break;
 case 0x5b:
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (51));
  break;
 case 0x5d:
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (52));
  break;
 case 0x2e:
  if (((((lex_ctx)->window[(1)].codepoint)) >= 0x30 && (((lex_ctx)->window[(1)].codepoint)) <= 0x39)) {





   goto slow_path;
  }
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (55));
  break;
 case 0x3b:
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (56));
  break;
 case 0x2c:
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (57));
  break;
 case 0x3c:

  if (((lex_ctx)->window[(1)].codepoint) == 0x21 && ((lex_ctx)->window[(2)].codepoint) == 0x2d && ((lex_ctx)->window[(3)].codepoint) == 0x2d) {





   duk__lexer_skip_to_endofline(lex_ctx);
   goto restart;
  } else

      if (((lex_ctx)->window[(1)].codepoint) == 0x3c && ((lex_ctx)->window[(2)].codepoint) == 0x3d) {
   advtok = ((((3) * sizeof(duk_lexer_codepoint)) << 8) + (93));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3d) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (60));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3c) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (74));
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (58));
  }
  break;
 case 0x3e:
  if (((lex_ctx)->window[(1)].codepoint) == 0x3e && ((lex_ctx)->window[(2)].codepoint) == 0x3e && ((lex_ctx)->window[(3)].codepoint) == 0x3d) {
   advtok = ((((4) * sizeof(duk_lexer_codepoint)) << 8) + (95));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3e && ((lex_ctx)->window[(2)].codepoint) == 0x3e) {
   advtok = ((((3) * sizeof(duk_lexer_codepoint)) << 8) + (76));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3e && ((lex_ctx)->window[(2)].codepoint) == 0x3d) {
   advtok = ((((3) * sizeof(duk_lexer_codepoint)) << 8) + (94));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3d) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (61));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3e) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (75));
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (59));
  }
  break;
 case 0x3d:
  if (((lex_ctx)->window[(1)].codepoint) == 0x3d && ((lex_ctx)->window[(2)].codepoint) == 0x3d) {
   advtok = ((((3) * sizeof(duk_lexer_codepoint)) << 8) + (64));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3d) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (62));
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (86));
  }
  break;
 case 0x21:
  if (((lex_ctx)->window[(1)].codepoint) == 0x3d && ((lex_ctx)->window[(2)].codepoint) == 0x3d) {
   advtok = ((((3) * sizeof(duk_lexer_codepoint)) << 8) + (65));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3d) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (63));
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (80));
  }
  break;
 case 0x2b:
  if (((lex_ctx)->window[(1)].codepoint) == 0x2b) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (72));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3d) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (87));
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (66));
  }
  break;
 case 0x2d:

  if (got_lineterm && ((lex_ctx)->window[(1)].codepoint) == 0x2d && ((lex_ctx)->window[(2)].codepoint) == 0x3e) {
# 1380 "duk_lexer.c"
   duk__lexer_skip_to_endofline(lex_ctx);
   goto restart;
  } else

      if (((lex_ctx)->window[(1)].codepoint) == 0x2d) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (73));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3d) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (88));
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (67));
  }
  break;
 case 0x2a:

  if (((lex_ctx)->window[(1)].codepoint) == 0x2a && ((lex_ctx)->window[(2)].codepoint) == 0x3d) {
   advtok = ((((3) * sizeof(duk_lexer_codepoint)) << 8) + (92));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x2a) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (71));
  } else

      if (((lex_ctx)->window[(1)].codepoint) == 0x3d) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (89));
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (68));
  }
  break;
 case 0x25:
  if (((lex_ctx)->window[(1)].codepoint) == 0x3d) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (91));
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (70));
  }
  break;
 case 0x26:
  if (((lex_ctx)->window[(1)].codepoint) == 0x26) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (82));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3d) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (96));
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (77));
  }
  break;
 case 0x7c:
  if (((lex_ctx)->window[(1)].codepoint) == 0x7c) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (83));
  } else if (((lex_ctx)->window[(1)].codepoint) == 0x3d) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (97));
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (78));
  }
  break;
 case 0x5e:
  if (((lex_ctx)->window[(1)].codepoint) == 0x3d) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (98));
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (79));
  }
  break;
 case 0x7e:
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (81));
  break;
 case 0x3f:
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (84));
  break;
 case 0x3a:
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (85));
  break;
 case 0x22:
 case 0x27: {
  duk__initbuffer((lex_ctx));
  duk__lexer_parse_string_literal(lex_ctx, out_token, x , strict_mode);
  duk__internbuffer(lex_ctx, lex_ctx->slot1_idx);
  out_token->str1 = duk_known_hstring(lex_ctx->thr, lex_ctx->slot1_idx);

  duk__initbuffer((lex_ctx));

  advtok = ((((0) * sizeof(duk_lexer_codepoint)) << 8) + (100));
  break;
 }
 default:
  goto slow_path;
 }

 goto skip_slow_path;

slow_path:
 if (duk_unicode_is_line_terminator(x)) {
  if (x == 0x000d && ((lex_ctx)->window[(1)].codepoint) == 0x000a) {





   duk__advance_chars((lex_ctx), (2));
  } else {
   duk__advance_chars((lex_ctx), (1));
  }
  got_lineterm = 1;
  goto restart_lineupdate;
 } else if (duk_unicode_is_identifier_start(x) || x == 0x5c) {
# 1511 "duk_lexer.c"
  duk_small_uint_t i, i_end;
  duk_bool_t first = 1;
  duk_hstring *str;

  duk__initbuffer((lex_ctx));
  for (;;) {

   if (((lex_ctx)->window[(0)].codepoint) == 0x5c) {
    duk_codepoint_t esc_cp;
    if (((lex_ctx)->window[(1)].codepoint) != 0x75) {
     goto fail_escape;
    }
    esc_cp = duk__lexer_parse_escape(lex_ctx, 1 );
    duk__appendbuffer((lex_ctx), (duk_codepoint_t) (esc_cp));




    if (!(first ? duk_unicode_is_identifier_start(esc_cp) : duk_unicode_is_identifier_part(esc_cp))) {
     goto fail_escape;
    }




    out_token->num_escapes++;
   } else {





    if (!duk_unicode_is_identifier_part(((lex_ctx)->window[(0)].codepoint))) {
     break;
    }
    duk__appendbuffer((lex_ctx), (duk_codepoint_t) (((lex_ctx)->window[(0)].codepoint)));
    duk__advance_chars((lex_ctx), (1));
   }
   first = 0;
  }

  out_token->str1 = duk__internbuffer(lex_ctx, lex_ctx->slot1_idx);
  str = out_token->str1;
  out_token->t_nores = 1;

  duk__initbuffer((lex_ctx));
# 1578 "duk_lexer.c"
  i_end = (strict_mode ? 167 : 158);

  advtok = ((((0) * sizeof(duk_lexer_codepoint)) << 8) + (1));
  if (out_token->num_escapes == 0) {
   for (i = 122; i < i_end; i++) {
    do { } while (0);
    do { } while (0);
    if (((lex_ctx->thr)->strs[(i)]) == str) {
     advtok = ((((0) * sizeof(duk_lexer_codepoint)) << 8) + (((i) -122 + 2)));
     break;
    }
   }
  }
 } else if (((x) >= 0x30 && (x) <= 0x39) || (x == 0x2e)) {
# 1616 "duk_lexer.c"
  duk_double_t val;
  duk_bool_t legacy_oct = 0;
  duk_small_int_t state;




  duk_small_uint_t s2n_flags;
  duk_codepoint_t y, z;
  duk_small_int_t s2n_radix = 10;
  duk_small_uint_t pre_adv = 0;

  duk__initbuffer((lex_ctx));
  y = ((lex_ctx)->window[(1)].codepoint);

  if (x == 0x30) {
   z = ((y) | 0x20);

   pre_adv = 2;
   if (z == 0x78) {
    s2n_radix = 16;
   } else if (z == 0x6f) {
    s2n_radix = 8;
   } else if (z == 0x62) {
    s2n_radix = 2;
   } else {
    pre_adv = 0;
    if (((y) >= 0x30 && (y) <= 0x39)) {
     if (strict_mode) {



      goto fail_number_literal;
     } else {




      duk__appendbuffer((lex_ctx), (duk_codepoint_t) (x));
      pre_adv = 1;
      legacy_oct = 1;
      s2n_radix = 8;
     }
    }
   }
  }

  duk__advance_chars((lex_ctx), (pre_adv));





  state = 0;
  for (;;) {
   x = ((lex_ctx)->window[(0)].codepoint);
   if (((x) >= 0x30 && (x) <= 0x39)) {



    if (state == 0 && legacy_oct && (x == 0x38 || x == 0x39)) {







     s2n_radix = 10;
    }
    if (state == 2) {
     state = 3;
    }
   } else if (s2n_radix == 16 && duk__is_hex_digit((x))) {

    ;
   } else if (x == 0x2e) {
    if (state >= 1 || s2n_radix != 10) {
     break;
    } else {
     state = 1;
    }
   } else if (x == 0x65 || x == 0x45) {
    if (state >= 2 || s2n_radix != 10) {
     break;
    } else {
     state = 2;
    }
   } else if (x == 0x2d || x == 0x2b) {
    if (state != 2) {
     break;
    } else {
     state = 3;
    }
   } else {
    break;
   }
   duk__appendbuffer((lex_ctx), (duk_codepoint_t) (x));
   duk__advance_chars((lex_ctx), (1));
  }


  (void) duk__internbuffer(lex_ctx, lex_ctx->slot1_idx);

  if (s2n_radix != 10) {

   s2n_flags = (1U << 10);
  } else {
   s2n_flags = (1U << 1) | (1U << 6) | (1U << 7) |
               (1U << 8) | (1U << 10);
  }

  duk_dup(lex_ctx->thr, lex_ctx->slot1_idx);
  duk_numconv_parse(lex_ctx->thr, s2n_radix, s2n_flags);
  val = duk_to_number_m1(lex_ctx->thr);
  if (
# 1731 "duk_lexer.c" 3 4
     __builtin_isnan (
# 1731 "duk_lexer.c"
     val
# 1731 "duk_lexer.c" 3 4
     )
# 1731 "duk_lexer.c"
                   ) {
   goto fail_number_literal;
  }
  duk_replace(lex_ctx->thr, lex_ctx->slot1_idx);

  duk__initbuffer((lex_ctx));





  if (((((lex_ctx)->window[(0)].codepoint)) >= 0x30 && (((lex_ctx)->window[(0)].codepoint)) <= 0x39) || duk_unicode_is_identifier_start(((lex_ctx)->window[(0)].codepoint))) {
   goto fail_number_literal;
  }

  out_token->num = val;
  advtok = ((((0) * sizeof(duk_lexer_codepoint)) << 8) + (99));
 } else if (duk_unicode_is_whitespace(((lex_ctx)->window[(0)].codepoint))) {
  duk__advance_chars((lex_ctx), (1));
  goto restart;
 } else if (x < 0) {
  advtok = ((((0) * sizeof(duk_lexer_codepoint)) << 8) + (0));
 } else {
  goto fail_token;
 }
skip_slow_path:





 duk__advance_bytes((lex_ctx), (advtok >> 8));
 out_token->t = advtok & 0xff;
 if (out_token->t_nores == 
# 1764 "duk_lexer.c" 3 4
                          (0x7fffffff * 2U + 1U)
# 1764 "duk_lexer.c"
                                         ) {
  out_token->t_nores = out_token->t;
 }
 out_token->lineterm = got_lineterm;





 if (got_lineterm || out_token->t == 50 || out_token->t == 0) {
  out_token->allow_auto_semi = 1;
 } else {
  out_token->allow_auto_semi = 0;
 }

 return;

fail_token_limit:
 do { duk_err_range((lex_ctx->thr), "duk_lexer.c", (duk_int_t) 1782, ("token limit")); } while (0);
 do { return; } while (0);

fail_token:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 1786; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid token"))); } while (0); } while (0);
 do { return; } while (0);

fail_number_literal:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 1790; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid number literal"))); } while (0); } while (0);
 do { return; } while (0);

fail_escape:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 1794; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid escape"))); } while (0); } while (0);
 do { return; } while (0);

fail_unterm_regexp:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 1798; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("unterminated regexp"))); } while (0); } while (0);
 do { return; } while (0);

fail_unterm_comment:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 1802; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("unterminated comment"))); } while (0); } while (0);
 do { return; } while (0);






}
# 1823 "duk_lexer.c"
static __attribute__ ((unused)) void duk_lexer_parse_re_token(duk_lexer_ctx *lex_ctx, duk_re_token *out_token) {
 duk_small_uint_t advtok = 0;
 duk_codepoint_t x, y;

 if (++lex_ctx->token_count >= lex_ctx->token_limit) {
  goto fail_token_limit;
 }

 do { void *duk__dst = (out_token); duk_size_t duk__len = (sizeof(*out_token)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);

 x = ((lex_ctx)->window[(0)].codepoint);
 y = ((lex_ctx)->window[(1)].codepoint);

 do { } while (0);

 switch (x) {
 case 0x7c: {
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (1));
  break;
 }
 case 0x5e: {
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (3));
  break;
 }
 case 0x24: {
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (4));
  break;
 }
 case 0x3f: {
  out_token->qmin = 0;
  out_token->qmax = 1;
  if (y == 0x3f) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (2));
   out_token->greedy = 0;
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (2));
   out_token->greedy = 1;
  }
  break;
 }
 case 0x2a: {
  out_token->qmin = 0;
  out_token->qmax = ((duk_uint32_t) 0xffffffffUL);
  if (y == 0x3f) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (2));
   out_token->greedy = 0;
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (2));
   out_token->greedy = 1;
  }
  break;
 }
 case 0x2b: {
  out_token->qmin = 1;
  out_token->qmax = ((duk_uint32_t) 0xffffffffUL);
  if (y == 0x3f) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (2));
   out_token->greedy = 0;
  } else {
   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (2));
   out_token->greedy = 1;
  }
  break;
 }
 case 0x7b: {

  duk_uint32_t val1 = 0;
  duk_uint32_t val2 = ((duk_uint32_t) 0xffffffffUL);
  duk_small_int_t digits = 0;

  duk_lexer_point lex_pt;




  duk_lexer_getpoint((lex_ctx), (&lex_pt));


  for (;;) {
   duk__advance_chars((lex_ctx), (1));
   x = ((lex_ctx)->window[(0)].codepoint);
   if (((x) >= 0x30 && (x) <= 0x39)) {
    digits++;
    val1 = val1 * 10 + (duk_uint32_t) duk__hexval(x);
   } else if (x == 0x2c) {
    if (digits > 9) {
     goto invalid_quantifier;
    }
    if (val2 != ((duk_uint32_t) 0xffffffffUL)) {
     goto invalid_quantifier;
    }
    if (((lex_ctx)->window[(1)].codepoint) == 0x7d) {

     if (digits == 0) {
      goto invalid_quantifier;
     }
     out_token->qmin = val1;
     out_token->qmax = ((duk_uint32_t) 0xffffffffUL);
     duk__advance_chars((lex_ctx), (2));
     break;
    }
    val2 = val1;
    val1 = 0;
    digits = 0;
   } else if (x == 0x7d) {
    if (digits > 9) {
     goto invalid_quantifier;
    }
    if (digits == 0) {
     goto invalid_quantifier;
    }
    if (val2 != ((duk_uint32_t) 0xffffffffUL)) {

     out_token->qmin = val2;
     out_token->qmax = val1;
    } else {

     out_token->qmin = val1;
     out_token->qmax = val1;
    }
    duk__advance_chars((lex_ctx), (1));
    break;
   } else {
    goto invalid_quantifier;
   }
  }
  if (((lex_ctx)->window[(0)].codepoint) == 0x3f) {
   out_token->greedy = 0;
   duk__advance_chars((lex_ctx), (1));
  } else {
   out_token->greedy = 1;
  }
  advtok = ((((0) * sizeof(duk_lexer_codepoint)) << 8) + (2));
  break;
 invalid_quantifier:




  duk_lexer_setpoint((lex_ctx), (&lex_pt));
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (10));
  out_token->num = 0x7b;



  break;
 }
 case 0x2e: {
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (9));
  break;
 }
 case 0x5c: {
# 1983 "duk_lexer.c"
  advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (10));
  if (y == 0x62) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (5));
  } else if (y == 0x42) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (6));
  } else if (y == 0x66) {
   out_token->num = 0x000c;
  } else if (y == 0x6e) {
   out_token->num = 0x000a;
  } else if (y == 0x74) {
   out_token->num = 0x0009;
  } else if (y == 0x72) {
   out_token->num = 0x000d;
  } else if (y == 0x76) {
   out_token->num = 0x000b;
  } else if (y == 0x63) {
   x = ((lex_ctx)->window[(2)].codepoint);
   if ((x >= 0x61 && x <= 0x7a) || (x >= 0x41 && x <= 0x5a)) {
    out_token->num = (duk_uint32_t) (x % 32);
    advtok = ((((3) * sizeof(duk_lexer_codepoint)) << 8) + (10));
   } else {
    goto fail_escape;
   }
  } else if (y == 0x78 || y == 0x75) {





   out_token->num = (duk_uint32_t) duk__lexer_parse_escape(lex_ctx, 0 );
   advtok = ((((0) * sizeof(duk_lexer_codepoint)) << 8) + (10));
  } else if (y == 0x64) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (11));
  } else if (y == 0x44) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (12));
  } else if (y == 0x73) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (13));
  } else if (y == 0x53) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (14));
  } else if (y == 0x77) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (15));
  } else if (y == 0x57) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (16));
  } else if (((y) >= 0x30 && (y) <= 0x39)) {

   if (y == 0x30) {
    if (((((lex_ctx)->window[(2)].codepoint)) >= 0x30 && (((lex_ctx)->window[(2)].codepoint)) <= 0x39)) {
     goto fail_escape;
    }
    out_token->num = 0x0000;
    advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (10));
   } else {

    duk_uint32_t val = 0;
    duk_small_int_t i;
    for (i = 0;; i++) {
     if (i >= 9) {
      goto fail_escape;
     }
     duk__advance_chars((lex_ctx), (1));
     x = ((lex_ctx)->window[(0)].codepoint);
     if (!((x) >= 0x30 && (x) <= 0x39)) {
      break;
     }
     val = val * 10 + (duk_uint32_t) duk__hexval(x);
    }

    advtok = ((((0) * sizeof(duk_lexer_codepoint)) << 8) + (17));
    out_token->num = val;
   }

  } else if (y >= 0) {







   do { } while (0);
# 2071 "duk_lexer.c"
   out_token->num = (duk_uint32_t) y;
  } else {
   goto fail_escape;
  }
  break;
 }
 case 0x28: {


  if (y == 0x3f) {
   if (((lex_ctx)->window[(2)].codepoint) == 0x3d) {

    advtok = ((((3) * sizeof(duk_lexer_codepoint)) << 8) + (7));
   } else if (((lex_ctx)->window[(2)].codepoint) == 0x21) {

    advtok = ((((3) * sizeof(duk_lexer_codepoint)) << 8) + (8));
   } else if (((lex_ctx)->window[(2)].codepoint) == 0x3a) {

    advtok = ((((3) * sizeof(duk_lexer_codepoint)) << 8) + (19));
   } else {
    goto fail_group;
   }
  } else {

   advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (18));
  }
  break;
 }
 case 0x29: {
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (22));
  break;
 }
 case 0x5b: {
# 2114 "duk_lexer.c"
  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (20));
  if (y == 0x5e) {
   advtok = ((((2) * sizeof(duk_lexer_codepoint)) << 8) + (21));
  }
  break;
 }
# 2130 "duk_lexer.c"
 case -1: {

  advtok = ((((0) * sizeof(duk_lexer_codepoint)) << 8) + (0));
  break;
 }
 default: {

  advtok = ((((1) * sizeof(duk_lexer_codepoint)) << 8) + (10));
  out_token->num = (duk_uint32_t) x;
  break;
 }
 }





 duk__advance_bytes((lex_ctx), (advtok >> 8));
 out_token->t = advtok & 0xff;
 return;

fail_token_limit:
 do { duk_err_range((lex_ctx->thr), "duk_lexer.c", (duk_int_t) 2152, ("token limit")); } while (0);
 do { return; } while (0);

fail_escape:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 2156; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid regexp escape"))); } while (0); } while (0);
 do { return; } while (0);

fail_group:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 2160; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid regexp group"))); } while (0); } while (0);
 do { return; } while (0);
# 2172 "duk_lexer.c"
}
# 2194 "duk_lexer.c"
static
void duk__emit_u16_direct_ranges(duk_lexer_ctx *lex_ctx,
                                 duk_re_range_callback gen_range,
                                 void *userdata,
                                 const duk_uint16_t *ranges,
                                 duk_small_int_t num) {
 const duk_uint16_t *ranges_end;

 do { (void) (lex_ctx); } while (0);

 ranges_end = ranges + num;
 while (ranges < ranges_end) {

  gen_range(userdata, (duk_codepoint_t) ranges[0], (duk_codepoint_t) ranges[1], 1);
  ranges += 2;
 }
}

static __attribute__ ((unused)) void duk_lexer_parse_re_ranges(duk_lexer_ctx *lex_ctx, duk_re_range_callback gen_range, void *userdata) {
 duk_codepoint_t start = -1;
 duk_codepoint_t ch;
 duk_codepoint_t x;
 duk_bool_t dash = 0;
 duk_small_uint_t adv = 0;

 do { } while (0);

 for (;;) {
  duk__advance_chars((lex_ctx), (adv));
  adv = 1;

  x = ((lex_ctx)->window[(0)].codepoint);

  ch = -1;
  do { (void) (ch); } while (0);

  if (x < 0) {
   goto fail_unterm_charclass;
  } else if (x == 0x5d) {
   if (start >= 0) {
    gen_range(userdata, start, start, 0);
   }
   duk__advance_chars((lex_ctx), (1));
   break;
  } else if (x == 0x2d) {
   if (start >= 0 && !dash && ((lex_ctx)->window[(1)].codepoint) != 0x5d) {

    dash = 1;
    continue;
   } else {

    ch = x;
   }
  } else if (x == 0x5c) {
# 2258 "duk_lexer.c"
   x = ((lex_ctx)->window[(1)].codepoint);

   adv = 2;

   if (x == 0x62) {




    ch = 0x0008;
   } else if (x == 0x66) {
    ch = 0x000c;
   } else if (x == 0x6e) {
    ch = 0x000a;
   } else if (x == 0x74) {
    ch = 0x0009;
   } else if (x == 0x72) {
    ch = 0x000d;
   } else if (x == 0x76) {
    ch = 0x000b;
   } else if (x == 0x63) {
    x = ((lex_ctx)->window[(2)].codepoint);
    adv = 3;
    if ((x >= 0x61 && x <= 0x7a) || (x >= 0x41 && x <= 0x5a)) {
     ch = (x % 32);
    } else {
     goto fail_escape;
    }
   } else if (x == 0x78 || x == 0x75) {



    ch = duk__lexer_parse_escape(lex_ctx, 0 );
    adv = 0;
   } else if (x == 0x64) {
    duk__emit_u16_direct_ranges(lex_ctx,
                                gen_range,
                                userdata,
                                duk_unicode_re_ranges_digit,
                                sizeof(duk_unicode_re_ranges_digit) / sizeof(duk_uint16_t));
    ch = -1;
   } else if (x == 0x44) {
    duk__emit_u16_direct_ranges(lex_ctx,
                                gen_range,
                                userdata,
                                duk_unicode_re_ranges_not_digit,
                                sizeof(duk_unicode_re_ranges_not_digit) / sizeof(duk_uint16_t));
    ch = -1;
   } else if (x == 0x73) {
    duk__emit_u16_direct_ranges(lex_ctx,
                                gen_range,
                                userdata,
                                duk_unicode_re_ranges_white,
                                sizeof(duk_unicode_re_ranges_white) / sizeof(duk_uint16_t));
    ch = -1;
   } else if (x == 0x53) {
    duk__emit_u16_direct_ranges(lex_ctx,
                                gen_range,
                                userdata,
                                duk_unicode_re_ranges_not_white,
                                sizeof(duk_unicode_re_ranges_not_white) / sizeof(duk_uint16_t));
    ch = -1;
   } else if (x == 0x77) {
    duk__emit_u16_direct_ranges(lex_ctx,
                                gen_range,
                                userdata,
                                duk_unicode_re_ranges_wordchar,
                                sizeof(duk_unicode_re_ranges_wordchar) / sizeof(duk_uint16_t));
    ch = -1;
   } else if (x == 0x57) {
    duk__emit_u16_direct_ranges(lex_ctx,
                                gen_range,
                                userdata,
                                duk_unicode_re_ranges_not_wordchar,
                                sizeof(duk_unicode_re_ranges_not_wordchar) / sizeof(duk_uint16_t));
    ch = -1;
   } else if (((x) >= 0x30 && (x) <= 0x39)) {
# 2344 "duk_lexer.c"
    ch = duk__lexer_parse_legacy_octal(lex_ctx, &adv, 0 );
    do { } while (0);
# 2354 "duk_lexer.c"
   } else if (x >= 0) {




    ch = x;
# 2369 "duk_lexer.c"
   } else {
    goto fail_escape;
   }
  } else {

   ch = x;
  }





  if (ch < 0) {



   if (start >= 0) {
    if (dash) {
     goto fail_range;
    } else {
     gen_range(userdata, start, start, 0);
     start = -1;

    }
   }
  } else {
   if (start >= 0) {
    if (dash) {
     if (start > ch) {
      goto fail_range;
     }
     gen_range(userdata, start, ch, 0);
     start = -1;
     dash = 0;
    } else {
     gen_range(userdata, start, start, 0);
     start = ch;

    }
   } else {
    start = ch;
   }
  }
 }

 return;

fail_escape:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 2417; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid regexp escape"))); } while (0); } while (0);
 do { return; } while (0);

fail_range:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 2421; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid range"))); } while (0); } while (0);
 do { return; } while (0);

fail_unterm_charclass:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 2425; do { } while (0); do { } while (0); duk_err_handle_error(((lex_ctx->thr)), "duk_lexer.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("unterminated character class"))); } while (0); } while (0);
 do { return; } while (0);
}
# 1 "duk_numconv.c"
# 35 "duk_numconv.c"
static const duk_uint8_t duk__str2num_digits_for_radix[] = {
 69, 44, 35, 30, 27, 25, 23, 22, 20, 20,
 20, 19, 19, 18, 18, 17, 17, 17, 16, 16,
 16, 16, 16, 15, 15, 15, 15, 15, 15, 14,
 14, 14, 14, 14, 14
};

typedef struct {
 duk_int16_t upper;
 duk_int16_t lower;
} duk__exp_limits;

static const duk__exp_limits duk__str2num_exp_limits[] = {
 { 957, -1147 }, { 605, -725 }, { 479, -575 }, { 414, -496 }, { 372, -446 }, { 342, -411 }, { 321, -384 },
 { 304, -364 }, { 291, -346 }, { 279, -334 }, { 268, -323 }, { 260, -312 }, { 252, -304 }, { 247, -296 },
 { 240, -289 }, { 236, -283 }, { 231, -278 }, { 227, -273 }, { 223, -267 }, { 220, -263 }, { 216, -260 },
 { 213, -256 }, { 210, -253 }, { 208, -249 }, { 205, -246 }, { 203, -244 }, { 201, -241 }, { 198, -239 },
 { 196, -237 }, { 195, -234 }, { 193, -232 }, { 191, -230 }, { 190, -228 }, { 188, -226 }, { 187, -225 },
};
# 79 "duk_numconv.c"
typedef struct {
 duk_small_int_t n;
 duk_uint32_t v[37];
} duk__bigint;
# 111 "duk_numconv.c"
static void duk__bi_normalize(duk__bigint *x) {
 duk_small_int_t i;

 for (i = x->n - 1; i >= 0; i--) {
  if (x->v[i] != 0) {
   break;
  }
 }


 x->n = i + 1;
 do { } while (0);
}


static void duk__bi_copy(duk__bigint *x, duk__bigint *y) {
 duk_small_int_t n;

 n = y->n;
 x->n = n;

 do { void *duk__dst = ((void *) x->v); const void *duk__src = ((const void *) y->v); duk_size_t duk__len = ((size_t) (sizeof(duk_uint32_t) * (size_t) n)); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
}

static void duk__bi_set_small(duk__bigint *x, duk_uint32_t v) {
 if (v == 0U) {
  x->n = 0;
 } else {
  x->n = 1;
  x->v[0] = v;
 }
 do { } while (0);
}





static int duk__bi_compare(duk__bigint *x, duk__bigint *y) {
 duk_small_int_t i, nx, ny;
 duk_uint32_t tx, ty;

 do { } while (0);
 do { } while (0);

 nx = x->n;
 ny = y->n;
 if (nx > ny) {
  goto ret_gt;
 }
 if (nx < ny) {
  goto ret_lt;
 }
 for (i = nx - 1; i >= 0; i--) {
  tx = x->v[i];
  ty = y->v[i];

  if (tx > ty) {
   goto ret_gt;
  }
  if (tx < ty) {
   goto ret_lt;
  }
 }

 return 0;

ret_gt:
 return 1;

ret_lt:
 return -1;
}



static void duk__bi_add(duk__bigint *x, duk__bigint *y, duk__bigint *z) {
 duk_uint64_t tmp;
 duk_small_int_t i, ny, nz;

 do { } while (0);
 do { } while (0);

 if (z->n > y->n) {
  duk__bigint *t;
  t = y;
  y = z;
  z = t;
 }
 do { } while (0);

 ny = y->n;
 nz = z->n;
 tmp = 0U;
 for (i = 0; i < ny; i++) {
  do { } while (0);
  tmp += y->v[i];
  if (i < nz) {
   tmp += z->v[i];
  }
  x->v[i] = (duk_uint32_t) (tmp & 0xffffffffUL);
  tmp = tmp >> 32;
 }
 if (tmp != 0U) {
  do { } while (0);
  x->v[i++] = (duk_uint32_t) tmp;
 }
 x->n = i;
 do { } while (0);


 do { } while (0);
}
# 281 "duk_numconv.c"
static void duk__bi_add_small(duk__bigint *x, duk__bigint *y, duk_uint32_t z) {
 duk__bigint tmp;

 do { } while (0);


 duk__bi_set_small(&tmp, z);
 duk__bi_add(x, y, &tmp);

 do { } while (0);
}
# 303 "duk_numconv.c"
static void duk__bi_sub(duk__bigint *x, duk__bigint *y, duk__bigint *z) {
 duk_small_int_t i, ny, nz;
 duk_uint32_t ty, tz;
 duk_int64_t tmp;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 ny = y->n;
 nz = z->n;
 tmp = 0;
 for (i = 0; i < ny; i++) {
  ty = y->v[i];
  if (i < nz) {
   tz = z->v[i];
  } else {
   tz = 0;
  }
  tmp = (duk_int64_t) ty - (duk_int64_t) tz + tmp;
  x->v[i] = (duk_uint32_t) ((duk_uint64_t) tmp & 0xffffffffUL);
  tmp = tmp >> 32;
 }
 do { } while (0);

 x->n = i;
 duk__bi_normalize(x);
 do { } while (0);
}
# 393 "duk_numconv.c"
static void duk__bi_sub_copy(duk__bigint *x, duk__bigint *y, duk__bigint *t) {
 duk__bi_sub(t, x, y);
 duk__bi_copy(x, t);
}


static void duk__bi_mul(duk__bigint *x, duk__bigint *y, duk__bigint *z) {
 duk_small_int_t i, j, nx, nz;

 do { } while (0);
 do { } while (0);

 nx = y->n + z->n;
 do { } while (0);

 if (nx == 0) {



  x->n = 0;
  return;
 }

 do { void *duk__dst = ((void *) x->v); duk_size_t duk__len = ((size_t) (sizeof(duk_uint32_t) * (size_t) nx)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 x->n = nx;

 nz = z->n;
 for (i = 0; i < y->n; i++) {

  duk_uint64_t tmp = 0U;
  for (j = 0; j < nz; j++) {
   tmp += (duk_uint64_t) y->v[i] * (duk_uint64_t) z->v[j] + x->v[i + j];
   x->v[i + j] = (duk_uint32_t) (tmp & 0xffffffffUL);
   tmp = tmp >> 32;
  }
  if (tmp > 0) {
   do { } while (0);
   do { } while (0);
   do { } while (0);
   x->v[i + j] = (duk_uint32_t) tmp;
  }
# 520 "duk_numconv.c"
 }

 duk__bi_normalize(x);
 do { } while (0);
}


static void duk__bi_mul_small(duk__bigint *x, duk__bigint *y, duk_uint32_t z) {
 duk__bigint tmp;

 do { } while (0);


 duk__bi_set_small(&tmp, z);
 duk__bi_mul(x, y, &tmp);

 do { } while (0);
}


static void duk__bi_mul_copy(duk__bigint *x, duk__bigint *y, duk__bigint *t) {
 duk__bi_mul(t, x, y);
 duk__bi_copy(x, t);
}


static void duk__bi_mul_small_copy(duk__bigint *x, duk_uint32_t y, duk__bigint *t) {
 duk__bi_mul_small(t, x, y);
 duk__bi_copy(x, t);
}

static int duk__bi_is_even(duk__bigint *x) {
 do { } while (0);
 return (x->n == 0) || ((x->v[0] & 0x01) == 0);
}

static int duk__bi_is_zero(duk__bigint *x) {
 do { } while (0);
 return (x->n == 0);
}







static duk_small_int_t duk__bi_is_2to52(duk__bigint *x) {
 do { } while (0);
 return (duk_small_int_t) (x->n == 2) && (x->v[0] == 0U) && (x->v[1] == (1U << (52 - 32)));
}


static void duk__bi_twoexp(duk__bigint *x, duk_small_int_t y) {
 duk_small_int_t n, r;

 n = (y / 32) + 1;
 do { } while (0);
 r = y % 32;
 do { void *duk__dst = ((void *) x->v); duk_size_t duk__len = (sizeof(duk_uint32_t) * (size_t) n); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 x->n = n;
 x->v[n - 1] = (((duk_uint32_t) 1) << r);
}


static void duk__bi_exp_small(duk__bigint *x, duk_small_int_t b, duk_small_int_t y, duk__bigint *t1, duk__bigint *t2) {


 do { } while (0);
 do { } while (0);
 do { } while (0);

 if (b == 2) {
  duk__bi_twoexp(x, y);
  return;
 }



 do { } while (0);

 duk__bi_set_small(x, 1);
 duk__bi_set_small(t1, (duk_uint32_t) b);
 for (;;) {




  if (y & 0x01) {
   duk__bi_mul_copy(x, t1, t2);
  }
  y = y >> 1;
  if (y == 0) {
   break;
  }
  duk__bi_mul_copy(t1, t1, t2);
 }

 ;
}
# 652 "duk_numconv.c"
typedef struct {





 duk__bigint f, r, s, mp, mm, t1, t2;

 duk_small_int_t is_s2n;
 duk_small_int_t is_fixed;
 duk_small_int_t req_digits;
 duk_small_int_t abs_pos;
 duk_small_int_t e;
 duk_small_int_t b;
 duk_small_int_t B;
 duk_small_int_t k;
 duk_small_int_t low_ok;
 duk_small_int_t high_ok;
 duk_small_int_t unequal_gaps;


 duk_uint8_t digits[1040];
 duk_small_int_t count;
} duk__numconv_stringify_ctx;
# 688 "duk_numconv.c"
static duk_size_t duk__dragon4_format_uint32(duk_uint8_t *buf, duk_uint32_t x, duk_small_int_t radix) {
 duk_uint8_t *p;
 duk_size_t len;
 duk_small_int_t dig;
 duk_uint32_t t;

 do { } while (0);
 do { } while (0);






 p = buf + 32;
 for (;;) {
  t = x / (duk_uint32_t) radix;
  dig = (duk_small_int_t) (x - t * (duk_uint32_t) radix);
  x = t;

  do { } while (0);
  *(--p) = duk_lc_digits[(dig)];

  if (x == 0) {
   break;
  }
 }
 len = (duk_size_t) ((buf + 32) - p);

 do { void *duk__dst = ((void *) buf); const void *duk__src = ((const void *) p); duk_size_t duk__len = ((size_t) len); do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } while (0);

 return len;
}

static void duk__dragon4_prepare(duk__numconv_stringify_ctx *nc_ctx) {
 duk_small_int_t lowest_mantissa;







 if (duk__bi_is_even(&nc_ctx->f)) {
  do { } while (0);
  nc_ctx->low_ok = 1;
  nc_ctx->high_ok = 1;
 } else {
  do { } while (0);
  nc_ctx->low_ok = 0;
  nc_ctx->high_ok = 0;
 }
# 755 "duk_numconv.c"
 if (nc_ctx->is_s2n) {
  lowest_mantissa = 0;
 } else {
  lowest_mantissa = duk__bi_is_2to52(&nc_ctx->f);
 }

 nc_ctx->unequal_gaps = 0;
 if (nc_ctx->e >= 0) {


  if (lowest_mantissa) {
# 780 "duk_numconv.c"
   do { } while (0)

                                        ;

   duk__bi_exp_small(&nc_ctx->mm, nc_ctx->b, nc_ctx->e, &nc_ctx->t1, &nc_ctx->t2);
   duk__bi_mul_small(&nc_ctx->mp, &nc_ctx->mm, (duk_uint32_t) nc_ctx->b);
   duk__bi_mul_small(&nc_ctx->t1, &nc_ctx->f, 2);
   duk__bi_mul(&nc_ctx->r, &nc_ctx->t1, &nc_ctx->mp);
   duk__bi_set_small(&nc_ctx->s, (duk_uint32_t) (nc_ctx->b * 2));
   nc_ctx->unequal_gaps = 1;
  } else {
# 804 "duk_numconv.c"
   do { } while (0)

                                      ;

   duk__bi_exp_small(&nc_ctx->mm, nc_ctx->b, nc_ctx->e, &nc_ctx->t1, &nc_ctx->t2);
   duk__bi_copy(&nc_ctx->mp, &nc_ctx->mm);
   duk__bi_mul_small(&nc_ctx->t1, &nc_ctx->f, 2);
   duk__bi_mul(&nc_ctx->r, &nc_ctx->t1, &nc_ctx->mp);
   duk__bi_set_small(&nc_ctx->s, 2);
  }
 } else {



  if (nc_ctx->e > (-1022) &&
      lowest_mantissa ) {
# 830 "duk_numconv.c"
   do { } while (0)

                                        ;

   duk__bi_mul_small(&nc_ctx->r, &nc_ctx->f, (duk_uint32_t) (nc_ctx->b * 2));
   duk__bi_exp_small(&nc_ctx->t1,
                     nc_ctx->b,
                     1 - nc_ctx->e,
                     &nc_ctx->s,
                     &nc_ctx->t2);
   duk__bi_mul_small(&nc_ctx->s, &nc_ctx->t1, 2);
   duk__bi_set_small(&nc_ctx->mp, 2);
   duk__bi_set_small(&nc_ctx->mm, 1);
   nc_ctx->unequal_gaps = 1;
  } else {
# 855 "duk_numconv.c"
   do { } while (0)

                                      ;

   duk__bi_mul_small(&nc_ctx->r, &nc_ctx->f, 2);
   duk__bi_exp_small(&nc_ctx->t1,
                     nc_ctx->b,
                     -nc_ctx->e,
                     &nc_ctx->s,
                     &nc_ctx->t2);
   duk__bi_mul_small(&nc_ctx->s, &nc_ctx->t1, 2);
   duk__bi_set_small(&nc_ctx->mp, 1);
   duk__bi_set_small(&nc_ctx->mm, 1);
  }
 }
}

static void duk__dragon4_scale(duk__numconv_stringify_ctx *nc_ctx) {
 duk_small_int_t k = 0;
# 897 "duk_numconv.c"
 do { } while (0)
                                                                                                                            ;
 ;
 ;
 ;
 ;

 for (;;) {
  do { } while (0);
  ;
  ;
  ;
  ;

  duk__bi_add(&nc_ctx->t1, &nc_ctx->r, &nc_ctx->mp);
  if (duk__bi_compare(&nc_ctx->t1, &nc_ctx->s) >= (nc_ctx->high_ok ? 0 : 1)) {
   do { } while (0);







   duk__bi_mul_small_copy(&nc_ctx->s, (duk_uint32_t) nc_ctx->B, &nc_ctx->t1);
   k++;
  } else {
   break;
  }
 }


 if (k > 0) {
  goto skip_dec_k;
 }

 for (;;) {
  do { } while (0);
  ;
  ;
  ;
  ;

  duk__bi_add(&nc_ctx->t1, &nc_ctx->r, &nc_ctx->mp);
  duk__bi_mul_small(&nc_ctx->t2, &nc_ctx->t1, (duk_uint32_t) nc_ctx->B);
  if (duk__bi_compare(&nc_ctx->t2, &nc_ctx->s) <= (nc_ctx->high_ok ? -1 : 0)) {
   do { } while (0);






   duk__bi_mul_small_copy(&nc_ctx->r, (duk_uint32_t) nc_ctx->B, &nc_ctx->t1);
   duk__bi_mul_small_copy(&nc_ctx->mp, (duk_uint32_t) nc_ctx->B, &nc_ctx->t1);
   if (nc_ctx->unequal_gaps) {
    do { } while (0);
    duk__bi_mul_small_copy(&nc_ctx->mm, (duk_uint32_t) nc_ctx->B, &nc_ctx->t1);
   }
   k--;
  } else {
   break;
  }
 }

skip_dec_k:

 if (!nc_ctx->unequal_gaps) {
  do { } while (0);
  duk__bi_copy(&nc_ctx->mm, &nc_ctx->mp);
 }
 nc_ctx->k = k;

 do { } while (0);
 ;
 ;
 ;
 ;
}

static void duk__dragon4_generate(duk__numconv_stringify_ctx *nc_ctx) {
 duk_small_int_t tc1, tc2;
 duk_small_int_t d;
 duk_small_int_t count = 0;
# 1000 "duk_numconv.c"
 for (;;) {
  do { } while (0)




                                               ;
  ;
  ;
  ;
  ;


  duk__bi_mul_small(&nc_ctx->t1, &nc_ctx->r, (duk_uint32_t) nc_ctx->B);
  d = 0;
  for (;;) {
   if (duk__bi_compare(&nc_ctx->t1, &nc_ctx->s) < 0) {
    break;
   }
   duk__bi_sub_copy(&nc_ctx->t1, &nc_ctx->s, &nc_ctx->t2);
   d++;
  }
  duk__bi_copy(&nc_ctx->r, &nc_ctx->t1);

  do { } while (0);
  ;

  duk__bi_mul_small_copy(&nc_ctx->mp, (duk_uint32_t) nc_ctx->B, &nc_ctx->t2);
  duk__bi_mul_small_copy(&nc_ctx->mm, (duk_uint32_t) nc_ctx->B, &nc_ctx->t2);
  ;
  ;







  if (nc_ctx->is_fixed == 0) {

   tc1 = (duk__bi_compare(&nc_ctx->r, &nc_ctx->mm) <= (nc_ctx->low_ok ? 0 : -1));

   duk__bi_add(&nc_ctx->t1, &nc_ctx->r, &nc_ctx->mp);
   tc2 = (duk__bi_compare(&nc_ctx->t1, &nc_ctx->s) >= (nc_ctx->high_ok ? 0 : 1));

   do { } while (0);
  } else {

   tc1 = 0;
   tc2 = 0;
  }




  count++;

  if (tc1) {
   if (tc2) {

    duk__bi_mul_small(&nc_ctx->t1, &nc_ctx->r, 2);
    if (duk__bi_compare(&nc_ctx->t1, &nc_ctx->s) < 0) {
     do { } while (0)

                                            ;
     do { do { } while (0); do { } while (0); ((nc_ctx)->digits[(count) -1]) = (duk_uint8_t) (d); } while (0);
    } else {
     do { } while (0)

                                            ;
     do { do { } while (0); do { } while (0); ((nc_ctx)->digits[(count) -1]) = (duk_uint8_t) (d + 1); } while (0);
    }
    break;
   } else {

    do { } while (0);
    do { do { } while (0); do { } while (0); ((nc_ctx)->digits[(count) -1]) = (duk_uint8_t) (d); } while (0);
    break;
   }
  } else {
   if (tc2) {

    do { } while (0)

                                           ;
    do { do { } while (0); do { } while (0); ((nc_ctx)->digits[(count) -1]) = (duk_uint8_t) (d + 1); } while (0);
    break;
   } else {

    do { } while (0);
    do { do { } while (0); do { } while (0); ((nc_ctx)->digits[(count) -1]) = (duk_uint8_t) (d); } while (0);
# 1100 "duk_numconv.c"
   }
  }


  if (nc_ctx->is_fixed) {
   if (nc_ctx->abs_pos) {
    int pos = nc_ctx->k - count + 1;
    do { } while (0)



                                                    ;
    if (pos <= nc_ctx->req_digits) {
     do { } while (0);
     break;
    }
   } else {
    do { } while (0)


                                                    ;
    if (count >= nc_ctx->req_digits) {
     do { } while (0);
     break;
    }
   }
  }
 }

 nc_ctx->count = count;

 do { } while (0);
# 1149 "duk_numconv.c"
}
# 1160 "duk_numconv.c"
static duk_small_int_t duk__dragon4_fixed_format_round(duk__numconv_stringify_ctx *nc_ctx, duk_small_int_t round_idx) {
 duk_small_int_t t;
 duk_uint8_t *p;
 duk_uint8_t roundup_limit;
 duk_small_int_t ret = 0;
# 1173 "duk_numconv.c"
 if (round_idx >= nc_ctx->count) {
  do { } while (0)

                                             ;
  return 0;
 } else if (round_idx < 0) {
  do { } while (0);
  return 0;
 }
# 1191 "duk_numconv.c"
 roundup_limit = (duk_uint8_t) ((nc_ctx->B + 1) / 2);

 p = &nc_ctx->digits[round_idx];
 if (*p >= roundup_limit) {
  do { } while (0);

  for (;;) {
   *p = 0;
   if (p == &nc_ctx->digits[0]) {
    do { } while (0);
    do { void *duk__dst = ((void *) (&nc_ctx->digits[1])); const void *duk__src = ((const void *) (&nc_ctx->digits[0])); duk_size_t duk__len = ((size_t) (sizeof(char) * (size_t) nc_ctx->count)); do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } while (0)

                                                                 ;
    nc_ctx->digits[0] = 1;
    nc_ctx->k++;
    nc_ctx->count++;
    ret = 1;
    break;
   }

   do { } while (0)



                                                 ;
   p--;
   t = *p;
   do { } while (0);
   if (++t < nc_ctx->B) {
    do { } while (0);
    *p = (duk_uint8_t) t;
    break;
   }

   do { } while (0);
  }
 }

 return ret;
}



static void duk__dragon4_convert_and_push(duk__numconv_stringify_ctx *nc_ctx,
                                             duk_hthread *thr,
                                             duk_small_int_t radix,
                                             duk_small_int_t digits,
                                             duk_small_uint_t flags,
                                             duk_small_int_t neg) {
 duk_small_int_t k;
 duk_small_int_t pos, pos_end;
 duk_small_int_t expt;
 duk_small_int_t dig;
 duk_uint8_t *q;
 duk_uint8_t *buf;
# 1271 "duk_numconv.c"
 do { } while (0);
 do { } while (0);

 k = nc_ctx->k;
 buf = (duk_uint8_t *) &nc_ctx->f;
 q = buf;
# 1285 "duk_numconv.c"
 expt = (65536);
 if (!nc_ctx->abs_pos ) {
  if ((flags & (1U << 1)) ||
      ((flags & (1U << 2)) &&
       (k - digits >= 1)) ||
      ((k > 21 || k <= -6) && (radix == 10))) {
   do { } while (0);
   expt = k - 1;
   k = 1;
  }
 }

 if (neg) {
  *q++ = '-';
 }


 pos = (k >= 1 ? k : 1);
 if (nc_ctx->is_fixed) {
  if (nc_ctx->abs_pos) {

   pos_end = -digits;
  } else {
   pos_end = k - digits;
  }
 } else {
  pos_end = k - nc_ctx->count;
 }
 if (pos_end > 0) {
  pos_end = 0;
 }

 do { } while (0)
# 1326 "duk_numconv.c"
                                              ;


 while (pos > pos_end) {
  do { } while (0);
  if (pos == 0) {
   *q++ = (duk_uint8_t) '.';
  }
  if (pos > k) {
   *q++ = (duk_uint8_t) '0';
  } else if (pos <= k - nc_ctx->count) {
   *q++ = (duk_uint8_t) '0';
  } else {
   dig = nc_ctx->digits[k - pos];
   do { } while (0);
   *q++ = (duk_uint8_t) duk_lc_digits[(dig)];
  }

  pos--;
 }
 do { } while (0);


 if (expt != (65536)) {
# 1364 "duk_numconv.c"
  duk_size_t len;
  char expt_sign;

  *q++ = 'e';
  if (expt >= 0) {
   expt_sign = '+';
  } else {
   expt_sign = '-';
   expt = -expt;
  }
  *q++ = (duk_uint8_t) expt_sign;
  len = duk__dragon4_format_uint32(q, (duk_uint32_t) expt, radix);
  q += len;
 }

 duk_push_lstring(thr, (const char *) buf, (size_t) (q - buf));
}





static void duk__dragon4_double_to_ctx(duk__numconv_stringify_ctx *nc_ctx, duk_double_t x) {
 duk_double_union u;
 duk_uint32_t tmp;
 duk_small_int_t expt;
# 1405 "duk_numconv.c"
 do { (&u)->d = (x); } while (0);

 nc_ctx->f.n = 2;

 tmp = ((&u)->ui[0]);
 nc_ctx->f.v[0] = tmp;
 tmp = ((&u)->ui[1]);
 nc_ctx->f.v[1] = tmp & 0x000fffffUL;
 expt = (duk_small_int_t) ((tmp >> 20) & 0x07ffUL);

 if (expt == 0) {

  expt = (-1022) - 52;
  duk__bi_normalize(&nc_ctx->f);
 } else {

  nc_ctx->f.v[1] |= 0x00100000UL;
  expt = expt - 1023 - 52;
  do { } while (0);
 }

 do { } while (0);

 nc_ctx->e = expt;
}

static void duk__dragon4_ctx_to_double(duk__numconv_stringify_ctx *nc_ctx, duk_double_t *x) {
 duk_double_union u;
 duk_small_int_t expt;
 duk_small_int_t i;
 duk_small_int_t bitstart;
 duk_small_int_t bitround;
 duk_small_int_t bitidx;
 duk_small_int_t skip_round;
 duk_uint32_t t, v;

 do { } while (0);




 do { } while (0);






 do { void *duk__dst = ((void *) &u); duk_size_t duk__len = (sizeof(u)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
# 1489 "duk_numconv.c"
 skip_round = 0;

recheck_exp:

 expt = nc_ctx->k - 1;
 if (expt > 1023) {

  bitstart = -255;


  expt = 2047;
 } else if (expt >= -1022) {

  bitstart = 1;
  expt += 1023;
  do { } while (0);
 } else {

  bitstart = 1023 + expt;


  expt = 0;
 }
 bitround = bitstart + 52;

 do { } while (0);

 if (!skip_round) {
  if (duk__dragon4_fixed_format_round(nc_ctx, bitround)) {




   do { } while (0);
   skip_round = 1;
   goto recheck_exp;
  }
 }





 t = 0;
 for (i = 0; i < 52; i++) {
  bitidx = bitstart + 52 - 1 - i;
  if (bitidx >= nc_ctx->count) {
   v = 0;
  } else if (bitidx < 0) {
   v = 0;
  } else {
   v = nc_ctx->digits[bitidx];
  }
  do { } while (0);
  t += v << (i % 32);
  if (i == 31) {

   do { (&u)->ui[0] = (duk_uint32_t) (t); } while (0);
   t = 0;
  }
 }


 do { } while (0);

 do { } while (0);
 t += ((duk_uint32_t) expt) << 20;





 do { (&u)->ui[1] = (duk_uint32_t) (t); } while (0);

 do { } while (0)

                                                                  ;

 *x = ((&u)->d);
}
# 1577 "duk_numconv.c"
static __attribute__((noinline)) void duk__numconv_stringify_raw(duk_hthread *thr,
                                                       duk_small_int_t radix,
                                                       duk_small_int_t digits,
                                                       duk_small_uint_t flags) {
 duk_double_t x;
 duk_small_int_t c;
 duk_small_int_t neg;
 duk_uint32_t uval;
 duk__numconv_stringify_ctx nc_ctx_alloc;
 duk__numconv_stringify_ctx *nc_ctx = &nc_ctx_alloc;

 x = (duk_double_t) duk_require_number(thr, -1);
 duk_pop(thr);





 c = (duk_small_int_t) 
# 1595 "duk_numconv.c" 3 4
                      __builtin_fpclassify (0, 1, 4, 3, 2, 
# 1595 "duk_numconv.c"
                      x
# 1595 "duk_numconv.c" 3 4
                      )
# 1595 "duk_numconv.c"
                                       ;
 if (
# 1596 "duk_numconv.c" 3 4
    __builtin_signbit (
# 1596 "duk_numconv.c"
    (double) x
# 1596 "duk_numconv.c" 3 4
    )
# 1596 "duk_numconv.c"
                           ) {
  x = -x;
  neg = 1;
 } else {
  neg = 0;
 }


 do { } while (0);

 if (c == 
# 1606 "duk_numconv.c" 3 4
         0
# 1606 "duk_numconv.c"
                   ) {
  duk_push_hstring_stridx(thr, 59);
  return;
 } else if (c == 
# 1609 "duk_numconv.c" 3 4
                1
# 1609 "duk_numconv.c"
                               ) {
  if (neg) {

   duk_push_hstring_stridx(thr, 61);
  } else {

   duk_push_hstring_stridx(thr, 60);
  }
  return;
 } else if (c == 
# 1618 "duk_numconv.c" 3 4
                2
# 1618 "duk_numconv.c"
                           ) {



  ;
 }
# 1636 "duk_numconv.c"
 uval = duk_double_to_uint32_t(x);
 if (duk_double_equals((double) uval, x) &&
     flags == 0) {

  duk_uint8_t *buf = (duk_uint8_t *) (&nc_ctx->f);
  duk_uint8_t *p = buf;

  do { } while (0);
  if (neg && uval != 0) {

   *p++ = (duk_uint8_t) '-';
  }
  p += duk__dragon4_format_uint32(p, uval, radix);
  duk_push_lstring(thr, (const char *) buf, (duk_size_t) (p - buf));
  return;
 }
# 1671 "duk_numconv.c"
 nc_ctx->is_s2n = 0;
 nc_ctx->b = 2;
 nc_ctx->B = radix;
 nc_ctx->abs_pos = 0;
 if (flags & (1U << 0)) {
  nc_ctx->is_fixed = 1;
  if (flags & (1U << 3)) {



   nc_ctx->abs_pos = 1;
   nc_ctx->req_digits = (-digits + 1) - 1;
  } else {
   nc_ctx->req_digits = digits + 1;
  }
 } else {
  nc_ctx->is_fixed = 0;
  nc_ctx->req_digits = 0;
 }

 if (c == 
# 1691 "duk_numconv.c" 3 4
         2
# 1691 "duk_numconv.c"
                    ) {




  duk_small_int_t count;
  if (nc_ctx->is_fixed) {
   if (nc_ctx->abs_pos) {
    count = digits + 2;
   } else {
    count = digits + 1;
   }
  } else {
   count = 1;
  }
  do { } while (0);
  do { } while (0);
  do { void *duk__dst = ((void *) nc_ctx->digits); duk_size_t duk__len = ((size_t) count); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
  nc_ctx->count = count;
  nc_ctx->k = 1;
  neg = 0;
  goto zero_skip;
 }

 duk__dragon4_double_to_ctx(nc_ctx, x);
 ;
 do { } while (0);





 duk__dragon4_prepare(nc_ctx);

 do { } while (0);
 ;
 ;
 ;
 ;

 duk__dragon4_scale(nc_ctx);

 do { } while (0);
 ;
 ;
 ;
 ;

 duk__dragon4_generate(nc_ctx);





zero_skip:

 if (flags & (1U << 0)) {

  duk_small_int_t roundpos;
  if (flags & (1U << 3)) {



   roundpos = -digits;
   roundpos = nc_ctx->k - roundpos;
  } else {
   roundpos = digits;
  }
  do { } while (0)



                                        ;
  (void) duk__dragon4_fixed_format_round(nc_ctx, roundpos);






 }

 duk__dragon4_convert_and_push(nc_ctx, thr, radix, digits, flags, neg);
}

static __attribute__ ((unused)) void duk_numconv_stringify(duk_hthread *thr, duk_small_int_t radix, duk_small_int_t digits, duk_small_uint_t flags) {
 duk_native_stack_check(thr);
 duk__numconv_stringify_raw(thr, radix, digits, flags);
}
# 1791 "duk_numconv.c"
static __attribute__((noinline)) void duk__numconv_parse_raw(duk_hthread *thr, duk_small_int_t radix, duk_small_uint_t flags) {
 duk__numconv_stringify_ctx nc_ctx_alloc;
 duk__numconv_stringify_ctx *nc_ctx = &nc_ctx_alloc;
 duk_double_t res;
 duk_hstring *h_str;
 duk_int_t expt;
 duk_bool_t expt_neg;
 duk_small_int_t expt_adj;
 duk_small_int_t neg;
 duk_small_int_t dig;
 duk_small_int_t dig_whole;
 duk_small_int_t dig_lzero;
 duk_small_int_t dig_frac;
 duk_small_int_t dig_expt;
 duk_small_int_t dig_prec;
 const duk__exp_limits *explim;
 const duk_uint8_t *p;
 duk_small_int_t ch;

 do { } while (0)


                                             ;

 do { } while (0);
 do { } while (0);
# 1839 "duk_numconv.c"
 if (flags & (1U << 0)) {




  duk_trim(thr, -1);
 }
 h_str = duk_require_hstring(thr, -1);
 do { } while (0);
 p = (const duk_uint8_t *) ((const duk_uint8_t *) ((h_str) + 1));

 neg = 0;
 ch = *p;
 if (ch == (duk_small_int_t) '+') {
  if ((flags & (1U << 3)) == 0) {
   do { } while (0);
   goto parse_fail;
  }
  p++;
 } else if (ch == (duk_small_int_t) '-') {
  if ((flags & (1U << 4)) == 0) {
   do { } while (0);
   goto parse_fail;
  }
  p++;
  neg = 1;
 }

 if ((flags & (1U << 5)) && strncmp((const char *) p, "Infinity", 8) == 0) {







  if ((flags & (1U << 2)) == 0 && p[8] != 0x00) {
   do { } while (0);
   goto parse_fail;
  } else {
   res = ((double) 
# 1879 "duk_numconv.c" 3 4
        (__builtin_inff ())
# 1879 "duk_numconv.c"
        );
   goto negcheck_and_ret;
  }
 }
 ch = *p;
 if (ch == (duk_small_int_t) '0') {
  duk_small_int_t detect_radix = 0;
  ch = ((p[1]) | 0x20);
  if ((flags & (1U << 11)) && ch == 0x78) {
   do { } while (0);
   detect_radix = 16;
# 1903 "duk_numconv.c"
  } else if ((flags & (1U << 13)) && ch == 0x6f) {
   do { } while (0);
   detect_radix = 8;
  } else if ((flags & (1U << 14)) && ch == 0x62) {
   do { } while (0);
   detect_radix = 2;
  }
  if (detect_radix > 0) {
   radix = detect_radix;

   flags &= ~((1U << 1) | (1U << 8) | (1U << 6) |
              (1U << 7) | (1U << 9));
   flags |= (1U << 10);
   p += 2;
  }
 }
# 1966 "duk_numconv.c"
 duk__bi_set_small(&nc_ctx->f, 0);
 dig_prec = 0;
 dig_lzero = 0;
 dig_whole = 0;
 dig_frac = -1;
 dig_expt = -1;
 expt = 0;
 expt_adj = 0;
 expt_neg = 0;
 for (;;) {
  ch = *p++;

  do { } while (0)
# 1989 "duk_numconv.c"
                                        ;
  ;


  if (ch >= (duk_small_int_t) '0' && ch <= (duk_small_int_t) '9') {
   dig = (duk_small_int_t) ch - '0' + 0;
  } else if (ch == (duk_small_int_t) '.') {




   if (dig_frac >= 0 || dig_expt >= 0) {
    if (flags & (1U << 2)) {
     do { } while (0);
     break;
    } else {
     do { } while (0);
     goto parse_fail;
    }
   }

   if ((flags & (1U << 6)) == 0) {



    if (flags & (1U << 2)) {
     do { } while (0);
     break;
    } else {
     do { } while (0);
    }
   }

   do { } while (0);
   dig_frac = 0;
   continue;
  } else if (ch == (duk_small_int_t) 0) {
   do { } while (0);
   break;
  } else if ((flags & (1U << 1)) && dig_expt < 0 &&
             (ch == (duk_small_int_t) 'e' || ch == (duk_small_int_t) 'E')) {
# 2040 "duk_numconv.c"
   do { } while (0);




   ch = *p;
   if (ch == (duk_small_int_t) '-') {
    expt_neg = 1;
    p++;
   } else if (ch == (duk_small_int_t) '+') {
    p++;
   }
   dig_expt = 0;
   continue;
  } else if (ch >= (duk_small_int_t) 'a' && ch <= (duk_small_int_t) 'z') {
   dig = (duk_small_int_t) (ch - (duk_small_int_t) 'a' + 0x0a);
  } else if (ch >= (duk_small_int_t) 'A' && ch <= (duk_small_int_t) 'Z') {
   dig = (duk_small_int_t) (ch - (duk_small_int_t) 'A' + 0x0a);
  } else {
   dig = 255;
  }
  do { } while (0);

  if (dig >= radix) {
   if (flags & (1U << 2)) {
    do { } while (0);
    break;
   } else {
    do { } while (0);
    goto parse_fail;
   }
  }

  if (dig_expt < 0) {


   if (dig_prec < duk__str2num_digits_for_radix[radix - 2]) {


    duk_small_int_t f_zero = duk__bi_is_zero(&nc_ctx->f);
    if (f_zero && dig == 0) {



     if (dig_frac < 0) {
      dig_lzero++;
     }
    } else {



     duk__bi_mul_small(&nc_ctx->t1, &nc_ctx->f, (duk_uint32_t) radix);
     duk__bi_add_small(&nc_ctx->f, &nc_ctx->t1, (duk_uint32_t) dig);
     dig_prec++;
    }
   } else {



    expt_adj++;
   }

   if (dig_frac >= 0) {
    dig_frac++;
    expt_adj--;
   } else {
    dig_whole++;
   }
  } else {


   do { } while (0);
   expt = expt * radix + dig;
   if (expt > 10000000L) {



    do { } while (0);
    goto parse_explimit_error;
   }
   dig_expt++;
  }
 }



 if (dig_lzero > 0 && dig_whole > 1) {
  if ((flags & (1U << 10)) == 0) {
   do { } while (0);
   goto parse_fail;
  }
 }



 if (dig_whole == 0) {
  if (dig_frac == 0) {

   do { } while (0);
   goto parse_fail;
  } else if (dig_frac > 0) {

   if ((flags & (1U << 7)) == 0) {
    do { } while (0)
                                                     ;
    goto parse_fail;
   }
  } else {





   if ((flags & (1U << 9)) == 0) {
    do { } while (0);
    goto parse_fail;
   } else if (((h_str)->blen) != 0) {
    do { } while (0);
    goto parse_fail;
   }
  }
 } else {
  if (dig_frac == 0) {

   if ((flags & (1U << 8)) == 0) {
    do { } while (0);
    goto parse_fail;
   }
  } else if (dig_frac > 0) {

   ;
  } else {

   ;
  }
 }





 if (dig_expt == 0) {
  if ((flags & (1U << 2)) == 0) {
   do { } while (0);
   goto parse_fail;
  }
  do { } while (0);
 }

 if (expt_neg) {
  expt = -expt;
 }
 do { } while (0)
                                                                                                                         ;
 expt += expt_adj;



 if (nc_ctx->f.n <= 1 &&
     expt == 0 ) {






  do { } while (0);
  if (nc_ctx->f.n == 1) {
   res = (double) nc_ctx->f.v[0];
  } else {
   res = 0.0;
  }
  goto negcheck_and_ret;
 }



 while (dig_prec < duk__str2num_digits_for_radix[radix - 2]) {



  do { } while (0);
  duk__bi_mul_small_copy(&nc_ctx->f, (duk_uint32_t) radix, &nc_ctx->t1);
  ;
  expt--;
  dig_prec++;
 }

 do { } while (0);



 if (nc_ctx->f.n == 0) {



  do { } while (0);
  res = 0.0;
  goto negcheck_and_ret;
 }






 explim = &duk__str2num_exp_limits[radix - 2];
 if (expt > explim->upper) {
  do { } while (0);
  res = (duk_double_t) ((double) 
# 2249 "duk_numconv.c" 3 4
                      (__builtin_inff ())
# 2249 "duk_numconv.c"
                      );
  goto negcheck_and_ret;
 } else if (expt < explim->lower) {
  do { } while (0);
  res = (duk_double_t) 0.0;
  goto negcheck_and_ret;
 }

 nc_ctx->is_s2n = 1;
 nc_ctx->e = expt;
 nc_ctx->b = radix;
 nc_ctx->B = 2;
 nc_ctx->is_fixed = 1;
 nc_ctx->abs_pos = 0;
 nc_ctx->req_digits = 53 + 1;

 ;
 do { } while (0);






 duk__dragon4_prepare(nc_ctx);

 do { } while (0);
 ;
 ;
 ;
 ;

 duk__dragon4_scale(nc_ctx);

 do { } while (0);
 ;
 ;
 ;
 ;

 duk__dragon4_generate(nc_ctx);

 do { } while (0);
# 2302 "duk_numconv.c"
 duk__dragon4_ctx_to_double(nc_ctx, &res);
 goto negcheck_and_ret;

negcheck_and_ret:
 if (neg) {
  res = -res;
 }
 duk_pop(thr);
 duk_push_number(thr, (double) res);
 do { } while (0);
 return;

parse_fail:
 do { } while (0);
 duk_pop(thr);
 duk_push_nan(thr);
 return;

parse_explimit_error:
 do { } while (0);
 do { duk_err_range((thr), "duk_numconv.c", (duk_int_t) 2322, ("exponent too large")); } while (0);
 do { return; } while (0);
}

static __attribute__ ((unused)) void duk_numconv_parse(duk_hthread *thr, duk_small_int_t radix, duk_small_uint_t flags) {
 duk_native_stack_check(thr);
 duk__numconv_parse_raw(thr, radix, flags);
}
# 1 "duk_regexp_compiler.c"
# 37 "duk_regexp_compiler.c"
typedef struct {




 duk_int32_t charlen;
# 57 "duk_regexp_compiler.c"
} duk__re_disjunction_info;
# 72 "duk_regexp_compiler.c"
static duk_uint32_t duk__encode_i32(duk_int32_t x) {
 if (x < 0) {
  return ((duk_uint32_t) (-x)) * 2 + 1;
 } else {
  return ((duk_uint32_t) x) * 2;
 }
}




static duk_uint32_t duk__insert_u32(duk_re_compiler_ctx *re_ctx, duk_uint32_t offset, duk_uint32_t x) {
 duk_uint8_t buf[7];
 duk_small_int_t len;

 len = duk_unicode_encode_xutf8((duk_ucodepoint_t) x, buf);
 do { } while (0);
 duk_bw_insert_ensure_bytes((re_ctx->thr), (&re_ctx->bw), (offset), (buf), ((duk_size_t) len));
 return (duk_uint32_t) len;
}

static void duk__append_u32(duk_re_compiler_ctx *re_ctx, duk_uint32_t x) {
 do { do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (7); duk__space = (duk_size_t) (((&re_ctx->bw))->p_limit - ((&re_ctx->bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((re_ctx->thr)), ((&re_ctx->bw)), duk__sz); } } while (0); do { duk_ucodepoint_t duk__cp; duk_small_int_t duk__enc_len; duk__cp = (duk_ucodepoint_t) ((x)); do { (((void) 0), ((void) 0)); } while (0); duk__enc_len = duk_unicode_encode_xutf8(duk__cp, ((&re_ctx->bw))->p); ((&re_ctx->bw))->p += duk__enc_len; } while (0); } while (0);
}

static void duk__append_7bit(duk_re_compiler_ctx *re_ctx, duk_uint32_t x) {



 do { } while (0);
 do { do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (1); duk__space = (duk_size_t) (((&re_ctx->bw))->p_limit - ((&re_ctx->bw))->p); if (duk__space < duk__sz) { (void) duk_bw_resize(((re_ctx->thr)), ((&re_ctx->bw)), duk__sz); } } while (0); do { do { (((void) 0), ((void) 0)); } while (0); *((&re_ctx->bw))->p++ = (duk_uint8_t) (((duk_uint8_t) x)); } while (0); } while (0);

}







static duk_uint32_t duk__insert_i32(duk_re_compiler_ctx *re_ctx, duk_uint32_t offset, duk_int32_t x) {
 return duk__insert_u32(re_ctx, offset, duk__encode_i32(x));
}

static void duk__append_reop(duk_re_compiler_ctx *re_ctx, duk_uint32_t reop) {
 do { } while (0);
 (void) duk__append_7bit(re_ctx, reop);
}
# 128 "duk_regexp_compiler.c"
static void duk__append_u16_list(duk_re_compiler_ctx *re_ctx, const duk_uint16_t *values, duk_uint32_t count) {

 while (count-- > 0) {
  duk__append_u32(re_ctx, (duk_uint32_t) (*values++));
 }
}

static void duk__insert_slice(duk_re_compiler_ctx *re_ctx,
                                 duk_uint32_t offset,
                                 duk_uint32_t data_offset,
                                 duk_uint32_t data_length) {
 duk_bw_insert_ensure_slice((re_ctx->thr), (&re_ctx->bw), (offset), (data_offset), (data_length));
}

static void duk__append_slice(duk_re_compiler_ctx *re_ctx, duk_uint32_t data_offset, duk_uint32_t data_length) {
 duk_bw_write_ensure_slice((re_ctx->thr), (&re_ctx->bw), (data_offset), (data_length));
}

static void duk__remove_slice(duk_re_compiler_ctx *re_ctx, duk_uint32_t data_offset, duk_uint32_t data_length) {
 duk_bw_remove_raw_slice(((re_ctx->thr)), ((&re_ctx->bw)), ((data_offset)), ((data_length)));
}
# 163 "duk_regexp_compiler.c"
static duk_uint32_t duk__insert_jump_offset(duk_re_compiler_ctx *re_ctx, duk_uint32_t offset, duk_int32_t skip) {
# 205 "duk_regexp_compiler.c"
 if (skip < 0) {
  if (skip >= -0x3eL) {
   skip -= 1;
  } else if (skip >= -0x3fdL) {
   skip -= 2;
  } else if (skip >= -0x7ffcL) {
   skip -= 3;
  } else if (skip >= -0xffffbL) {
   skip -= 4;
  } else if (skip >= -0x1fffffaL) {
   skip -= 5;
  } else if (skip >= -0x3ffffff9L) {
   skip -= 6;
  } else {
   skip -= 7;
  }
 }


 return duk__insert_i32(re_ctx, offset, skip);
}

static duk_uint32_t duk__append_jump_offset(duk_re_compiler_ctx *re_ctx, duk_int32_t skip) {
 return (duk_uint32_t) duk__insert_jump_offset(re_ctx, (duk_uint32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base)), skip);
}
# 308 "duk_regexp_compiler.c"
static void duk__regexp_emit_range(duk_re_compiler_ctx *re_ctx, duk_codepoint_t r1, duk_codepoint_t r2) {
 do { } while (0);
 duk__append_u32(re_ctx, (duk_uint32_t) r1);
 duk__append_u32(re_ctx, (duk_uint32_t) r2);
 re_ctx->nranges++;
}






static duk_codepoint_t duk__re_canon_next_discontinuity(duk_codepoint_t start, duk_codepoint_t end) {
 duk_uint_t start_blk;
 duk_uint_t end_blk;
 duk_uint_t blk;
 duk_uint_t offset;
 duk_uint8_t mask;


 do { } while (0);
 do { } while (0);
 do { } while (0);
 start_blk = (duk_uint_t) (start >> 5);
 end_blk = (duk_uint_t) (end >> 5);

 for (blk = start_blk; blk <= end_blk; blk++) {
  offset = blk >> 3;
  mask = 1U << (blk & 0x07);
  if (offset >= sizeof(duk_unicode_re_canon_bitmap)) {

   return end;
  }
  do { } while (0);
  if ((duk_unicode_re_canon_bitmap[offset] & mask) == 0) {





   if (blk > start_blk) {
    return (duk_codepoint_t) (blk << 5);
   } else {
    return start;
   }
  }
 }
 do { } while (0);
 return end;
}
# 371 "duk_regexp_compiler.c"
static void duk__regexp_generate_ranges(void *userdata, duk_codepoint_t r1, duk_codepoint_t r2, duk_bool_t direct) {
 duk_re_compiler_ctx *re_ctx = (duk_re_compiler_ctx *) userdata;
 duk_codepoint_t r_start;
 duk_codepoint_t r_end;
 duk_codepoint_t i;
 duk_codepoint_t t;
 duk_codepoint_t r_disc;

 do { } while (0)



                                   ;

 do { } while (0);

 if (direct || (re_ctx->re_flags & (1U << 1)) == 0) {
  do { } while (0);
  duk__regexp_emit_range(re_ctx, r1, r2);
  return;
 }

 do { } while (0);

 r_start = duk_unicode_re_canonicalize_char(re_ctx->thr, r1);
 r_end = r_start;

 for (i = r1 + 1; i <= r2;) {




  r_disc = duk__re_canon_next_discontinuity(i, r2);
  do { } while (0);
  do { } while (0);

  r_end += r_disc - i;
  t = duk_unicode_re_canonicalize_char(re_ctx->thr, r_disc);
  if (t == r_end + 1) {



   r_end = t;
  } else {
   duk__regexp_emit_range(re_ctx, r_start, r_end);
   r_start = t;
   r_end = t;
  }
  i = r_disc + 1;
 }
 duk__regexp_emit_range(re_ctx, r_start, r_end);
# 444 "duk_regexp_compiler.c"
}
# 496 "duk_regexp_compiler.c"
static const duk_uint16_t * const duk__re_range_lookup1[3] = { duk_unicode_re_ranges_digit,
                                                           duk_unicode_re_ranges_white,
                                                           duk_unicode_re_ranges_wordchar };
static const duk_uint8_t duk__re_range_lookup2[3] = { sizeof(duk_unicode_re_ranges_digit) / (2 * sizeof(duk_uint16_t)),
                                                  sizeof(duk_unicode_re_ranges_white) / (2 * sizeof(duk_uint16_t)),
                                                  sizeof(duk_unicode_re_ranges_wordchar) / (2 * sizeof(duk_uint16_t)) };

static void duk__append_range_atom_matcher(duk_re_compiler_ctx *re_ctx,
                                              duk_small_uint_t re_op,
                                              const duk_uint16_t *ranges,
                                              duk_small_uint_t count) {





 duk__append_reop(re_ctx, re_op);
 duk__append_7bit(re_ctx, count);
 duk__append_u16_list(re_ctx, ranges, count * 2);
}

static void duk__parse_disjunction(duk_re_compiler_ctx *re_ctx, duk_bool_t expect_eof, duk__re_disjunction_info *out_atom_info) {
 duk_int32_t atom_start_offset = -1;
 duk_int32_t atom_char_length = 0;
 duk_uint32_t atom_start_captures = re_ctx->captures;
 duk_int32_t unpatched_disjunction_split = -1;
 duk_int32_t unpatched_disjunction_jump = -1;
 duk_uint32_t entry_offset = (duk_uint32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base));
 duk_int32_t res_charlen = 0;
 duk__re_disjunction_info tmp_disj;

 do { } while (0);

 duk_native_stack_check(re_ctx->thr);
 if (re_ctx->recursion_depth >= re_ctx->recursion_limit) {
  do { duk_err_range((re_ctx->thr), "duk_regexp_compiler.c", (duk_int_t) 531, ("regexp compiler recursion limit")); } while (0);
  do { return; } while (0);
 }
 re_ctx->recursion_depth++;





 for (;;) {






  duk_int32_t new_atom_char_length;
  duk_int32_t new_atom_start_offset;


  duk_uint32_t new_atom_start_captures;

  duk_lexer_parse_re_token(&re_ctx->lex, &re_ctx->curr_token);

  do { } while (0)



                                                                                                                     ;


  new_atom_start_offset = -1;
  new_atom_char_length = -1;
  new_atom_start_captures = re_ctx->captures;

  switch (re_ctx->curr_token.t) {
  case 1: {







   if (unpatched_disjunction_jump >= 0) {
    duk_uint32_t offset;

    do { } while (0);
    offset = (duk_uint32_t) unpatched_disjunction_jump;
    offset += duk__insert_jump_offset(re_ctx, offset, (duk_int32_t) (((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base)) - offset));

    duk__insert_jump_offset(re_ctx,
                            (duk_uint32_t) unpatched_disjunction_split,
                            (duk_int32_t) offset - unpatched_disjunction_split);
   }


   (void) duk__insert_u32(re_ctx, entry_offset, 7);
   unpatched_disjunction_split = (duk_int32_t) (entry_offset + 1);


   duk__append_reop(re_ctx, 6);
   unpatched_disjunction_jump = (duk_int32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base));


   res_charlen = -1;
   break;
  }
  case 2: {
   if (atom_start_offset < 0) {
    do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 601; do { } while (0); do { } while (0); duk_err_handle_error(((re_ctx->thr)), "duk_regexp_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("quantifier without preceding atom"))); } while (0); } while (0);
    do { return; } while (0);
   }
   if (re_ctx->curr_token.qmin > re_ctx->curr_token.qmax) {
    do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 605; do { } while (0); do { } while (0); duk_err_handle_error(((re_ctx->thr)), "duk_regexp_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("quantifier values invalid (qmin > qmax)"))); } while (0); } while (0);
    do { return; } while (0);
   }
   if (atom_char_length >= 0) {
# 621 "duk_regexp_compiler.c"
    duk_int32_t atom_code_length;
    duk_uint32_t offset;
    duk_uint32_t qmin, qmax;

    qmin = re_ctx->curr_token.qmin;
    qmax = re_ctx->curr_token.qmax;
    if (atom_char_length == 0) {

     if (qmin > 1) {
      qmin = 1;
     }
     if (qmax > 1) {
      qmax = 1;
     }
    }

    duk__append_reop(re_ctx, 1);
    atom_code_length = (duk_int32_t) (((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base)) - (duk_size_t) atom_start_offset);

    offset = (duk_uint32_t) atom_start_offset;
    if (re_ctx->curr_token.greedy) {
     offset += duk__insert_u32(re_ctx, offset, 10);
     offset += duk__insert_u32(re_ctx, offset, qmin);
     offset += duk__insert_u32(re_ctx, offset, qmax);
     offset += duk__insert_u32(re_ctx, offset, (duk_uint32_t) atom_char_length);
     offset += duk__insert_jump_offset(re_ctx, offset, atom_code_length);
    } else {
     offset += duk__insert_u32(re_ctx, offset, 9);
     offset += duk__insert_u32(re_ctx, offset, qmin);
     offset += duk__insert_u32(re_ctx, offset, qmax);
     offset += duk__insert_jump_offset(re_ctx, offset, atom_code_length);
    }
    do { (void) (offset); } while (0);
   } else {
# 666 "duk_regexp_compiler.c"
    duk_int32_t atom_code_length;
    duk_uint32_t atom_copies;
    duk_uint32_t tmp_qmin, tmp_qmax;


    atom_copies = (re_ctx->curr_token.qmax == ((duk_uint32_t) 0xffffffffUL)) ? re_ctx->curr_token.qmin :
                                                                                                        re_ctx->curr_token.qmax;
    if (atom_copies > 1000) {
     do { duk_err_range((re_ctx->thr), "duk_regexp_compiler.c", (duk_int_t) 674, ("quantifier requires too many atom copies")); } while (0);
     do { return; } while (0);
    }


    do { } while (0);
    if (atom_start_captures != re_ctx->captures) {
     do { } while (0);
     do { } while (0)

                                                   ;


     duk__insert_u32(re_ctx,
                     (duk_uint32_t) atom_start_offset,
                     (re_ctx->captures - atom_start_captures) * 2U);
     duk__insert_u32(re_ctx, (duk_uint32_t) atom_start_offset, (atom_start_captures + 1) * 2);
     duk__insert_u32(re_ctx, (duk_uint32_t) atom_start_offset, 12);
    } else {
     do { } while (0)

                                                  ;
    }

    atom_code_length = (duk_int32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base)) - atom_start_offset;


    tmp_qmin = re_ctx->curr_token.qmin;
    tmp_qmax = re_ctx->curr_token.qmax;
    while (tmp_qmin > 0) {
     duk__append_slice(re_ctx,
                       (duk_uint32_t) atom_start_offset,
                       (duk_uint32_t) atom_code_length);
     tmp_qmin--;
     if (tmp_qmax != ((duk_uint32_t) 0xffffffffUL)) {
      tmp_qmax--;
     }
    }
    do { } while (0);


    if (tmp_qmax == ((duk_uint32_t) 0xffffffffUL)) {


     if (re_ctx->curr_token.qmin == 0) {



      duk__append_reop(re_ctx, 6);
      duk__append_jump_offset(re_ctx, atom_code_length);
      duk__append_slice(re_ctx,
                        (duk_uint32_t) atom_start_offset,
                        (duk_uint32_t) atom_code_length);
     }
     if (re_ctx->curr_token.greedy) {
      duk__append_reop(re_ctx, 8);
     } else {
      duk__append_reop(re_ctx, 7);
     }
     duk__append_jump_offset(re_ctx, -atom_code_length - 1);
    } else {
# 751 "duk_regexp_compiler.c"
     duk_uint32_t offset = (duk_uint32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base));
     while (tmp_qmax > 0) {
      duk__insert_slice(re_ctx,
                        offset,
                        (duk_uint32_t) atom_start_offset,
                        (duk_uint32_t) atom_code_length);
      if (re_ctx->curr_token.greedy) {
       duk__insert_u32(re_ctx, offset, 7);
      } else {
       duk__insert_u32(re_ctx, offset, 8);
      }
      duk__insert_jump_offset(re_ctx,
                              offset + 1,
                              (duk_int32_t) (((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base)) - (offset + 1)));
      tmp_qmax--;
     }
    }


    duk__remove_slice(re_ctx, (duk_uint32_t) atom_start_offset, (duk_uint32_t) atom_code_length);
   }


   res_charlen = -1;
   break;
  }
  case 3: {
   duk__append_reop(re_ctx, 16);
   break;
  }
  case 4: {
   duk__append_reop(re_ctx, 17);
   break;
  }
  case 5: {
   duk__append_reop(re_ctx, 18);
   break;
  }
  case 6: {
   duk__append_reop(re_ctx, 19);
   break;
  }
  case 7:
  case 8: {
   duk_uint32_t offset;
   duk_uint32_t opcode =
       (re_ctx->curr_token.t == 7) ? 13 : 14;

   offset = (duk_uint32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base));
   duk__parse_disjunction(re_ctx, 0, &tmp_disj);
   duk__append_reop(re_ctx, 1);

   (void) duk__insert_u32(re_ctx, offset, opcode);
   (void) duk__insert_jump_offset(re_ctx,
                                  offset + 1,
                                  (duk_int32_t) (((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base)) - (offset + 1)));




   res_charlen = -1;
   break;
  }
  case 9: {
   new_atom_char_length = 1;
   new_atom_start_offset = (duk_int32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base));
   duk__append_reop(re_ctx, 3);
   break;
  }
  case 10: {
# 831 "duk_regexp_compiler.c"
   duk_uint32_t ch;

   new_atom_char_length = 1;
   new_atom_start_offset = (duk_int32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base));
   duk__append_reop(re_ctx, 2);
   ch = re_ctx->curr_token.num;
   if (re_ctx->re_flags & (1U << 1)) {
    ch = (duk_uint32_t) duk_unicode_re_canonicalize_char(re_ctx->thr, (duk_codepoint_t) ch);
   }
   duk__append_u32(re_ctx, ch);
   break;
  }
  case 11:
  case 12:
  case 13:
  case 14:
  case 15:
  case 16: {
   duk_small_uint_t re_op;
   duk_small_uint_t idx;

   new_atom_char_length = 1;
   new_atom_start_offset = (duk_int32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base));

   do { } while (0);
   do { } while (0);
   do { } while (0);
   do { } while (0);
   do { } while (0);
   do { } while (0);
   re_op = (re_ctx->curr_token.t & 0x01) ? 4 : 5;

   do { } while (0);
   do { } while (0);
   idx = (duk_small_uint_t) ((re_ctx->curr_token.t - 11) >> 1U);
   do { } while (0);

   duk__append_range_atom_matcher(re_ctx, re_op, duk__re_range_lookup1[idx], duk__re_range_lookup2[idx]);
   break;
  }
  case 17: {
   duk_uint32_t backref = (duk_uint32_t) re_ctx->curr_token.num;
   if (backref > re_ctx->highest_backref) {
    re_ctx->highest_backref = backref;
   }
   new_atom_char_length = -1;
   new_atom_start_offset = (duk_int32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base));
   duk__append_reop(re_ctx, 15);
   duk__append_u32(re_ctx, backref);
   break;
  }
  case 18: {
   duk_uint32_t cap;

   new_atom_char_length = -1;
   new_atom_start_offset = (duk_int32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base));
   cap = ++re_ctx->captures;
   duk__append_reop(re_ctx, 11);
   duk__append_u32(re_ctx, cap * 2);
   duk__parse_disjunction(re_ctx,
                          0,
                          &tmp_disj);
   duk__append_reop(re_ctx, 11);
   duk__append_u32(re_ctx, cap * 2 + 1);
   break;
  }
  case 19: {
   new_atom_start_offset = (duk_int32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base));
   duk__parse_disjunction(re_ctx, 0, &tmp_disj);
   new_atom_char_length = tmp_disj.charlen;
   break;
  }
  case 20:
  case 21: {
# 929 "duk_regexp_compiler.c"
   duk_uint32_t offset;

   do { } while (0);


   new_atom_char_length = 1;
   new_atom_start_offset = (duk_int32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base));
   duk__append_reop(re_ctx,
                    (re_ctx->curr_token.t == 20) ? 4 :
                                                                                                    5);
   offset = (duk_uint32_t) ((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base));


   re_ctx->nranges = 0;
   duk_lexer_parse_re_ranges(&re_ctx->lex, duk__regexp_generate_ranges, (void *) re_ctx);


   duk__insert_u32(re_ctx, offset, re_ctx->nranges);
   break;
  }
  case 22: {
   if (expect_eof) {
    do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 951; do { } while (0); do { } while (0); duk_err_handle_error(((re_ctx->thr)), "duk_regexp_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("unexpected closing parenthesis"))); } while (0); } while (0);
    do { return; } while (0);
   }
   goto done;
  }
  case 0: {
   if (!expect_eof) {
    do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 958; do { } while (0); do { } while (0); duk_err_handle_error(((re_ctx->thr)), "duk_regexp_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("unexpected end of pattern"))); } while (0); } while (0);
    do { return; } while (0);
   }
   goto done;
  }
  default: {
   do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 964; do { } while (0); do { } while (0); duk_err_handle_error(((re_ctx->thr)), "duk_regexp_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("unexpected token in regexp"))); } while (0); } while (0);
   do { return; } while (0);
  }
  }


  if (new_atom_start_offset >= 0) {
   if (new_atom_char_length < 0) {
    res_charlen = -1;
   } else if (res_charlen >= 0) {

    res_charlen += new_atom_char_length;
   }
  }


  atom_start_offset = new_atom_start_offset;
  atom_char_length = new_atom_char_length;
  atom_start_captures = new_atom_start_captures;
 }

done:


 if (unpatched_disjunction_jump >= 0) {
  duk_uint32_t offset;

  do { } while (0);
  offset = (duk_uint32_t) unpatched_disjunction_jump;
  offset += duk__insert_jump_offset(re_ctx, offset, (duk_int32_t) (((duk_size_t) ((&re_ctx->bw)->p - (&re_ctx->bw)->p_base)) - offset));

  duk__insert_jump_offset(re_ctx,
                          (duk_uint32_t) unpatched_disjunction_split,
                          (duk_int32_t) offset - unpatched_disjunction_split);
 }




 out_atom_info->charlen = res_charlen;
 do { } while (0);

 re_ctx->recursion_depth--;
}





static duk_uint32_t duk__parse_regexp_flags(duk_hthread *thr, duk_hstring *h) {
 const duk_uint8_t *p;
 const duk_uint8_t *p_end;
 duk_uint32_t flags = 0;

 p = ((const duk_uint8_t *) ((h) + 1));
 p_end = p + ((h)->blen);



 while (p < p_end) {
  duk_uint8_t c = *p++;
  switch (c) {
  case (duk_uint8_t) 'g': {
   if (flags & (1U << 0)) {
    goto flags_error;
   }
   flags |= (1U << 0);
   break;
  }
  case (duk_uint8_t) 'i': {
   if (flags & (1U << 1)) {
    goto flags_error;
   }
   flags |= (1U << 1);
   break;
  }
  case (duk_uint8_t) 'm': {
   if (flags & (1U << 2)) {
    goto flags_error;
   }
   flags |= (1U << 2);
   break;
  }
  default: {
   goto flags_error;
  }
  }
 }

 return flags;

flags_error:
 do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 1056; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_regexp_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid regexp flags"))); } while (0); } while (0);
 do { return 0U; } while (0);
}
# 1080 "duk_regexp_compiler.c"
static void duk__create_escaped_source(duk_hthread *thr, int idx_pattern) {
 duk_hstring *h;
 const duk_uint8_t *p;
 duk_bufwriter_ctx bw_alloc;
 duk_bufwriter_ctx *bw;
 duk_uint8_t *q;
 duk_size_t i, n;
 duk_uint_fast8_t c_prev, c;

 h = duk_known_hstring(thr, idx_pattern);
 p = (const duk_uint8_t *) ((const duk_uint8_t *) ((h) + 1));
 n = (duk_size_t) ((h)->blen);

 if (n == 0) {
  duk_push_literal_raw((thr), ("(?:)"), sizeof(("(?:)")) - 1U);
  return;
 }

 bw = &bw_alloc;
 do { duk_bw_init_pushbuf((thr), (bw), (n)); } while (0);
 q = ((bw)->p);

 c_prev = (duk_uint_fast8_t) 0;

 for (i = 0; i < n; i++) {
  c = p[i];

  q = (((duk_size_t) ((bw)->p_limit - (q)) >= (2)) ? (q) : ((bw)->p = (q), duk_bw_resize((thr), (bw), (2))));

  if (c == (duk_uint_fast8_t) '/' && c_prev != (duk_uint_fast8_t) '\\') {



   *q++ = 0x5c;
  }
  *q++ = (duk_uint8_t) c;

  c_prev = c;
 }

 do { (bw)->p = (q); duk_bw_compact((thr), (bw)); } while (0);
 (void) duk_buffer_to_string(thr, -1);


}
# 1141 "duk_regexp_compiler.c"
static __attribute__ ((unused)) void duk_regexp_compile(duk_hthread *thr) {
 duk_re_compiler_ctx re_ctx;
 duk_lexer_point lex_point;
 duk_hstring *h_pattern;
 duk_hstring *h_flags;
 duk__re_disjunction_info ign_disj;

 do { } while (0);






 h_pattern = duk_require_hstring_notsymbol(thr, -2);
 h_flags = duk_require_hstring_notsymbol(thr, -1);







 duk__create_escaped_source(thr, -2);
# 1174 "duk_regexp_compiler.c"
 do { void *duk__dst = (&re_ctx); duk_size_t duk__len = (sizeof(re_ctx)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);
 duk_lexer_initctx((&re_ctx.lex));
 re_ctx.thr = thr;
 re_ctx.lex.thr = thr;
 re_ctx.lex.input = ((const duk_uint8_t *) ((h_pattern) + 1));
 re_ctx.lex.input_length = ((h_pattern)->blen);
 re_ctx.lex.token_limit = 100000000L;
 re_ctx.recursion_limit = 10000;
 re_ctx.re_flags = duk__parse_regexp_flags(thr, h_flags);

 do { duk_bw_init_pushbuf((thr), (&re_ctx.bw), (64)); } while (0);

 do { } while (0)

                                                   ;





 lex_point.offset = 0;
 lex_point.line = 1;
 duk_lexer_setpoint((&re_ctx.lex), (&lex_point));





 do { } while (0);

 duk__append_reop(&re_ctx, 11);
 duk__append_7bit(&re_ctx, 0);
 duk__parse_disjunction(&re_ctx, 1 , &ign_disj);
 duk__append_reop(&re_ctx, 11);
 duk__append_7bit(&re_ctx, 1);
 duk__append_reop(&re_ctx, 1);
# 1220 "duk_regexp_compiler.c"
 if (re_ctx.highest_backref > re_ctx.captures) {
  do { do { duk_errcode_t duk__err = (5); duk_int_t duk__line = (duk_int_t) 1221; do { } while (0); do { } while (0); duk_err_handle_error(((thr)), "duk_regexp_compiler.c", (((duk_uint_t) duk__err) << 24) | ((duk_uint_t) duk__line), (("invalid backreference(s)"))); } while (0); } while (0);
  do { return; } while (0);
 }






 duk__insert_u32(&re_ctx, 0, (re_ctx.captures + 1) * 2);
 duk__insert_u32(&re_ctx, 0, re_ctx.re_flags);



 do { duk_bw_compact((thr), (&re_ctx.bw)); } while (0);
 (void) duk_buffer_to_string(thr, -1);







 duk_remove(thr, -4);
 duk_remove(thr, -3);

 do { } while (0)

                                                        ;
}
# 1262 "duk_regexp_compiler.c"
static __attribute__ ((unused)) void duk_regexp_create_instance(duk_hthread *thr) {
 duk_hobject *h;



 duk_push_object(thr);
 h = duk_known_hobject(thr, -1);
 duk_insert(thr, -3);



 do { (&(h)->hdr)->h_flags = ((&(h)->hdr)->h_flags & (~(((1UL << (5)) - 1UL) << ((7 + (20)))))) | (((11)) << ((7 + (20)))); } while (0);
 duk_hobject_set_prototype_updref((thr), (h), (thr->builtins[18]));

 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-3)) << 24) + (((duk_uint_t) (98)) << 8) + (duk_uint_t) (0)));
# 1285 "duk_regexp_compiler.c"
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (101)) << 8) + (duk_uint_t) (0)));



 duk_push_int(thr, 0);
 (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 24) + (((duk_uint_t) (47)) << 8) + (duk_uint_t) (((1U << 0)))));


}
# 1 "duk_regexp_executor.c"
# 28 "duk_regexp_executor.c"
static duk_uint32_t duk__bc_get_u32(duk_re_matcher_ctx *re_ctx, const duk_uint8_t **pc) {
 return (duk_uint32_t) duk_unicode_decode_xutf8_checked(re_ctx->thr, pc, re_ctx->bytecode, re_ctx->bytecode_end);
}

static duk_int32_t duk__bc_get_i32(duk_re_matcher_ctx *re_ctx, const duk_uint8_t **pc) {
 duk_uint32_t t;


 t = (duk_uint32_t) duk_unicode_decode_xutf8_checked(re_ctx->thr, pc, re_ctx->bytecode, re_ctx->bytecode_end);
 if (t & 1) {
  return -((duk_int32_t) (t >> 1));
 } else {
  return (duk_int32_t) (t >> 1);
 }
}

static const duk_uint8_t *duk__utf8_backtrack(duk_hthread *thr,
                                                 const duk_uint8_t **ptr,
                                                 const duk_uint8_t *ptr_start,
                                                 const duk_uint8_t *ptr_end,
                                                 duk_uint_fast32_t count) {
 const duk_uint8_t *p;


 p = *ptr;
 if (p < ptr_start || p > ptr_end) {
  goto fail;
 }

 while (count > 0) {
  for (;;) {
   p--;
   if (p < ptr_start) {
    goto fail;
   }
   if ((*p & 0xc0) != 0x80) {

    break;
   }
  }
  count--;
 }
 *ptr = p;
 return p;

fail:
 do { duk_err_error_internal((thr), "duk_regexp_executor.c", (duk_int_t) 74); } while (0);
 do { return 
# 75 "duk_regexp_executor.c" 3 4
((void *)0)
# 75 "duk_regexp_executor.c"
; } while (0);
}

static const duk_uint8_t *duk__utf8_advance(duk_hthread *thr,
                                               const duk_uint8_t **ptr,
                                               const duk_uint8_t *ptr_start,
                                               const duk_uint8_t *ptr_end,
                                               duk_uint_fast32_t count) {
 const duk_uint8_t *p;

 p = *ptr;
 if (p < ptr_start || p >= ptr_end) {
  goto fail;
 }

 while (count > 0) {
  for (;;) {
   p++;




   if (p >= ptr_end || ((*p & 0xc0) != 0x80)) {

    break;
   }
  }
  count--;
 }

 *ptr = p;
 return p;

fail:
 do { duk_err_error_internal((thr), "duk_regexp_executor.c", (duk_int_t) 109); } while (0);
 do { return 
# 110 "duk_regexp_executor.c" 3 4
((void *)0)
# 110 "duk_regexp_executor.c"
; } while (0);
}
# 121 "duk_regexp_executor.c"
static duk_codepoint_t duk__inp_get_cp(duk_re_matcher_ctx *re_ctx, const duk_uint8_t **sp) {
 duk_codepoint_t res;

 if (*sp >= re_ctx->input_end) {
  return -1;
 }
 res = (duk_codepoint_t) duk_unicode_decode_xutf8_checked(re_ctx->thr, sp, re_ctx->input, re_ctx->input_end);
 if (re_ctx->re_flags & (1U << 1)) {
  res = duk_unicode_re_canonicalize_char(re_ctx->thr, res);
 }
 return res;
}

static const duk_uint8_t *duk__inp_backtrack(duk_re_matcher_ctx *re_ctx, const duk_uint8_t **sp, duk_uint_fast32_t count) {
 return duk__utf8_backtrack(re_ctx->thr, sp, re_ctx->input, re_ctx->input_end, count);
}


static duk_codepoint_t duk__inp_get_prev_cp(duk_re_matcher_ctx *re_ctx, const duk_uint8_t *sp) {

 (void) duk__inp_backtrack(re_ctx, &sp, (duk_uint_fast32_t) 1);
 return duk__inp_get_cp(re_ctx, &sp);
}
# 156 "duk_regexp_executor.c"
static const duk_uint8_t *duk__match_regexp(duk_re_matcher_ctx *re_ctx, const duk_uint8_t *pc, const duk_uint8_t *sp) {
 duk_native_stack_check(re_ctx->thr);
 if (re_ctx->recursion_depth >= re_ctx->recursion_limit) {
  do { duk_err_range((re_ctx->thr), "duk_regexp_executor.c", (duk_int_t) 159, ("regexp executor recursion limit")); } while (0);
  do { return 
# 160 "duk_regexp_executor.c" 3 4
 ((void *)0)
# 160 "duk_regexp_executor.c"
 ; } while (0);
 }
 re_ctx->recursion_depth++;

 for (;;) {
  duk_small_int_t op;

  if (re_ctx->steps_count >= re_ctx->steps_limit) {
   do { duk_err_range((re_ctx->thr), "duk_regexp_executor.c", (duk_int_t) 168, ("regexp step limit")); } while (0);
   do { return 
# 169 "duk_regexp_executor.c" 3 4
  ((void *)0)
# 169 "duk_regexp_executor.c"
  ; } while (0);
  }
  re_ctx->steps_count++;





  do { } while (0);



  op = *pc++;

  do { } while (0)




                                  ;

  switch (op) {
  case 1: {
   goto match;
  }
  case 2: {
# 208 "duk_regexp_executor.c"
   duk_codepoint_t c1, c2;

   c1 = (duk_codepoint_t) duk__bc_get_u32(re_ctx, &pc);
   do { } while (0)
                                                                      ;
   c2 = duk__inp_get_cp(re_ctx, &sp);
# 222 "duk_regexp_executor.c"
   do { } while (0);

   do { } while (0);
   if (c1 != c2) {
    goto fail;
   }
   break;
  }
  case 3: {
   duk_codepoint_t c;

   c = duk__inp_get_cp(re_ctx, &sp);
   if (c < 0 || duk_unicode_is_line_terminator(c)) {

    goto fail;
   }
   break;
  }
  case 4:
  case 5: {
   duk_uint32_t n;
   duk_codepoint_t c;
   duk_small_int_t match;

   n = duk__bc_get_u32(re_ctx, &pc);
   c = duk__inp_get_cp(re_ctx, &sp);
   if (c < 0) {
    goto fail;
   }

   match = 0;
   while (n) {
    duk_codepoint_t r1, r2;
    r1 = (duk_codepoint_t) duk__bc_get_u32(re_ctx, &pc);
    r2 = (duk_codepoint_t) duk__bc_get_u32(re_ctx, &pc);
    do { } while (0)



                                   ;
    if (c >= r1 && c <= r2) {




     match = 1;
    }
    n--;
   }

   if (op == 4) {
    if (!match) {
     goto fail;
    }
   } else {
    do { } while (0);
    if (match) {
     goto fail;
    }
   }
   break;
  }
  case 16: {
   duk_codepoint_t c;

   if (sp <= re_ctx->input) {
    break;
   }
   if (!(re_ctx->re_flags & (1U << 2))) {
    goto fail;
   }
   c = duk__inp_get_prev_cp(re_ctx, sp);
   if (duk_unicode_is_line_terminator(c)) {

    break;
   }
   goto fail;
  }
  case 17: {
   duk_codepoint_t c;
   const duk_uint8_t *tmp_sp;

   tmp_sp = sp;
   c = duk__inp_get_cp(re_ctx, &tmp_sp);
   if (c < 0) {
    break;
   }
   if (!(re_ctx->re_flags & (1U << 2))) {
    goto fail;
   }
   if (duk_unicode_is_line_terminator(c)) {

    break;
   }
   goto fail;
  }
  case 18:
  case 19: {







   duk_small_int_t w1, w2;

   if (sp <= re_ctx->input) {
    w1 = 0;
   } else {
    duk_codepoint_t c;
    c = duk__inp_get_prev_cp(re_ctx, sp);
    w1 = duk_unicode_re_is_wordchar(c);
   }
   if (sp >= re_ctx->input_end) {
    w2 = 0;
   } else {
    const duk_uint8_t *tmp_sp = sp;
    duk_codepoint_t c;
    c = duk__inp_get_cp(re_ctx, &tmp_sp);
    w2 = duk_unicode_re_is_wordchar(c);
   }

   if (op == 18) {
    if (w1 == w2) {
     goto fail;
    }
   } else {
    do { } while (0);
    if (w1 != w2) {
     goto fail;
    }
   }
   break;
  }
  case 6: {
   duk_int32_t skip;

   skip = duk__bc_get_i32(re_ctx, &pc);
   pc += skip;
   break;
  }
  case 7: {

   const duk_uint8_t *sub_sp;
   duk_int32_t skip;

   skip = duk__bc_get_i32(re_ctx, &pc);
   sub_sp = duk__match_regexp(re_ctx, pc, sp);
   if (sub_sp) {
    sp = sub_sp;
    goto match;
   }
   pc += skip;
   break;
  }
  case 8: {

   const duk_uint8_t *sub_sp;
   duk_int32_t skip;

   skip = duk__bc_get_i32(re_ctx, &pc);
   sub_sp = duk__match_regexp(re_ctx, pc + skip, sp);
   if (sub_sp) {
    sp = sub_sp;
    goto match;
   }
   break;
  }
  case 9: {
   duk_uint32_t q, qmin, qmax;
   duk_int32_t skip;
   const duk_uint8_t *sub_sp;

   qmin = duk__bc_get_u32(re_ctx, &pc);
   qmax = duk__bc_get_u32(re_ctx, &pc);
   skip = duk__bc_get_i32(re_ctx, &pc);
   do { } while (0)


                                     ;

   q = 0;
   while (q <= qmax) {
    if (q >= qmin) {
     sub_sp = duk__match_regexp(re_ctx, pc + skip, sp);
     if (sub_sp) {
      sp = sub_sp;
      goto match;
     }
    }
    sub_sp = duk__match_regexp(re_ctx, pc, sp);
    if (!sub_sp) {
     break;
    }
    sp = sub_sp;
    q++;
   }
   goto fail;
  }
  case 10: {
   duk_uint32_t q, qmin, qmax, atomlen;
   duk_int32_t skip;
   const duk_uint8_t *sub_sp;

   qmin = duk__bc_get_u32(re_ctx, &pc);
   qmax = duk__bc_get_u32(re_ctx, &pc);
   atomlen = duk__bc_get_u32(re_ctx, &pc);
   skip = duk__bc_get_i32(re_ctx, &pc);
   do { } while (0)



                                     ;

   q = 0;
   while (q < qmax) {
    sub_sp = duk__match_regexp(re_ctx, pc, sp);
    if (!sub_sp) {
     break;
    }
    sp = sub_sp;
    q++;
   }
   while (q >= qmin) {
    sub_sp = duk__match_regexp(re_ctx, pc + skip, sp);
    if (sub_sp) {
     sp = sub_sp;
     goto match;
    }
    if (q == qmin) {
     break;
    }






    do { } while (0);
    sp = duk__inp_backtrack(re_ctx, &sp, (duk_uint_fast32_t) atomlen);
    q--;
   }
   goto fail;
  }
  case 11: {
   duk_uint32_t idx;
   const duk_uint8_t *old;
   const duk_uint8_t *sub_sp;

   idx = duk__bc_get_u32(re_ctx, &pc);
   if (idx >= re_ctx->nsaved) {

    do { } while (0);
    goto internal_error;
   }
   old = re_ctx->saved[idx];
   re_ctx->saved[idx] = sp;
   sub_sp = duk__match_regexp(re_ctx, pc, sp);
   if (sub_sp) {
    sp = sub_sp;
    goto match;
   }
   re_ctx->saved[idx] = old;
   goto fail;
  }
  case 12: {
# 497 "duk_regexp_executor.c"
   duk_uint32_t idx_start, idx_count;



   duk_uint8_t **range_save;
   const duk_uint8_t *sub_sp;

   idx_start = duk__bc_get_u32(re_ctx, &pc);
   idx_count = duk__bc_get_u32(re_ctx, &pc);
   do { } while (0)





                                                                  ;
   if (idx_start + idx_count > re_ctx->nsaved || idx_count == 0) {

    do { } while (0)

                                       ;
    goto internal_error;
   }
   do { } while (0);

   duk_require_stack(re_ctx->thr, 1);
   range_save = (duk_uint8_t **) duk_push_fixed_buffer_nozero(re_ctx->thr, sizeof(duk_uint8_t *) * idx_count);
   do { } while (0);
   do { void *duk__dst = (range_save); const void *duk__src = (re_ctx->saved + idx_start); duk_size_t duk__len = (sizeof(duk_uint8_t *) * idx_count); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);






   do { void *duk__dst = ((void *) (re_ctx->saved + idx_start)); duk_size_t duk__len = (sizeof(duk_uint8_t *) * idx_count); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);


   sub_sp = duk__match_regexp(re_ctx, pc, sp);
   if (sub_sp) {

    do { } while (0)



                                                                   ;
    duk_pop_unsafe(re_ctx->thr);
    sp = sub_sp;
    goto match;
   }


   do { } while (0)



                                                                  ;
   do { void *duk__dst = ((void *) (re_ctx->saved + idx_start)); const void *duk__src = ((const void *) range_save); duk_size_t duk__len = (sizeof(duk_uint8_t *) * idx_count); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0)

                                                ;
   duk_pop_unsafe(re_ctx->thr);
   goto fail;
  }
  case 13:
  case 14: {
# 576 "duk_regexp_executor.c"
   duk_int32_t skip;
   duk_uint8_t **full_save;
   const duk_uint8_t *sub_sp;

   do { } while (0);

   duk_require_stack(re_ctx->thr, 1);
   full_save =
       (duk_uint8_t **) duk_push_fixed_buffer_nozero(re_ctx->thr, sizeof(duk_uint8_t *) * re_ctx->nsaved);
   do { } while (0);
   do { void *duk__dst = (full_save); const void *duk__src = (re_ctx->saved); duk_size_t duk__len = (sizeof(duk_uint8_t *) * re_ctx->nsaved); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);

   skip = duk__bc_get_i32(re_ctx, &pc);
   sub_sp = duk__match_regexp(re_ctx, pc, sp);
   if (op == 13) {
    if (!sub_sp) {
     goto lookahead_fail;
    }
   } else {
    if (sub_sp) {
     goto lookahead_fail;
    }
   }
   sub_sp = duk__match_regexp(re_ctx, pc + skip, sp);
   if (sub_sp) {

    duk_pop_unsafe(re_ctx->thr);
    sp = sub_sp;
    goto match;
   }



  lookahead_fail:

   do { void *duk__dst = ((void *) re_ctx->saved); const void *duk__src = ((const void *) full_save); duk_size_t duk__len = (sizeof(duk_uint8_t *) * re_ctx->nsaved); do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } while (0);
   duk_pop_unsafe(re_ctx->thr);
   goto fail;
  }
  case 15: {
# 630 "duk_regexp_executor.c"
   duk_uint32_t idx;
   const duk_uint8_t *p;

   idx = duk__bc_get_u32(re_ctx, &pc);
   idx = idx << 1;
   if (idx < 2 || idx + 1 >= re_ctx->nsaved) {

    do { } while (0);
    goto internal_error;
   }
   if (!re_ctx->saved[idx] || !re_ctx->saved[idx + 1]) {

    do { } while (0)

                                           ;
    break;
   }
   do { } while (0);

   p = re_ctx->saved[idx];
   while (p < re_ctx->saved[idx + 1]) {
    duk_codepoint_t c1, c2;






    c1 = duk__inp_get_cp(re_ctx, &p);
    do { } while (0);
    c2 = duk__inp_get_cp(re_ctx, &sp);
# 669 "duk_regexp_executor.c"
    if (c1 != c2) {
     goto fail;
    }
   }
   break;
  }
  default: {
   do { } while (0);
   goto internal_error;
  }
  }
 }

match:
 re_ctx->recursion_depth--;
 return sp;

fail:
 re_ctx->recursion_depth--;
 return 
# 688 "duk_regexp_executor.c" 3 4
       ((void *)0)
# 688 "duk_regexp_executor.c"
           ;

internal_error:
 do { duk_err_error_internal((re_ctx->thr), "duk_regexp_executor.c", (duk_int_t) 691); } while (0);
 do { return 
# 692 "duk_regexp_executor.c" 3 4
((void *)0)
# 692 "duk_regexp_executor.c"
; } while (0);
}
# 707 "duk_regexp_executor.c"
static void duk__regexp_match_helper(duk_hthread *thr, duk_small_int_t force_global) {
 duk_re_matcher_ctx re_ctx;
 duk_hobject *h_regexp;
 duk_hstring *h_bytecode;
 duk_hstring *h_input;
 duk_uint8_t *p_buf;
 const duk_uint8_t *pc;
 const duk_uint8_t *sp;
 duk_small_int_t match = 0;
 duk_small_int_t global;
 duk_uint_fast32_t i;
 double d;
 duk_uint32_t char_offset;

 do { } while (0);

 do { } while (0)

                                                        ;
# 734 "duk_regexp_executor.c"
 h_regexp = duk_require_hobject_with_class(thr, -2, 11);
 do { } while (0);
 do { } while (0);
 do { (void) (h_regexp); } while (0);

 h_input = duk_to_hstring(thr, -1);
 do { } while (0);

 (((void) 0), ((void) 0), duk_xget_owndataprop_stridx_short_raw((thr), (((duk_uint_t) (-2)) << 16) + ((duk_uint_t) (98))));
 h_bytecode =
     duk_require_hstring(thr, -1);
 do { } while (0);
# 759 "duk_regexp_executor.c"
 do { void *duk__dst = (&re_ctx); duk_size_t duk__len = (sizeof(re_ctx)); do { } while (0); (void) memset((duk__dst), 0, ((size_t) duk__len)); } while (0);

 re_ctx.thr = thr;
 re_ctx.input = (const duk_uint8_t *) ((const duk_uint8_t *) ((h_input) + 1));
 re_ctx.input_end = re_ctx.input + ((h_input)->blen);
 re_ctx.bytecode = (const duk_uint8_t *) ((const duk_uint8_t *) ((h_bytecode) + 1));
 re_ctx.bytecode_end = re_ctx.bytecode + ((h_bytecode)->blen);
 re_ctx.saved = 
# 766 "duk_regexp_executor.c" 3 4
               ((void *)0)
# 766 "duk_regexp_executor.c"
                   ;
 re_ctx.recursion_limit = 10000;
 re_ctx.steps_limit = 1000000000L;


 pc = re_ctx.bytecode;
 re_ctx.re_flags = duk__bc_get_u32(&re_ctx, &pc);
 re_ctx.nsaved = duk__bc_get_u32(&re_ctx, &pc);
 re_ctx.bytecode = pc;

 do { } while (0);
 global = (duk_small_int_t) (force_global | (duk_small_int_t) (re_ctx.re_flags & (1U << 0)));

 do { } while (0);
 do { } while (0);

 p_buf = (duk_uint8_t *) duk_push_buffer_raw((thr), (sizeof(duk_uint8_t *) * re_ctx.nsaved), 0 );
 do { (void) (p_buf); } while (0);
 re_ctx.saved = (const duk_uint8_t **) duk_get_buffer(thr, -1, 
# 784 "duk_regexp_executor.c" 3 4
                                                              ((void *)0)
# 784 "duk_regexp_executor.c"
                                                                  );
 do { } while (0);
# 799 "duk_regexp_executor.c"
 do { } while (0)



                                                 ;
# 824 "duk_regexp_executor.c"
 (((void) 0), ((void) 0), duk_get_prop_stridx_short_raw((thr), (((duk_uint_t) (-4)) << 16) + ((duk_uint_t) (47))));
 (void) duk_to_int(thr, -1);
 d = duk_get_number(thr, -1);
 duk_pop_nodecref_unsafe(thr);

 if (global) {
  if (d < 0.0 || d > (double) duk_hstring_get_charlen((h_input))) {

   char_offset = 0;
   do { } while (0);
   goto match_over;
  }
  char_offset = (duk_uint32_t) d;
 } else {





  char_offset = (duk_uint32_t) 0;
 }

 do { } while (0);
 sp = re_ctx.input + duk_heap_strcache_offset_char2byte(thr, h_input, char_offset);
# 857 "duk_regexp_executor.c"
 do { } while (0);

 for (;;) {

  do { } while (0);
  do { } while (0);


  do { } while (0);

  do { } while (0)



                                                        ;
# 892 "duk_regexp_executor.c"
  if (duk__match_regexp(&re_ctx, re_ctx.bytecode, sp) != 
# 892 "duk_regexp_executor.c" 3 4
                                                        ((void *)0)
# 892 "duk_regexp_executor.c"
                                                            ) {
   do { } while (0);
   match = 1;
   break;
  }


  char_offset++;
  if (char_offset > duk_hstring_get_charlen((h_input))) {
# 910 "duk_regexp_executor.c"
   do { } while (0);
   break;
  }


  (void) duk__utf8_advance(thr, &sp, re_ctx.input, re_ctx.input_end, (duk_uint_fast32_t) 1);
 }

match_over:
# 936 "duk_regexp_executor.c"
 if (match) {



  duk_uint32_t char_end_offset = 0;

  do { } while (0);

  do { } while (0);
  do { } while (0);






  duk_push_array(thr);
# 963 "duk_regexp_executor.c"
  duk_push_uint((thr), (duk_uint_t) (char_offset));
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw(((thr)), (((duk_uint_t) ((-2))) << 24) + (((duk_uint_t) ((49))) << 8) + (duk_uint_t) (((1U << 0) | (1U << 1) | (1U << 2)))));

  duk_dup_m4(thr);
  (((void) 0), ((void) 0), ((void) 0), duk_xdef_prop_stridx_short_raw(((thr)), (((duk_uint_t) ((-2))) << 24) + (((duk_uint_t) ((108))) << 8) + (duk_uint_t) (((1U << 0) | (1U << 1) | (1U << 2)))));

  for (i = 0; i < re_ctx.nsaved; i += 2) {




   duk_push_uint((thr), (duk_uint_t) ((duk_uarridx_t) (i / 2)));

   if (re_ctx.saved[i] && re_ctx.saved[i + 1] && re_ctx.saved[i + 1] >= re_ctx.saved[i]) {
    duk_push_lstring(thr,
                     (const char *) re_ctx.saved[i],
                     (duk_size_t) (re_ctx.saved[i + 1] - re_ctx.saved[i]));
    if (i == 0) {





     char_end_offset = char_offset + (duk_uint32_t) duk_get_length(thr, -1);
    }
   } else {
    duk_push_undefined(thr);
   }


   duk_def_prop(thr, -3, (1U << 6) | (((1U << 3) | (1U << 0)) | ((1U << 4) | (1U << 1)) | ((1U << 5) | (1U << 2))));
  }





  if (global) {

   duk_push_uint((thr), (duk_uint_t) (char_end_offset));
   (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-6)) << 16) + ((duk_uint_t) (47))));
  } else {

   ;
  }
 } else {






  do { } while (0);

  duk_push_null(thr);



  duk_push_int(thr, 0);
  (((void) 0), ((void) 0), duk_put_prop_stridx_short_raw((thr), (((duk_uint_t) (-6)) << 16) + ((duk_uint_t) (47))));
 }



 duk_insert(thr, -5);



 duk_pop_n_unsafe(thr, 4);






}

static __attribute__ ((unused)) void duk_regexp_match(duk_hthread *thr) {
 duk__regexp_match_helper(thr, 0 );
}




static __attribute__ ((unused)) void duk_regexp_match_force_global(duk_hthread *thr) {
 duk__regexp_match_helper(thr, 1 );
}
# 1 "duk_selftest.c"
# 2 "duk_tval.c"
# 1 "duk_unicode_tables.c"
# 26 "duk_unicode_tables.c"
const duk_uint8_t duk_unicode_ids_noa[1116] = {
249,176,176,80,111,7,47,15,47,254,11,197,191,0,72,2,15,115,66,19,50,7,2,34,
2,240,66,244,50,247,185,249,98,241,99,7,241,159,57,240,181,63,31,241,191,
21,18,245,50,15,1,24,27,35,15,2,2,240,239,15,244,156,15,10,241,26,21,6,240,
101,10,4,15,9,240,152,175,39,240,82,127,56,242,100,15,4,8,159,1,240,5,115,
19,240,98,98,4,52,15,2,14,18,47,0,27,9,85,19,240,98,98,18,18,31,17,50,15,5,
47,2,130,34,240,98,98,18,68,15,4,15,1,31,9,12,115,19,240,98,98,18,68,15,16,
18,47,1,15,3,2,84,34,52,18,2,20,20,36,191,8,15,38,114,34,240,114,240,4,15,
12,38,31,16,5,114,34,240,114,146,68,15,18,2,31,1,31,4,114,34,241,147,15,2,
6,41,47,10,86,240,36,240,130,130,3,111,44,242,2,29,111,44,18,2,66,240,130,
2,146,26,3,66,15,7,63,18,15,49,114,241,79,13,79,101,241,191,6,15,2,85,52,4,
24,37,205,15,3,241,98,6,3,241,178,255,224,63,35,54,32,35,63,25,35,63,17,35,
54,32,35,62,47,41,35,63,51,241,127,0,240,47,70,53,79,254,21,227,240,18,240,
166,243,180,168,194,63,0,240,47,0,240,47,0,194,47,1,242,79,21,5,15,53,244,
152,67,241,34,6,243,107,240,255,35,240,227,76,241,197,240,175,40,240,122,
242,95,68,15,79,241,255,3,111,41,240,238,27,241,207,12,241,79,27,43,241,67,
136,241,179,47,27,50,82,20,6,251,15,50,255,224,8,53,63,22,53,55,32,32,32,
47,15,63,37,38,32,66,38,67,53,92,98,38,246,96,224,240,44,245,112,80,57,32,
68,112,32,32,35,42,51,100,80,240,63,25,255,233,107,241,242,241,242,247,87,
52,29,241,98,6,3,242,136,15,2,240,122,98,98,98,98,98,98,98,111,66,15,254,
12,146,240,184,132,52,95,70,114,47,74,35,111,27,47,78,240,63,11,242,127,0,
255,224,244,255,240,0,138,143,60,255,240,4,14,47,2,255,227,127,243,95,30,
63,253,79,0,177,240,111,31,240,47,15,63,64,241,152,63,87,63,37,52,242,42,
34,35,47,7,240,255,36,240,15,34,243,5,64,33,207,12,191,7,240,191,13,143,31,
240,224,240,36,41,180,47,25,240,146,39,240,111,7,64,79,34,32,65,52,48,32,
240,162,58,130,213,53,53,166,38,47,27,43,159,99,240,255,255,0,26,150,223,7,
95,33,255,240,0,255,143,254,6,3,245,175,24,109,70,2,146,194,66,2,18,18,245,
207,19,255,224,93,240,79,48,63,38,241,171,246,100,47,119,241,111,10,127,10,
207,73,69,53,53,50,241,91,47,10,47,3,33,46,61,241,79,107,243,127,37,255,
223,13,79,33,242,31,16,239,14,111,22,191,14,63,20,87,36,241,207,142,240,79,
20,95,20,95,24,159,36,248,239,254,2,154,240,107,127,138,83,2,241,194,20,3,
240,123,240,122,240,255,51,240,50,27,240,107,240,175,56,242,135,31,50,15,1,
50,34,240,223,28,240,212,240,223,21,114,240,207,13,242,107,240,107,240,62,
240,47,96,243,159,41,242,62,242,62,241,79,254,13,15,13,176,159,6,248,207,7,
223,37,243,223,29,241,47,9,240,207,20,240,240,207,19,64,223,32,240,3,240,
112,32,241,95,2,47,9,244,102,32,35,46,41,143,31,241,135,49,63,6,38,33,36,
64,240,64,212,249,15,37,240,67,240,96,241,47,32,240,97,32,250,175,31,241,
179,241,111,32,240,96,242,223,27,224,243,159,11,253,127,28,246,111,48,241,
16,249,39,63,23,240,32,32,240,224,191,24,128,240,112,207,30,240,80,241,79,
41,255,152,47,21,240,48,242,63,14,246,38,33,47,22,240,112,240,181,33,47,16,
240,0,255,224,59,240,63,254,0,31,254,40,207,88,245,255,3,251,79,254,155,15,
254,50,31,254,236,95,254,19,159,255,0,16,173,255,225,43,143,15,246,63,14,
240,79,32,240,35,241,31,5,111,3,255,225,164,243,15,114,243,182,15,52,207,
50,18,15,14,255,240,0,110,169,255,225,229,255,240,1,64,31,254,1,31,35,47,3,
57,255,224,126,255,231,248,245,182,196,136,159,255,0,6,90,244,82,243,114,
19,3,19,50,178,2,98,243,18,51,114,98,240,194,50,66,4,98,255,224,70,63,9,47,
9,47,15,47,9,47,15,47,9,47,15,47,9,47,15,47,9,39,255,232,40,241,219,111,2,
15,254,6,95,28,255,228,8,251,95,45,243,72,15,254,58,131,47,11,33,32,48,41,
35,32,32,112,80,32,32,34,33,32,48,32,32,32,32,33,32,51,38,35,35,32,41,47,1,
98,36,47,1,255,240,0,3,143,255,0,149,201,241,191,254,242,124,252,227,255,
240,0,87,79,0,255,240,0,194,63,254,177,63,254,17,0,
};
# 124 "duk_unicode_tables.c"
const duk_uint8_t duk_unicode_ids_m_let_noa[42] = {
255,240,0,94,18,255,233,99,241,51,63,254,215,32,240,184,240,2,255,240,6,89,
249,255,240,4,148,79,37,255,224,192,9,15,120,79,255,0,15,30,245,240,
};
# 148 "duk_unicode_tables.c"
const duk_uint8_t duk_unicode_idp_m_ids_noa[576] = {
255,225,243,246,15,254,0,116,255,191,29,32,33,33,32,243,170,242,47,15,112,
245,118,53,49,35,57,240,144,241,15,11,244,218,240,25,241,56,160,240,163,40,
34,36,241,210,246,158,47,17,242,130,47,2,38,177,57,240,50,242,160,38,49,50,
160,177,57,240,0,50,242,160,36,81,50,64,240,107,64,194,242,160,39,34,34,
240,97,57,181,34,242,160,38,49,50,145,177,57,240,64,242,212,66,35,160,240,
9,240,36,242,182,34,35,129,193,57,240,50,242,160,38,34,35,129,193,57,240,
35,242,145,38,34,35,160,177,57,240,65,243,128,85,32,39,121,49,242,240,54,
215,41,244,144,56,197,57,243,1,121,192,32,32,81,242,63,4,33,106,47,20,160,
245,111,4,41,211,82,34,54,67,235,46,255,225,179,47,254,42,98,240,242,240,
241,241,1,243,47,16,160,57,241,50,57,245,209,241,64,246,139,91,185,247,41,
242,244,242,185,47,13,58,121,240,141,243,68,242,31,1,201,240,56,210,241,12,
57,241,237,242,47,4,153,121,246,130,47,5,80,112,50,251,143,42,36,255,225,0,
31,35,31,5,15,109,197,4,191,254,175,34,247,240,245,47,16,255,225,30,95,91,
31,255,0,100,121,159,55,5,159,18,31,66,31,254,0,64,64,80,240,148,244,161,
242,79,2,185,127,2,234,240,231,240,188,241,227,242,29,240,25,192,185,242,
29,208,145,57,241,50,242,64,34,49,97,32,241,180,97,253,231,33,57,255,240,3,
225,128,255,225,213,240,15,2,240,4,31,10,47,178,159,23,15,254,27,16,253,64,
248,116,255,224,25,159,254,68,178,33,99,241,162,80,249,113,255,225,49,57,
159,254,16,10,250,18,242,126,241,25,240,19,241,250,242,121,114,241,109,41,
97,241,224,210,242,45,147,73,244,75,112,249,43,105,115,242,145,38,49,50,
160,177,54,68,251,47,2,169,80,244,63,4,217,252,118,56,240,209,244,79,1,240,
25,244,60,153,244,94,89,254,78,249,121,253,150,54,64,240,233,241,166,35,
144,170,242,15,0,255,224,137,114,127,2,159,42,240,98,223,108,84,2,18,98,9,
159,34,66,18,73,159,254,3,211,255,240,3,165,217,247,132,242,214,240,185,
255,226,233,2,242,120,63,255,0,59,254,31,255,0,3,186,68,89,115,111,16,63,
134,47,254,71,223,34,255,224,244,242,117,242,41,15,0,15,8,66,239,254,68,70,
47,1,54,33,36,255,118,169,255,224,150,223,254,76,166,245,246,105,255,240,
192,105,175,224,0,
};
# 217 "duk_unicode_tables.c"
const duk_uint8_t duk_unicode_caseconv_uc[1411] = {
152,3,128,3,0,184,7,192,6,192,112,35,242,199,224,64,74,192,49,32,128,162,
128,108,65,1,189,129,254,131,3,173,3,136,6,7,98,7,34,68,15,12,14,140,72,30,
104,28,112,32,67,0,65,4,0,138,0,128,4,1,88,65,76,83,8,104,14,72,43,16,253,
28,189,6,39,240,39,224,24,114,12,16,132,16,248,0,248,64,129,241,1,241,128,
195,228,3,229,2,7,204,7,206,4,15,160,15,164,6,31,96,31,104,16,62,224,63,
116,8,125,200,127,32,32,251,176,254,208,33,247,129,255,128,67,239,67,253,
64,135,223,7,254,129,15,216,15,220,2,31,208,31,216,4,63,192,63,208,8,133,
192,133,128,129,38,129,37,177,162,195,2,192,5,229,160,2,20,9,170,220,4,232,
40,127,160,255,144,154,136,4,4,4,0,192,9,152,9,144,48,19,160,19,145,0,41,
96,41,69,192,94,128,94,65,128,193,128,193,2,1,161,1,160,6,3,104,3,102,8,7,
56,7,52,64,14,248,14,240,144,31,144,31,130,128,68,96,68,66,64,145,192,145,
130,129,184,129,184,2,3,217,3,216,24,8,194,8,192,68,18,44,18,40,216,38,16,
38,8,112,77,16,77,6,3,192,35,192,18,199,168,71,168,24,15,168,143,172,132,
44,104,44,103,6,89,2,89,0,200,179,176,179,172,21,50,13,50,1,122,104,26,104,
1,212,228,116,228,65,233,204,233,204,143,211,189,83,188,130,167,127,167,
126,11,79,35,79,32,10,158,94,158,88,85,61,173,61,160,97,192,107,64,107,1,0,
226,128,226,3,1,198,1,196,6,3,228,3,226,8,10,0,6,152,16,31,192,31,184,34,
199,50,199,32,65,128,196,0,195,130,1,185,1,184,4,4,205,79,84,8,0,192,143,0,
142,193,1,52,128,203,2,45,39,16,199,5,253,0,11,80,57,192,15,240,23,128,19,
16,4,144,23,240,5,48,24,0,36,48,25,32,25,16,25,80,31,96,25,144,25,128,25,
160,35,208,25,224,34,0,26,128,26,112,27,240,31,112,29,208,24,224,31,48,31,
16,37,2,198,240,37,18,198,208,37,34,199,0,37,48,24,16,37,64,24,96,37,144,
24,240,37,176,25,0,37,202,122,176,38,0,25,48,38,26,122,192,38,48,25,64,38,
90,120,208,38,128,25,112,38,178,198,32,38,202,122,208,39,18,198,224,39,32,
25,208,39,80,25,240,39,210,198,64,40,42,124,80,40,122,123,16,40,128,26,224,
40,144,36,64,40,192,36,80,41,32,27,112,41,218,123,32,41,234,123,0,52,80,57,
144,55,112,55,96,58,192,56,96,60,32,58,48,60,192,56,192,61,0,57,32,61,16,
57,128,61,80,58,96,61,96,58,0,61,112,60,240,63,0,57,160,63,16,58,16,63,32,
63,144,63,48,55,240,63,80,57,80,76,240,76,1,200,0,65,33,200,16,65,65,200,
32,65,225,200,80,66,33,200,96,66,161,200,112,70,33,200,138,100,161,215,154,
119,209,215,210,198,49,216,234,124,97,233,177,230,1,251,224,57,145,254,81,
254,194,20,226,19,34,24,66,24,50,198,18,198,2,198,80,35,162,198,96,35,226,
207,50,207,42,120,202,120,186,121,74,124,74,124,58,124,42,181,58,123,60,
192,27,240,2,152,2,152,10,76,5,120,0,156,3,225,0,37,1,134,1,200,96,115,32,
97,0,96,32,118,24,29,40,24,64,24,8,44,60,10,106,10,164,61,45,0,36,1,152,
143,75,192,10,128,97,3,211,16,2,184,24,80,244,204,0,178,6,20,61,53,0,32,
129,95,15,168,64,116,160,98,99,234,88,29,40,24,152,24,0,250,166,7,74,6,38,
6,2,62,173,129,210,129,137,129,161,15,192,67,225,0,115,35,240,48,248,72,28,
200,252,20,62,20,7,50,63,7,15,133,129,204,143,194,67,225,128,115,35,240,
176,248,104,28,200,252,52,62,28,7,50,63,15,15,135,129,204,143,196,67,225,0,
115,35,241,48,248,72,28,200,252,84,62,20,7,50,63,23,15,133,129,204,143,198,
67,225,128,115,35,241,176,248,104,28,200,252,116,62,28,7,50,63,31,15,135,
129,204,143,200,67,229,0,115,35,242,48,249,72,28,200,252,148,62,84,7,50,63,
39,15,149,129,204,143,202,67,229,128,115,35,242,176,249,104,28,200,252,180,
62,92,7,50,63,47,15,151,129,204,143,204,67,229,0,115,35,243,48,249,72,28,
200,252,212,62,84,7,50,63,55,15,149,129,204,143,206,67,229,128,115,35,243,
176,249,104,28,200,252,244,62,92,7,50,63,63,15,151,129,204,143,208,67,237,
0,115,35,244,48,251,72,28,200,253,20,62,212,7,50,63,71,15,181,129,204,143,
210,67,237,128,115,35,244,176,251,104,28,200,253,52,62,220,7,50,63,79,15,
183,129,204,143,212,67,237,0,115,35,245,48,251,72,28,200,253,84,62,212,7,
50,63,87,15,181,129,204,143,214,67,237,128,115,35,245,176,251,104,28,200,
253,116,62,220,7,50,63,95,15,183,129,204,143,217,67,247,64,115,35,246,112,
28,136,28,200,253,164,7,12,7,50,63,109,1,200,129,161,15,219,224,114,32,104,
64,115,35,247,144,28,136,28,200,254,20,63,148,7,50,63,135,1,203,129,204,
143,226,64,113,32,115,35,248,208,28,184,26,16,254,62,7,46,6,132,7,50,63,
153,1,203,129,204,143,233,96,115,32,97,0,96,3,250,120,28,200,24,64,24,8,
254,180,7,50,6,132,63,175,129,204,129,132,1,161,15,241,96,116,160,97,0,96,
3,252,120,29,40,24,64,24,8,255,36,7,66,6,38,63,205,1,210,129,161,15,243,
224,116,160,97,0,104,67,254,80,255,208,28,200,255,156,7,82,7,50,63,233,1,
199,129,204,143,251,64,117,32,104,67,254,248,29,72,26,16,28,200,255,228,7,
82,7,51,246,1,0,35,0,35,125,128,192,8,192,9,63,96,80,2,48,2,103,216,30,0,
140,0,140,0,147,246,9,128,35,0,35,0,38,125,130,192,10,96,10,159,96,208,2,
152,2,167,216,156,10,136,10,141,246,41,2,162,2,154,253,138,192,168,128,167,
127,98,208,42,112,42,55,216,188,10,136,10,122,
};
const duk_uint8_t duk_unicode_caseconv_lc[706] = {
160,3,0,3,128,184,6,192,7,192,112,24,144,37,96,64,54,32,81,64,128,226,0,
235,65,129,199,1,230,130,3,145,3,177,34,7,70,7,134,36,15,244,13,236,24,32,
0,34,129,0,65,0,67,4,0,166,32,172,41,132,40,11,64,19,9,208,85,184,80,19,
240,19,248,12,57,32,33,160,172,114,244,67,244,24,248,64,248,0,129,241,129,
241,0,195,229,3,228,2,7,206,7,204,4,15,164,15,160,6,31,104,31,96,16,63,16,
63,0,32,126,96,126,64,64,253,64,253,0,129,251,129,251,0,67,247,67,238,0,
135,242,7,220,130,15,236,15,232,2,31,218,31,118,4,63,208,63,192,8,127,168,
125,232,16,255,192,251,192,33,255,161,247,192,68,44,4,46,4,9,45,137,52,13,
22,0,22,24,47,44,126,2,63,5,254,67,254,130,106,48,16,0,16,19,0,38,64,38,96,
192,78,64,78,132,0,165,0,165,151,1,121,1,122,6,3,4,3,6,8,6,128,6,132,24,13,
152,13,160,32,28,176,28,193,32,59,192,59,226,64,124,128,124,193,0,252,0,
252,148,2,34,2,35,18,4,140,4,142,20,13,192,13,196,16,30,192,30,200,192,70,
0,70,18,32,145,64,145,102,193,48,65,48,131,130,104,2,104,176,30,0,30,1,150,
61,64,61,66,192,125,100,125,68,33,99,57,99,64,50,200,2,200,22,69,157,101,
157,128,169,144,41,144,75,211,64,83,64,142,167,34,167,35,15,78,101,78,102,
126,157,230,157,232,21,59,245,59,248,90,121,10,121,16,84,242,212,242,226,
169,237,41,237,67,12,3,76,5,0,8,6,176,6,180,16,14,32,14,48,48,28,80,28,96,
64,126,224,127,0,139,28,139,28,193,6,3,14,3,16,8,6,224,6,228,21,61,80,19,
48,32,3,1,150,2,105,4,4,118,4,120,8,67,28,180,156,23,240,192,94,0,63,192,
96,64,148,192,97,128,149,0,99,128,119,64,99,192,150,64,100,0,150,192,100,
64,100,128,100,192,152,0,101,0,152,192,101,192,154,0,102,0,102,64,103,64,
156,128,103,192,157,64,105,192,106,0,107,128,162,0,109,192,164,128,124,64,
124,192,125,128,101,64,125,192,111,192,136,0,103,128,142,139,25,64,143,64,
102,128,143,139,25,128,144,192,96,0,145,0,162,64,145,64,163,0,221,128,221,
192,223,192,252,192,225,128,235,0,227,0,243,0,243,192,245,192,253,0,238,0,
254,64,252,129,48,1,51,199,167,128,55,199,239,7,236,199,243,7,240,199,251,
7,249,71,255,7,252,200,73,128,242,72,74,128,26,200,74,192,57,72,76,136,83,
136,96,200,97,11,24,11,24,75,24,128,154,203,24,199,95,75,25,0,159,75,27,64,
148,75,27,128,156,75,27,192,148,11,28,0,148,139,60,139,60,233,223,71,94,
105,226,233,227,41,227,64,153,105,234,192,151,41,235,0,152,105,235,64,155,
41,236,0,167,169,236,64,161,233,236,128,167,105,236,234,212,233,240,169,
240,233,241,41,229,41,241,64,160,169,241,135,99,128,128,152,64,13,32,96,
224,
};
# 6159 "duk_unicode_tables.c"
const duk_uint8_t duk_unicode_re_canon_bitmap[256] = {
23,0,224,19,1,228,255,255,255,255,255,255,255,255,255,255,63,254,255,127,
255,255,255,255,255,255,255,255,231,231,0,16,255,227,255,255,63,255,255,
255,255,255,255,255,1,252,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
227,129,255,255,255,147,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,251,
};
# 1 "duk_util_bitdecoder.c"
# 11 "duk_util_bitdecoder.c"
static __attribute__ ((unused)) duk_uint32_t duk_bd_decode(duk_bitdecoder_ctx *ctx, duk_small_int_t bits) {
 duk_small_int_t shift;
 duk_uint32_t mask;
 duk_uint32_t tmp;




 do { } while (0);

 while (ctx->currbits < bits) {




  ctx->currval <<= 8;
  if (ctx->offset < ctx->length) {



   ctx->currval |= ctx->data[ctx->offset++];
  }
  ctx->currbits += 8;
 }
# 43 "duk_util_bitdecoder.c"
 shift = ctx->currbits - bits;
 mask = (((duk_uint32_t) 1U) << bits) - 1U;
 tmp = (ctx->currval >> shift) & mask;
 ctx->currbits = shift;






 return tmp;
}

static __attribute__ ((unused)) duk_small_uint_t duk_bd_decode_flag(duk_bitdecoder_ctx *ctx) {
 return (duk_small_uint_t) duk_bd_decode(ctx, 1);
}




static __attribute__ ((unused)) duk_uint32_t duk_bd_decode_flagged(duk_bitdecoder_ctx *ctx, duk_small_int_t bits, duk_uint32_t def_value) {
 if (duk_bd_decode_flag(ctx)) {
  return duk_bd_decode(ctx, bits);
 } else {
  return def_value;
 }
}


static __attribute__ ((unused)) duk_int32_t duk_bd_decode_flagged_signed(duk_bitdecoder_ctx *ctx, duk_small_int_t bits, duk_int32_t def_value) {
 return (duk_int32_t) duk_bd_decode_flagged(ctx, bits, (duk_uint32_t) def_value);
}


static __attribute__ ((unused)) duk_uint32_t duk_bd_decode_varuint(duk_bitdecoder_ctx *ctx) {
 duk_small_uint_t t;




 switch (duk_bd_decode(ctx, 2)) {
 case 0:
  return 0;
 case 1:
  return duk_bd_decode(ctx, 2) + 1;
 case 2:
  return duk_bd_decode(ctx, 5) + 5;
 default:
  t = duk_bd_decode(ctx, 7);
  if (t == 0) {
   return duk_bd_decode(ctx, 20);
  }
  return (t - 1) + 37;
 }
}
# 112 "duk_util_bitdecoder.c"
static const duk_uint8_t duk__bitpacked_lookup[16] = { 0x30, 0x31, 0x32, 0x33,
                                                   0x34, 0x35, 0x36, 0x37,
                                                   0x38, 0x39, 0x5f, 0x20,
                                                   0x82, 0x80, 0x22, 0x7b };

static __attribute__ ((unused)) duk_small_uint_t duk_bd_decode_bitpacked_string(duk_bitdecoder_ctx *bd, duk_uint8_t *out) {
 duk_small_uint_t len;
 duk_small_uint_t mode;
 duk_small_uint_t t;
 duk_small_uint_t i;

 len = duk_bd_decode(bd, 5);
 if (len == 31) {
  len = duk_bd_decode(bd, 8);
 }

 mode = 32;
 for (i = 0; i < len; i++) {
  t = duk_bd_decode(bd, 5);
  if (t < 26) {
   t = t + 0x41 + mode;
  } else if (t == 26) {
   t = duk__bitpacked_lookup[duk_bd_decode(bd, 3)];
  } else if (t == 27) {
   t = duk__bitpacked_lookup[8 + duk_bd_decode(bd, 3)];
  } else if (t == 28) {
   t = duk_bd_decode(bd, 5);
   do { } while (0);
   do { } while (0);
   t = t + 0x41 + (mode ^ 32);
  } else if (t == 29) {
   mode = mode ^ 32;
   t = duk_bd_decode(bd, 5);
   do { } while (0);
   do { } while (0);
   t = t + 0x41 + mode;
  } else if (t == 31) {
   t = duk_bd_decode(bd, 8);
  }
  out[i] = (duk_uint8_t) t;
 }

 return len;
}
# 1 "duk_util_bitencoder.c"






static __attribute__ ((unused)) void duk_be_encode(duk_bitencoder_ctx *ctx, duk_uint32_t data, duk_small_int_t bits) {
 duk_uint8_t tmp;

 do { } while (0);
 do { } while (0);


 do { } while (0);

 ctx->currval = (ctx->currval << bits) | data;
 ctx->currbits += bits;

 while (ctx->currbits >= 8) {
  if (ctx->offset < ctx->length) {
   tmp = (duk_uint8_t) ((ctx->currval >> (ctx->currbits - 8)) & 0xff);
   ctx->data[ctx->offset++] = tmp;
  } else {

   ctx->truncated = 1;
  }

  ctx->currbits -= 8;
 }
}

static __attribute__ ((unused)) void duk_be_finish(duk_bitencoder_ctx *ctx) {
 duk_small_int_t npad;

 do { } while (0);
 do { } while (0);

 npad = (duk_small_int_t) (8 - ctx->currbits);
 if (npad > 0) {
  duk_be_encode(ctx, 0, npad);
 }
 do { } while (0);
}
# 1 "duk_util_bufwriter.c"
# 15 "duk_util_bufwriter.c"
static void duk__bw_update_ptrs(duk_hthread *thr, duk_bufwriter_ctx *bw_ctx, duk_size_t curr_offset, duk_size_t new_length) {
 duk_uint8_t *p;

 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);




 p = (duk_uint8_t *) ((bw_ctx->buf)->curr_alloc);
 do { } while (0);
 bw_ctx->p = p + curr_offset;
 bw_ctx->p_base = p;
 bw_ctx->p_limit = p + new_length;
}

static __attribute__ ((unused)) void duk_bw_init(duk_hthread *thr, duk_bufwriter_ctx *bw_ctx, duk_hbuffer_dynamic *h_buf) {
 do { } while (0);
 do { } while (0);
 do { } while (0);

 bw_ctx->buf = h_buf;
 duk__bw_update_ptrs(thr, bw_ctx, 0, (((duk_hbuffer *) ((duk_hbuffer *) (h_buf)))->size));
}

static __attribute__ ((unused)) void duk_bw_init_pushbuf(duk_hthread *thr, duk_bufwriter_ctx *bw_ctx, duk_size_t buf_size) {
 do { } while (0);
 do { } while (0);

 (void) duk_push_buffer_raw((thr), (buf_size), (1 << 0) );
 bw_ctx->buf = (duk_hbuffer_dynamic *) duk_known_hbuffer(thr, -1);
 do { } while (0);
 duk__bw_update_ptrs(thr, bw_ctx, 0, buf_size);
}




static __attribute__ ((unused)) duk_uint8_t *duk_bw_resize(duk_hthread *thr, duk_bufwriter_ctx *bw_ctx, duk_size_t sz) {
 duk_size_t curr_off;
 duk_size_t add_sz;
 duk_size_t new_sz;

 do { } while (0);
 do { } while (0);





 curr_off = (duk_size_t) (bw_ctx->p - bw_ctx->p_base);
 add_sz = (curr_off >> 2) + 64;
 new_sz = curr_off + sz + add_sz;
 if (__builtin_expect((new_sz < curr_off), 0)) {

  do { duk_err_range((thr), "duk_util_bufwriter.c", (duk_int_t) 71, ("buffer too long")); } while (0);
  do { return 
# 72 "duk_util_bufwriter.c" 3 4
 ((void *)0)
# 72 "duk_util_bufwriter.c"
 ; } while (0);
 }
# 82 "duk_util_bufwriter.c"
 do { } while (0);

 do { } while (0);

 duk_hbuffer_resize(thr, bw_ctx->buf, new_sz);
 duk__bw_update_ptrs(thr, bw_ctx, curr_off, new_sz);
 return bw_ctx->p;
}


static __attribute__ ((unused)) void duk_bw_compact(duk_hthread *thr, duk_bufwriter_ctx *bw_ctx) {
 duk_size_t len;

 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);

 len = (duk_size_t) (bw_ctx->p - bw_ctx->p_base);
 duk_hbuffer_resize(thr, bw_ctx->buf, len);
 duk__bw_update_ptrs(thr, bw_ctx, len, len);
}

static __attribute__ ((unused)) void duk_bw_write_raw_slice(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t src_off, duk_size_t len) {
 duk_uint8_t *p_base;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);

 p_base = bw->p_base;
 do { void *duk__dst = ((void *) bw->p); const void *duk__src = ((const void *) (p_base + src_off)); duk_size_t duk__len = ((size_t) len); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0);
 bw->p += len;
}

static __attribute__ ((unused)) void duk_bw_write_ensure_slice(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t src_off, duk_size_t len) {
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (len); duk__space = (duk_size_t) ((bw)->p_limit - (bw)->p); if (duk__space < duk__sz) { (void) duk_bw_resize((thr), (bw), duk__sz); } } while (0);
 duk_bw_write_raw_slice(thr, bw, src_off, len);
}

static __attribute__ ((unused)) void duk_bw_insert_raw_bytes(duk_hthread *thr,
                                          duk_bufwriter_ctx *bw,
                                          duk_size_t dst_off,
                                          const duk_uint8_t *buf,
                                          duk_size_t len) {
 duk_uint8_t *p_base;
 duk_size_t buf_sz, move_sz;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);

 p_base = bw->p_base;
 buf_sz = (duk_size_t) (bw->p - p_base);
 move_sz = buf_sz - dst_off;

 do { } while (0);
 do { void *duk__dst = ((void *) (p_base + dst_off + len)); const void *duk__src = ((const void *) (p_base + dst_off)); duk_size_t duk__len = ((size_t) move_sz); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } } while (0);
 do { void *duk__dst = ((void *) (p_base + dst_off)); const void *duk__src = ((const void *) buf); duk_size_t duk__len = ((size_t) len); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0);
 bw->p += len;
}

static __attribute__ ((unused)) void duk_bw_insert_ensure_bytes(duk_hthread *thr,
                                             duk_bufwriter_ctx *bw,
                                             duk_size_t dst_off,
                                             const duk_uint8_t *buf,
                                             duk_size_t len) {
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (len); duk__space = (duk_size_t) ((bw)->p_limit - (bw)->p); if (duk__space < duk__sz) { (void) duk_bw_resize((thr), (bw), duk__sz); } } while (0);
 duk_bw_insert_raw_bytes(thr, bw, dst_off, buf, len);
}

static __attribute__ ((unused)) void duk_bw_insert_raw_slice(duk_hthread *thr,
                                          duk_bufwriter_ctx *bw,
                                          duk_size_t dst_off,
                                          duk_size_t src_off,
                                          duk_size_t len) {
 duk_uint8_t *p_base;
 duk_size_t buf_sz, move_sz;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);

 p_base = bw->p_base;


 do { } while (0);

 if (dst_off <= src_off) {



  src_off += len;
 }

 buf_sz = (duk_size_t) (bw->p - p_base);
 move_sz = buf_sz - dst_off;

 do { } while (0);
 do { void *duk__dst = ((void *) (p_base + dst_off + len)); const void *duk__src = ((const void *) (p_base + dst_off)); duk_size_t duk__len = ((size_t) move_sz); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } } while (0);
 do { void *duk__dst = ((void *) (p_base + dst_off)); const void *duk__src = ((const void *) (p_base + src_off)); duk_size_t duk__len = ((size_t) len); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memcpy(duk__dst, duk__src, (size_t) duk__len); } } while (0);
 bw->p += len;
}

static __attribute__ ((unused)) void duk_bw_insert_ensure_slice(duk_hthread *thr,
                                             duk_bufwriter_ctx *bw,
                                             duk_size_t dst_off,
                                             duk_size_t src_off,
                                             duk_size_t len) {
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);


 do { } while (0);

 do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (len); duk__space = (duk_size_t) ((bw)->p_limit - (bw)->p); if (duk__space < duk__sz) { (void) duk_bw_resize((thr), (bw), duk__sz); } } while (0);
 duk_bw_insert_raw_slice(thr, bw, dst_off, src_off, len);
}

static __attribute__ ((unused)) duk_uint8_t *duk_bw_insert_raw_area(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t off, duk_size_t len) {
 duk_uint8_t *p_base, *p_dst, *p_src;
 duk_size_t buf_sz, move_sz;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);

 p_base = bw->p_base;
 buf_sz = (duk_size_t) (bw->p - p_base);
 move_sz = buf_sz - off;
 p_dst = p_base + off + len;
 p_src = p_base + off;
 do { void *duk__dst = ((void *) p_dst); const void *duk__src = ((const void *) p_src); duk_size_t duk__len = ((size_t) move_sz); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } } while (0);
 return p_src;
}

static __attribute__ ((unused)) duk_uint8_t *duk_bw_insert_ensure_area(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t off, duk_size_t len) {
 do { } while (0);
 do { } while (0);
 do { } while (0);

 do { duk_size_t duk__sz, duk__space; do { } while (0); duk__sz = (len); duk__space = (duk_size_t) ((bw)->p_limit - (bw)->p); if (duk__space < duk__sz) { (void) duk_bw_resize((thr), (bw), duk__sz); } } while (0);
 return duk_bw_insert_raw_area(thr, bw, off, len);
}

static __attribute__ ((unused)) void duk_bw_remove_raw_slice(duk_hthread *thr, duk_bufwriter_ctx *bw, duk_size_t off, duk_size_t len) {
 duk_size_t move_sz;

 duk_uint8_t *p_base;
 duk_uint8_t *p_src;
 duk_uint8_t *p_dst;

 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { } while (0);
 do { (void) (thr); } while (0);

 p_base = bw->p_base;
 p_dst = p_base + off;
 p_src = p_dst + len;
 move_sz = (duk_size_t) (bw->p - p_src);
 do { void *duk__dst = ((void *) p_dst); const void *duk__src = ((const void *) p_src); duk_size_t duk__len = ((size_t) move_sz); do { } while (0); do { } while (0); if (__builtin_expect((duk__len > 0U), 1)) { do { } while (0); do { } while (0); (void) memmove(duk__dst, duk__src, (size_t) duk__len); } } while (0);
 bw->p -= len;
}
# 1 "duk_util_cast.c"
# 71 "duk_util_cast.c"
static __attribute__ ((unused)) duk_int_t duk_double_to_int_t(duk_double_t x) {






 do { if (__builtin_expect((x >= (duk_double_t) (
# 78 "duk_util_cast.c" 3 4
(-0x7fffffff - 1)
# 78 "duk_util_cast.c"
)), 1)) { do { } while (0); if (__builtin_expect((x <= (duk_double_t) (0x7fffffff)), 1)) { return (duk_int_t) x; } else { return (duk_int_t) (0x7fffffff); } } else { return (duk_int_t) (
# 78 "duk_util_cast.c" 3 4
(-0x7fffffff - 1)
# 78 "duk_util_cast.c"
); } } while (0);

}

static __attribute__ ((unused)) duk_uint_t duk_double_to_uint_t(duk_double_t x) {



 do { if (__builtin_expect((x >= (duk_double_t) (0)), 1)) { do { } while (0); if (__builtin_expect((x <= (duk_double_t) (
# 86 "duk_util_cast.c" 3 4
(0x7fffffff * 2U + 1U)
# 86 "duk_util_cast.c"
)), 1)) { return (duk_uint_t) x; } else { return (duk_uint_t) (
# 86 "duk_util_cast.c" 3 4
(0x7fffffff * 2U + 1U)
# 86 "duk_util_cast.c"
); } } else { return (duk_uint_t) (0); } } while (0);

}

static __attribute__ ((unused)) duk_int32_t duk_double_to_int32_t(duk_double_t x) {



 do { if (__builtin_expect((x >= (duk_double_t) (
# 94 "duk_util_cast.c" 3 4
(-2147483647-1)
# 94 "duk_util_cast.c"
)), 1)) { do { } while (0); if (__builtin_expect((x <= (duk_double_t) (
# 94 "duk_util_cast.c" 3 4
(2147483647)
# 94 "duk_util_cast.c"
)), 1)) { return (duk_int32_t) x; } else { return (duk_int32_t) (
# 94 "duk_util_cast.c" 3 4
(2147483647)
# 94 "duk_util_cast.c"
); } } else { return (duk_int32_t) (
# 94 "duk_util_cast.c" 3 4
(-2147483647-1)
# 94 "duk_util_cast.c"
); } } while (0);

}

static __attribute__ ((unused)) duk_uint32_t duk_double_to_uint32_t(duk_double_t x) {



 do { if (__builtin_expect((x >= (duk_double_t) (0)), 1)) { do { } while (0); if (__builtin_expect((x <= (duk_double_t) (
# 102 "duk_util_cast.c" 3 4
(4294967295U)
# 102 "duk_util_cast.c"
)), 1)) { return (duk_uint32_t) x; } else { return (duk_uint32_t) (
# 102 "duk_util_cast.c" 3 4
(4294967295U)
# 102 "duk_util_cast.c"
); } } else { return (duk_uint32_t) (0); } } while (0);

}
# 118 "duk_util_cast.c"
static __attribute__ ((unused)) duk_float_t duk_double_to_float_t(duk_double_t x) {
# 132 "duk_util_cast.c"
 duk_double_t t;

 t = fabs(x);
 do { } while (0);

 if (__builtin_expect((t <= 340282346638528859811704183484516925440.0), 1)) {



  do { } while (0);
  return (duk_float_t) x;
 } else if (t <= 340282356779733623858607532500980858880.0) {

  do { } while (0);
  if (x < 0.0) {
   return (duk_float_t) -340282346638528859811704183484516925440.0;
  } else {
   return (duk_float_t) 340282346638528859811704183484516925440.0;
  }
 } else if (
# 151 "duk_util_cast.c" 3 4
           __builtin_isnan (
# 151 "duk_util_cast.c"
           x
# 151 "duk_util_cast.c" 3 4
           )
# 151 "duk_util_cast.c"
                       ) {

  do { } while (0);
  return (duk_float_t) x;
 } else {

  if (x < 0.0) {
   return (duk_float_t) -((double) 
# 158 "duk_util_cast.c" 3 4
                        (__builtin_inff ())
# 158 "duk_util_cast.c"
                        );
  } else {
   return (duk_float_t) ((double) 
# 160 "duk_util_cast.c" 3 4
                       (__builtin_inff ())
# 160 "duk_util_cast.c"
                       );
  }
 }

}
# 1 "duk_util_double.c"






static __attribute__ ((unused)) duk_bool_t duk_double_is_anyinf(duk_double_t x) {
 duk_double_union du;
 du.d = x;
 return ((((&du))->ull[0] & 0x7fffffffffffffffULL) == 0x7ff0000000000000ULL);
}

static __attribute__ ((unused)) duk_bool_t duk_double_is_posinf(duk_double_t x) {
 duk_double_union du;
 du.d = x;
 return (((&du))->ull[0] == 0x7ff0000000000000ULL);
}

static __attribute__ ((unused)) duk_bool_t duk_double_is_neginf(duk_double_t x) {
 duk_double_union du;
 du.d = x;
 return (((&du))->ull[0] == 0xfff0000000000000ULL);
}

static __attribute__ ((unused)) duk_bool_t duk_double_is_nan(duk_double_t x) {
 duk_double_union du;
 du.d = x;



 do { } while (0);
 return (((((&du))->ull[0] & 0x7ff0000000000000ULL) == 0x7ff0000000000000ULL) && (((((&du))->ull[0]) & 0x000fffffffffffffULL) != 0));
}

static __attribute__ ((unused)) duk_bool_t duk_double_is_nan_or_zero(duk_double_t x) {
 duk_double_union du;
 du.d = x;



 do { } while (0);
 return (((((&du))->ull[0] & 0x7ff0000000000000ULL) == 0x7ff0000000000000ULL) && (((((&du))->ull[0]) & 0x000fffffffffffffULL) != 0)) || ((((&du))->ull[0] & 0x7fffffffffffffffULL) == 0x0000000000000000ULL);
}

static __attribute__ ((unused)) duk_bool_t duk_double_is_nan_or_inf(duk_double_t x) {
 duk_double_union du;
 du.d = x;







 return (du.ull[0] & 0x7ff0000000000000ULL) == 0x7ff0000000000000ULL;




}

static __attribute__ ((unused)) duk_bool_t duk_double_is_nan_zero_inf(duk_double_t x) {
 duk_double_union du;

 duk_uint64_t t;



 du.d = x;
# 81 "duk_util_double.c"
 t = du.ull[0] & 0x7ff0000000000000ULL;
 if (t == 0x0000000000000000ULL) {
  t = du.ull[0] & 0x8000000000000000ULL;
  return t == 0;
 }
 if (t == 0x7ff0000000000000ULL) {
  return 1;
 }
# 99 "duk_util_double.c"
 return 0;
}

static __attribute__ ((unused)) duk_small_uint_t duk_double_signbit(duk_double_t x) {
 duk_double_union du;
 du.d = x;
 return (duk_small_uint_t) (((&du)->ull[0] >> 63U));
}

static __attribute__ ((unused)) duk_double_t duk_double_trunc_towards_zero(duk_double_t x) {

 duk_small_uint_t s = duk_double_signbit(x);
 x = floor(fabs(x));
 if (s) {
  x = -x;
 }
 return x;
}

static __attribute__ ((unused)) duk_bool_t duk_double_same_sign(duk_double_t x, duk_double_t y) {
 duk_double_union du1;
 duk_double_union du2;
 du1.d = x;
 du2.d = y;

 return (((du1.ui[1] ^ du2.ui[1]) & 0x80000000UL) == 0);
}

static __attribute__ ((unused)) duk_double_t duk_double_fmin(duk_double_t x, duk_double_t y) {





 return (x < y ? x : y);
}

static __attribute__ ((unused)) duk_double_t duk_double_fmax(duk_double_t x, duk_double_t y) {





 return (x > y ? x : y);
}

static __attribute__ ((unused)) duk_bool_t duk_double_is_finite(duk_double_t x) {
 return !duk_double_is_nan_or_inf(x);
}

static __attribute__ ((unused)) duk_bool_t duk_double_is_integer(duk_double_t x) {
 if (duk_double_is_nan_or_inf(x)) {
  return 0;
 } else {
  return duk_double_equals(duk_js_tointeger_number(x), x);
 }
}

static __attribute__ ((unused)) duk_bool_t duk_double_is_safe_integer(duk_double_t x) {



 return duk_double_is_integer(x) && fabs(x) <= 9007199254740991.0;
}






static __attribute__ ((unused)) duk_bool_t duk_is_whole_get_int32_nonegzero(duk_double_t x, duk_int32_t *ival) {
 duk_int32_t t;

 t = duk_double_to_int32_t(x);
 if (!duk_double_equals((duk_double_t) t, x)) {
  return 0;
 }
 if (t == 0) {
  duk_double_union du;
  du.d = x;
  if ((((&du)->ull[0] & 0x8000000000000000ULL) != 0)) {
   return 0;
  }
 }
 *ival = t;
 return 1;
}




static __attribute__ ((unused)) duk_bool_t duk_is_whole_get_int32(duk_double_t x, duk_int32_t *ival) {
 duk_int32_t t;

 t = duk_double_to_int32_t(x);
 if (!duk_double_equals((duk_double_t) t, x)) {
  return 0;
 }
 *ival = t;
 return 1;
}





static __attribute__ ((unused)) inline duk_double_t duk_double_div(duk_double_t x, duk_double_t y) {

 if (__builtin_expect((duk_double_equals(y, 0.0) != 0), 0)) {






  if (x > 0.0) {
   if (
# 215 "duk_util_double.c" 3 4
      __builtin_signbit (
# 215 "duk_util_double.c"
      y
# 215 "duk_util_double.c" 3 4
      )
# 215 "duk_util_double.c"
                    ) {
    return -((double) 
# 216 "duk_util_double.c" 3 4
           (__builtin_inff ())
# 216 "duk_util_double.c"
           );
   } else {
    return ((double) 
# 218 "duk_util_double.c" 3 4
          (__builtin_inff ())
# 218 "duk_util_double.c"
          );
   }
  } else if (x < 0.0) {
   if (
# 221 "duk_util_double.c" 3 4
      __builtin_signbit (
# 221 "duk_util_double.c"
      y
# 221 "duk_util_double.c" 3 4
      )
# 221 "duk_util_double.c"
                    ) {
    return ((double) 
# 222 "duk_util_double.c" 3 4
          (__builtin_inff ())
# 222 "duk_util_double.c"
          );
   } else {
    return -((double) 
# 224 "duk_util_double.c" 3 4
           (__builtin_inff ())
# 224 "duk_util_double.c"
           );
   }
  } else {

   return 
# 228 "duk_util_double.c" 3 4
         (__builtin_nanf (""))
# 228 "duk_util_double.c"
                       ;
  }
 }


 return x / y;
}



static __attribute__ ((unused)) inline void duk_dblunion_host_to_little(duk_double_union *u) {


 do { (void) (u); } while (0);
# 265 "duk_util_double.c"
}

static __attribute__ ((unused)) inline void duk_dblunion_little_to_host(duk_double_union *u) {
 duk_dblunion_host_to_little(u);
}

static __attribute__ ((unused)) inline void duk_dblunion_host_to_big(duk_double_union *u) {



 u->ull[0] = ((duk_uint64_t) __builtin_bswap64((duk_uint64_t) (u->ull[0])));
# 298 "duk_util_double.c"
}

static __attribute__ ((unused)) inline void duk_dblunion_big_to_host(duk_double_union *u) {
 duk_dblunion_host_to_big(u);
}

static __attribute__ ((unused)) inline void duk_fltunion_host_to_big(duk_float_union *u) {


 u->ui[0] = ((duk_uint32_t) __builtin_bswap32((duk_uint32_t) (u->ui[0])));






}

static __attribute__ ((unused)) inline void duk_fltunion_big_to_host(duk_float_union *u) {
 duk_fltunion_host_to_big(u);
}






#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wfloat-equal"





static __attribute__ ((unused)) inline __attribute__((always_inline)) duk_bool_t duk_double_equals(duk_double_t x, duk_double_t y) {
 return x == y;
}

static __attribute__ ((unused)) inline __attribute__((always_inline)) duk_bool_t duk_float_equals(duk_float_t x, duk_float_t y) {
 return x == y;
}

#pragma GCC diagnostic pop
# 1 "duk_util_hashbytes.c"
# 1 "duk_util_memory.c"
# 20 "duk_util_memory.c"
static __attribute__ ((unused)) inline duk_small_int_t duk_memcmp_unsafe(const void *s1, const void *s2, duk_size_t len) {
 do { } while (0);
 do { } while (0);
 if (__builtin_expect((len == 0U), 0)) {
  return 0;
 }
 do { } while (0);
 do { } while (0);
 return duk_memcmp(s1, s2, len);
}

static __attribute__ ((unused)) inline duk_small_int_t duk_memcmp(const void *s1, const void *s2, duk_size_t len) {
 do { } while (0);
 do { } while (0);
 return memcmp(s1, s2, (size_t) len);
}
# 1 "duk_util_tinyrandom.c"
# 62 "duk_util_tinyrandom.c"
static inline __attribute__((always_inline)) duk_uint64_t duk__rnd_splitmix64(duk_uint64_t *x) {
 duk_uint64_t z;
 z = (*x += 0x9E3779B97F4A7C15ULL);
 z = (z ^ (z >> 30U)) * 0xBF58476D1CE4E5B9ULL;
 z = (z ^ (z >> 27U)) * 0x94D049BB133111EBULL;
 return z ^ (z >> 31U);
}

static inline __attribute__((always_inline)) duk_uint64_t duk__rnd_rotl(const duk_uint64_t x, duk_small_uint_t k) {
 return (x << k) | (x >> (64U - k));
}

static inline __attribute__((always_inline)) duk_uint64_t duk__xoroshiro128plus(duk_uint64_t *s) {
 duk_uint64_t s0;
 duk_uint64_t s1;
 duk_uint64_t res;

 s0 = s[0];
 s1 = s[1];
 res = s0 + s1;
 s1 ^= s0;
 s[0] = duk__rnd_rotl(s0, 55) ^ s1 ^ (s1 << 14U);
 s[1] = duk__rnd_rotl(s1, 36);

 return res;
}

static __attribute__ ((unused)) void duk_util_tinyrandom_prepare_seed(duk_hthread *thr) {
 duk_small_uint_t i;
 duk_uint64_t x;






 x = thr->heap->rnd_state[0];
 for (i = 0; i < 64; i++) {
  thr->heap->rnd_state[i & 0x01] = duk__rnd_splitmix64(&x);
 }
}

static __attribute__ ((unused)) duk_double_t duk_util_tinyrandom_get_double(duk_hthread *thr) {
 duk_uint64_t v;
 duk_double_union du;





 v = (0x3ffULL << 52U) | (duk__xoroshiro128plus((duk_uint64_t *) thr->heap->rnd_state) >> 12U);
 du.ull[0] = v;
# 122 "duk_util_tinyrandom.c"
 return du.d - 1.0;
}
